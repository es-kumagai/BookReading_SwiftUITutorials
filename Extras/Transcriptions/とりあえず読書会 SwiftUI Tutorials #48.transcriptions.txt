Transcription & Summarize : とりあえず読書会 SwiftUI Tutorials #48

はい、では続いて紹介を始めていきましょう。Swift UI Tutorialsのリファクタリング的なところ。リファクタリングもだいぶ落ち着いた感じがするので、フォードを振り返りながら様子をちょっと振り返ってチェックしてみたり、こんな感じのことをしつつ書き換えられそうな場所は書き直してみたりとか、そんな感じでやっておりますが、引き続きこんなところでやっていきましょう。はい、さっそくフォードを移していきますが、今日はサプルイメージのところからですね、それより前までは終わっているので、いいですね。 これは変えるところがあるんですかね。サプルイメージでビューで、イメージ。これレッドでいいですね。なんかまだね、このビューを準拠させたときに、それをレッドにすべきかバーのままでいいのか、この辺りはまだちょっと把握というか判断できないところがあるんですけど、まあ、テイトでないんだったらレッドにしといて何も差し支えないのかなっていうね、そんな感じがするんで、レッドで良いのでしょう。それでイメージを表示して、いろいろサイズをこう指定してですね。これでストロークがホワイトとかやってるけど、これカスタマイズできるようにする必要があるんでしょうかね。どうなんだろう。例えばこうですね、コンポーネントとしてね、第三者、第三者 ラインウィズとストローク、ストロークカラーか、まあそれでいいかな、ストロークカラー、とにかくね、こうカラーを提出させるようにして、それであとね、ストロークがラインカラーの方がいいですかね。ラインカラーなのでここでラインカラーがカラー型で、ラインウィズがCGフロートWTですかね。 そういう人UIではどちら、WTをよく使うんですかね。あとは一般的にはIOSではCGフロートを使ってたと思うんですけど、CGフロートとWTというのはね、どっちもあんまり変換ができるという、そういう人にとっては結構謎のルールがなぜかトップレートとして用意されてるんで、そういう人UIでコードを書く時にはわざわざCGフロートで書かないで、WTで書いておいた方が自然な感じは出てきますよね。なのでWTにしてみてますが、その辺は好みでいいのかもしれないです。 サークルカラー、ラインカラー、どっちがいいんでしょうね。フレームかな。フレームカラーとかの方がいいのかな。サークルで別に和を作るけどね、和が別に特別なものでもないので、どうしようかな。フレーム、フレームの気がするな。フレームカラー。でもフレームって言うとUの固定のサイズを感じてしまうような気もするんで、どうすると難しいですね。 ボーダーカラーとボーダーウィズ。これはいいかもしれないですね。このボーダーのストロークからホワイトが、規定をホワイトにするか、ウィズを規定するかですね。サークルイメージで、規定でやってもいい気がしますね。ホワイトで幅は4みたいな感じですね。これでストロークのボーダーカラー。こっちの幅がボーダーウィズ。こんな感じでカスタマイズできるようにしておいても悪くはないでしょう。 あとは半径、シャドウのラディウス。ここも普通はプロパティでちゃんと用意すると思うんですよね。レッド、ボーダー、シャドウ、ラディウス。これもダブルにしてデフォルト7にして、それでボーダー、シャドウ、ボーダー、シャドウ、ラディウスね。こんな感じにして、こうするとカスタマイズできるよね。これだけですけどね。やれることとしたらあれぐらいですか。そうすることによって、例えばこのプレビューでイメージがあって、ここで7、ボーダーカラー、そしてね、ちょっとイエローとか。こんな風にするとあれダメなのかな。ボーダーカラーじゃなかったっけ。ボーダーカラーキッチリしてます タイプをできないところにするとダメなんでした。ダメかダメに決まってますね。 イニシャライザーを搭載しないといけないのか。だからイニシャライザーを搭載して、キッチリしてあげるという形を取るのが若干準備が面倒ですね。 コンポーネント用意するとなるとこういうことだと思うんですけどね。 カラーがホワイトが規定で、幅が4が規定で、ラディウスが7が規定ね。こんな風にしてあげて、そうするとここでイエローが出てくるんで、広くなるよね多分ね。 こんな感じでカスタマイズができるよって言うだけですけどね。 こんなところでコード自体は綺麗だから良いでしょう。 次のエヴァリッドボタン。エヴァリッドボタンは、バインディングバーでイズセット。 バインディングはレッドでできるのかなと思ったんですけど、バインディングは読み書き可能にしないとダメですよね。 確かに、確か。ちょっとやってみますか。 レッドにするとそうですね。飛ぶるかダメって言われますね。 ここから伺うこととしてはね、バインディングっていうものだけじゃなくか、バーからレッドとかそういった価値観で見たときに、普通のソフィットの構造体を扱うときと、ソフィットUIのビューを扱うときと、構造体の変数のトロパティの扱い方が何か感覚が違う気がしますね。 普通はこれ、イズセットをバインディングだから読み書き可能とするのが良いのか、ただ外側から、エヴァリッドボタンを外側から操作する機械というのはソフィットUIでは基本ないはずなので、 バーとレッドとバーでいいと思うんですけど、普通のソフィットの価値観で考えると、これ外からの書き換えは保護したいじゃないですか。ボタンを押したときにイズセットが安定する。 こういうのを考えるとプライベートセットっていう風に書いてあげるのが、本来のソフィットらしい書き方なのかなっていう気がする。 この中でいくとアットセットもそうですよね。アットセットはプライベート付けなさいってこのチュートリアルで言われてますけど、プライベートで保護するので外からアクセスしないためですよね。 なんかこういう風に作ったとき。だとするんだったらやっぱりプライベートセットは欲しい気がしますね。バインディングでもね。 そうなんでプライベートセットに合わせましょうか。そうするとちょっと遡って、クリメディバインドしてないですね。ボタンビューはバインドはしてないですね。バッジもしてないかな。 こっちも大丈夫。次から出てきたものをプライベートセットと言ってみましょう。本当にそれが良いかどうかわからないですけどね。 足使いの評価高分では悪くないはずなんで、これで良いでしょう。 それでボディの中ではボタンを押すとイズセットがグルされるのと、ラベルとして星マークですね。 これがこっちと今動かない。コンスタントにしてるのか。コンスタントで面白くないですよね。 これはあとなんだっけ。プレビュアブル、プレビュアブル、ステート、パワー、イズ、セット、そしてグルみたいな風にして、 これをイズセットに対してバインディング渡してあげるといいですね。そうするとこれが押したりできますね。 こっちの方がプレビューらしくていいですね。 そしてバインディングプライベートセットでボディとしてはボタンがイズセットとグルでラベルで、アクセスビリティラベル。 これはいいですね。問題ないですね。 次、エチャカード。これはiOS用の方ですね。 ファイルの置き場所も悩んでたところなんですけど、フォルダーを開けてファイルをiOS用のフォルダーに置くか、 それともファイル名にiOSを捨てたとか、または他のやり方があるか。 そういったところが好きになってるところですけど、どれがいいかまだ分からないですね。 とりあえずファイル名でやってますが、ファイル名長くなっちゃうんですよね。 ここみたいに省略されてる。 長くなっちゃうので、フォルダーを開けると遠くに他だろう得ない状況になっちゃって、 アプリにくいのかなみたいな。そういったクロスプラットフォームならでは問題はまだ見えてないし、 これはまあルールでその都度その都度、今回はこうしましょうみたいな感じでもいい気もしますけどね。 とりあえずフェッチャーパードはこういったフェッチャーパード表示の機能になっていて、 あれを作ってるのがここですね。ランドマークを取って、 ボディとしてはイメージがランドマークイメージのフィッチャーイメージオブ、 ランドマークイメージフィッチャーイメージオブ、なんか無かったらしいけど、これはしょうがないですね。 このランドマークからフェッチャーイメージオブ、ランドマークのイメージは何だったかな。 これをちょっと生ドロップしますね。ランドマーク。ランドマークのとこ、 ランドマークイメージのフィッチャーイメージオブ、ランドマークという形でイニシャライズをして、 オッケーですかね。名前がなんか無かったらしいけど、これはしょうがないでしょう。 コードが見にくいから横のバーの届くとかやってね。 イフレットですね。それでイメージが取れた場合には、 イメージをこうやって表示してあげるよっていう形を取っていると、 そういうことで良いんですね。ここもシンプルに書いてる気がしますね。 他にはランドマークイメージが取れた場合にマップを使って表示する方法もあるかと思うんですけど、 マップがオプショナルかどうかが分かってないと、 このマップがどう動くのか想像しにくいのと、 あとそういう人の特徴なんですかね。他の言語もそうかもしれないですけど、 元一の方がオプショナルなのかどうなのかっていうのが、コードだけ見たときにわからないですよね。 フィッチャーイメージオブランドマークってこのイメージがイニシャライズ失敗するかもしれないっていうのが目に見えてないじゃないですか。 これがもし目に見える形だったら、例えば後半ってのを書かないといけないとかね、 こういった書き方だったとしたら自分違ったと思うんですけどね。 これをテキストオーバーレイにしたけど、まあまあいいか。 オーバーレイでなんか被っちゃってのが気になりますね。 テキストオーバーレイランドマーク。 まあまあ、モディファイアにしてもいいのかなと思ったんですけど、 オーバーレイでモディファイアにする。 オーバーレイにしてモディファイアか。 まあまあそこまでしなくていいかな。 オーバーレイのテキスト。 オーバーレイテキストにすればいいのか。 テキストオーバーレイだとなんか変な感じがするような気がするんで、 オーバーレイに対してオーバーレイするテキスト。 こんな感じにすればいいんじゃないですかね。 それでオーバーレイテキストでランドマークを渡してあげて、 このランドマークを表示してあげるよっていうそんな感じ。 ちょっとラベル名が気になりますけど、 これはイニシャライザーというか、 その観点で見たときにはまあ良い範囲かなという気はありますかね。 オーバーレイテキストウィズランドマークとかそういった名前をつける手もあると思うし、 あとは何だろう。オーバーレイテキストでラベル抜きでランドマーク。 それはないか。ウィズにするとランドマークで渡すか。 オーバーレイテキスト、うんそうね。ランドマークでいい気がしますね。 まあそんな感じでオーバーレイテキストを別に作ってこれをランドマークをとって、 グラデーションはこんな色ですよということが規定で、 計算型プロパティで用意しておくことによって、 グラデーションで塗るって言ったらこれで塗るよっていうね。 そんな感じになり、あとはボディとしてZスタッフでグラデーション。 このグラデーションって何塗ってるんだ?そういえば。 コメント渡してみましょうか。ああそうなんだ。ああそうなんだ。 透明度で塗ってるから。さっきなんか隠してたのね。 なるほど。グラデーションオーバーレイテキストの。 だからオーバーレイテキスト。グラデーションというよりバックグラウンドな感じがしますね。 リニアグラディメントって何だろう。形状しているものね。 テープスタイルでビューでシャドウが。 グラデーションじゃなくてバックグラウンドっていう風にして。 大きさのビューにして。それでこれはグラデーションの線形。グラデーションね。 っていう風にしてあげると、バックグラウンドをZスタッフで乗せてその上にVスタッフで色々乗せていくよっていう雰囲気になるから。 もしここ将来グラデーションじゃないよみたいなことしたくなっても別にグラデーションじゃない。 AIデザインガイドラインに変数名は制約ではなくて用途で名前を付けなさいっていう決まり事がありますよね。 なのでここでグラデーションって名前を付けてしまうと、制約ですよね。この変数はグラデーションですよ。 バックグラウンドって付ければこれはバックグラウンドを塗るために使うものですよっていう用途でちゃんと名前が付くんで、バックグラウンドって名前の方が良さそうですね。 オーバーテキストに対してバックグラウンド。 で、ボディの中でZスタッフテキストでランドマークのネームとランドマークのパーク。これがイオシナに表示されてOKですね。 ワークラウンドスタイルホワイト。これはオプションで良い気がしますね。テキストで。 例えばレッドカラーとしてカラーね。こう持たせた上でイニシャライザーとしてカラー。 カラーというかカラーも持たせられる。で、そこでテキストホワイトにして。 そうしたらここがね、ワークラウンドスタイルがカラーで良いですよね。 こんな感じにしてあげれば、アスタマイズが効いて、一列の音色を適宜調整することが可能になる。 まあ、そうなるとバックグラウンドもアスタマイズできた方が良いような気もしないかもしれないですけどね。 まあまあ、この辺は今のところは良しとしますか。 こんな感じでできたのかな。ボディも分かりやすいしね。 大丈夫ですね。はい、こんな感じでフェーチャーバードはOK。 じゃあ次ですね、バイクパッチ。 バイクパッチの方は上から見ていくときに、ネームをとってボディがあって、これがペースタップで重ねられて、パッチがこういったプロパティで表示されて、テキストがこういったプロパティで表示される。 これはこれで良さそうですかね。 あと考えられることとしては、このスケールとか幅とかね、高さとか、こういったところを考えていくっていうのは大事になってくる可能性もありますけどね。 これスケールエフェクトってなんだろう。サイズ、スケールエフェクトを消すと大きくなりますよね。 ここは300は?あ、小さくなるんだ。ああそうなんだ。これ200は?ああそうなるんだ。ああなるほど。距離が取られちゃうんだ。 フレームによって3分の1にして、ここなんか少し不思議に感じる。なんかフィットする系ないのかな。 わかんないか。エールの通行ってそういうものなのかな。この辺、感覚わかんないや。 パッチに対してフレームを設定して、エールエフェクトを設定して、フレームを再度設定する。 こんなことをして3分の1ですねこれね。そういうことをしないといけないのか。 まあいいか。そういうものとして今回は取られておけばいいですかね。 ハイクバッジはネームとして、まあいいのか。パッチ名ですね。OKですね。 次、ハイクディテールビュー。これはOSによる違いで、VスタックにするかHスタックにするかの切り替えをボタンスタックでやっている。 これは若干クニックの作のような気もしつつ、OSごとのレイアウトの差を、タイプエリア層を使って切り替えて、その下では同じコードで書けるというのはなかなかいい選択だったなという気がするので、これはこれで良いでしょう。 ハイクディテールビューに対して、ディテールビューを搭載して、このデータパスというのはこのどのデータを表示させるかというのをハイクのオブザーベーション。 このパターンに対して、レンジWを返してくる、例のDパス。 これで指定している。ちなみにハイクオブザーベーション型っていうのは、エレベーションならこのデータ。 エースならこのデータ。アートレートならこのデータ。 レンジW型なので、このオブザーベーション型の、われらがセレクトできるDパス。 これをここのデータパスで用意できるようにするようにして、ハイクはレッドで持っていて、プライベートバーでデータパス。 エレベーションが指定で選ばれている。これが良いですね。 ボタンアイテム数は、エレベーションとアートレートとDトレートかEトレートとエース。 これらがどれぞれこのデータで利用されるよということがボタンアイテムとして宣言されている。 ボタンアイテムはまた別に定義していますね。 とにかくボディとしては、ハイクグラフに対してハイクとデータパスを渡してあげると、こういったのが入ってくれる。 で、あとはボタンズバー。これを配置する。この辺は良いですね。 で、ボタンズバーはボタンスタック。さっきのタイプエリアでどっちに配置するかですよね。 あ、でかいほうか。それで、この配置の具合によって、こう位置してボタンアイテム数に対してボタン比をこうやって配置してあげる。 で、いつアイテムデータパスとデータパスが一致したときには選択しているものを見直すと、これもう大丈夫ですね。 で、それで プッシュアイテムを押したアイテムのことですね。それが新しいデータパスとして定義される。 名前がやや欲しい気もしないものですけど、これを全体をやったり、とりあえずこうしてみようって感じで、名前を付けた感じですね。 そうでなければアイテムにしたり、またはダラダローでね、よりしていったり。 そのところですが、これはプッシュアイテム、ボタン、プッシュアイテム、アイテム、どっちが良いかな。 プッシュアイテムも今は見ると違和感を覚えるので、一般的なアイテムにしておきますか。 押したボタンに対するデータパスが、カレントのデータパスにリカバリをということで、うまく動きができていると。 OKですね。次、タイプグラフ。これを見ていきますが、タイプグラフはというと、タイプが、パスも同じように持っていて、カラーとしてパスの種類に応じて色を配置していく。 ここも悪くないですかね。で、アンノーンだったときには、アンノーン用の色を指定していますけど、ここは今の現状だとフェイタルエラーにすることもできるんですが、 もし色を増やしたときに、落ちるより別に色が適切じゃない方が、親切なような気がするので、この辺はフォールバック、失敗したときのリカバリを作成して、落とすのではなくて、確認用の、分かんないとき用の色、実際にはブラックにしているようですが、 どれでもいいですけど、そういったのを返すよ、という風にして、統制外の場面も落とさずにしのぐ、最適な方法でしのぐっていうね、こういったことができているからOKでしょ。 で、ボディは10メートルリリーターで、ハイクのオブザーベーションズをとって、そのカウントが0だったら、エンプティビュー、そうじゃなければ、グラフビューというものを表示していく、という風になっている。これもOKですね。 エンプティビュー、オブザーベーションズカウント、オブザーベーションズが0かどうかですね。これもしかすると別に、あの、IFがでいいですね、これね。IF、オブザーベーションズ、ISEMPTYではなければ表示で良さそうですね。 で、その時にオブザーベーションズって表示する時にしか使っていないので、これ中でいいですね。さっきまで無駄でしたんで、ちょっとね。で、まぁこうやって、あっ、無駄じゃなかった。自分の見落としだった。 これを見て、数あるか見てのか、これは最初に読んないといけないというものだった。間違えた。これで、ハイクオブザーベーションズで、もう何か端的な良い方法ないかなと思ったけど、まぁまぁないですかね。 ハイクに対して、ハズオブザーベーションズみたいなプロパティを持たせれば、まぁ、もうちょっと、まぁこんな感じになるでしょうけど、まぁそれも必要ないかなっていう気がするんで、これで良いですね。 で、それで、カプセル、この丸みたいなやつをね、隠すやつですね。カプセルはどこで使ってるんだったかな。まぁいいか。カプセルはいろんなプロパティがあって、それぞれの情報を、それぞれ計算型プロパティで用意しておいて、 ここでカプセルっていう名前をね、使っちゃってるんで、そういったUIで言うカプセルをここで使ってるっていうね、ちょっと生意気感が必要になってますけど、 これについては、まぁボディの中で収めてあるから、まぁ私らしくなくて大丈夫でしょう。で、カラーを塗って、この辺はいいですね。ちゃんと書けてますね。 で、グラフビューっていうのは、バウンスとオブザーベーションズを受け取って、で、オブザーベーションズとカラーであったときには、点数状況を満たさないという形を取ってますね。 えーと、その可能性はあったような気がするんだけど、うーん、ないかな。えーと、まぁまぁいいか。この辺はちゃんと気を付けてね、使う。 だから要はグラフビューを参照するときには、事前にね、オブザーベーションズがエンプティーでないことを確認して使うっていうのが基本になってくるってことですね。 で、実際調べてみますね。エンプティーじゃないときには表示していくよっていうね。これなら何の問題もない。いい感じにできてますかね。 時々ね、コードを見ていて、グラフビューの中で、オブザーベーションズがカラーだったときにはエンプティーを返すみたいな、そういったコードを見たりすることがあって、 それはね、必ずグラフビューというものが存在していて、その中身が真っ白だよっていうようなときはね、いいと思うんですけど、 そうじゃないときね、カラーだった場合は表示ができないよっていうね、そういったスタンスを取ると、もう言い口で弾くんでね、 その呼び出し元がカラーだったときにはどうしなきゃいけないかとかね、考えて実装する日も多いってことになるので、 となると、良い感じに肯定しているコードが開けるようになりますね。 利用者にとってね。これがエンプティーを返すようなときだと、カラーだからエンプティーになってくるかどうかっていうのは分からないわけですよね。データがどう取ろうかによってね。 なのでそうすると対処が遅れたりすることもあったりするんで、エンプティー化判定は外側でやっちゃうほうが基本的には良いはず。一般的にはね。 まあその感じで前提条件を入れた後、アバを指定して、最大のアバを取って、最大マグニチュード。 これもね、オブザベーションレンジズがアラではないことが前提条件によって保証されているので、安心しては無くアンラップでの強制アンラップができる。 そうですね、その感じでOKですね。オーバーオールレンジのマグニチュード。オーバーオールレンジのマグニチュードってこれ0の可能性ないですかね。 アッパーバウンドしローバーバウンドですよね。なのでオーバーオールレンジってのは、オブザベーションレンジズでスモールレストエンクロージングレート。 これが0-0ありますよね。0-0。0-0。なので、レンジデータがカラーだったときか。 そのときは0の可能性があって、それ以外はレンジのローバリュー、マックスアッパーバリュー。この2つが両方0の可能性でレンジデータがありますよね。 なので、要素が1個で0-0のレンジデータだったときに、0が返ってくる可能性があるので、そうするとここ、0で割る可能性出てきますね。 そうですね。ってことは何とかしないといけないですね、これね。まあまあ、そこで落ちるという選択は全然アリではあるんですけど。 これコンディションにしてしまうか、それとももう別の何かにするか。えーと、どうしますかね。オーバーオールレンジマグニチュード。 万全を起こすとすると、オーバーオールレンジマグニチュードをあらかじめ設定した上で、プレコンディション。 オーバーオールレンジマグニチュードは0かな?そんなのあるかな?続きがちかな?オーバーオールが違う。 オーバーオールのレンジマグニチュードが0とじゃあ、これだめか?プレコンディションは0?プレコンディションは0?全部続きがちだったという。 最高ね。ドロップしたときにプレコンディションだけでいいか。全部書いてあげないと何の意味もない気がしますけどね。 とりあえずこれで、オーバーオールレンジマグニチュードを押してあげることで、0での途端を除外することが可能になった。 0が何かやったら出てるのかな?ドロップフィルトかけてみますか。フィルト、どういうか、フォード、何かおかしくなっているのかな? 大丈夫ですね。じゃあ、よいか。こんな感じで厳密な姿勢を求めていくとこんな感じになってきそうですね。 それで、落ちるね。iOS。iOS。今はiOSですよね。落ちるようになった。 何だろう。パワーシミュレーター。アサーションフィーラー。アサーションフィーラーか。こんなアサーションフィーラー。 それで、インクメイン。また、オブザーベーションを選択。センターウィーズオブザーベーション。これは普通のアップデートバリュー。 何だろう。何が起きるようになったんだろう。 何か悪いことをしたかな。ここで、マグニチュード。ここ0は別にいいですね。 レンジの数はダブルの0か。ダブルの0に来ている。 オーバーオールレンジマグニチュード。ここ何か変ですね。 オーバーオールレンジマグニチュード。 これは0か。なるほど。 だから、そうすると、これが0だったら、ということは、 オーバーオールレンジが0か判断すればいいのか。 そうですね。プレイコンディションならね。 強い気がする。なので、割り算を復活させて。 それで、オーバーオールレンジ。これを0か判定する。 これダメか。レンジは0ってないのかな。 レンジの方。これは、まあまあこう見れば大丈夫ですね。 レンジでしょ。レンジで、これがスモールレストエンプローディングレンジ。 レンジダブルですよね。レンジダブルの方として、レンジは、 イツエンプティ。イツエンプティ。 まあ、イツエンプティなのか。イツエンプティでいいですね。 イツエンプティですね。 その、実際的なマグニチュードが0になったら困るんで。 なので、オーバーコンディションはイツエンプティではないという状況ですね。 なので、オフで落ちてますね。 これで、こうすると、レビュー通りのように多分、なってるでしょ。 うん。あ、いいですね。これでいいですね。 これで、0と3が、まあ、点で定点としてね、弾かれる。落ちますけどね。 で、それで、あとはHスタップでいろいろと、この、 ちょっとマジックな場合になりますけど、 なんだこの120で割るの。みたいなのがあるものの、 まあまあしょうがないか。 よくなくはないか。えっと、スペーシングドア。 ああ、スペーシングドアで見ると120か。 Hスタップで120で割る。 Hスタップアライメント。125度の高さかな。 あ、あ、あ。幅で120分の1。 Hスタップ、Hだから、水平並びですね。 あ、点々のところかな。うん。まあ、まあいいか。 120分の1。120分の幅。 で、FOR1でアレでオブザベーションエナミュレーティブを、 P値で回してオフセット。 これ、アレにする必要があるのか。 FOR1。FOR1のIDとコンテント。 FOR1でデータでとっていきますか。 えっと、データは、FOR1に対してコンテントとデータ。 データは、どこに定義されているか。 どこにも定義されていない。 データは、FOR1。FOR1型で、FOR1型の定義はどこか。 FOR1。結構、適用言われますね。 FOR1でデータ。データはランダムアクセスコレクションですね。 ランダムアクセスか。ランダムアクセスね。 どこに、余らなかったって感じですかね。 これはね。エナミュレーティブはね。 どうか。アイレット作んなきゃいけないな。 なんとなくもったいないですね。 回し。どうかないか。これで、インデックスオブザベーションで カプセルを表示してあげて、OKですね。 ここまで良しで、あとはプレビューか。 プレビューも問題なしですね。 これで良いという感じで。 じゃあ、次。HikeView。 HikeViewの方は、プライベートバーでレッドでHikeで、 ポジはVスタックの後Hスタックで、 Hikeグラフランドマップサマリーでスペースを置いて、 SHOW DETAILボタン。これは分かりやすいですね。 もし、SHOW DETAILが条件付いていた場合には、 DETAIL VIEWを表示していくと。 ここですよね。これで、お苦労して、この動き。 アニメーションが、なんか変だったな。 右から来ましたね、一回ね。 右から来て、後ろに抜けて。 これ、レンダーが速くなると、 オーディオするときに後ろから来ないことがありますね。 これはしょうがないんだろうか。 SHOW DETAILで、DETAIL VIEWでトランジションをMove & Fade。 SHOW DETAILは、この辺のプロパティは悪くないですね。 SHOW DETAILボタンで、ウィズアニメーションで SHOW DETAILがブログされていると。 これだけですね。アニメーションを制御しているとね。 あとは、この画像とかですが、 SHOW DETAIL、この辺かな。 ローテーションエフェクト。 それは、この三角のボタンですね。 ちゃんと適切に動いてるからOKですね。 それで、ボタンを押すと、SHOW DETAILがブログされるよ。 SHOW DETAILがブログされると、音が変わって、Move & Fadeで動く。 なんかアニメーション変だけど、良いのかな。 直し方が分からないというところもあるんですけど。 ボタンを押して、Move & Fadeをアニメーショントランジションで、 Moveでいろいろやって、コンバインリムーバル。 アニメーションが微妙な感じするけど、まあいいか。 逆上が来たら考えますが、逆上は起こらないですけどね。 まあ、そんな感じで、妥協するのもありなことはありですかね。 次は、Pipe View。Pipe ViewもOKですね。 PipeとBodyで、Scroll Viewで、Full Stackで、ランドマークサマリーと、ここのDetail View。 この2つが硬いアプローバティでも、硬いアプローバティでも、ちょっと気になりますね。 ランドマークサマリーと、例えば、同じような感覚でね、ここでランドマーク、Detail、みたいな風にして、そのランドマークDetailとして、Detail Viewを返すみたいな方法もありますよね。 ランドマークDetailとして、Sum Viewにして、こっちの方がバランス感は良いですかね。 ということで、終わりにしてみますか。あれ、プレビューがうまくいってないですね。 Pipe Viewでスペースを定義して、モデルデータのPipeを渡して、それでここへ来ていって、ランドマークサマリーとDetail View。 Detail Viewがなんか特別なものを使ってるんですかね。Detail Viewは、PipeとDatapath。問題なさそうですね。 もう一回、PipeとDatapath。Datapath規定がある。なので、Pipeだけで良し。 ただ、これは動いてないですね。これはなんだ。 Pipe View、WatchOSソリストが見つからない。 WatchOS、Pipe View、WatchOS、これですね。 ExcluseSourceFileNames。 これは見つからないって言ってるけど、 プラットフォームによってですね、Pipe View、これが実際に使われるのはWatchOSだけですね。 WatchOSの中で、このプレビューがここだけですよね。 これが動かないのがちょっと謎の気がする。 これも解決したいけど、ちょっと分からない気がするかな。 WatchOSのNodeBuildTargetDescriptionFound、DefinedTargetDescriptionが見つからない。 ExcluseNumBearerを付けなければならない。 という感じらしいけど、ちょっと分からないですね。 そうすると、プレビューがうまく動かない。 プレビューは動いて欲しいんですよね。 どっちかというと、当たり前ですけど。 なので、これが動かないとなると、どこが悪いんだろう。 DetailViewは定義を辿ると、これはWatchOSでも入ってきますよね。 大丈夫ですね。 そもそもWatchOSでビルドが変わればというか、 WatchOSにならないからかな。 もしかして、もしかしても、その可能性は非常に高いですね。 Pipe ViewのプレビューがWatchOSだけしか動かない可能性は WatchOS専用ファイルなんで、当たり前のようにある気がする。 この辺が厄介ですね。プレビューが表示されないとなった時に、 プラットフォームの違いというのを意識する。 この辺りを今、自分が忘れてちょっと悩んでましたけど、 こんなことになっちゃうので、もったいないですね。 WatchOSなのだから、WatchOS以外の所では プレビューが働かないようになって欲しいというか、 そういうことはできますよね。 じゃあ、pifOS、WatchOS。 そうすれば、そのだけなんでね。 悩んだからこれですか。そうかもしれない。 そうすると、ターゲットがiOSだった時に、iOSだった時には プレビューがプレビューの中からパラッとしてますね。 プレビューコードないですよね。コードないから 本来動かないんじゃないのかなと思ったんだけど、そんなことないのか。 そうか。だとすると、あり得る方法としてはこっちですね。 プリスタクト、こっち側を入れてあげる。 そうすると、プレビューが何にも表示されないという形を 取ってくれるのかな、おそらく。 あれ、違うか。WatchOS。 今はランドマックス4をiOSですね。 じゃあ、pifOSは、あれ、聞き方違います? 1個前。1個前。あれ、違うか。 俳句グラフだったかな? どこかで使ってましたよね。あったこれ。 じゃあ、pifOS、WatchOSですよね。 それで、俳句ViewのWatchOS。 この時にプレビューが、プレビューが 外してるっていうのは、何ですかね、これね。 WatchOSだった時には表示する。なので、WatchOSじゃないんで、 そんなことしないと思ってるんですけど、 そういう話ではないらしい。そうか。 これは放置するしかないのかな。 うん。なんか不思議ですね、これね。動きが。 なんでこれでプレビューが生きちゃうんだろう。 今、まだロードしてますね。 頑張ってビルド中なのかな。 これでプレビューから消えてくれれば、変な悩みの前に、 ターゲットのOSが違うじゃんみたいな感じでね、 早い発見が、プレビューが動かないことに対する 早い発見ができるようになると思うんで、 これで終わってほしいんですけどね。 なんかずっと読んでるのは、もう止まっちゃってるのかな。 もう一回一切読み込みまして、うん。 まあいいか。とりあえず、じゃあ、これを、 昨日はしなかったけど、外側にしておきますか。 外側の方が本来の形な気がするんですよね。 俳句Viewを読もうとしちゃってますけど、これを読めなかったです。 ここから帰ってきて、一回消してもう一回やっても、 やっぱり表示しようとしますね。 このプレビューをちょっとアクティブにしておきますか。 そうすると、IfAvailableになってストラクトを定義して、 それをMakePreviewでアピックファンクしているよ、 という感じのコードがSharpIFの中に出来上がる。 そうすると、うん。悪くない感じですね。 こうした時にこの中でできるけど、 このベースタックはどう使ってるんだ。 このベースタックは、俳句Viewがここに転送されてたのか。 なるほどね。 なるほどね。ということで、SharpIFとかをつけておけば、 ちゃんとここでも機能してくれるということには なってくるという感じですかね。 なるほど。 こうした場合は中でも外でも良いというね。 そんな感じに見えますけど、思ったように動いてないですね。 まあいいか。とりあえず形状は良いでしょっていう感じで、次行きますかね。 プラス、ListMenuModifier。 ListMenuModifierはファインディングきましたね。 そうすると、メモリビューは出てないか。 うん。これらはさっき言ったようにね、プライベートセットをつけたりですね。 言語使用的にはというような感じですね。 これでOKで、デフォルティはコンテンツに対して、 OnLongPressGestureとConfirmationDialogね。 これを表示して、ConfirmationDialogではボタンを表示して、 それで、お気に入りボタンとユーザープロファイルボタン。 あの辺はスマートに書けてる感じしますね。 ユーザープロファイルはトゥルー制御で、 お気に入りボタンはトゥルー制御。 これは意図的にやってるんで、これでOK。 あと、ViewのListMenuとして、これはModifierですね。 Modifierとして、こうやってバインディングを指定して渡してあげるようにして、モディファイヤーをアクセスする。 これも大丈夫ですね。 次、MapViewはここですね。 これはUiとMapKitを使っていて、MapViewの中ではAppStorageとしてMapViewのZoomがセットされていて、 PrivateBarでZoomというプロパティとコーディネート。 コーディネート、これレッドでいいですね。レッドにしましょうか。 こんな感じにして、それでボディはマップをポジション、リージョンで表示してあげるよ。 このリージョン、これの中で約5個目ますね。何のリージョンだろうか。 センターのリージョンスタンクからMapViewのリージョンか。 ランドマーク、コーディネートかランドマークのコーディネートか。 コーディネートに対してコーディネートリージョン。 リージョンでいいか。名前が微妙な感じに接しますけどね。 とりあえずそのまま渡して、あとはMapViewに対してリージョンスパンというのを拡張して、 それがこのね、近隣か、中間か、遠いか、空間するかによってどれくらいの倍率にするかというのをリージョンスパン。 これで手に入れるよということになっている。 スパンってどういう意味なんだろうねっていうのがあったときになるんですけど、Mapコーディネートスパンから取った。 制約に近いので気を付けないと。という間違う可能性があるかもしれないようなことですけどね。 なのでスパンという言葉は意味的に重要な感じもするので、ちょっとだけ調べておきましょうか。 スパンとしては、スパン、あれ、スパン、意味。 間隔とかそういった感じを勝手に想像しますけど、 そんなことないのか。スパンとしてレングス、スパンの意味。 よりや時間よりの広がりを表すんだ。ああなるほどね。 だから、よりの間隔をNear、Medium、Farで表現しているということですね。 なのでMapViewのリージョンスパン、 これリージョンって言わないかもしれないですね。 MapViewのスパンの方がわかりやすいかもしれないですね。 ちょっと名前変えておきますか。 リージョン、リージョンスパン、わかるかな、リージョンスパンで。 リージョンにしておきますか、このエリアの間隔ね。 そうしてみますか、とりあえず。 これでリージョンスパンを生成するのを拡張して、これでOKですね。 Mapが表示できるようになっているよということで、 MapViewも問題なく綺麗な感じにできている気がしますね。 次はプロファイル、ツールバー。これはモデファイヤーですね。 ピューモデファイヤー。 で、それはバインディングだから、ここもね。 ちょっとリアルでは何も言ってないですけど、 プライベートセットの方がソフィスと言語的には いいんじゃないかなという感じがするので、これをつけておいて。 で、これでボディで、これはツールバーに対して、 ドリンクプロファイルをルールにするボタンをね、入れている。 悪くないですね。ヘビーニューステンションして、 モデファイヤーを利用するためのものを搭載する。 うん、綺麗に書けてますね。 じゃあ次、超フェイバリット。 超フェイバリットオンリートグルか。 超フェイバリットオンリートグルというのが、 名前がややこしいですけど、 要は、フェイバリット、お気に入りの実を 表示するためのトグルボタンのことですね。 トグルボタンをトグルって表現するから、 それと同じ名前を習ってつけてるんですけど、 わかりにくいですよね、これね。 トグルって聞くとなんか、常識的に取られてるんですかね。 なんかトグルしそうな感じするけど、 そのボタンないよっていうのは、 トグルボタンとするか、まあこのままね、 流儀に従って慣れていくか。 今回は慣れていくを選びましたからね。 ここのプライベートセットにするのが 言語使用的には良い気がして、やっとおくとして。 で、ボディはトグルで、リズオン、フェイバリットオンリー。 難しいことじゃないですね。 次、スターイメージ。 スターイメージは合同体で、ISACTIVE。 これはREDですね。REDにしましょう。 で、それでボディはイメージとして、 スターを表示して、ここでカラー。 このカラーはどこから持ってきた。 カラーはスターイメージのエクステンションが エクステンションで持ってるからOKですね。 なので、これで良くて。 で、スターイメージとしては、 プライベートでアクティブのときはこのスターイメージ。 インアクティブのときはこのスターイメージを使うことが 簡単にできるようになっているよっていうことを提示しますね。 これ、ちゃんと作ってるのかな。 自分で作っておいてなんですが。 フェイバリットボタンでISET。 これは状態によって変わるからしょうがないですね。 で、あとはこの定義が良くて。 えーと、これか。 ここも状態によって変わるけど、 ISFAVORITEだったときには、 スターイメージのアクティブのものを表示する。 あるなら使おうよって感じですよね。 アクティブ。これで大丈夫ですよね。 そのため、インアクティブに変えてみて、 色が変わる。 ね、変わりますね。大丈夫ですね。 FAVORITEだった場合にはアクティブですよっていうことを ちょっととってOKですね。 うん。 これで使い忘れてた。 用意しておいたのに。 用意するほどでもないと思いますけどね。 これぐらいだとね。 で、それであとはスターイメージの拡張で、 システムイメージネームをプライベートで拡張することによって、 ファイル内だけで使う。内部的にね。 システムイメージネームはこれですよ。 スタートは示してないですよ。って言うね。 と言ったのが、ITSUACTIVEで、 判断立ててね。 選ばれるのとカラーもそうですね。 ITSUACTIVEだと、カラーが選ばれる。 このカラーもカスタマイズできるようにする っていう手がないとは言えないですね。 例えばこれで、RED、TINT、COLOR、 そしてカラーを持たせて、 イニシャライザーを持たせて、 TINT、COLORがYELLOWみたいなね。 こういった風にしておいて、 これでフォアグラウンドスタイルがTINT、COLOR。 こんな風にしておけば、 カスタマイズがいくようになって、 例えばこのプレビューでね。 IMAGE IS ACTIVEでTINT、TINT、COLOR、 そしてBLUEみたいなね。 こういう風にすると、青色の星になるみたいな。 まあ、こういったことができる。 で、PORSの場合は、TINT、COLORは、 えーと、これってどう聞くんだ? えーと、TINT、COLOR。 そして、例えば、GREENとかにすると、 グリーンになりますね。 大丈夫ですね。 まあ、どう聞くかっていうのは、 ここのフォアグラウンドスタイルですね。 これで、システムイメージネームの色が変わっていく。 うん。 こうやってあげると、 まあ、今回の場合は、星黄色なので、 なんの問題もないですけど、 ライブラリーとして提供するときにはね、 ここでは緑で表示したいんだみたいな、 そういったこととかに対応できるようになるんで、 まあ、悪くない対応かな。 ライブラリーとして考えるときはね。 うん。 はい。 まあ、そんな感じで、ここもうまくできていると。 まあ、なんでいいですかね。 いやー、ちょっとクビリがいいんで、 時間的にもね、いい具合なのでこれぐらいにして、 次回はまたこのランドマーク周りのビューのところから、 今みたいな感じでね、様子を眺めつつ、 コードを直したほうが良さそうなのでは? みたいなところを眺めていく。 こんな感じにしていこうと思いますが、 まずはコードを直しきれいになった。 えーと、これ、TINT、COLORですよね。 TINT、COLORを取って、 TINT、COLORを渡してますよね。 だから、ここ、COLORが、IT'S ACTIVE、YELLOW、GREY。 TINT、COLORで状態によって変わるんで、 これ、危ない、バグってました。 ここがCOLORで、このCOLORの中、 ここで、IT'S ACTIVEがTINT、COLORですね。 ここでTINT、COLORを返さないといけない。 で、あ、そうか。非アクティブの時はグレーになるんだ。 そうね。 という風に、まあ、作ってやってるって感じですね。 これは仕様として、ドライブがさっきみたいに、 グレーとしないほうが良いのか、 本来はグレーとしないほうが良いですね。 いろんな場面でね、使えるようにね、作るので。 だから、まあ、その辺が難しいですが、そうね。 難しいのと、このCOLORの変数の意味が微妙になってますね。 COLORは、イメージの実際のCOLORなので、 アクチャル、アクチャルは変ですね。 EFFECTIVE、COLOR、みたいな感じにしておいてあげると、 実際の効果が発揮する色は、どんな感じなのか、 という風に、この中で決定した上で、 実際の有効なCOLORを張っていく。 で、アクティブじゃなかった時に、 グレーであるのが嫌だった場合は、 もう1個ね、TINT、COLORでなくて、なんか、別のCOLORといったものを指定しても 良いかもしれないけど、今回はこれでやっていく感じにしますかね。 危ない、バックルとかでした。 こんな感じで、タイミングはOKなので、 次、また近いね、ランドマーク、 ディテール周りのところから、リファクタリング、 観察かな、でいこうかなと思います。 はい、ではこれで終わりにしますね。 お疲れ様でした。
