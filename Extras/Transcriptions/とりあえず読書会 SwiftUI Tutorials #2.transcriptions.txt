Transcription & Summarize : とりあえず読書会 SwiftUI Tutorials #2

さて、今日もとりあえず読書会を始めていきましょう。 Swift UI 2.0です。 これに前回から入っていきましたけれど、 まあ、まだね、すごい初めのところなのもあって、 まあ、簡単ですね。 簡単すぎて、まあ、まだね、簡単だからかと思うんですけど、 なんか、読んでいてもなんか面白くないなーみたいな、 なんかそんなこと感じたりするんで、 まあ、なんかコメントとか、なんかね、そういったので、 割り込んでもらってもいいのかなーとか、もっと雑談っぽいこと? どっちの方がなんかね、身乗りになるような気もしないでもない。 読むだけだったらね、まあ、好きなペースで読んだ方が早かったりとかしますからね。 まあ、そんなところも一日ずつ、 まだね、どう思うようにいかないみたいなね、 そんなところもあると思うんで、 まずは気ままに、いつもをだんだん掴めるような、 そんなつもりでね、読んでいきたいなとは思います。 はい、まあ、ということで、とりあえず、読み進めていきますが、 こちらですかね。 んーと、今日は、2章。 レーティング&コンバイニングビューズ。 あれ、これ見たような気がする。 Swift UI Essentials。 これを見ましたね。 あれじゃないな。 えーと、あれだ。 ここは読んだ。 まだ1章の話ですね、これね。 あ、この一番下まで行けばいいのかな。 一番下を見ると、どうなるかなとね。 あれだ、えーと。 うん、ここを押せばいいのか。 はい、これエッセンシャルズだ。 まだ、まだある。 えーと、これも、あれでもやった? これやってないね。 2章じゃないのかな? もしかして、えーと、Swift UI Essentials。 読むと、もう、リモートが間違えたかな。 今、トップページに行きましたけど、 1章の、えーと、これ読んで、 2章とか言ったけど、 1章か、まだ。 1章だ。 これの、バインディングリスト&ナビゲーション? ここに来るんですかね。 ここかもしれない。 うん、ま、まず読んでみて。 いや、読み終わって、読むみたいな話になったら、 だけ行けばいいですね。 はい。 では、ま、こんなところで、 いきなり、なんか変なリズムですが、 読んでいきましょう。 えーと、リストとナビゲーションを作るらしい。 えーと、ベストラのマクリティティルビューを作っていく。 えーとー。 ユーザーに、えーと、フルリスト。 ランドマークのフルリストを見せるのを提供する必要があって、 で、ビューのディテール、それぞれのロケーションの ビューのディテールを見つけていくみたいね。 で、それに必要があるのが、えーとー、 インフォメーション、ランドマーク、2義のランドマークの情報。 それを見ているビューを作って、 ダイナミックに、ダイナミックってどういう意味ね。 例えば、ダイナミックって日本語とプログラミングの雰囲気となんか違いますよね。 ダイナミック、まあもうすっかり慣れてるから、 違和感ないですけど。 えーと、ダイナミックアリ、ジェネレート、スクロールリスト。 で、えーと、それが、タップ、ディテールビュー、 ランドマークのビューを、ランドマークの詳細を見るための、 なんかリスト、スクロールするリストを作るらしい。 で、ファインチューン、チューン、ユーアイ。 ユーアイをよくするなんて感じですか? 特にわからなかったけど、えーと、エクスコード、レンダープレビュー。 エクスコード、レンダープレビュー。 えーと、異なるデバイスサイズ、そうね。 ファインチューン、それぞれのデバイスに合わせるという意味か。 そのために、プレビューを使う方法を見ていくらしい。 で、とにかくそれをやるにあたって、プロジェクトが必要らしいので、 これをちょっとダウンロードしておきつつ、始めていきましょうか。 セクション1、ランドマークモデルを作る。 えーと、最初、このチュートリアルの最初で、 まず、ハードコーディング、このチュートリアルで全体の話ですかね。 えーと、インフォメーションを、えーと、カスタムビュー、えーと、 ハードコードしたインフォメーションを全てのカスタムビューに追加した。 うん、そうだったかもしれない。 ね、ここで、えーと、モデル、データをストアする、 落とすモデル、えーと、ビューにね、渡す。 そういったのを作る。 モデルっていうのは、あまりね、自分はこの辺のことばっかり知らないんですけど、 まあ、データを保存、データを表現するものですかね、モデルっていうとね。 ちょっと見ておきますか。 なんか、せっかくならね、自分も調べると、 まあ、普通は勉強ってそういうもんですよね。 だから、モデル、プログラミングにおけるモデル、 モデルとは、プログラミングにおける設計手法や行動の構造を定義する枠組み、 とか言って読んでると思うんですけど、 最近こうやってAIによる概要が先に出てくるけど、 これって、正しいですかね、どうなんだろう。 まあ、モデルぐらいだったら、そう外さないと思うんですけど、 それよりはね、こういうちゃんと、人間が書いた、なんか、お話。 こういう方が、いいですよね。 えー、時々ね、あの、こういったのを間違ってるとかありますけど、 まあ、間違う分にはね、大したことないじゃないですか。 周りの人が直してくれたりとか、直さないこともありますけど、 まあ、それはどっちでもよくてね、とりあえず、 AIはもう間違っても、 AI自体はね、この瞬間には気づけなし、誰くらいも教えてもらわないじゃないですか。 そっちの方が怖いですよね。 なんで、こういうブログの方が安心感があるなというのは、 今のところの個人的な印象ですね。 MVC、モデルビューコントローラーの、 あ、キクタですかね。 モデルビューコントローラー。 まあ、他にもいろいろありますけどね。 っていう、なんかそんな感じの話を聞くような気がするんだけど、 どっちにしましょうか。 モデルビューモデルっていうコート? まあ、でも、わからない、どっちか。 うん、自分にはね、わからない。 普通の、なんか一般的なプログラマーはわかると思うんですけど、うん。 えーと、まあ、どれでMVVMと聞くとはいいから、 MVVMはMVPの派生モデルビュープレゼンター。 そっちかな。 まあ、でも、アップルってあんまりこういうアーキテクチャにこだわんないところがある気がして、 まあ、そこが自分は好きなんですけどね。 状況によるじゃないですか。 アプリ開発ぐらいだとね、2、3人とかで作っていったら、 まあ、プログラマーの力量にもよると思うんですけど、うん。 なんかアーキテクチャを最初に早期で選ぶのも、まあ、いいのかな。 でも、なんか状況、状況によって合わせていくっていうんですかね。 なんかほら、えっと、この読書会で前の課題が入っておけば、 読んだ方が、読んだ本が、ラストだったんですけど、 その、The Last Programming Languageで読んでて、 特にね、はっきり書いてあったのが、 あの、オブジェクト指向を想定したデザインパターンを ラストに投入したときのコードの複雑さが、 ラストの本来の、なんか性能を生かしたコードに直していくと、 全く違うコードになって、非常にシンプルになったみたいなね。 そういった具体例を出してくれたりとかして、 まあ、あれはね、ちょっと賢い人じゃないと、 たどり着きにくい境地なのかもしれないですけど、 まあでも、それぐらいのことを応用にしてやるのとね、 あとは、こういったMVPとかって、 オブジェクト指向でよく使われてたんじゃないのかなっていうところがあって、 これをね、そういう人で表現しようとしたりすると、 本当にクラスがたくさん出てきて、 なんか、クラスばかりになると、 いろいろと大変、難しい、 従来通りのコードになっちゃうっていうところがあって、 なかなかね、難しいところなんですよね。 なので、まあ、両方ですよ。 けどね、キテクちゃんを知ってて、 かつ、現行の性能を生かせるみたいなのが一番いいんでしょうけど、 まあまあ、どっちか? どっちかって言うのもないか、 どっちかできればという分ですかね、まずはね。 あまりよくなってもね、まあいいや。 とりあえず、そんなんいろいろあって、 まあ、思うところはありますが、 とにかくMVP、とにかく、とりわけモデルですね。 モデルをちょっとちゃんと見ておきたいなと思ったけど、 出てこなかったな。 うーんと、モデルとは? っていう話が、 やっぱ、キテクちゃんと話できて、 どこでも一緒とは言えないけど、 まあまあ、ざっとね、 言っておけばいいかなっていう気がするんで、 モデル。 モデルはシステムの中で、 ビジネスプロジェクト、データアクセスを担当しています。 そういえばそうでしたね、 っていうぐらいの認識になったんですけど、 自分は。 ああ、そうだ、そういえば。 こういったことは難しいですよね、なかなか。 ちゃんと知ってる人は、 まあ知ってるんでしょうけど、 そういう人にAPIデザインガイドラインに書いてあるんですけど、 要は、それが本当に意味がちゃんと通じるために、 必要なときにのみ使うことっていうね、 ことっていうもののガイドラインなんで、 あくまでも参考なんですけど、 そういった技術があって、 自分はすごく好きなんですけど、 うん。 まあだからだってね、 このモデルっていう言葉を理解しなくて、 他の言葉にしろってわけでもないですけど、 ただにMVCとかね、 こういった中でモデルとは何ってね、 ちゃんと理解されれば、 意思疎通でね、 しっかりできる言葉でしょうから、 うん。 悪くはないんでしょうけどね、 うん。 なんかめちゃくちゃな感じの話になってきたな、 まあまずモデルを理解しろって感じですね、 ビジネスロジックとデータアクセスを担当する、 結構幅広い守備範囲かなっていう気がするけど、 個人的にはなんか、 あ、データを表現するかと、 みたいなイメージを持ってたけど、 それよりはるかに多いですね、 ユースケースとか、 こういったのと、 あとなんだ、 データアクセスっていうことは、 一般にリポジトリとか言うんですがね、 そういった辺りも担当する方向向いておいた方がいいかな、 まあMVC見てもしょうがないかもしれないですけど、 要はコントローラーでモデルとビューの中間、 モデルはさっきのですね、 ビューはビューですね、 うん、 まあまあ、 なんとなくイメージが浮いたような気がする、 MVCであれじゃない、 あのUIキットの構成じゃないですか、 ね、 それならあの、 UIキットの分割として自分は慣れてるんで、 うん、 大丈夫な気がする、 イメージがつきやすい気がする、 うん、 で、 まあとにかくそうやって、 具体的な機能としては、 アプリケーションデータやファン数、 コントローラーやビューと違いますもんね、 ちょっとね、 なるほど、 まあそういった担当の者がモデルで、 なんでモデルの話になったんだっけ、 ここか、 えーと、 この辺に出てきたんですよね、 ここだっけ、 えーと、 これがここでモデルを作って、 データをストア保存する、 えーと、 ビューに表示するデータを保存するよと、 うん、 で、 えーと、 オンプリティットプロジェクト、 えーとさっきの、 あ、さっきのじゃない、 前のチュートリアルで作ったやつと、 で、 ディスクリプションがあって、 はいととしてその種類、 こういったデータをいろいろ持たせるよ、 ということね、 なるほど、 今まではこれをハードコードしていたけど、 ちゃんとモデルに持たせて、 ビューに入れ込んでいくよというのを、 今日はやっていくらしい、 で、 そのステップ1として、 えーと、 ランドマックスデータチェストの、 さっきダウンロードしたリソースから、 えーと、 プロジェクトに入れてくれと、 で、 えーと、 ナビゲーションペインに入れて、 えーと、 あと2ターゲット、 これをね、 ここだけちょっとやってみますか、 えーと、 前回のがあるので、 これを開きますが、 今回はちょっとその前に、 ダウンロードしたやつをね、 使う必要があるので、 これを投げ込みます、 これ最大化しても投げられるのかな、 みたいなことはこんなところで実験してみよう、 えーと、 ダウンロードしたやつ、 あれないな、 えーと、 さっきダウンロードしたのは、 ここに、 えーと、 ダウンロードは、 ダウンロード、 あれ、 ダウンロードフォルダーにない、 うーん、 もう1回やりますか、 ロジカ、 このエクスコードのファイルの中に、 これのリソースをね、 えーと、 ランドマークデッドジュースというのが、 さっきの中に入ってて、 やっぱり投げられないか、 ここからだとしたら、 まあまあ、 デカくなので、 おまけな感じですが、 これを持っていきましょう、 はい、 あ、ここ、 そう、 これいいですね、 そうしれば、 それっぽい、 えーと、 ダウンロードしたやつのリソースの中に、 ランドマークデッドジェットというのがね、 あらかじめ用意されているので、 これをランドマークズに投げ込んで、 で、コピーファイルストゥディスティネーション、 なんか、 ちょっとやるとメニュー変わっちゃってますけど、 これでいいですね、 コピーファイルストゥディスティネーション、 で、されて、 ターゲットランドマークズっていう感じで入れてあげると、 これが、ランドマークデータが、 ファイルプロジェクトのあるファイルの中に書かれる、 ここね、このパスなんですけど、 中にコピーされた上、 このターゲットメンバーシップにランドマークズが追加されていると、 なので、クロスし忘れた場合には、 この辺をね、操作して、 あ、この辺というか、 メンバーシップチェック忘れた方から、 追加してあげるみたいな感じですね、 まあ、それはちょっとしょうがないから、 なんとか頑張らないといけない、 はい、まあこれで、コピーできて、 あ、で、実際にそのファイル見ておきましょうか、 画面が拡大されすぎて見にくいですが、 これで、名前が何だったか、 アテゴリが何だったかね、 ITが何だったか、 じゃんとデータが揃ってる、ありがたいですね、 こういったデータ用意してくれると最高ですよね、 まあ、そんなので、とりあえず用意ができました、 というのがここまでですね、 ステップ3、ランドマークコード体を定義して、 いくつかのプロパティ、 名前、さっきのランドマークデータファイルと一致する名前のコード体を定義して、 コード体を定義して、コーダブルコンフォーマンスを使って、 データをコード体へ簡単に変換できるようにしようと、 まあ、コーダブルの話、どこまで出てくるんだろう、 これ、楽しみですね、 それで、コーダブルコンポーネント、 コーダブルのデコーダブルコンポーネントを、 リレーしてまた、選択する、アテル、求める、 まあ、よくわからなかったけど、 とにかくデコーダブルコンポーネントを使って、 後でデータをファイルから読み込むよ、という形、 これはコピーしちゃったほうがいいのかな、 IDネームパック、ステートディスクリプション、全部ストリングとIDがインと、 これは作ってみますかね、 コピーばかりに頼ると、なんか面白くないんですよ、 なので、実際、なんか理解不安かりしますしね、 リソーサーや、これで、えーと、 まあ、なんだっけ、うーんと、 作ればいいのかな、ランドマークする人が、 これを作りますね、まあ必要は必ずしもないんですけど、 一般的にね、プラスじゃない方ごとにね、 クリックしていくんで、 ウィフトファイルを選んで、ランドマークっていう、 アイオンを作ると、ランドマークする人ができるんで、 ここにですね、ドラッグと、 ランドマークデータと同じ項目を、 用意していくことになるんで、 えーと、それでちょっと、ナビゲーションで、 またクラフトしますが、 これくらいでいいかな、ちょっと狭いですけどね、 この、なんだっけ、ミニマップ消したいですね、 ミニマップ邪魔なんですよね、自分にとってね、 ミニマップは、エキストエディターの中に、消せるのかな、 えーと、ネジドーバースクロール、モールってなんだ、 これは、何かがあった、まあとにかくミニマップじゃないから、 興味ないや、これでミニマップにしといて、 えーと、エディティングディスクレーターの、 コードのプライナンバーでしょ、 で、コードホルディングリボン、えーと、横のね、 コードの、関数ごとに閉じたりできるやつ、 まあ、スロープにもしてますが、 えーと、どうにしようかな、オンにしてもいい気がするな、 うるさくなる、ちょっとだけね、ここ開いたくぐらい、 うん、まあちょっとでも見えたほうがいいかな、 で、えーと、コードストラクチャー、これだ、多分消した、 あるいは、これはコードストラクチャーってあるか、 だからどこまでのコードですよって感じか、 で、セパレーター、まあこれはいいとして、 インタフェースコードを、 あ、インアクティブコードを、なんか無視するみたいな感じと、 コードパヴァレット、まあこれはいいですね、 で、えーと、えーと、フォーキュメントデリミッター、 ロキュメントコメントマークがプラップインライン、 ここじゃないですね、ここか、 そうすると、エディティング、エディティングの中で、 サチェストはいいとして、 エスケープキーの話はいいとして、 オートマチックで何か閉じるのが多いでしょ、 で、えーと、プロトコメント閉じる、 タイプオーバーコンプリッション、なんだそれ、まあいいか、 えーと、で、あとは、オブジェクティブCメソッドの調整と、 エンクローズセレクト、マッチングデリミッター、これもいいですね、 うん、せっかくすると閉じ方が見えるやつね、 で、あとは、うんと、オートマチカリ、違うな、 マップインデンテーション、ここじゃないですよね、 インデンテーション、えーと、この辺に何かあるかな、 うん、コード、ミニマップを消したい、というね、 そういったことになってますが、 エディティングじゃないのか、テーマかな、 テーマは色付けるやつですよね、 で、あとは、えーと、考えられるものとしたら、ナビゲーション、 ナビゲーションの中で、えーと、この辺は、 どうクリックするとどう反応するというね、 そういった設定が主だと思うので、これも違うよね、 で、ね、あれとして、アピアランスは、 これは、あの、インタークラウドのやり方ですよね、 で、えーと、問題はインラインに出してほしいし、 で、えーと、ファイル、拡張し、ナビゲーション、 ナビゲーターサイトってなんだ、 あ、上のバーのことかな、で、あとナビゲーション、 イシュー、デバッグ、あ、ナビ、とか、 うん、まあ、いいか、えーと、やっぱり見つかるでしょ、きっと、 Xコード、ミニマップ、表示ね、とりあえずこれで、 プラス、エディターの右上のプラス、 エディターの右上のプラス、こっちか、 これを押して、違うね、これじゃないね、 Xコード、DVじゃないんでね、アイドミニマップ、 あ、ここか、えーと、アイドミニマップ、 この辺かな、アイドミニマップ、あ、いいんじゃない、 あ、両方消さないとダメなのかな、アイドミニマップ、 うん、あ、広くなっていいですね、 じゃ、これでストラップっていきますが、 これでランドマーク、ランドマークだと作って、 全部バーでしたよね、普通はバーなんですよ、 ID、イントで、普通は言い過ぎたんですが、 IDと、いろいろあって、 えーと、IDとネームと、ちょっと、やっぱり、 ドキュメント見ないと、わからないですね、 全部をね、作るとか、 そういうんだったらよかったんですけど、 ID、ネーム、アークステート、ディスクリプション。 アークステート、ディスクリプションね、ネームと アー、アーク、ストリング、アー、ディスクリプション、 ディスクリプションっていう名前が、 ディスクリプションって名前は、 ちょっとさざいんですよね、いつも的には。 これね、カスタムストリングコンバーティブル ってことばって、 これを使ったのをテキスト、このインスタンスが 表示されるテキストをカスタマイズできるんですよね。 その、カスタムストリングコンバーティブルは カスタマイズするために、 実装するべきプロパというか、ディスクリプションなんですよ。 このディスクリプションを何をするかというと、 そのインスタンスがテキスト表現できると想定して、 そのテキスト表現を表す、 要はインスタンスの表している値が何なのか、 っていうのを説明するためのテキスト。 それなんですけど、ディスクリプションだけ取っちゃうと、 これほら、例えば、パープルロックの情報なんですけど、 このディスクリプションを見ると、 別にパープルロックって出てこないじゃないですか。 なので、この説明を読んでね、 これパープルロックじゃん、みたいな感じで、 まあ、そういったのなら、どれが成り立つのならいいんですけどね。 まあ、そうじゃないとすると、 ちょっとパフォーマンスストリームコンバーティブル、 まあ、全部は立てないんで、今回は。 なので、まあ、どこまで考えなくていいのかもしれないですけどね。 ディスクリプションだと、うん、なんとなく微妙なんですよ。 なので、改造したい気もしないでもない。 えっと、まあ余計なことしないほうがいいのかな。 まあ、余計なことせず、行きますかね。 うん。余計なことしたい気もするけどな。 各所からやっていく。 まあ、それで混乱したら混乱したで、頑張ればいいか。 っていう感じで、行ってみましょうか。 あ、でもね、やっぱり、スウィフトUIチュートリアル。 いや、でも、セパートスウィフト1って言ったら、スウィフト5とか来たいですよね。 まあ、ただ、ひとゆえがいいな、ところもあるかもしれないですけど。 まず、やってみるか。 うん。なんとなく、余計なことする気がするな。 まあ、困ったらにしますかね。 ちょっとね、まずは、あの、調べていきましょう。 どっちかというと、やっぱりね、あの、ディスクリプションが嫌だから、 これ、サマリンにしようかな、みたいなことを、今、ふと思ったんですけど。 サマリンにしてしまうと、まあまあ、こっちは、いいんですけど、 このランドマークと、こっちのランドマークのデータね、これが普通になってる中で、 左はサマリンって言ってるの、右はディスクリプションって言ってるっていうのはね、 結構、いいな、驚きに繋がってきますよね。 そうすると、やっぱり、よろしくないかな、っていう気持ちが、 なんとなく、たまってきたので、ディスクリプションにしましょう。 で、名前を一致しておくと、もっとね、いいこと、いろいろあって、 ここで、コーダブルですよね。コーダブルというプロトコルに準拠すると、 同じフィールド名を使って、まあ、サマリンでできるんで、 サマリンにしたって、全然大丈夫なんですけど、 まあ、これでね、あの、同じ名前同士、 ジェイソンと型を、あの、自由にね、変換、行き来できるっていうね、 そういった、あの、特徴が、自動的に実装されるんで、 これだけでね、ジェイソンファイルから、インスタンスを作るっていうことが、要因になる。 で、あとさっき、ハッシュボルもついてましたね。 これは、後の事情だと思うんですけど、 まあ、ハッシュ、ハッシュって何かというと、 えっと、あるものを有限な範囲の数値に、言い表すみたいな感じで、 えっと、これによって、例えば、そうだね、 えっと、その時にも、いろいろあって、 ハッシュ値っていうのは、値が異なれば、 絶対に違うインスタンス、インスタンスじゃなくてもいいんですけど、 その、ハッシュ値を求める元になったものが、 絶対違うっていうのが保証されるんですよ。 まあ、そういう値をね、参照とするのがハッシュ値。 で、ハッシュ値が一致した場合には、えっと、 それが同じかもしれないし、違うものかもしれない、元の値がね。 っていう、そういった性質を持っているのがハッシュ値。 うん。なので、えっと、これを使うことによって、 この、例えば、ランドマークだと、 IDとネームとパークとステップとディスク率量、 この全部の値が違ったら別のものですよね。 なので、普通にチェックしようとすると、 これら5つのものをチェックして、 全部が合ってるか違うか、そういったのね、 判断しないといけない。 ただし、ハッシュ値を使うと、えっと、これをね、 一つのイントバーにしますね、そういう人のハッシュ値はね。 なので、数値同士の比較で、とにかくその元の値が 同じかもしれないとか違うことが確実に判断できる。 っていうね、そういったものですね。 ハッシュ値が1のものと、ハッシュ値が2のものだったとしたら、 元の値は両方全体違うよっていうのが分かるんで、 1回の計算でサクッとね、違うっていうことが分かる。 で、ハッシュ値が一緒だったときは、やっぱり分かるんですけど、 こういったのをコリージョンって言うんですけど、 例えば、両方ともハッシュ値が一致だったというときには、 値が同じかもしれないし違うかもしれないんでしょ。 なので、ハッシュ値が一致したときには、 全部を比較していかないといけないんですけど、 で、これで同じならいいんですけど、違うような場合は、 衝突が起こったっていう感じで、 ハッシュ値はこうやって、ハッシュ値が一致したときには、 比較のことが急に跳ね上がるというか、 元々断雷の毒が、それプラスちょっとかかってくるんで、 なのでね、ハッシュ値がなるべくぶつからないようなものを 計算するっていうのが、より良いハッシュ値と言われる。 まあ、そんなのはシステムとか、いろんな数学者とかが 頑張ってやってくれてるんで、普通のプログラマーはね、 そんなピンにする必要はないのかな。 自分はピンにしたことないですけど、そういったのがハッシュ値。 このハッシュ値を計算できるよっていうのが、 ハッシュアブルっていうところで、 このプロトコルにぴょんぴょんさせてあげると、 ハッシュバリオというものがね、計算できるようなシステムが、 今回の場合は自動で作る。 なぜ自動で作るかというと、 イントー型もストリング型もハッシュ値を 計算できる型なので、 こういった型だけで構成されている型については、 どれらのハッシュ値をね、 ハッシュ値の生成器かな、とにかく内部的に、 余地なりにハッシュを計算するっていう機能を 勝手に実装しているハッシュアブルを搭載するだけで、 これもプロトコルテキューボーの構成という機能の用意なんですけど、 そういった感じで、ハッシュアブルとコードアブルとね、 コードアブルはさっきの最初の話、 JSONから変換する、この2つを後で使いたいんでしょう。 コードアブルとハッシュアブルは全然別の話なんで、 この2つはバラバラに考えてもらって、 今度はスルーと、良くないですからね。 とにかくこうやってランドマークという構造体が 出来上がりました。 これはJSONからの相互変換が可能で、 JSONとのですね、JSONとの相互変換が可能で、 ハッシュが取得可能なフィールドがこの5つある、 ランドマーク型ですよ、構造体ですよ、 っていう風になった、ここまでですね。 で、次にいくつかのステップ、モデル、イメージ、 それぞれのランドマークに割り当てられているイメージを モデル化するみたいな感じですかね。 それでJPEGファイルをプロジェクトに入れましょう、 ということになるらしい。 リソースファイルになるらしいですね。 プロジェクトに入れるにあたって、 アセットカタログですね、インターセットカタログ。 新しいイメージを自動的にそれぞれに対して作ってくれると。 で、ニューイメージが、タトゥーイメージジョイン。 タトゥーログ1、ジョインって入ってる。 ジョインって組み込まれるとかね、 そういった意味だと思うんですけど。 実行するか、ニューイメージジョイン1を タトゥーログなんで前回出たんですけど。 他の、それは以前からあるから、 今回のに入ってないってことですからね。 さっそく入れていきましょう。 入れるにあたっては、ダウンロードしたのがあるんで、 これを入れていきますが、 とりあえず並べて見やすくして。 これのプロジェクト、横のデザイン。 どちらでもいいんですが、このアセットですね。 このアセットの中に、リソースの中にあったイメージ。 この中のイメージを全部選んで、ポイントをここに投げてあげると、 はい、いましたよという感じですね。 なってきましたね。 これでいいかな。 たたび、ドキュメントに戻ると、 戻らない。Xコードでなくてさっきだったんですね。 はい、ドロップできました。 次ステップ5として、イメージネームプロパティ。 これを、Name of the image from the data、イメージネームプロパティ。 そのイメージをね、データから呼ぶためのイメージネームを追加して、 で、計算型イメージプロパティ。 珍しいかとするけど、計算型プロパティのイメージ型なんですよね。 それでイメージはデータカタログからロードするというシステムをやる。 で、プライベート、プロパティをプライベートで定義する。 なぜなら、ユーザー、ランドマークの構造体はイメージプロパティからのみアクセス管理するから、 プライベートでいいよというお話ですかね、イメージのプロパティは。 で、それが、サンプルコードがない気がするけど、 ランドマークにスウィフトUIを入れて、これはイメージを使えるようにするというお話ですけど、 で、そうして、これをまずやりたかったか。 まずやりたいですね。 で、それでランドマークロケーションのマネージをしていく。 あれ、時間ね、もう終わってる。 自分の役が悪いのかな。 イメージネームプロパティを作るんですよね、イメージネーム。 で、fromUserDataから読み込みを作ってあった。 作ってないよね、ノープレビュー。 うん、まあいいか、いいのかな。 ランドマークにスウィフトUIをインポートするだけなら、 また強になったらいいと思うんですけど、どうしますか、よくわかんないね。 で、とりあえず次にコーディネートプロパティを作っていく。 で、そうしたコーディネート型を作って、それをJSONデータの構造と合わせていくよということみたいね。 で、マークディスプロパティをプライベートとして定義する。 なぜなら、次のステップでやるパブリックデータ型プロパティでのみ生成するから。 うん、そうなのか。プライベート、まあなんか、 自分は普通にインターナルで作る気がするけど、まあまあそれは自分が見越せないわけですかね。 とりあえず、コーディネートプロパティの方が、 こっちはプライベートにするらしい。 で、それでもプライベートにするんだ。 ネットプライベートコンピューティプロパティで作るから。 うーん、どうなんだ、なんか違和感がある。 まあいいや、作っていこう。 これもハシャブルとコードアウェイの構造体で、 ラティチュードとロンギティテュードね。 ロンギティテュードにこれをダブル型で作っていくよっていう感じみたいに。 コーディネートってなってる。 コーディネートとコーディネート、ラティチュードとロンギティテュードを、 この2つでコーディネートになるのかな? ちょっとここも疑問だから調べてみよう。 コーディネート、コーディネート。 えーと、コーディネートが、えーと。 曖昧? あ、違う。 何だっけ? わからなかった。 算数系? あ、これでいいや。 コーディネートとX&Yコーディネート。 X&Yコーディネートを勉強した。 数学的には複数になってる。 代表が言うと、コーディネートという複数系はコーディネート。 だいたいだってこの対象があるので、複数系を聞くことが多い。 まあそういうことなんだ。 だからラティチュードとロンギティテュードも、 呼ばわせてコーディネートなのかということかもしれないですね。 ざっと見る限りね。 そういうことにして、適してみますか。 また新たに内容を1個作って、 コーディネート、コーディネート。 コーディネート型を作って、この中でストラクト、コーディネート。 で、ハッシャブルとオーダブルにして、 これでバーでラティチュード、これがダブル。 で、バーでロンギティテュード、これがダブル。 プライベートにしてましたね。 同じファイルに書いていただけたさっきは。 で、ランドマークの中に所属させるみたいなね。 こういった感じになってますね。 なので、これはエクステンションで、 ランドマークみたいな風に書いてあげると、 これでランドマークが残り方をするコーディネートだと、 こういう表現が可能になる。 ハタ拡張というのですね。 これを使ってランドマークをコーディネートで、 ハッシャブルとオーダブルで作ってあげるよ。 これの大事なところとしては、コーディネートというのは、 座標みたいなお話でしたよね。 ランドマークに所属させないコーディネートというのは座標なんですよ。 それに対してランドマークに所属させるコーディネートは、 ランドマークの座標なんですよ。 こんな感じで、あたりに密接に変わってくるのが、 こういったものは状況にもよってきますけど、 中に入れ込んであげるみたいなことをすると、 なかなかいい感じに表現できたりするので、 こういったのを考えながらカットを定義していくのが、 おすすめなところ。 こうしたわけで、ランドマークの方のプロパティに、 プライベートパーでしたよね。 これでコーディネートで、ランドマークがその中なので、 ここは何も断りなくコーディネートがあったみたいに、 ここができる。 これを作った場合には、こんな感じで、 ランドマークのコーディネートって、 こういった表現になってきて、 これでわかりやすいでしょうね。 コーディネートはランドマークのコーディネートですよ、 って言ったらもう、さっき分かれちゃうんですか。 コーディネートはコーディネートですよって言ったら、 そういった人と勘違いする人もいるかもしれないし、 みたいなふうに、要は語弊を含み出してくるという、 こういったところが大きいところで、 これを名前付くというのを活かしていくと、 わかるようですね。 こんな感じで、コーディネートはプライベートパー、 まだちょっと半信半疑なんですけど、 プライベートパーで定義して、 コーディネートコンピュータの ロケーションコーディネートプロパティーを作っていくらしい。 役立つ、インタラクティング、 実はマップディットフレームワークで役に立つ。 それを作っていくのか、そのために、 インポートコアロケーションを定義する。 最後に、ファイルから。 あれ、なんか表現抜けてない? これ作り終わらせるんじゃない、もしかして。 画面大きすぎるのかな、チェックするとどうなる。 あれ、ここだけど、このままかな。 あ、あった、ImageNameプロパティーあった。 画像とか画面拡大すると見えなくなるのか、これ。 あ、ないのか。あ、出た出た。 何したんだ。プライベートしたら出てきた。 これでいいや。 スイスと言われて定義して、プライベートパーで ImageName。 え、えーと、えー、あー、それでパーでイメージで、 ImageNameを提供するのか。 あ、こういうこと普通にやるんだ。 なんかこれ、どうなんだろうみたいなことをすごく感じていて、 微妙じゃないのって思ったけど、 スイスと言うとリアルに出てくるのか。 なるほど。どうかどうしようかな、これ。 直したいですね。いやでも、いや、悪くない。 自分の頭でもただの感覚的なところなんで、 どっちがいいとかいう話ではなさそうなんですけど、 自分の中ではなんか、JSONタイがちゃんと対応付けたいっていうのが、 ま、もちろん、あの、パターンとしてもいいんですけど、 同じのJSONの生データの一部をプライベートにするっていうのが、 なんとなく結構覚えたんですけど、 いや、悪くないか。改めて見てみると。 これでやったほうがいいのかな。 プライベートイメージネームにして、 ImageNameは隠蔽しておいて、 そのイメージネームからイメージを生成するよ。 で、外側からはイメージを見えるようにするよ。 うん、ランドマークのイメージ。 ま、確かに悪くないのか。プライベートパワー。 だかこうしてしまうとですよ。 えっと、これコードブルにしてるじゃないですか。 ま、いいんですけど、 イニシャライザーもインターナルで公開されてる中で、 ImageName、あ、これもイニシャライザーで提供されるからいいのか。 ああ、いいのか。いいかもね。 うーん、やってみますか。ちょっとしたたってみますか。 イメージネームをちゃんとプライベートパワーで定義して、 イメージを返す。それやってみますよ。 うん。あ、自分が微妙だかもしれないですね。 スイスとUIをインポートすることでイメージを見えるようにした上で、 で、それで、えっと、コーディネートさっきさっき後で出てくるやつですけど、 写真上で写真上というか、画面に表示されてなかった、 あといった都合で、えっと、先にやっちゃったんで、 まあまあ、ちょっとおいときますけど、プライベートパワー、イメージネーム。 これはね、ランドマークデータ、これに合わせてますよね。 ランドマークデータのイメージデータ、イメージネーム、 イメージネームプロパティがあるので、 えーと、イメージネームとフィールドがね、あるので、 あるよね、ディスクリプションと、 あぁだ、イメージネームね。 これがあるのでね、それと合わせていこうということで、 で、これはJSONではストーリングなので、 これをね、イメージネームに合わせていって、 で、その上で、プライベート、違う、 これがパブリックじゃない。インターナル。 まあ、イメージとしてイメージ。 で、えーと、これで、普通に普通にというのか、 まぁこれで、イメージのネーム、ネームは、 イメージネームか、イメージネーム、 こんな風にしてね、これで公開するイメージは、それで、 で、えーと、なんかここどうしようかな、 これでいいかな、まあいいですよね。 うん、まあいいか、ここはこれでいいにするかな。 あとはストリングで、これがイメージがイメージ型であって、 で、イメージ型、そうだ、これコーダブルかどうかによっても ちょっと面白いことできるんじゃない? えーと、余計なことしだしますが、えーと、このイメージがあって、 まあ、アルケンさん方がプロパティでしょ? ちょっとこれを、えーと、一旦コメント渡しました。 このイメージネームがそのまんまイメージだとするじゃないですか。 そうすると、そうですよね、こっちエラーになって、 なぜエラーかというと、 コーダブルに勉強していない。 あとは、変更ダブル。 発車ブルも来るか。 えーと、発車ブルが来る。 うーん、発車ブルも来るか。 ちょっとややこしくなっちゃいますね。 独自の型を作る手もあるし、イメージのままいく手もあるし、 どっちがいいですかね、イメージネーム。 いや、これのストリングにしてイメージ。 まあ、これでいいかな。 どうしようかな、なんか、なんとなく、微妙。 まあ、まあいいか。 まずはそれでやってみますかね。 独自のランドマーク用のイメージ型というのを作る手もあるわけですよ。 これやってみようかな、ちょっとせっかくだから。 えーと、例えば、型を分けなくていいかな。 まあ、ここら辺にちょっと追加であげますけど、 ランドマークの中で、えーと、ランドマークの中で使うドラフトイメージというのをね、 用意したとして、 で、今回はこれコーダブルと発車ブルであってほしいなというところがあり、 で、それで、この中で、ちょっとこれ難しいですけどね、 イメージの中で、バーとしてローバリオというか、 ネームでいいですね、イメージネーム。 うん、ネームでいいですね。 これをストリングで持たせる。 これをイメージネームから作るとね、コーダブルで変換するためには、 ちょっとこれだと厄介。 というのも、ここでね、イメージネームの中でオブジェクトとして、 ネームとしてカードロックみたいになってないといけないんで、 互換性というか、ちょっとね、JSONとコードがずれちゃうんで、 こういったときには、コーダブルが必要としているメソッド、 InitFromDecoder。 まだ、この中いろいろ勝手に増えたの。 えーと、KeepValue。 これ違いますね。 えーと、求めるものと違う。 とにかく、イメージ型は、ここのJSONではストリング型、 唯一1個のデータとして表現されているので、 コンテナーをシングル、 全部消そうかな、ちょっと。 ややこしいので。 これを慣れているとね、簡単なんですけど、 えーと、ここで、コンテナーとして、 えーと、デコードとして、 デコーダーのシングルバリューコンテナ、 シングルバリューコンテナ。 名前からしては明らかに、 単一の値に対するエンコーダーですね。 それのコンテナ。 で、これでコンテナを作ったら、 InitFromだからこれで、 えーと、いきなりもうやっちゃいけないかな。 Nameイコールコンテナーに対して、 えーと、コンテナーエンコードの時は、 バーですね。 コンテナーイコール、 トライはいらないから、 エンコーダーで、 シングルバリューコンテナ。 で、それで、 コンテナーに対して、 エンコードで、 Name。 こんな風にすると、 持ち列に対してね、 チェストエンコードで、 コードがいきなりできる、 イメージ型が完成して、 これで、 コードをプルト発射する要法をね、 持ち回してね、 これをそのまんま、 イメージネームじゃなくて、 イメージプロパティにして、 ここにイメージ型、 こんな感じでね、 専用のイメージ型を作ることによって、 で、そうして、 またドキュメントに戻りますが、 ここに取ってありましたけど、 この追加されたコード1個でね、 そのために変な準備が、 あるわけですが、 これが、 ファイルをリフレッシュすると、 えーと、 こっちまで戻っちゃうんだ。 画面をオープンしてると、 コードが途中までしか見えないという、 そういった問題があることに、 今やってたのがここですよね。 それで、困ってるんですが、 間違えたとすればいいんですけど、 とにかくそれをやって、 これがね、 プライベートになってるのが、 すごい気になってたんですけど、 これについては、 この後でね、 ロケーションコーディネートプロパティを、 計算型で作ってます。 キットフレームワーク、 簡単にね、 使うようにしようというお話で、 このためにプライベートにして保護して、 で、コアロケーションを使って、 このファイルですよね。 このファイルの中で、 えーと、 ここですね、 ロケーションコーディネートは、 シールロケーションコーディネート2D、 で、それができると、 コーディネートと、 えーと、 ランドマークの名前空間内に、 わざわざそれ用のコーディネートとして、 座標をね、 表現できる型を作ったにも関わらず、 これをプライベートにするっていうのが、 すごいもったいなくなんですが、 そういったのを踏まえると、 コーディネートに表現させたほうが、 本来ランドマークとしては最適なわけですよ。 で、このコアロケーションのね、 座標、 これを表現するっていうのは、 純粋に、 これはマップキットと連携したいがために、 考え出したやつですよね。 コーディネート型を、 CLロケーションコーディネート2Dに変換する、 っていうね、 こういった表現の行動になってるわけですよ。 こういった時に、 そういう人は、 APIデザインガイドラインでは、 変換イニシャライザーを定義して表現しよう、 っていうのを推奨している。 ここはそれをやりましょう。 そうすると、 コーディネート型はもうそうですけど、 CLロケーションコーディネート2Dを 超拡張してあげるという取り方をしますね。 なので、 えーと、 ここで、 だから、 まずこのね、 ファンデーションをインポートしてますけど、 ファンデーションを使ってないときは、 自分は消したい派なので、 消しておきますか。 これで、 いいかな、 コピーしただけですね。 で、 ランドマークのほうがスッキリしました、 というのと、 TWIFT UI、 TWIFT UIもいらないですね、 そうするとね、 ファンデーション、 ファンデーションもいらないですね。 でも、 このインポートを消していくだけよって、 自分は不毛に思うんですけど、 どうなんですかね。 なんか、 いいけど、 うん、 まあいいや、 とりあえずこれで、 イメージとコーディネートができて、 コーディネートなんですけど、 このときに、 特にしますかね、 コーディネートでいいかな、 コーディネートの中に、 インポート、 CL、 あれ、 コアロケーションを定義というか、 インポートして、 その上で、 変換イニシャライザーは、 変換先に実装するというのが、 APIデザインガイドライン流なんで、 エクステンション、 CLロケーション、 コーディネート2D、 こっちに対して拡張して、 変換のことを、 バリュープリザービングタイプコンバージョン、 という名前がつけられていて、 要は対応方程式のコンバージョン、 昔はこれを全部変換と言ってたんですけど、 最近はバリュープリザービングという言い方をして、 そういったイニシャライザーのときには、 ラベルを省略して、 リスを受けるというのがガイドライン流、 ロケーションを取って、 ここで変換元の方なんで、 ランドマークのコーディネートを取る、 というね、 こういったイニシャライザーを定義してあげて、 これで、 ですよ。 というのが、 ロケーションのラティテュード、 ロンギティ―ト、 ロケーションのロンギティ―ト、 こんな風に太い、 ダメだった。 セルフがいる? セルフがいる? ああ、そうだ。 そういうことのコード体の性質で、 他のモジュールで定義されている、 コード体を発表したときには、 必ずイニシャライザーを通して、 初期化しなければならない、 なぜなら安全性を担保できなくなってしまうので、 それを許さんって、 それ以外のことされちゃうとね、 そういった事情があるんで、 これの中で、 ロケーションのラティティ―トと、 ロケーションのロンギティ―トを渡してあげる、 こういう風な形にしないといけないんでしたね、 忘れてましたが、 こんな感じで実装できる。 そうすると、 何がすごいかというと、 APIデザイン外観にしたことで、 どういうことが起こるかというと、 関数があったときに、 例えば、 バリューがあったりとか、 インテリアでしょうか、 インテリア、 そして数字、 イント型の数字があったとしますよね、 これを不動所数点数型に直したいときって、 これと同じことが、 例えば、 コーディネーツ、 そして、 ランドマークのコーディネーツで、 これで、 ラティティ―トとロンギティ―トを、 例えばあったとして、 こういったのがあったときに、 それで、 ALコーディネーツに変換するときに、 コアロケーションのコーディネーツ2D、 それに対して、 コーディネーツって渡してあげると、 型変換ができる。 イント型からダブルに変換するときの型変換と、 ランドマークコーディネーツから、 ALロケーションコーディネーツ2Dに変換するときの、 書式が全く同じ。 これをする人らしいというわけですよね。 なので、 この形のほうが、 本来、 事前の感じ、 まあ、 それと言われると全然関係ないですけどね。 こんな感じで、 作ってあげたほうが、 いいよというふうに、 ガイドラインが言っているので、 そう作りました。 という感じ。 で、 これでいいですね。 ALロケーションコーディネーツ2Dのための変換も用意できて、 さっきのね、 このセクションで言っている、 このインターフェース、 少なくとも、 自分のメニューは、 ストリームにできた。 という感じ。 これでOKですね。 とりあえずね。 これで、 パス、 デコート閉じるのか。 いいですね。 やっと分かってきた。 これ、 途中までしか出ていないと、 分かんないですよね。 困りますね、 これね。 まあいいか。 あんで、 頑張る感じですかね。 次、 ステップ8。 ニュースウィフトファイル。 これはいいのかな。 モデルデータを作る。 モデルデータ。 今作ったモデルデータじゃないのか。 という、 ロードメソッドは、 テコダブルプロトコルに 添付している。 オーダブルプロトコル。 コンフォーネント部分、 コトブルプロトコル。 英語で言うのかな。 リターンタイプのコンフォーマンス。 ああ、 テコダブルね。 ジェネリック使っていくんだ。 面白いね。 しかも、 モデルデータスウィフトで、 今のところなのかな。 フリーのファンクション使っていきますね。 スウィフト APIデザインガイドラインの話に またなるんですけど、 フリーのファンクションは、 所属先が見つからなかったときに限って使っているのが 提唱されているんですが、 ロードはどうだろうね。 こんなところにあっていいのかな。 まあ、後々変わっていくかもしれないし、 状況が見えていたら、 改造していこうかなと思いますが、 ジェネリック関数ですね。 ファンクションがあって、 ロードという名前があって、 ある型Tがあって、 Tは何でもいいけど、 デコーダブルにしてくださいね、 ということですね。 それで、ファイル名を受け取って、 Tだからテコダブルな型を返す。 それで、データがあって、 データをメインバンドから呼び出してなかったらエラーです。 まあ、まあいいか。 データがあって、ガードして。 不思議なことですね。 で、ToCatchでデータをJSONから変換して、 それで、データを読み込んで、 それをJSONデコーダを使って、 デコードを引ける型のはずなんでね。 これ、APIデザインバイトライン的に かなり微妙なことになってますね。 8ネックなら良いんだったかな。 ああ、いやでも良くないですね。 一般的に、戻り値の型を使って型推論をすることが 推奨されてるんですよ、バイトラインで。 なので、これ大めきに戻り値の型で推論してるんで、 ちょっと工夫が必要。 工夫の仕方はパラメータにとか、どんな形にするかって 情報を渡すわけなんですけど、ちょっとそれ必要か。 で、あと、ロードで、この後のファイル名というのが ちょっと唐突ですよね。 ロードストリングってなってる状況ですよ。 ラベルを省略してるんで。 そうすると、このストリングが何なのかが わからないっていうね。 そういったところがあるんで、 ちょっとラベル名を付けなければ、 まあ、ならないまでは言ってないですけど、 バイトライン的には名前を付けたい。 で、あと、この辺のガードと、これね。 宣言を先にして初期化を後にするっていうのを、 ディフィニートイニシャライゼーションというね、 仮組みなんですけど、これを使うのってなんか珍しいですね。 まあ、何も悪くないんでね、いいんですけど。 これがすごい違和感。 ディフィニートイニシャライゼーションを使ってるけど、 ここでデータでしょ。 トライキャッチでエラーを出して、そういうことか、 トライキャッチというか、エラーハンドリングを それぞれバラバラとやって、 確実にエラーハンドリングをしたかったっていうことか。 これはまあ、気持ちはわからないでもないですね。 そのためにディフィニートイニシャライゼーションを使う。 うん、悪くはないですね。 何も間違ってはいないかっていう感じ。 タブキャッチ、いや、でもあんま良くないでしょ、これ。 っていうので、ちょっとコピーで書き換えていきましょう。 良くないというか、全然他の動きとしては間違ってないんで、 こういうこと書いていいんですけどね。 そういったのをするために、モデル。 モデル、何モデルでしたっけ、作るの。 モデルデータ、モデルデータ。 これもしかして当たり前なのかな。 モデルデータって何っていう感じに見えちゃうんですけど、 女子のかもしれないですね、自分が知らないだけでね。 データを作るからインポートファンデーションが入りますね。 これで今コピーしてきたやつ。 こうなっているわけですけど、まずファンクションロード、 これをどこかに所属させたいのと、ロード。 所属させたいけど、まあいいかな。 いや、予測させたいですよね、これ。 バンドル。バンドルから取ってるじゃないですか。 バンドルのメインインスタンス。 ということは、バンドルからロードしてますよね、 っていう雰囲気ですよね。 バンドル、ロードの辺か。 バンドルメインでデータ。 データを取ってくるって感じですよね、今回ね。 とにかく取りたいのはランドマークデータなんでね。 データを取りたいから、今エクステンションしておきたいですね。 エクステンションバンドル。 ちょっとね、所属者に所属させると、 まあ、探しやすいんですよ。 フリーの関数の何が問題かというと、 ロードっていう関数があるってことを知らないとわからないというね、 そういったこと。 例えば、ストリングがあって、 俺の長さを取りたいなっていう時に、 カウントディーじゃないですかっていうね、 こういった発想と、 次元語みたいな、 手続きカードプログラミングのオブジェクト指向じゃないやつ。 まいっともとと、 SDR連という関数を知っていないと、 文字数が取れないみたいなこういう、 そうですかね。 うん。 そんなのでね、所属先があると、 バンドルからすぐ取れるんで、 これで型は何でもいいけど、 ここはいいか。 ここ型は何でもいいとは言っても、 何にしようかな。 データ、運送データ、モデルデータ。 モデルデータでいいんですかね。 モデルデータの言葉に自信がないので、 ここで使っていいのかな。 モデルデータ。 まあ、モデルデータかな。 これでレコーダブル。 これでデータから取り立てる、 レコードできる型であるよという情報が与えられて、 データを、 バンドルデータ、 ここでバンドルはフォーリソースでファイル名を渡しているんで、 これをちょっと拝借しちゃったらいいかなという気がしますね。 フォーリソースでドリンクですね。 ここまで13行目と比較していただいてますけどね。 これでモドリッジとしてモデルデータを返すよという、 こういったインターフェースになる。 ただ、このインターフェースもまだちょっと微妙で、 さっき言った、 モドリッジの型で型推論していくという状況になっちゃうんで、 一般的にはここでね、 AZタイプみたいな感じで、 モデルデータのメタタイプ、 型情報ですね。 要はね、型情報を受け取ることによって、 モドリッジの型で推論するのではなくて、 AZに渡した型情報、 これで推論するというのかな、 そういった感じでヒントにして、 型を作っていくよ、 型を推論していくよというね、 そういった方法を取る。 このタイプは多分使わないと何だったかわからないですがね、 内部編集ではね。 これでAPIインターフェースができたかな。 またここ、 自信ないですけど、 モデルデータでいいですかね。 どうなんですかね。 これなんか変だよという感じだったら、 一応教えて欲しいんですけど、 モデルデータにしてみますか。 こんな感じでね、 インターフェースを置き、 これで実装していくわけですけど、 まずこれで、 withExtensionでNil渡してますね。 これ渡しておいた方が勝手がいいですよね。 だからその前に、 allResourceでwithExtension、 そしてExtension、 名前パブルかな。 大丈夫かな。 で、ストリングですよね。 これもね、 ただしこれNilが渡してるってことはオプショナルですよね。 で、さらに一般的には、 渡さない、 リソースName、 allResourceで、 実はJSON渡すと思うんですけど、 どうなってんだこれ。 まあいいか。 オプショナルは読み込むに使わないで、 いいポイントはちゃんと使っておかないといけない気がするんで、 これはもしね、 今後Nilじゃないと都合悪いってときはまた考えますね。 まずこうして、 で、そうしてあげると、 まずGuardFile="PandleMain="でなくて、 今回自分自身がパンドルなんで、 ここから、 URLですね。 URL、 allResourceWithExtension、 これを使って読み込むことができ、 このallResource、 これ名前よくないですね。 先に書いてみましょうか。 allResourceで渡すと、 ダサいですよね。 だってExtensionの方、 これでダサいじゃないですか。 ダサいとこだけじゃなくて、 過読性がかかるって普通は言うんですけど、 これだから、 内部変数名としてリソース、 こうですよね。 リソース、 リソースはリソースですよって、 こういう書き方しますね。 一般的にはこれ、 こうにするんですよ。 リソース。 ただ、 スクリーンの方みたいに、 文字列が渡ってきたからって、 その文字列が何を意味しているのかわからないみたいなことが、 こういう表現力の高すぎる、 汎用性の高すぎる方だと往々にしてあるんで、 この文字列はリソースを期待しているっていうのが、 フォーリソースって書くことで上がっていく。 こんな感じでね。 モデルデータフォーリソース、 こんな感じで表現すると、 ガイドライン的に最適な名前になってくると。 で、これでできましたね。 で、ファイルが取れなかった場合には、 エラーメッセージ、 これフェータルエラーだとしてますね。 フェータルエラー、 今回はロジックエラーでいいですかね。 ロジックエラーってのはフェータルエラーのことね。 アイル名が見つからなかっただけで、 今回リソース名ですね。 回避できるかな。 時々そういう使用がありますが、 今回何かどうしたらしょうがない。 よくないってことでもないんですけど、 オプショナルもね、 含めて文字列化するという意図を示すときには、 ストリング、あとのイニシャライザーで、 ディスクライビング。 そうですね、 こっちだけで大体なりますね。 これでフェータルエラーでOKでしょ。 ファイルが取れました。 になったら次のコードね、 こっち、 データ作れたじゃないですか。 これも、 これエラーハンドリングか。 で、フェータルエラーでエラーを取ってるか。 そうか、 エラーハンドリングをするか、 別の方法ないかな。 エラーハンドリングをするか。 まあ、やるか。 2ブロック。 はい、ここじゃない。 ここは元のやつだ。 間違いなく最後についてやってる感じで。 ガード。 ここで2か。 何か怖いですね。 何か意外でありますかね。 レプデータイコール、 えーと、 1、 2、 3、 4、 5、 6、 7、 8、 9、 10、 11、 12、 13、 14、 15、 データイコール、 データコンテンツ、 オブ、 ファイル、URLが、 URLをさっき取ってる。 このファイルはちょっとままよくないですね。 ファイルURLがいいですね。 ファイルURL。 ファイルURLもそうなんですけど、 ファイルURL。 URLはURLでいいかな。 ファイルなんですけど、 ファイルがありなんじゃないですか。 リソースのURLなんで。 まあ、これでURL。 で、これをデータに変換できなかった場合には、 エラーハンドリングにしてキャッチして、 キャッチした時には、データエラーで、 原因を表示しつつ、落としますよ。 そういったロジックエラーを経由する。 これ自体は悪くなくて、 ファイルメーターなくてリソースになっている。 メインハンドルじゃなくて、今いるハンドルですよね。 っていう感じで、 AN、ANで理由を出してるか。 これはいいですかね。 だから、複数領、リテラルにしましょうか。 ダブルクティションをずっと並べて書いて、 最初、いきなりエンターさせて、 インデントはどこでもいいんですけど、 必ずそのインデントを揃えて、 最後の3つの土地、これを必ず揃えてあげる。 ここが、基準のインデントになる。 こういった書き方ですね。 これで、データが取れたらOK。 取れなかったら、エラーで落とすよ。 っていう感じで、リソースを読み込めなかった。 なるほどね。 ここで、ディフィニュートにしちゃいましょうか。 まあ、どうですかね。悪いことしてないんでね。 どうしますか。 レッド、データ、データ。 これで初期値を書かずに、 これをプロップで良き顔する。 こういった書き方ですね。 ディフィニュートにしちゃいましょうね。 悪いことじゃないです。全然。 あとは、リザルト。リザルトはよく使わないもんね。 デコーしまして、あとは、JSONのデコーダーね。 これも、地域でやってみます。とりあえず。 データをパスできなかったときには、 このエラーを出すよということで。 このために、ブロックを分けたというのが、 今回のディフィニュートイニシャライゼーションを使った理由。 こっちのモデルデータカードですね。 ここでデューブロック。 あまり、こういう書き方を自分はやってこなかったので、 違和感はありますけど、まあまあ妥当ですね。 デコーダー、そして、デコーダー、 そして、JSONデコーダーと言いますよね。 それで、データの説明は何になりましたっけね。 ああ、リターンするか。ああ、なるほど。リターンでいいですね。 リターンでいい。 それで、デコーダー失敗する可能性があるので、 デコーダープライディングを始めて、デコーダーデコードで、 デコードタイプ。タイプが、あれ、どこ行った。 ああ、大丈夫ね。 デコード。 タイプは、こう、最初に取ったね。 あとは何かしらないけど、デコードに対応しているといったデコードデータですね。 この型にデコードして、fromデータから、というね、こういった感じ。 で、これでキャッチをしまして、キャッチして、 あとエラーが出た場合には、リソースをね、パスできなかったと。 パスキーというか、これモデルデータですね。 モデルデータに変更できなかった。 これも、あの、複数項の対応の持ち列にしておきますか。 そうするとね、この、SKPシーケーシのようになるんでね。 まあ、多少はともになるかなという。 これぐらいだと、まあ、そんなでもないですけど。 これで、いいですね。 えっと、あれ、ここですね。 これで、コードはできた。うん。 できたんですが、自分がね、よく書くコードは、これを、この中にね、 えーと、トゥーブロック一箇所にまとめて、こうやって、よりする方法。 そうすると、ディフィニュートイニシャライゼーションとかではなくて、 こうやってね、ネットで書いて、こうやって、こうやって、みたいな感じでできて、 で、これで、キャッチ、例えば、あれなんかおかしい。 えーと、あ、丸書こがないですね。ここね。うん。 で、キャッチして、デコードに失敗したときは、 まあ、デコード、エラー、デコーディングエラーの場合はね、 デコーディングエラーの、あの、エラー出来、みたいな風に、 書けばするんですけど、まあ、こうするとね、あの、 あのエラーが、ロード、バンドルからロードできなかった。 で、上が、デコードに失敗した、ではあるんですけど、 この、デコードに失敗しなかった、ここの、もう1個の方が、 本当に、デコーターが失敗したものが来ないかどうか、 たとえや、どうもそうなんですけど、 まあ、混ざっちゃうわけですよね。エラーがね。うん。 で、今回、モデルデータが、エラー出したときに、細かい情報を出して、 エラーメッセージを返してくれてるんで、 そこは、損傷しないといけないところがあって、 まあ、そういった、あの、エラーをね、しっかりと処理していこうみたいなときには、 としても、こういうふうに、エラーハンドリングがね、 複雑になるということは、あり得なくはないんでね。 まあまあ、これで、どうしようがないでしょう、みたいな感じで、 いいですかね。何も悪いことはしてないんでね。 で、これで、モデルデータができました、というね、 そういった感じになって、 モデルデータを、あ、これは、呼ぶときに使うからいいな。 だから、そう、呼ばれてきた。 これによって、ロード関数がちゃんと、メインバンドルに 所属して、デコードを書けるよ、というふうになるんで、 使い方としては、えーと、なんか、あったときに、ここでね、 バンドル、メインの、えーと、モデルデータを、リソース、 何だっけ、えーと、ランドマークデータ、 で、エクステンションアプリケーション、で、 使い方としては、ランドマーク、こういうふうにね、 書くことができますよ、というね、こんな感じ。 これを期待している、という感じで、コードが、 えーと、リファクタリングできました。 まあ、これぐらいにしておきますかね。 今日はね、ちょっと時間かかっちゃったんでね。 まあ、そんな感じで、とりあえず、このロードまでできて、 えーと、ロードまでできたので、 次は、これぐらいで大丈夫だよね。 これだけかな、ちょっと見ておきますが、 そうですね、これだけですね。はい、で、これでOKで、うん。 で、ステップ10へ行きましょう、という感じで、 ロードするわけですが、ここはまた、次回にしますかね。 はい、えーと、いくの、ロードして、ロードして、4、うん。 うん、大丈夫ですね。うん、大丈夫な気がする。 じゃあ、ここは時間にしましょう。 はい、じゃあ、今日はこれで終わりにしますね。 お疲れ様でした。
