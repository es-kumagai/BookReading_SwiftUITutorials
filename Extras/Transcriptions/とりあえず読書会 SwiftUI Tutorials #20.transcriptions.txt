Transcription & Summarize : とりあえず読書会 SwiftUI Tutorials #20

はい、ではとりあえず紹介を始めていきましょう。 SwiftUIとUIKitを連携していろいろやっていくみたいな、 そういったところに入っていくみたいなので、また雰囲気が違うという感じですけど、 なかなか面白いところなのと、意外と難しいところというか、 プラットフォームじゃないですけど、フレームワークというか、 全然違うライフサイクル同士が連携するとなると難しいところがあると思うので、 そこもっと細かくのっているか、触れられているかわからないですけどね、 まあまあ見ていきましょう。 リアルなところから、Chapter4ですね。 このインターフェイスティング with UIKit、このところから見ていきましょう。 SwiftUIはリムレスに、既存のUIフレームワーク、全てのアプリプラットフォーム、 全てのアプリプラットフォームということは、UIKitとAppKitですかね。 そんな2人とリムレスに連携できるらしい。 例えば、UIKitのViewとViewControllerをSwiftUIのViewの中でやったりね、 これはなんだろう、その逆って感じかな、雰囲気だけで今言うんだけど、逆もしかい。 で、このChapter4では、コンバート、チャドランドマーク、どのように変換するか。 チャドランドマークを、ホームスクリーンから、ラップインターフェイス。 UIPageViewControllerとUIPageControllerのインスタンスをラップする。 それをどうやるか見ていくみたいね。 で、UIPageViewControllerを表示する、SwiftUIViewのパローセルを表示する、 UIPageViewControllerからかな。 あとは、ステップの変数とバインディングを、コーディネートでAppKit、ユーザーインターフェイスを押して更新していく。 この連携ですね、ステップをUIKitとAppKitと連携していくか、みたいな感じのも触れていくような感じに見える。 で、このプロジェクトをダウンロードしておいて、これをまた使うときに開けたらいいでしょう。 で、今ちょっとセキュリティ設定から一応ダウンロード。 プライバシー設定で整えておこうかな。 ウェブサイトの設定から、ダウンロードするかどうかっていう画面が出てきましたけど、 あれ出たときで、Appleからのサイトならダウンロードしてもいいだろうみたいなときが、ここで許可になってるか。 そちらは大丈夫かな。SwiftUIってときは出てるか、Appleとかもですもんね。 大丈夫か。今確認して許可したかな。 はい、まあいいか。 はい、じゃあこんな感じで早速いきましょう。 ビューを作る再表現。UIPageViewControllerをリプレゼント再表現。 SwiftUIで再表現という意味かな。 リプレゼントUIPageViewとUIPageViewControllerをSwiftUIで再表現するためにサイトを作る。 まず、UIViewRepresentableに準拠している型を作って、 UIViewControllerRepresentableの2つを準拠させる必要があるのかな。 2つというかどちらかですかね。 で、CustomTypeを送るという型は、 Create&Configure、UITypes、UITypes、リプレゼントを再表現するUIキットの型。 これを設定する。 SwiftUIはマネージする。 その間は、SwiftUIのライフサイクルでマネージアップデートを必要に応じてやっていくと。 そのためにセクシーとして、PageViewというグループをプロジェクトに作成して、 それで、Swiftファイル、PageViewControllerSwift、 これはPageViewControllerTypeをUIViewControllerRepresentable、 これに準拠したものにしていく。 パックが書いてあるけど、ジェネイクになってるね。 まあいいか。 PageViewController、とにかくこれを作って、 PageViewグループというのを作って、PageViewControllerを作ると、 それはリファクタリングが若干終わってないのを思いました。 まあいいか。 とりあえず、ビュー、あれ?なんだっけ? PageViewか。 だからビューのところで良いですかね。 この中にグループって書いてあるけど、今のエクスコードではこれだ。 それで、PageView。 この中にSwiftファイルを作成して、PageViewControllerですね。 こうした後に、Swift、UIインポートして、 クラスですけど、ファイナルクラスですね。 ファイナルクラス、PageViewControllerとして、 UI、PageView、Representable、 UI、UIじゃないか。 UI、あ、そっか。 UIViewControllerか。 UIViewControllerRepresentableね。 という形を作るけど、まだ実装が足りないと。 で、実装の時に特には求められていないか。 で、どうやるかね。 ページがビューで表現されていて、そのページを複数持つという、 こういった作りにするみたいなので、 まだそうしておきますが、ちょっと見とこ。 PageViewControllerですね。 その他パラメータなので、ここでページとしてビューですね。 で、そうしてバーとしてページ図としてページの配列ね。 これで大丈夫かな。とりあえずはこれから使っていくか分からないんで、 もっと様子を見てから整えていきますね。 もしもストラクトかノラクか、SwiftUIとUIキット両方インポートしてますね。 ではそれもやっておきますか。 ここまでだとSwiftUIだけでできてると思うんですけど、 これができてそう。 また必要になったらやるとして、あとストラクトなのね。 ストラクトとSwiftUIからいじるからですからね。 UIViewControllerリプレゼンタブル自体も別にクラスを求めてるわけでもないですし、いいですね。 ではこれで、PageViewControllerは配列でページのインスタンスを保持して、 それはビューに除去した後でなければならないと。 これらは、ロール、ランドマークス、 ロールビットにランドマークス版をロールするのに使うみたい。 次に、2つのリクワイアメント、2つの要求。 UIViewControllerリプレゼンタブルが要求する2つを実装する。 まずはMakeUIViewControllerを実装してあげて、 UIPageViewControllerのコンフィギュレーションをしていくみたいね。 SwiftUIはこのメソッドを1回だけレジティブに作れる。 このビューを表示する準備ができたときに1回だけ実行する。 そしてそれから、ViewControllerのライフサイクルが マネージされていくっていう感じみたいね。 ここまで作るのと、後ろからのコピペでいってみますか。 とりあえずね、UIPageViewリプレゼンタブルに必要なもの。 これでは無理かな、とりあえずね。 こうしてあげて、作ったものとしてはMakeUIViewControllerで コンテキストが渡ってきて、 UIViewControllerを返すよということになっていて、 ページビューコントローラーはUIPageViewControllerをインスタンス化したもので、 後にね、また重ね足していないけど、 インスタンスだけを返す。 やっぱり今、配慮適当に整えてますけど、 まあまだ1行だと長すぎるのかな。 まず1行にしておきましょう。 とにかくUIPageViewControllerでトランジションタイプがスクロールで、 ナビゲーションオリエンテーションが水平みたいね。 ここまで作ったら、次はもう1つの必要な要求。 UpdateUIViewController。 これを使っていく。 SetViewController。 UpdateUIViewControllerメソッド。 これは、セットビューコントローラーから呼ばれるもの。 提供するビューコントローラー、 ディスプレイするために呼ばれるらしい。 今、このCreateUIHostingController、 ホストしたページ、そのページをCreateUIViewに、 ホスト、UIViewController、CreateUIViewControllerで ホストするんですよね、ページビュー。 Page3とUIのビューのページが常にすべてのアップデートで、 クリエイトするのかな? ダメだ、予約していない。 ここの前半予約してもらおう。 CreateUIViewをホストするUIViewControllerを 更新のたびに作成する。 全然役立ちない。 更新のたびに作成しているのっていうこと。 よりエフィシェント。 もう大変だ。 効果的。いいですね。 より効果的な初期化。 一度だけの初期化とやっていくと、 今は作りまくると。 それはとりあえずということですね。 なので、こんな感じでオフィスしただけですけど、 CreateUIViewControllerはまだ不完全だけど、 こんな風に実装していくよってお話ですね。 ページビューコントローラーとコンテキストが渡ってくるので、 ページビューコントローラーに SetViewControllersを呼び出して、 UIホスティングコントローラー、ルートビューがページの0番目。 エレクションがフォワードでアニメーションが出るっていうのを、 毎回更新のたびにやっていこうというお話をしていたと。 とりあえず。 何にしてもこの普通のメソッドを実装することによって、 ライフサイクルが始まるときに一回だけ呼ばれるものと、 それが用意できて、そのときにUIキットのページビューコントローラーを送ってあげたり、 渡されてきたページビューコントローラーを更新してあげたりとか、 そういったことをやっていくということになるみたいね。 続けていく前に、フェーチャーファード。 ページで使うフェーチャーファードを整えておくみたいね。 準備しておくみたいね。 そのために、イメージさっきダウンロードしたやつですね。 リソースディレクトリの中のイメージを、 カタログに入れてあげると。 ランドマックスフェーチャーイメージ。 これがあるなら、 このアルティメーション。 これはレギュラーイメージとこのアルティメーション。 やってみよう。 ダウンロードしたやつを今持っていきますね。 ダウンロードしたリソースを隣にフォルダを持っていって。 リソースフォルダを持っていって。 ここに持っていったはずなのにいない。 どこいった? いなくなったし。 どこいった? リソース。 どこいっちゃった? この横に置いたと思ったんですけどね。 完全にいなくなってますね。 もう一回開きますか。 ダウンロードのリソースでしょ。 こうやって横に持ってきて。 一旦これを自作して、 ここで移していきますか。 リソースフォルダ。 リソースフォルダの置き場所がよくなかったかな。 デスクトップ。 まあいいか。 リソースをアセットカタログに入れていくか。 ここにリソースを入れていくよ。 ここにリソースを入れていくよ。 できましたね。 これでリソースはよくって。 続いて、ユーザリアルでは、 次ステップ。 コンピュータブルログだというランドマックスフェーチャーイメージ。 さっきのイメージを返すのにランドマックスフェーチャーの中に入れていく。 これがあるなら、なんかさっきから役ができてないな。 ランドマックスフェーチャー構造体にフェチャー画像が存在する場合に、 それを返す決算プロパティを追加する。 もしそれがあるなら、リターンスフェーチャーイメージを返すプロパティ。 これを追加していくよということで、これですね。 これが残っていたランドマックス構造体か。 イメージはランドマックス構造体。 ランドマックス構造体って結構意地悪なやつですよね。 今どうなってたかな。 ランドマーク。 ランドマークの中の、ここは完全にコードを取りに合わせて、 独自のキーを設定して、 これがイメージはイメージ画像で、 スフェーチャーだった場合には、これがイメージを返っていくよか。 ここに置くか迷いますね、どうしようかな。 悪くないんですけど、全然。 変換イニシャライザーと捉えるとするとイメージに戻せて、 そうじゃないとするとここでいいんですけど、 今ランドマーク型あんまり余計なプロパティを持たせてないんですよね。 今ね、個人的な愛憎により。 なので、ここにフェーチャーイメージ。 まあでもここでもいいのかな。 フェーチャーイメージ。 フェーチャーイメージ。 スフェーチャーだったらフェーチャーイメージがね、取れてもおかしくないと思うんでね。 いいのかな。フェーチャーイメージ。 まあこの通りで多分きれいだと思うんで、基本はこれで問題ないと思うんですけど、 今回はやはり初期化イニシャライザーでやってみますか。 イメージも独自のイメージ型を作ってやる都合で、イメージで出てくるかな。 イメージ型の中でランドマークのイメージがここかな。 ランドマークのイメージでやりましたね。 これを今のところ、ランドマークからの変換イニシャライザー。 ランドマークのイメージから変換イニシャライザーを用意してますけど、 これと同じノリで、今用意しているのはランドマークイメージからスウィートUIのイメージ。 こちらはランドマークのイメージからスウィートUIのイメージだ。 ここじゃないな。ランドマークイメージだ。 この中で変換イニシャライザーが用意されていないですね。 作ってみますか。 今回の場合はNarrow Type Conversionという分野に入っていくの。 あとは変換を伴うNarrow Type Conversionの2つがあって、 これによってAPIデザインガイドラインによってラベルを付けて説明するか付けないで説明するかが第一必要ですけど、 それが決まっているというかガイドラインとして示されているので、 今回は変換するタイプなので、 イニットでラベル名で説明する。ランドマークイメージをフェーチャーイメージですよね。 だからランドマークイメージの初期化で、 フェーチャーイメージオブみたいな感じですかね。名前としてね。 オブランドマーク。 そして、これでランドマークがこれを受け取るような変換イニシャライザー。 Narrow Type Conversionを用意してあげて、 さらに、IsFetchedだったら初期化するというね。 そういったのが例になる都合で、 生成できないかもしれないので、失敗可能イニシャライザーにしてあげますよね。 そして上で、これはガード文があるのかな。 ガード、Is、Isというかランドマーク。 ランドマークがIsFetchedだったら画像を生成できるので、 こうしたのかとしたら、終了。 一旦はですね、こんな感じ。 ここまでできたとしたら、戻り値。戻り値というかセルフですね。 セルフイコール。セルフイコールというのかな。 イニシャライザーというのかな。 セルフのイニシャライザー。 今回はどっちでも大丈夫ですけどね。 ネームとして、このネームは、イメージネーム。 イメージネームか。ランドマークのイメージ。 ランドマークのイメージ。 名前はどうしたっけ。ネームか。 いろいろ改良してあるんでね。改良。改良。 まあ、そうね。改良。 あとは、スプリングインターポレーションでやるのが一般的かな。 そういう人だと、確かに全然問題ないんですけど。 なので、スプリングインターポレーションで、 イメージネームに対して、アンダースコアネームとして。 これで終わりかな。こうすることによって、 フェーチャーイメージにランドマークから変換する。 全然意味の違うものに変換する。 なるほど、タイプコンバージョン。 タイプコンバージョンか。これはタイプコンバージョンとは 言わないですね。 とってもファクトリーメソッドに近い イニシャライザーになってくるんですがね。 ちょうどデコーダブルの、 イニシャブルもデコーダーと似たような感じで。 別にこれデコーダーからの 可変化じゃないんですよね。 だからこっちもそんなノリですね。 全然タイプコンバージョンじゃないわ、これね。 とにかく、フェーチャーイメージオフで、 ランドマークからイメージを制定するイニシャライザーですよと。 そういったのが出来ました。 全然違うの作ったけど。 はい、じゃあ次行きましょう。 ステップロックとして、新しいソリストUIPファイルを フェーチャーカードという名前で作る。 これがランドマークフェーチャーイメージを 表示するものらしいフェーチャーカードね。 それで、アスペクトレイトモディファイヤーを含む、 インクルードアクセプトレイトモディファイヤー。 ミミックスって何だ? 何か聞いたことある単語ですけど分かんないな。 モノマネをする。 アスペクトレイトのアスペクトレイトを 模倣するため、フェーチャーカードが イベンチャリ、イベンチャリ、結局最後には プレビュー、後のプレビューで表示。 何だかよく分からなかった。 含めることで、フェーチャーカードが最終的に プレビューされるビューのアスペクトレイトを模倣する。 アスペクトレイトが最終的にこういうアスペクトレイトが 出てるっていうのをやっているらしい。 これはコピーしてやればいいでしょう。 フェーチャーカードね。 フェーチャーカードはどこに置くかな? ページビューというよりはコントロールに見えるので、 多分このビュートリアル的には ページビューに置きたいなと思うんですけど、 ここでフェーチャーカード、定義した、 適当かコピーしたものを貼り付けて、 あーなるほど、ちょっと使い心地悪いですね。 どうか、こうして、 ここがオプショナルでしょ? あーそっか、オプショナルだからこうか。 で、こうしてあげて、 ここが失敗したのにしてられたので、 あれだと使い心地悪かったですね。 イメージがランドマークイメージになって、 ランドマークイメージが普通のイメージにキャストしないといけなくて、 だから普通のイメージをフェーチャーイメージオブで 変換するを作ってあげるってどうだろう? なんかちょっとやりすぎ感を感じるけど、 それでイメージがあったときには、 ここでね、イメージ。 で、イメージ。 で、リサイザブル。 こっちですね。 じゃあどうなのかね。 イメージを取って、それをUIDでね、 そういったUIDで表示するっていう形。 取れた場合には。 っていうのが一般的だと思うんですけどね。 まあまあ、もう一個ちょっと試しにね、やってみましょう。 どれがいいかはちょっと分かんないんですが、 あんまりよくないんじゃないかなとは思うんですけど、 そういったUIDの、そういったUIDのイメージビューに対しても、 ユニットで失敗可能な可能性があって、 フェーチャーイメージオブランドマークみたいな風にね、 同じインターフェースを用意してあげて、 で、これで、 あれ、これで、フェーチャーイメージオブランドマーク。 で、else、return nilにして、 でこれで、 あとは、self.unit.imageとかですね。 うん、こうしてあげて、 もうするとね、 あの普通のUIのイメージ型も普通に、いきなり、 ダイレクトにね、作っていけるようになるんで、 そうすると、まあ、ここがね、ランドマークイメージじゃなくて、 いきなり、イメージ型に変換していって、 で、それでそれが取れたんだったら、 リサイズするよ。っていうね。 リサイザブル可能にするよって感じでね。 どっちがいいんだろうね。 うん、ランドマーク、 イメージフェーチャーイメージオブランドマークで 失敗するかもしれないで、 nilだとしたら何にも表示されないよ。 っていう形。 これを取るか、またはね、さっきの、 iFoodでね、こう取るか。 うん。 なんか個人的にはこっちのほうが、 いいかな。 まあ、あのね、nil、なんだっけ、 オプショナルトレーニングを使っていないっていうのは、 それだけなんですけど、 うん、こっちにしてみようかな。 まあ、でもこの辺は好みで、 なんかいい気がしますね。 まあ、いえ、まあ、ともともね、 こんな悩みは普通しないと思うんですけど、 まあ、とりあえずこうやってやって、 で、それで、 フェーチャーズカードのランドマーク、 モデルデータのフェーチャーズがないとですね、 フェーチャーズなんだっけ、 えーと、モデルデータ、 モデルデータの中にランドマークス、 iXプロファイルですよね。 フェーチャーズは、もしかして、 作ったのに忘れてる? えーと、フェーチャーズは、 うーんと、 モデルデータでも問題じゃないですよね。 あれ、えーと、なんだろう、 レビュー、 あれ、これは、この、 分かんない。 どうなんだ? まあいいか、とりあえずさっき行ってみましょう。 フェーチャーズなんだったかな? ここのモデルデータにフェーチャーズなんで。 ね、まあ、分かんないからしょうがないや。 さっき行きましょう、まずは。 えーと、ステップ7として、オーバーレイ、 テキストインフォメーションを、ランドマークに対する、 関係のね、テキストインフォメーションをイメージの上に置きます。 はい、えーと、テキストオーバーレイ。 テキストオーバーレイという画を作って、 それを使っていくよーというね、こんな感じみたいね。 うん、でもプレビュー出てるから、 やっぱりフェーチャーズあるんですよね、きっとね。 フェーチャーズがあるとなると、どこであった? えーと、フェーチャーズ、フェーチャーズ、えー、うん、どこだ? フェーチャーズは、どこら辺まで辿ると出てくるんだろうね。 戻っていくにしてもね。 フェーチャーズ、まあいいか、戻るしかないか。 ウォーキングウィズUIコントロール、この辺に出てくるかな? フェーチャーズ、ここではないかな? え、じゃあ、この前、えーと、こっちかな? あ、間違えた。フェーチャーズ、あ、いった。 フェーチャーズ配列。 えーと、New Computed Propertyをモデルデータに使ってますね。 えーと、どこだ?ここか。 フェーチャーズ、モデルデータの中にフェーチャーズとランドマークスフィルターで、 イズフェーチャードフィルターやってますね。 イズフェーチャードフィルターっていうのを見た時に、 フィルターでやってるのは、これがImage Markerですね。 これがFlagですね。 これがただのキーですね。 これがランドマーク、イズフェーチャードでフィルターやってる。 フィルターとランドマークスだ、これだ。 モデルデータの中にありましたね、これか。 そうすると、忘れてはダメだよね、まあ、ような日忘れてしまっていいと。 フェーチャー、フェーチャーランドマークスと、 これでいいですね。 そうすると、プレビューが見れるようになるので、 ピント目は外して、これでいいかな? それで、さっきのコピペしたのはもう消しちゃった。 これで、何か表示ができたと。 こんな状況なので、続いて、さっきのね。 ここに戻ってきて、コピペをする。 コピペはどこだ? このモデルマーですね、ここだ。 Text Overlay、これをコピペするけど、 Text Overlayってどこで使うんだろう? どこで使うか、このフェーチャードカードだけですかね、使うのね。 だとすると、その中に所属させたいんですよ、個人的には。 なので、エクステンションとして、所属先はね、 ちゃんと考えるの大事で、 所属先が、主体がある場合には、 その主体に添えなさいというのが、 APIデザインガイドラインの指針になっていて、 それを守るとだいたい、 このPのきっとここにあるよねっていうのがね、 想像しやすくなるので、 所属場所を大事にしないといけない気がするんですよね。 フェーチャードカードの中でだけで使うと、 想定すると、プライベートPですかね。 あそこまでフォーカスビットはあるのかな?わかんないけど。 とにかくText Overlay型で、これがバー、プライベートPかな。 どっちがいいかはね、まだわかってないんですけど。 グラデーションが、このグラデーション定義ですよっていうのは、 ゲーサー型プロパティのスタティックで、 スタティックというか、統理でいいでしょう。 それで、ポイントとしては、こんな感じでグラデーションを、 セットスタック、グラデーション、グラデーションがわかるのか。 セットスタックの中で、ランドマークのネームとランドマークのパークを 表示するよっていう、こんなね、情報になっていて、 これをオーバーレイで表示するよということですよね。 なので、ここでしたっけ、イメージにオーバーレイすればいいのかな。 オーバーレイのランドマークとして、ランドマーク。 ここで通りですね。 いい感じですね。 ここまでやって、もうちょっと変えたい気がないかもしれないけど。 ここまでできました。 次に、CustomView。 URBコントローラーリプレゼンタブルViewを表示するための、 CustomViewを作る。 そこで表示するための、プレゼントを。 URBコントローラーリプレゼンタブルを表示するのかな。 CustomViewプレゼント。 こっちだ。 そうですよね。表示するためのCustomViewを作ります。 いいのかな。 コードと違うような気が何となくするんだけど。 ニュースUIファイルを作って、名前をPageViewとする。 それで、PageViewは、PageViewコントローラーで、 プレゼントを表示すると、このプレゼントはまた失敗すると。 とにかくここまでやってみますか。 PageViewを作るよと。 PageViewを作るのは、PageViewのフォルダだけですからね。 ここで、PageViewを作って、コピーした感じで完成させちゃって。 それで、PageViewは、ページを型パラメータで指定して、 それで、ページ図を持っていて。 これは今のところレッドできますね。 それで、ページ図を渡すことで表示すると。 PageViewはまだページ図を渡していないから、 ビルド失敗している状態ですよ。 そういった感じですね。 ステップビューとして、アスペクト比を追加して、 プレビューを要求すれば、 ページの配列を渡してあげるように書き換えて、 プレビューを動くようにしましょうと。 だから、アスペクトレイトを加えて、 かつ、フェーチャーとイメージのランドマークか。 フェーチャーカードを渡してあげると。 なるほど。フェーチャーカードがページなのね。 そうすると、またアスペクトレイト、 アスペクト比を設定してあげて。 それで、PageViewに対して、最初にページ図イコールにしようかな。 それで、モデルデータのフェーチャーとランドマークのマップの、 何だっけ。ページだけど、PageViewじゃなかったな。 何でしたっけ。 フェーチャーカードか。フェーチャーパード。 パードでランドマークですね。 これじゃダメだった。 フェーチャーカードとランドマーク。 フェーチャープランドマークは普通にフィルターしてランドマークを返す。 フェーチャーカードとランドマーク。 フェーチャーカードとランドマーク。 次のステップ。 次のステップ。 ビューコントローラーデータソースを作る。 UIページビューコントローラーをコンテンツ。 UIビューからコンテンツを表示するために使う。 コーディネーター。データソースがコーディネーターで ビューがあるという、そういった構造らしい。 まずは、UIKITのビューコントローラーを再表現できる スイッチとUIビューは、コーディネーター型を定義できて、 それが、UIがマネージしたり提供したりする。 ビューコンテキストの再表現のためのものらしい。 そして、ステップ1として、コーディネーターを入れ込みして定義する。 PageViewコントローラーの中に入れ込みして定義する。 この名前の除去環境は良さそうですね。 PageViewコントローラーのコーディネーターを作っていくということですね。 UIは、UIビューコントローラーリプレゼンタブルタイプの コーディネーターをマネージする。 そして、提供するコンテキスト。 上で定義したメソッドを呼び出すときに、 コンテキストの一部として提供する。 もうとにかく、コーディネーターを作っていきましょうということなので、 早速、定義を丸写しですが、できますね。 PageViewコントローラーね。コーディネーター。 この中に入れてもいいわけですけども、個人的に拡張したいのと、 コーディネーターはこのバイオナリーしか使わないので、 プライベートエクステーションで良さそうですね。 それで、PageViewコントローラー。 これを拡張して、この中に公表したパターンをそのままやってあげる。 コーディネーターはNSオブジェクトを継承していますね。 これは求められているのかな? NSオブジェクトは、コーディネーターは、 だからPageViewコントローラーのUIビューコントローラーリプレゼンタブルタイプ。 これがコーディネーターを求めているわけですよね。 コーディネーターってディフォルトボイドか、 NSオブジェクトを継承する必要ってあるのかな? あるのかもしれないですね。 あるのかもしれないけど、どちらかな? もうちょっと残しておきますか。 何にしても、これ継承する予定は多分ないと思うので、ファイナルグラスですね。 それで、ペアレントはレッドで良さそうですね。 イニシャライザーはペアレントを通るって感じで、良さそうですね。 インペーディコントローラー。 そしたらこれを拡張してあげる感じですか? あとは謎メソッド、別のメソッド。 コーディネーターを作るためのMakeコーディネーター。 これを引き下げる。 続いてURLはMakeコーディネーターメソッドを MakeUIViewControllerの前に呼び出す。 呼び出してくれる。 で、アクセスコーディネーターオブジェクトに コンフィグレーション時にアクセスすることができるよと。 そういう風になるらしいので、 Makeコーディネーターをとりあえず作っていく。 これはこの辺ですかね。 Makeコーディネーターで、コーディネーターを定義できたはずなのか。 あ、なるほどね。なんだっけ? ロトルの要求に入ってるからプライベートじゃダメなんだ。 これでコーディネーター準備できましたね。 そうしたらTipsとして使うことができるコーディネーターを 共通のパターンで作れる。 例えばDelegate、DataSource、RespondingToUserEvent、TargetAction、 TargetActionとかDelegateとかいろんなもので コーディネーターを使っていけるというプライベートを NSオブジェクトに検証したからというのも起きそうな気がしますね。 それを狙ってNSオブジェクトを検証したんですかね。 そういうことにしておいて。 で、初期化する次にコントローラーの配列を初期化するコーディネーター。 ページ配列のビューのページ、ビューの配列、 ページアレイドオブビューのページの配列を使ってコーディネーターをフュージングする。 コーディネーター内でコントローラーを初期化するかな。 コントローラー内じゃないか。 200が全然違いそうだな。 コントローラーInTheCoordinator、そのコーディネート内でアレイドを初期化する。 この辺か。コントローラーを用意して。 コントローラーというのはEventのページのこれを持ったね。 UIホスティングコントローラー。 これを作るということになるらしい。 なのでコーディネートを実装していきますが、コーディネートここか。 ここで、レッド、コントローラーですね。 コントローラーとして、UIホスティングコントローラー。 これを用意するであってますかね。 UIViewコントローラー。 UIViewコントローラーを配列として持って、 この中でコントローラーとして、ペアレントのページ図のマップの、 ここで、ページビューコントローラー。 あれ、なんかここが閉まってるかな。 これがUIViewコントローラーになってるか。 UIホスティングコントローラーに入れていくのか。 なるほど。だからUIホスティングコントローラーの イニットとして、ルートビューに入れていくという感じですね。 ここでいろいろとやらが出てきましたね。 まずは、久しぶりにSwiftのコンパレーションがやらが出てきた感じですか。 とりあえず入れることとしては、メインアクター関係の エラー。それだけか。 それで、ロボティページがメインアクター。 これはペアレントで、ペアレントはページビューコントローラーで、 ページビューコントローラーはUIViewコントローラーに プレゼントされているからということですね。 なので、このストロークはメインアクターなので、 ページビューもメインアクター。 なので、そのページビューを使うわけですけども、 コーディネーターがメインアクターになっていないので、 これはどう考えてもメインアクターから 使うことが大前提でしょう。 なので、これ解決ですね。OKな気がする。 ここで、ちょっとリアルなコードで、 リアルなコードを買ったんですけど、 ここでコントローラーと空の配列で 初期化してるじゃないですか。 イニシャライザーでコントローラーと初期化してますよね。 これいらないですよね。 Zipの書いたコードでは発祥してますけど、 何でだろうこれ。いらない。 いらないですね。 で、ページビューコントローラーで、 ホスティングコントローラー。 ここUIViewコントローラーの配列に入れてるんですけど、 ホスティングコントローラーでいいんじゃないかな。 ここをわざわざ今の段階で、 今の段階でもいいんですけど、 別にここを親クラスにする必要ないですよね。 UIホスティングコントローラーしか いらないんじゃないのかな。 ジェネリックタイプか。 ジェネリックタイプだからダメなのか。 ああ、そうか。 ホスティングコントローラーで、 ニットルートビューに対してページビュー。 ページビューは?でもページビューですよね。 ページビューがビューで、ビューコントローラーか。 ビューコントローラーか。でもページビューコントローラーだから。 UIホスティングコントローラーページ。 これで入りますよね。 ジェネリックにする必要が、今後トリモリズムを 考えていくんだったら大丈夫なんですけど、 今のところこのコーディネーターが それをしようとしているようには見えないので、 これでいいんじゃないかな。 面積的なほうが何かと、あいあいというか直感的というか、 別にどうでもいい気もしないでもないですが、 ここはいいかな。ここはこれでいいかな。 うん、これで大丈夫な気がしますね。 では、これでいってみましょう。 はい、これでステップ4。 UIビューコントローラーデータソースを 準備をさせるコーディネーター。 ああ、このためにNSオブジェクトにしたんだ。 UIページビューコントローラーデリゲートで、 それでスタッフの要求を実装してあげる。 これらの2つのメソッドで、 ビューコントローラーとの連携を確立する。 つまり、スワイプ、バックアンドフォース、 アジェントをここに移動できるようにするよ、 というお話らしい。 ま、詰まるところにしちゃいましょうか。 はい、あのね、なんか当事者だと書けますけどね。 サンプルを追いかけながらだと結構書けないですよね。 まあまあ、これでアクションするけど、 アクションソフトがいいかな。 好みの問題ですが。 エクステンション、ページビューコントローラー、 アジェント、ページビューコントローラーのコーディネーターね。 これに対して、UI、エクステンション、 ビューコントローラー、デリゲート、 データソースでしたっけ、データソースだったかな。 デリゲートかな、データソースか、データソースでした。 なのでこうして実装を書いてあげることにして、 AdobeJCがいるよって言ってますよね。 AdobeJCメンバーズはここにもいるかな。 メンバーズは他ダメですね。 じゃあどうしようかな。 コーディネーター、まあ、AdobeJCつけていきますか。 AdobeJC、あれでも選べますね。 これで、ページビューコントローラーとAdobeJCメンバーが 必要ですって言ってますけど、 ここで、UI、ビューコントローラーと UI、ページビューコントローラー、 うん、あーでも大丈夫そうね、安全に。 やっぱり、拡張じゃダメですよっていうことを言っているので、 ではね、埋めていきますか。 で、これで、あとは、プラットフォームの状況。 nouns page view więc pg page views controller でいいですかね。 ころで、pageview controllerがUIPG controllerで。 ここにUIPG view controllerが 来るから、ケニー gutrollerが UI、ページビューコントローラーにしていたのかな。 違うか。 jungle use-controllerが こっちか、view controller before。 これがね、UIP gview controllerに いってここにもトリモフィズムで下がる やつだと思ったのかな、どっちだと思ったんだけど、 まぁこれはこれで大丈夫ですね。 とこうしてあげることによって、 indexがコントローラーの first index of view controllerで なければ二ラウンドクライスですって 返すよって言ってますね。これはview controllerが、 UI view controllerか、これが コントローラーで、ここもジェネフィックで 大丈夫かな、大丈夫ですね。はい、これで 後半で開業されたんだと思ったけど、ここら辺が 開業が荒れているから、えっと半端に、 ちょっと半端って言った方もないか。長すぎるとね、 開業した方がいいと一般的には言われますからね。 はい、でこれで、first index view controllerが なかった場合には、これはreturn nilにして、 indexが0だった時にはコントローラーのラストを返す。 インデックスが0だった時にラストを返す。 それ以外はインデックス-1を返すだけ。 first indexが見つかった場合で、 first indexが0だった時、0に見つかった時にラストを返す。 のでなければ、見つかったインデックスの 1個前を返す。ああ、そっかそっか。はいはい。 戻したいのね、とりあえずね。1個前にね。うん、インデックス-1。 これインデックスが後から0だったら、ラストを返すのか。 ラストを返す。まあラスト、気持ちは分かるか。 インデックスが0の時にラストを返すって、 すなわちそれをインデックス0のものを返すですよね。 ラストでいいのかな。インデックスが0だった時。 まあ、ラストでもいいんですけど、ラストでもいいんですけど、 0番目返すのとどっちがいいですかね。 どう感じますかね、これ。 えーと、インデックスが0しかないのと、 0返すのがないかな。違うかな。 あとここスイッチがいいの、個人的には。スイッチ。 あ、まあこれは個人の観点の読みですね。 ケース0だった場合には、えーと、リターン。 スイッチ式にしたいかな、これくらいだとね。 リターン、ローラーは0ね。 で、それ以外だったら、こう、ディフォルト。 そして、リターンは要らないけど、コントローラーの インデックス-1、つまり1個前ですよっていうことですね。 うん、こんな感じ。 これで良さそうですね。 で、次、こっちもネクストの方ね。 えーと、どっちどこ。ネクストのね、このHBコントローラー、 HBコントローラーのUコントローラー。 これは何だ。 えーと、HBコントローラーのBコントローラーbeforeとafterだったね。 で、次いくタイプですね。 これも同様に、ここは絶対にジェネリックで、あの、サブタイプがね、もう明確に分かってるんで、 えーと、既定クラスじゃなくて、サブタイプに変えてあげれば、扱いやすいですよね。 で、それで、インデックスを探して見つからなかったら、入。 で、そうじゃなかったら、えーと、インデックス-1がコントローラーのカウントか、とか。 あの、カウントは数で、インデックスはインデックスなんですよ。 なので、インデックスとね、カウントをね、比較するっていうのは、本来型が違うんですよね。 なので、たまたまイントガードで言ってしちゃってるだけで、型が違うんで、 これはね、ちゃんとインデックスで、あの、把握した方がいいと思うんですよね。 そうするとね、どういう風になるかっていうと、 えーと、スイッチ、またスイッチに書き換えたいですね。 えーと、インデックスプラス1に対して、ケース、コントローラーズのエンドインデックスですね。 要は、最終インデックスに到達した場合には、 あ、ここでファースト返すっていう言い方をするのか、 あ、そっか、カローセルか、カローセルだから、ゼロの時に、 あ、ラストか。あれ、そういうことか。 あー、なるほど。全然間違えましたね。自分のミスですね、これね。ラストか。 だから、どんどん前に行って、ゼロになったら、次はラスト。 それをね、返す。だから、後ろに戻らないといけないから、ラストですね。絶対に。 で、同様に、ここで、エンドインデックスまでに到達したのだったとしたら、 違ってるのかな?そうだね。待ってますね。 だとしたら、えーと、ここにいたのか。リターンの、えーと、ファーストね。 最後まで行ったから、コントローラーのファーストを返しようと。 で、それ以外だったら、えーと、コントローラーのインデックスプラス1か。インデックスプラス1か。 なんかちょっと、1をもう1回出してるのが気になるな。 でも、2回も出さなくていいんだとすると、ファーストインデックスオブ。 ここで、1を足して、ここでケースレッド、 ネクストインデックスですね。これでいいんだ。 これで、ネクストインデックス。 こうしてあげれば、ちゃんと取れますよね。 すると、上もそうですね。上もそうでもないか。 インデックスがA、これが0だったらラストでしょ? そうでなければ1個前ですね。 次は、インデックスが、インデックスプラス1と、 エンドインデックスと比較したいから、 インデックスを1個動かしちゃったんですね。 これは、インデックスラストと比較するって 言うても、まあないとは言えないんですけど、 これは、コントローラーが0だったらどうなるんだろう? ちょっと気になってきましたね。 ページが0だったときに、コントローラーが0になって、 コントローラーが0になったときに、 ラストインデックスが見つからなければ、見るですね。ページ。 うん、そうね。だからこの時点で、 絶対に0ではないんだ。この下ね。 なので、絶対に0ではないということを、 ここでも証明されていることを踏まえると、 だからここも、どんなにしようとしたんだっけ? そうそう、ラストインデックス。 なので、インデックスに対して、 あ、でもエンドインデックスの方が早いですね。 エンドインデックスでいいかな? インデックスに1を足して、エンドインデックスか。 うん、どうしますかね? えーっと…。1を足すか。1を足したのが、 ネクストインデックスですもんね。 こんなにややこしいことをするのか? それとも、ここでね、 ネクストインデックスは、えーっと、インデックス プラス1に1回こうやっちゃった方がいいのかな? で、それで、えーと、ネクストインデックスを比較して、 ネクストインデックスがエンドに到達しちゃったんだったら、 ファストに戻してあげるよ。 そうですね、ネクストインデックスを、 コントローラーに取得してあげる。 そういった感じで、そうすると、 ここがディフォルトでもいいと。 そうですね、こんな感じで。 こうすると、 えーっと、ビューコントローラーアフターと ビューコントローラービフォアのコードがね、 画的にこんな感じの雰囲気になるんで、 まあ、でいいか。 こうしておきましょう。 はい、ここまでできたら、スワイプができる という話だった気がする。 えーっと、とりあえず、どうかな? まだか。 で、コーディネーターを、えーと、データソース。 UIページビューコントローラーの データソースとして追加する。 うん。で、もう1個までいっておきますかね。 えーっと、あー、ビューコントローラーに 戻って、動くことを確認しようか。 だから、ここまでですね。 なので、ページビューコントローラーの、 えーっと、Make UIビューコントローラー。 UIビューコントローラー、ここ1回だけ終わるやつですね。 他のページビューコントローラーに、 ページビューコントローラーのデータソースとして、 コンテキストのコーディネーター。 これを入れてあげるという話だったような気がしたけど、 違ったっけ。えーっと、データソースにコンテキストのコーディネーターですね。 で、UIコントローラーのコーディネーターには、 データソースを適用させてますよね、って話でしたよね。 だから、これは何だ?発信できない。 コーディネーター、えーっと、ページコーディネーターから、 UIページビューコントローラーデータソースに、 設定できない。 まずは強制的に開けてるけど、それは違うので、 UIコーディネーターになってる。 これ間違ってますね。 データソースですね。データソース。 あれ、これで準拠していない。 あー、やっぱダメだったか。 えーっと、画面っぽい可能性があるのは、まずここですね。 ポリモフィズムというか、直指定したけど、 UIビューコントローラーかな? えーっと、ちょっと行ってみますか。 それで、アフターとビフォアを見た時に、 えーっと、UIビューコントローラーを返す。 で、もらうのもね、UIビューコントローラーなんですけど、 とりあえずこうして、で、こっちも、 UIビューコントローラーを返すにしてみましょう。 UIビューコントローラー、コントローラーね。 はい、こうしてあげると、 これで、あー、ダメだった。 そっか、こっちも4枚とダメか。 UIビューコントローラーの引数の方ね。 ホスティングじゃなくて、UIビューコントローラーね。 UIビューコントローラー、 あれ、確保できたのかな? そうですね。 で、これでもう1個。 こっちも、UIビューコントローラー。 で、やると、準拠はできたとか、ということか。 もう1回、もう1個ちょっとやりたいんですけど、 UIホスティングコントローラーを元1として返す。 あれは? あれも準拠できたのか。 で、こうして、 なるほど、ここでビューコントローラーのインデックスを取るよって言う時に、 ここのコントローラー図が、親クラスになっていることが求められていくのか。 気をつけ方変化でもね、いいとは思うんですけど、 まあ、そこで、どちらかの処置するぐらいだったらね、 ポリモリズムで、走っちゃった方が安全ですよね。 なので、これで、あれ、こっちは大丈夫なのか。 こうやって書き換え忘れているだけか。 なるほど、これでできましたね。 そしたら、コンテントビューまで戻るって言ったっけ? コンテントビュー。 ここまで戻って、プレビューを確認しようと。 で、フェチャードイメージが、ロール。 スクロールできないような、ここじゃないのかな。 エイプス、えーと、ここじゃないのか。 えーと、ここはね、違いますよね。 ここがちゃんと作ったやつで、 フェチャードイメージが動かない気がする。 プレビューどうなっているって。 ここか。あ、これか。 えーと、だから、ページ名に戻るか。間違えた。 コンテントビューの中に戻らなくていいから、 ページビュー、えーと、ページビュー。 ここに戻って、これのプレビューを見ようという話か。 で、ここがスクロールするからですね。 あれ、1個だけどうか。 あれ、1個だけって、1個ですよね。 あれは、そんなことなかったな。 えーと、今は何個かあるっぽいんですが、 これがうまくいってないのかな。 プレビューはここに書いてないか。 えーと、プレビューっぽいところは、ここですね。 フェチャードランプマークで見れますよね。 だから、いいはずですが、いないですね。 いないのか。 ここで、ページビューのイニシャライザー。 ページビューのイニシャライザーで、 あ、そっか、ページのボディで、プレビューで、 ここでいいかプリントで、えーと、 何か絵を出して、で、その上でページ図ね。 ページ図のカウントでいいかな。 この、なんだ、このマークはディスクリプション、メモかな。 うん。で、これで3個ありますね。 うん。 3個あるのにスクロールしないのか。 だから、バグってる。 バグっていい、大げさだな。 自分のコードが間違ってるということですかね。 なので、ページビューをちょっと止めておいて、 ページビューコントローラー、このページ図が3つ渡ってるはずなんですよ。 この3つがね、渡ってるのに表示されないという、 そういった状況になっているはずなので、 これで一応、ちゃんと見てみますかね。 メイクビューコントローラーでデータソース、ページ図、 ページ図があって、コーディネーターを作るときは、 コーディネーターを作るときには、シェルフを渡してますね。 だから、ページ図が渡ってますね。 一応ここで、念のため、プリントで、 ページが何個あるか、それを見てみますかね。 ページ図のカウント。 こうしたときに、表示されると、文字が出るかな。 出なかった、出なかった、出なかった。 コーディネーターをリターンしないといけなかったんですね。 こうすると、3個って変わんないと思うんですけど、 あれ、変わんないところか。 メイクコーディネーターが呼ばれなかったかな。 メイクコーディネーター、メイクコントローラー、 こっちにも入れといてみますか。 こっちで、そちら側も2つという感じでやってみますが、 表側が進んでないだけかな。 表側どうするんだ、これ。 ノースコードを書き換えたら動くと思うんですが、 もう見えたのがこれ。 動いてるけど、プリント。出てた、出てた。 普通に3個、ちゃんと出てますね。 これで3個は分かってきているということは、 問題は自分にあるということですね。 1個目は表示されてるんだ、というのを踏まえると、 私はそれから、データソースが、 セルフのコーディネーターが分かっていて、 データソースでやってますもんね。 それで、ページビューコントローラーの セットビューコントローラー図で、 ページ0、ページ図0。 これがいいような気がする。 これは、ちゃんとノースすると、アップデートでしょ。 アップデートのときに、現在のページ。 それを出さないといけないのかな。 ページビューコントローラーで、ルートビュー。 この辺かな。 ちょっとコード見ないと、分かんないや。 何を表示すればいいんだっけ、あそこね。 この辺は、ここが0でしょ。ここはいいんですよね。 それで、この先でフィッシャーイメージ用意して、 その後、グラデーションオーバーレイトの表示用意して、 あとは、アスペクトレイト。 これでモデルデータを初期化して、 ここでデータソース。 これが残ってますね。 それでコーディネーターを追加して、 で、分かりましたね。 アップデートのコーディネーターのコントローラー図の0を定するよ。 ここを抜かしていた。 これが、ページ図じゃなくて、 丸かっこ、丸かっこはいいのか。 なので、コンテキストのコーディネーターのコントローラー図だけ忘れたか。 コントローラー図の最初、0番目、0。 ここは必ず0、0以上なのかな。 メイクコーディネーターでコーディネーターがあって、 それで、イニシャライザーで、ここは別に数は気にしてないですね。 ネクストとかやってるけど、これ0のことがあり得そうですね。 そうすると、このコードではよろしくなくて、 メイクページビューコントローラーでオプショナルですよね。 ファストインデックスか。 ここを見たかったんじゃない。 こうやって、アップデートUIビューコントローラーとして、 ページビューコントローラーが渡ってきて、 アップデートUIビューコントローラーのセットビュー コントローラー図に対して、いろいろ渡っていきますけど、 これ、何もページビューコントローラーにされていない可能性が考慮されてないので、 これは考慮した方が良さそうですかね。 そうすると、0ということは、 つまりこれを要素にする、1個の配列。 セットビューコントローラー図は、パラメーターに何をとるのか。 配列か、その配列をオプショナルでとりますね。 なるほど、オプショナルでとるのか。 だとしたら、一応1回変数とってみますか。 コントローラー図、コーディネートのコンテキストのコーディネートのコントローラー図の対象。 対象をとって、それを配列にすることですかね。 終わりだ。これで、ここの二重の括弧は何だ。 これは、インデックスとか。インデックスと配列ね。 なので、ここをコントローラー図にすると、コントローラー図。 これで、OKですね。 そして、上げた時に、プレビューは動いた動いた。 いいですね。まあ、いいですね。自分の行動を見せるんですけど。 これで、パルセルっぽく次へどんどん行くと。 良く出来てますね。これで出来たということですね。 これの段階で、やることは全部一通り終わって、 次に、パラックページをそういうというIPのセットでね、色々見ていくよという、そういった話になるようですけど。 追いかけるのは、また次回にしましょう。 行動なんかいじるとかあるかな、というくらいだけね。 さっそく、今日は見ておきますかね。 というものとしては、PageViewとPageViewController、これくらいですかね。 それで、PageViewの中では、PageViewが、 ジェネリックプログラミングになっていて、ページが用意されていて。 それで、PageViewControllerのページ図。 だから、PageViewというホストを使って、 それで、PageViewControllerをこの中で、 用事するよという材料を取っていて。 それで、ここにページ図に渡してあげているよと。 で、PageViewControllerは、 UIViewControllerリプレゼンタブルになっていて、 これ自体は、そういったUIとして、 何か機能しているわけですけど。 そういえば、UIViewControllerとか、 インポートUIキットをやらなくても使えるのね。 面白いね。 まあ、何だろうね、これはね。 まあいいか。 これが、ページのジェネリックになっていて、 ページを持っていて、 コーディネーター、MECコーディネーターに対して、 自分自身を渡していますけど、 自分自身の何を使っているかというと、 ユアレントの中では、 余計なもの渡さなくていいんだったら、 セルフの方は渡さなくて、 ページだけ渡せば済んではかなと、 思ったんですけど、 そうすると、コンテキストからアクセスする時に、 コンテキストのコーディネーターがコントローラーズ、 コーディネーターはコーディネーター型ですね。 コーディネーター型はどうなっていたかな? こうかな、コーディネーター型ですね。 コントローラーズを持っていて、 ペアレントを持っていますよね。 ペアレントをどこで使っているか、 イニシャライザー。 イニシャライザーでしかペアレントを使っていないんだったら、 持っておく必要が別にないのかなという、そういったお話。 渡すことは大事になってくるのかな、と思ったけど、 ページしか使ってないですね、ここでね。 だから、ページだけ渡せば済んじゃないかな、 というのがあるんですけど、 コーディネーターはペアレント渡すんですかね。 コーディネーターはだからいいのかな、これで。 渡したところで、こんな大きな問題には ならなそうですからね、まあいいとしますか。 コーディネーターをイニシャライズしてますけど、 これはファイルプライベートでいいですね。 イニシャライズを外からすることはないと思うんでね、 コーディネーターをね。 コーディネーター自体はね、プロトコルが要求しちゃってるんで、 このPageViewControllerに追加した、 UIViewControllerにプレゼントがね、要求しちゃってるんで、 型は見せないといけないんですけど、 インスタンス化はね、させる必要はないので、 ファイルプライベートでいいでしょう。 あとコーディネーターを、どこともプライベートにする手ありますよね、 この辺全部。 ファイル、プライベート、こういう風な手もある。 ここまでやる必要あるかな。 メソッドはしょうがない、公開するしかない。 こんな感じですね。いいですね。 これで、PageViewControllerとメークコーディネーターが 足りたくなったから、省略しようかな。 それと、UIViewControllerは、これでコントローラー作って、 データソースを設定して、ファイルしている。 OKですね。 アップデートUIViewController、 これはコーディネーターの対象。 それをコントローラー、PageViewのコントローラーとして、 渡してあげて、 それで、フォワードとかの処理を、 どこがコーディネーターかやるのか。 だから、ここはいいんだ。 重要になってくるのは、PageViewControllerは、 スイートUIを考え方でいくから、 構造感になっている都合で、 これ自身がDelicateのレシーバーとかには なれないわけですよね。 なので、この辺は、普通に何もしないで、 コーディネーターをプラスで用意してあげて、 コーディネーターがデータソースを上手くなっていくよ、 ということをやっていくと。 コーディネーターは特に何も要件なかったのかな、 という気がするけど、調べておきますか。 ボイドというか何もしてはないですね。 何もしてはないですけど、Delicateとか、 あとは、コーディネーターをアップデートの度に 使い回していくのを考えると、普通はプラスで作りますよね。 その辺だけ注意すれば、問題なく売れていくという感じで、 コントローラーもこれでよかったし、 マップの感じで、これは比較だから、 見た目の問題なだけで、 メソッドチェーンを単純に縦に並べていこうかな という気分になっただけなんで、 こういう風にして、最終的にはね、 先頭要素だけの配列をPageViewに渡して、 そのPageViewが、またDelicate、データソースか、 データソースによってスクロールを提供していく という形にしているという感じなんですかね。 あとコーディネーターをメインアクターにしたのでよく、 全部ファイルをプライベートにした、さっき言った、 コントローラーをペアレント保持する必要はないんですよね。 いいとして、ここもメソッドチェーンにしようかな、 という感じで、 こんな感じでOKで、 それで、この辺は、 コントローラーズ、インデックス、マイナス1を返す、 UIPコントローラー、 ちょっとPageViewの仕組みが自分がやったと分かってないですね。 最初、複数渡せるじゃないですか。 ここね、コントローラーズ。 PageViewコントローラーのセットビューコントローラー、 ちょっとそれだけ調べておきますかね。 UIPageViewコントローラーのセットビューコントローラー、 ちょっと見ておきますが、 これ見ようかな。 UIの、さっきのか、セットビューコントローラーズ、 これはビューディテロッドのトップページジェンプなどの スワイプ以外で表示するビューコントローラーを変更したりしたりに使い、 要素数は表示するページの枚数になっている人と呼ばれる、 ということらしい。 デーゲートのデータソースの実装は必須になっていて、 PageViewのbefore、afterを返す。 これを呼ばれるタイミングはスワイプ完了してビューコントローラーが切り替わった後と、 セットビューコントローラーなどの後のスワイプ開始時になると。 1ページ目から2ページ目にスワイプすると、 PageViewのafterが呼ばれる3ページ目を取得しに行くと。 もしかすると、というのも何もないか。 これでたくさん用意したのが間違いで、 例えば、prefix、このupdateで、ファーストの代わりに、 要は、.prefix2とかやると良いことになるのかな。 これでコントローラーズが、これマップで配列にしたけど、 コントローラーズのファーストの代わりにprefix2にして、 マップにした時に型が違うのか。 型は何だ? マップとか、マップじゃないね。 これを配列にしようとしないといけないんだ。 だから、prefix2に対して、 これを配列にしていかないといけないからここでアリか。 これで2つというパターンにした時に、 これもダメか。 何かが違う。これがアリになってるね。 大丈夫だね。これでもダメか。 自分が簡単にUIPGBコントローラーの使い方が 分かってないだけか。 2個を設定しても、何個を設定するとダメということで、 どこでクラッシュしてるんだろうね。 ネットとかのところかな。 Argumentationを、No.1をコントローラーズに、 そのまま1にしないといけない。 Required1。あ、そっか。何か増やさないといけないのか。 ページの数が増やさないといけないのかな。 どこかに書いてあるかな。表示するページの枚数。 これをデータソースだとこれがあって、 ページの枚数はどこかで宣言するのかな。 ページ。ページの枚数。 データソースを見ればわかるかな。 データソースの定義ね。 ページのコントローラーのbefore&afterのほかに、 プレゼンテーションカウント。これかな。 プレゼンテーションインデックスカウントがある。 やってみましょうか。プレゼンテーション。 ダイアログ。ダイアログを頻繁に出すなんて、 確かのガイドラインにありますよね。UIのね。 まあいいか。また放置しちゃった。 ページ。ページ出てこないや。 結局コピーしないのね。ちょっとわかんないですね。 ページコントローラーじゃなくて、 プレゼンテーションカウントか。 全然違う名前か。面白いね。 ベリゲート名ってこんなのだったっけ。 これで2を返せばこれで動くのかな。 動くでしょうね。どうどうでしかないけど。 これ2でもこれでもダメなのか。 プレゼンテーションカウントをプレゼンテーション。 プレゼンテーション。これで2を返せばいけるのかなと思ったけどできなかったね。 1だとどうにもならないですよね。 なんかわからなかった。 カウント。カウントっぽいのないか。 UIページビューコントローラーで複数ページをするにはどうするんだろう。 コントローラー。ここら辺でいくな。 ページビューコントローラーのカウントってあるのかな。ないか。 ページ。ないか。調べればわかるのかな。 UIページコントローラー複数ページと書いてあるというのかな。 複数のコントローラーを設定できるのでこれでいいか。 これで良さそうね。 こういうやつですよね。 それで1枚目を表示するようにする。 コントローラーのメソッドは複数のUIページビューコントローラーを使ってできるので、 3ページ分のコントローラーが良さそうに見えるのに、実際にはUIビューコントローラーという指標でするもののみを設定する。 これは公開するインターフェースがこうなっちゃってるだけなのか。 1個だけ取れば何の後悔もないのに、なぜか。 裏側できっと配列で持ってるからなのかな。 そのせいで配列で取っちゃうという、そういった事情なのかな。 プレゼンテーションカウントは見たかったな。 現在のページ位置の表示。 プレゼンテーションカウントから表示するページです。 なるほどね。 じゃあできないのか。 まあできなそうな雰囲気を感じるし、そういえばそうだったなという気が。 そんなことを前にも感じた気がするような。 とにかく1個だけにして、配列に変換しなくていいからこれでできました。 結局のところからやっていただきますよと。 コードもいい感じに整ってる気がするので、 これくらいかな。 もうちょっと最後の方までもう一回改めて見てみますが、これが無くなった。 それで、この辺も良しなに。 ここが気になるんだ。 エンドインデックスをやってるからプラスイッチにしていて、 これはこれでエンドインデックスと合わせるのが ゆっくり出たかどうかはやりやすいですからね。 このノリでいくとすると、 インデックスが0だったとき、この時に1歩前に戻るインデックスが、 ファーストインデックスの前とかでね、 そういう表現しないからですね。 左が閉区間なのに右が開区間になってるからコードがずれてる当然ですね。 やっぱり0というよりスタートインデックスですね。 スタートインデックスだから、コントローラーズのスタートインデックスにたどり着いちゃった場合には、 0でいいんですけど、配列は0ですからOKですけどね。 スライスがくることもないからいいんですけど、 インデックスの先頭で言ったら一番正しいのはスタートインデックスなので、 スタートインデックスに対して比較をする。 こんな感じで、インデックスの1歩前。 インデックスの1歩前、そういう厳密なことを言うとここも変えないといけないですよね。 本来はコントローラーズのインデックスbefore、これでインデックス。 こっちのほうが本来はタトゥー、ジェネリック的なコードで言うならですけどね。 これと同じように、他のインデックスも本来はコレクション的なコントローラーズのインデックスafter、これが本来タトゥーですね。 こっちのほうがコードが長くなっているのが良くなくなってくるような気もしないような気もないですけど、 インデックスを1歩後ろに進めたものがネクストインデックスですね。 それでネクストインデックスがエンドインデックスに到達してしまったなら、ファーストへ戻す。 そうでなければネクストインデックスでアクセスする。 簡単な話になっていて、インデックスがスタートインデックスに到達してしまったらラストにする。 このインデックスの1歩前、前のインデックス、これはbeforeなのでこれでOKですね。 こっちのほうが気分が良いですね。 コードは見にくくはないですよね。 意味としてはちゃんと説明されているので、これで良いですね。 こんなところでOKということで、今日はこれぐらいにして、 次回はまたこの続きのイベントをちゃんとといといといといとの間で連携していこうというお話になっていくようです。 今日はこれで終わりにしますね。お疲れ様でした。
