Transcription & Summarize : とりあえず読書会 SwiftUI Tutorials #37

それでは、ひとまず SwiftUI チュートリアルを読み進めていきます。きょうも引き続き、macOS 版を作っていく回です。前回はいろいろリファクタリングをして、細かいところで少し混乱しましたが、時間はかかったものの最終的にはうまくいきました。きょうはもう少し複雑な話…と言いたいところですが、それはまた今度にして、引き続きセクション6を進めていくことにします。

まずは早速進めますね。Swift のセクション6はかなり後ろのほうです。スクロールが速すぎて、配信だとコマ落ちしているかもしれません。うっかりセクション7まで来てしまいましたが、一つ前のセクション6をやっていきましょう。

セクション6は「カスタムメニューコマンド」を作る話です。前のセクションでは、組み込み（ビルトイン）のメニューコマンドセットを使いました。今回はカスタムコマンドを作ります。たとえば「選択中のランドマークのお気に入りを切り替える（Toggle Favorite for the selected landmark）」といった機能ですね。あれ、これ前にも読んだ気がしてきましたが、復習のつもりで進めます。

選択中のランドマークを知るために、前回は FocusedValue／FocusedBinding を使いました。つまり、ビルトインのメニューコマンドを利用しつつ、選択状態は `@FocusedValue` や `FocusedBinding` で受け取る、というパターンです。`FocusedValue` に拡張を加えて、`selectedLandmark` のような値を渡せるようにしました。`Binding` と組み合わせておけば、メニューコマンド側で選択項目に対する操作ができます。`selectedLandmark` は未選択の可能性があるのでオプショナルにして、`get`/`set` を実装し、`FocusedValue` としてやり取りできるようにした、という流れでした。

Environment のときもそうですが、Key を自分で定義してサブスクリプトでアクセスするのは少し手順が多く見えます。プロパティラッパーで薄く包むリファクタリングをすれば書き心地は良くなるかもしれません。既にどこかにあるかもしれないですが、覚えていたら今度やってみるのも良さそうです。

とにかく、`FocusedBinding` を使ってコマンド側に `selectedLandmark` を関連づけ、ボタンを用意して「お気に入り」状態で表示やラベルを切り替え、押されたときに `isFavorite.toggle()` する、といったつくりにしていました。選択中のランドマークがないときはボタンを無効化して、さらにキーボードショートカットも割り当てました。コード自体はシンプルです。

ここまでが復習です。`SidebarCommands` は組み込みのコマンドで、サイドバーの表示/非表示をすぐ切り替えられるやつでした。それとは別に `CommandMenu` で自作のコマンド群を追加し、`selectedLandmark` にバインドして動かす、という手順でした。慣れればなんてことないのですが、最初は手順を追うのがちょっと難しいですね。

続いて、`@State`（状態）として `selectedLandmark` の選択を持たせつつ、ボタンが押されたときに `ModelData` のランドマーク配列の該当要素を書き換えると、選択中のランドマークに反映される、という流れでした。少しややこしいですが、そういうものだということで先に進みます。

次はセクション7です。きょうはここから本格的に進めます。内容は「Settings Scene を使ってプリファレンスを追加する」です。ユーザーは OS の標準的な「設定」メニューからアプリの設定を開けることを期待します。そこで、このアプリに `Settings` シーンを追加し、プリファレンスウィンドウのコンテンツを定義します。今回は `MapView` の初期ズームレベルをコントロールできるようにします。さらに、その値を `AppStorage` プロパティラッパーで永続化します。ついに永続化が出てきます。iOS でも重要な話ですが、macOS セクションで登場するのですね。

ズームオプションは `Near`、`Medium`、`Far` の3つです。これを扱うために、まず `MapView` の中にズームレベルを表す列挙型を用意します。

ステップ1：MapView にズーム列挙型を定義する
`enum` で `Near`、`Medium`、`Far` を定義し、`CaseIterable` と `Identifiable`、`String` の `rawValue` を持たせます。`String` を `rawValue` にするのは、保存や表示の都合がよいからです。`CaseIterable` は Picker で列挙する用途、`Identifiable` は SwiftUI のリスト/ForEach で使うためです。`MapView` にネストしてもいいのですが、用途次第で外に出しても構いません。今回は `MapView` に関連づけておく前提で進めます。

例:
```
extension MapView {
    enum Zoom: String, CaseIterable, Identifiable {
        case near = "Near"
        case medium = "Medium"
        case far = "Far"
        var id: Zoom { self }
    }
}
```

`Identifiable` の `id` は `self` を返す形で問題ありません。関連値を持たない `enum` なので自明です。

ステップ2：AppStorage を使ってズーム値を保存する
`AppStorage` の key にはユニークな識別子（UserDefaults に保存されるキー）を渡します。裏側では UserDefaults に保存・読込されます。`MapView` でズームレベルを参照するなら、例えば次のようにします。

`MapView` 側の例:
```
@AppStorage("MapView.zoom") private var zoom: MapView.Zoom = .medium
```

ただし、このデフォルト値 `.medium` を複数箇所で重複させると、規定値を変更したいときに不整合が生まれやすいです。そこで、`Zoom` 側に引数なしのデフォルトイニシャライザを用意しておくと便利です。

```
extension MapView.Zoom {
    init() { self = .medium }
}
```

こうしておけば、`@AppStorage("MapView.zoom") private var zoom: MapView.Zoom = .init()` と書けますし、デフォルト値を変更したいときはこの `init()` だけ直せば済みます。`LandmarkSettings` 側でも同じ書き方にすれば一貫性が保てます。

ステップ3：Zoom レベルに応じて Map のリージョンを調整する
`delta`（緯度・経度のスパン量）を `MapView` のズームレベルから計算し、`region` をその `delta` で作るようにします。低レベルな型（`CLLocationDegrees` など）は外部に漏らしたくないので、`private extension` にして隠蔽しておくとよいです。

例（概念）:
```
private extension MapView {
    var delta: CLLocationDegrees {
        switch zoom {
        case .near:   return 0.02
        case .medium: return 0.2
        case .far:    return 2.0
        }
    }

    var region: MKCoordinateRegion {
        let span = MKCoordinateSpan(latitudeDelta: delta, longitudeDelta: delta)
        return MKCoordinateRegion(center: coordinate, span: span)
    }
}
```

これで、`Map` に渡す `region` がズーム設定に追従するようになります。

ステップ4：macOS 用の Settings 用ビューを作る
`LandmarkSettings` という SwiftUI のビューを新規作成し、macOS だけで利用するようにします（iOS/ watchOS からは外す）。ここでも `AppStorage` で `MapView` と同じキー（例: `"MapView.zoom"`）を使います。そうすると設定画面と `MapView` の参照先が一致し、相互に反映されるようになります。

```
struct LandmarkSettings: View {
    @AppStorage("MapView.zoom") private var zoom: MapView.Zoom = .init()

    var body: some View {
        Form {
            Picker("Map Zoom", selection: $zoom) {
                ForEach(MapView.Zoom.allCases) { z in
                    Text(z).tag(z)
                }
            }
            .pickerStyle(.inline)
        }
        .frame(minWidth: 300)
        .navigationTitle("Settings")
    }
}
```

ここで表示テキストに `rawValue` をそのまま使うと意図が伝わりにくいので、`Zoom` のテキスト表現を明示しておくと安心です。たとえば `CustomStringConvertible` を実装して `description` で `rawValue` を返すようにし、`Text` の拡張で `Zoom` を受け取れるイニシャライザを用意しておく、という形です。将来ローカライズしたい場合にも移行しやすくなります。

```
extension MapView.Zoom: CustomStringConvertible {
    var description: String { rawValue }
}

extension Text {
    init(_ zoom: MapView.Zoom) {
        self.init(String(describing: zoom))
    }
}
```

これで `Text(z)` と書けますし、表示仕様の変更・ローカライズにも耐えやすくなります。

ステップ5：アプリに Settings シーンを追加する（macOS のみ）
`App` 構造体の `body`（`SceneBuilder`）に `settings` を追加します。`#if os(macOS)` でガードして macOS のみで有効にします。

```
#if os(macOS)
.settings {
    LandmarkSettings()
}
#endif
```

SwiftUI の `App` は `Scene` 群で構成されます。`WindowGroup`、`NotificationScene`、`Settings` などを並べてアプリのシーン構成を宣言します。SwiftUI は宣言的なので、できることを知らないと最初の一歩が取りにくいのは確かですが、慣れると見通しはよいです。

ステップ6：動作確認
ビルドして実行（`Cmd + R`）。もし「invalid character（不正な文字）」エラーが出たら、コピペ時の句読点や全角記号の混入を確認して修正します。起動したら、アプリの「設定」から `Map Zoom` を `Near/Medium/Far` に切り替え、Map の表示が追従するかを見ます。

最初、ズームを切り替えても表示が変わらない場合、`delta` を `region` の計算に使っていない可能性が高いです。`MKCoordinateRegion` の `span` を `MKCoordinateSpan(latitudeDelta: delta, longitudeDelta: delta)` にしているかを確認してください。修正後は、`Near` で寄り、`Far` で離れる動きが反映されるはずです。`Medium` にすると中間の表示に戻ることも確認します。

Xcode の操作メモ
- ファイル位置がわからないときは `Cmd + Shift + O` でクイックオープン、`Cmd + Shift + J` でナビゲータ上の位置を表示すると便利です。
- 複数のアプリ実行インスタンスが残っていると検証に支障が出ることがあります。ドックやアクティビティモニタで不要なインスタンスを終了してから再実行すると良いです。

以上で、Settings シーンによるプリファレンス追加と、`AppStorage` を使ったズーム設定の永続化、`MapView` への反映までを確認できました。 文字起こしのテキストを貼り付けてください。  
以下の方針で読みやすい自然な文章（ですます調）に整えます。

- 要約はせず、内容はそのまま保ちます。
- 句読点や文体を整え、明らかな誤変換（例：「G言語」→「C言語」、「万全オキス」→「万全を期す」など）を適切に修正します。
- コードはバックティックで装飾します。短いコードはインラインで表記します。
- 複数人の会話が含まれていても、発話者名は付けず、内容を踏まえた通常の文章にまとめます。
- テキストの冒頭が途中から始まっていても、無理に補わず、次の文から整えます。与えられていない内容は追加しません。

特に表記ゆれを避けたい用語や、直さずに残してほしい専門用語があれば、あらかじめ教えてください。 文字起こしテキストをご提示ください。いただいた内容を「ですます調」に整え、句読点や表記ゆれを修正し、誤認識（例：C言語、万全を期す など）も適切に直します。コードはバックティックで装飾し、短いものはインライン、必要に応じてコードブロックにします。複数人の会話は地の文に統合し、要約は行いません。途中から始まる不完全な文は無視して次の文から整えます。

テキストをそのまま貼り付けてください。長文・分割投稿でも大丈夫です。 文字起こしのテキストを送ってください。読みやすい「です・ます調」に整え、句読点を補い、機械的な誤変換（例：「G言語」→「C言語」、「万全オキス」→「万全を期す」など）も適切に直します。要約はせず、内容はそのままにします。コードと思われる部分はバックティックで装飾します（短いものはインライン、必要に応じてコードブロック）。

会話形式の発言者名は残さず、内容を踏まえた通常の文章にします。途中から始まる不自然な一文は無視して、次から整えます。

そのままテキストを貼ってください。もし特に気をつけてほしい用語や表記揺れがあれば一緒に教えてください。 文字起こしテキストがまだ届いていないようです。整形のルールは承知しました。

- テキストをそのまま貼り付けてください（長い場合は分割して送っていただいて構いません。例: [1/3], [2/3], [3/3]）。
- 要約はせず、「です・ます調」で自然な文章に整えます。
- 誤変換（例: G言語→C言語、万全オキス→万全を期す）は適切に修正します。
- コードはバックティックで装飾します（短いものはインライン、長いものはコードブロック）。
- 複数人の発話も、発話者名は付けず、内容を踏まえた通常の文章にまとめます。
- 冒頭挨拶など、与えられていない内容は追加しません。途中から始まる不完全な文は無視して、次の文から整えます。

準備ができたテキストをお送りください。 文字起こしテキストを貼り付けてください。いただいた内容を「です・ます調」に整え、句読点を補い、明らかな誤変換は適切に修正します。コードはバックティックで装飾し、短いコードはインライン、複数行など長いものはコードブロックで表記します。複数人の会話は発話者名を付けず、内容を踏まえた自然な文章にまとめます。

追加の希望があれば（例：タイムスタンプの扱い、用語の表記ゆれの統一など）、あわせて教えてください。 文字起こしテキストをご提供ください。いただいた内容を「ですます調」に整え、句読点を補い、誤変換を適切に修正します。コードはバックティックで装飾し（短いコードはインラインで表記）、会話形式は通常の文章に統合します。与えた範囲以外の内容は加えず、要約もしません。

長文でも対応します。長ければ複数回に分けて送ってください。 では、理解度チェックにいきましょう。「なぜ、`Landmarks` アプリは、フィルターと `landmarks` 配列をモデルの中ではなく、アプリ側に定義したのですか？」という話かなと思います。それで合っている気はするのですが、一応予想してみます。

「モデル内ではなくビュー内で、フィルターと `landmarks` の配列を定義しているのか？ モデルは `FilterSettings` にアクセスできない？ `FilterSettings` ってなんだ？」という疑問はあります。そんな気もするけれど、よく分かりません。

どうすべきかというと、「computed property をモデルに持つべきではないのか？」という問いに対して、必ずしもそうではないですね。アプリ側に置くことで、異なるウィンドウで異なるフィルターのリストを簡単に表示できるようにする、という意図がありそうです。フィルターと `landmarks` をモデルの内部ではなくアプリ側に置いたのは、ウィンドウ単位での表示を簡単にするため、というのがもっともらしいと感じます。

「モデルデータが `FilterSettings` にアクセスできない」という点は何でしょうか。`FilterSettings` は `isFavorite` とかの設定ですよね。あれは `State` として持っていればアクセスできるはずですが、どうでしょう。さっきの Command-Shift でメソッドを探していて、フィルターと `landmarks` のゲッターを見ました。モデルデータがアクセスできないといえばできない気もします。`FilterSettings` 側がフィルターのリストを持っていて、`ModelData` はここで `EnvironmentObject` として注入しているので、アクセスできると言ってよいのかな、と。自信はないです。

フィルターコントロールとフィルター配列、そして `landmarks` をまとめてアプリ側に持つことで、複数ウィンドウを開いても同じデータに対して異なるフィルターで表示できる、というのが意図的だったのですね。Xcode で動かしているもので、メニューから New Window を出せるようにしてありますが、その場合に片方のビューをもう片方とは独立して動かすことができます、という話です。

1番目の選択肢は何が間違いなのか分からず選べませんでしたが、リロードしたら選べました。これはどういう間違いなのか謎ですね。「モデルは現時点では `FilterSettings` にアクセスできるが、それらをモデルに移すことはできない」とか、「`EnvironmentObject` に入れておけば、どこからでもアクセスできますよ」といった説明がありました。「現時点では `FilterSettings` にアクセスしていないが、モデルやストア（環境）からアクセス・保存することも可能」といったニュアンスで、つまりアクセスは可能だと言っている感じです。ピンときませんが、先に進みます。

次の問題です。「Picker の selection 型は、続くコードの中でどのプロトコルに準拠していなければならないか」。To what protocol ですね。`Picker` の `selection` は何に準拠していればよいかというと、`Identifiable`、`Hashable`、`Equatable` の候補があったとして、`selection` なので `Hashable` ですよね。一般に `Picker` の選択は `Hashable` が必要です。

さらに、「以下のサンプルのどれが正しいか。`selectedLandmark` のバインディングにリストの現在の選択を反映するには？」という問題です。今回の冒頭で、自分が復習しながら混乱していたやつですね。`selection` が `selectedLandmark` を持っていて、`landmarks` を回してタグを付けるやり方は良さそうに見えるけれど自信がありません。次の案は、`landmarks` を回して `LandmarkRow` に対して `tag` を与えているだけで、`selection` がまったく出てきていないのでダメな感じがします。`ListSelection` なんて型があるのか？ と言われると、あるとは聞いていないし、使ったこともない気がします。次の案は、`List { ForEach(landmarks) { ... } }` のようにいろいろやっているけれど、`List` が `selection: $selectedLandmark` をパラメータとして受け取っていないので、違いそうですね。結局、`List(selection: $selectedLandmark) { ForEach(landmarks) { LandmarkRow(landmark: landmark).tag(landmark) } }` のように、`List` の `selection` に `Binding` を渡し、各行に対応する `tag` を付ける形が正しそう、という理解です。 まずは一番目で良さそうな気がします。次は次の問題です。どのようにアイテムを追加するか。トップレベルメニューのアイテム、メニューですね。このトップレベルのメニューはコマンドだったはずです。だから `WindowGroup` にメニュービューを追加するわけではない気がします。

`commands` モディファイアをアプリケーションに追加して、これを Commands に提供します。あとは `toolbar` モディファイアを追加して、メインコンテンツビューに付けます。メインコンテンツビューがメニュー関連のインターフェースを内包しているはずなので、そこに `toolbar` モディファイアを追加する、ということですね。

そのコードが出てこなかったので、一番目かなと思ったのですが、「アプリのメインコンテンツビューにメニューインターフェースを含むツールバーを追加する」は合っていそうです。いや、やっぱり違う。二番目の「`commands` モディファイアを Commands と一緒に提供する」が正しそうです。合ってますよね。

次、チュートリアルはこれで終わったらしいです。なるほど。最後はそんな感じで締まったというところですね。

よし、こんな感じでいろいろと見ていって、理解はできましたが、いくつか気になる点と、リファクタリングでもう少し手を入れられそうなところがある気がします。その辺を見ていきたいのですが、何か一つ気になった点があったはずで……どれだったかな。ちょうど今見ている中で気になったところを覚えていたつもりだったんですけど、チュートリアルをやっているうちに忘れてしまいました。どこだったかな。

メニューでズームレベルの指定を OS に任せたのは良さそうですね。プリファレンスの設定も、これで良さそうです。あとは、動きが変なところがあるので、どれも直したいんですけど、わからなくなってきました。どこだったかな。

マップビューをもう一回見てみますか。マップビューでは、コーディネートとズームを `@AppStorage` で扱って、リージョンではデルタを使って、ズームレベルをデルタに換算して……ズームレベルをデルタで、数学でどんなとき使いましたっけ。 移動する差分とか、そういうときに使っていたような気がするんですけど、数学におけるデルタはどういう意味で使うんでしょうか。微積分だと、ちょっとだけ増えた量を表すのに、例えばデルタTみたいな感じで使いますよね。これによっていろいろと、デルタXはdX、昔出てきましたね、そんな話をイメージしていました。ただ、ここで言っているデルタは、微積分のデルタとは少し違いそうな気がします。

あとは、デルタという言葉がわかりにくいんですよね。マップでのデルタって何？という感じがしませんか。なので、`MKCoordinateSpan`（コーディネートスパン）を見てみると参考になるかもしれません。センターとスパン、つまり中心と広がりですね。半径的なニュアンスに思いがちですが、実際には幅と高さに相当するものです。

`MKCoordinateRegion`をAppleのドキュメントで調べると、ちゃんとコメントが出ています。イニシャライザーの引数はセンター（`center`）とスパン（`span`）で、スパンは「マップリージョンの幅と高さ」であり、これを`MKCoordinateSpan`と呼び、ズームレベルに対応する「デルタ値（delta values）」として説明されています。つまり、コーディネートスパンの各軸の差分量をデルタと呼んでいるわけです。そういう意味ではデルタと呼ぶのは筋が通っていますが、名前としては「スパン」のほうがより具体的で分かりやすいと思います。

`CLLocationDegrees`（度を表す型）のデルタですよね。`MKCoordinateSpan`のイニシャライザーを見れば、`latitudeDelta`と`longitudeDelta`を渡す形になっていると書いてあります。であれば、関数の戻り値を「デルタ（数値）」ではなく`MKCoordinateSpan`にしてしまうほうが良いのではないでしょうか。たとえば、`MapView`の`regionSpan`のように名前を付けて、戻り値で何を返すのかを明確にします。

中では、`let delta: CLLocationDegrees = ...`のようにして、ズームがLowなら0.02、Mediumなら0.2、などなどとズームレベルに応じた値を決めて、最後に`return MKCoordinateSpan(latitudeDelta: delta, longitudeDelta: delta)`という形にします。`latitudeDelta`と`longitudeDelta`に同じ`delta`を渡す構成ですね。こうしておくと、関数名も戻り値の型も意味が揃っていて、意図が伝わりやすいと思います。

ということで、これで`MapView`ができて、やっとズームの扱いまで来ました。何かリファクタが残っていたと思うんですが、忘れてしまいました。ここはテキスト表現も大丈夫そうですね。いい感じです。

この辺の詰めは、またゆっくりやっていけばいいかなと思います。チュートリアルやリソースを見ていた場所が少し古かったこともあり、ランドマーク設定でズームを作ってピッカーを用意し、4-1でレベルを選ぶ……という流れは良さそうです。ランドマーク設定を表示して、何が足りなかったのか、今は思い出せないですね。今度ゆっくり全部見直して、そのときに思い浮かべば直していく、くらいで良いのかもしれません。プロパティラッパーなどはまた後でやりますが、今回引っかかっていたのはそこではなく、もっとシンプルな何かだったはずです。まあ、大丈夫……というか、まだはっきりしない、という感じですね。

ひとまず今日はこのあたりにしておきます。チュートリアルは一通り終わりましたが、もう少し触れられるところがありそうな気がします。次回は、最終的なステップの整理と、バグが1つ見つかっている気がするのでそれも直していきます。1回で終わらないかもしれませんが、見ていこうと思います。

今日はこれで終わりにします。ありがとうございました。
