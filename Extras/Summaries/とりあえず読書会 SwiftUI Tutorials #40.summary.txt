Transcription & Summarize : とりあえず読書会 SwiftUI Tutorials #40

それでは、SwiftUI 2.0 を進めていきましょう。大詰めというか、やるべきことは一通り終わったところです。前回と前々回は、リファクタリングをしながらコードを書いて、崩れたところを直す回でした。前回で良い感じに直せたので、今日は純粋にコード全体を見渡し、少し手を入れると面白くなりそうなところや、アートワークは用意できているけれど表現としてもう少し工夫できそうな箇所を中心に見ていければと思います。

やることは明確に決めていませんが、その中でも気になっていたのが `compactMap` 周りです。大したことではないのですが、`compactMap` がどれくらい読みやすい書き方になっているかが気になっているので、まずはそこを眺めてみます。`compactMap` として検索すれば見つかるはずなので、出てきたところからゆっくり見ていきます。

また、クロスプラットフォーム（複数の OS）を想定して作っているので、その前提でのコードの整理が適切かも気になっています。まずは上からソースを見ていきます。

`Category` は `String` の raw value を持つ `enum` で、`Sendable` にも準拠させています。Swift Concurrency 対応も今回入れてみましたが、ネットワーク通信をしていないためか、ほとんど引っかかるところはありませんでした。`Codable` も付けています。今回のように複雑でない場合は、`Codable` にしておけば自動実装で適切に動きますし、わざわざカスタムのエンコード／デコードを書かなくても良さそうです。

さらに `CaseIterable` を付けて、UI をビルドする際に列挙できるようにしています。`CustomStringConvertible` も `description` を返すだけで問題ありません。`Identifiable` は `id = self` で十分ですね。そもそも `Identifiable` が必要かどうかは用途次第で、デバッグのために一時的に付けた記憶もあるので、不要であれば余計な `id` プロパティを生やさず削ってしまって良いと思います。

`Category` の `Dictionary` を `description` で眺めたときに並び順が変わって見える件は、コードがやや読みにくくなるので気になっています。ただ、`Category` のテキスト表現は自分自身で良いので、ここはこのままでも良さそうです。

`Landmark` は問題なく、次に `Hike` を見ていきます。`Hike` でも配列のデータをこうして表現していて、`id` プロパティがあるため `Identifiable` を付けておくのは差し支えありません。`Identifiable` を使うと便利な場面も多いので、このままで良いでしょう。

`Observation` の配列は、これまで生の配列型で書いていましたが、一貫性のために `typealias` を用意しておきます。たとえば、`typealias Observations = [Observation]` のようにしておけば、以後は `Observations` と書けて読みやすくなります。ここはそんなに大きく触らなくても大丈夫です。

型については、`distance` は `Double`、`difficulty` は `Int` といった具合です。フォーマッタ周りでは、`LengthFormatter` を使って距離のテキストを出すところを `@MainActor` で保護していましたが、UI 用の整形だけのために `@MainActor` を付けるのは少し大げさかもしれないと感じています。`LengthFormatter` を `@MainActor` から外してみてもエラーにはならず、ビルドも通りました。

`LengthFormatter` は `Formatter` のサブクラスで、`Formatter` は `NSObject` 派生です。`Sendable` ではないので、本来ならコンカレンシーまわりで警告が出ても良さそうですが、出ていないのが少し気になりました。ビルド設定（たとえば `Swift Language Version` や Strict Concurrency の設定など）の影響で、現状は緩めのチェックになっている可能性があります。Swift Concurrency 対応が甘かったということになるので、これから設定を見直し、より厳密な Swift Concurrency 対応を進めていくことにします。 ここが出ませんでした。Swift ですよね。ロック…いえ、Swift Concurrency の設定は「Complete」ですね。ここは大丈夫です。設定は良いはずなのですが、もう一回開き直してビルドをかけます。これで結構出ると思ったのですが、出ないはずがないという気分でいっぱいです。クリーンしたほうがいいのかな。ファイルのほうですね。このフォーマッタ。これをメインアクターの保護をやめた、という状況です。これで一回保存してビルドをかけても変わらないかな。ではクリーンしてみます。今、クリーン成功。で、ビルド。成功しましたね。これで大丈夫そうなのかな。

`private static let` ですが、`private let` だとどうでしょう。これは実験ですね。ビルドをかけたときにファイルがエラーになります。これは `Decodable` に準拠していない、あとこれは同じ、という感じです。では、グローバルに置いてみます。とりあえずグローバルに `private let`。これで良いですね。ビルドをかけると大丈夫です。`var` にするとダメ、`let` なら OK ということですかね。やはりダメですね。そうなると、Swift Concurrency のチェックが働いていないのでは、と思ってしまいます。違うのかな。

Swift のバージョンはこれで良いですよね。Swift の Language Version。モジュールバージョンではなく、ここら辺。Swift Language Version は 6 ですよね。Swift 6 でコンカレンシー周りはこれで良かったはずです。macOS も 6 なんですけど、プロジェクトの中で 6 を指定して、それを引き継いでいるという形を取っています。これを明示してみます。明示したところで大体変わらないと思うのですが、いったん別の値を選んで、もう一回 6 を選び直してビルドをかけます。macOS のビルドですね。Succeeded で警告が出ません。中身でハマっていますね。どうしよう。

Swift コンパイラでやると…これもう大丈夫か。警告出ていないですね。Swift の話じゃなかったでしたっけ。では iOS でビルドかけてみましょう。iOS は最初から iOS を想定したコードを作っているので、ここは大丈夫…と思ったらエラーです。Concurrency-safe のエラーが出ますよね。macOS でも出ましたね。もう一回 mac に変えて、macOS ビルドで。これは困りました。どうしたものか。iOS だとレポートされるけれど、そうじゃないと…構成を見直せていないのかな。macOS はここですよね。もう一回ビルドをかけて、これですよね。これ、何でしょうね。わからないとちょっと困ります。

Swift Strict Concurrency Checking がここですよね。これが iOS、watchOS、macOS に対して保存…いえ、設定されています。それで、このプロジェクトの設定を Levels で見てみます。Swift Language Version は Resolved が 6 ですよね。Landmarks アプリが 6 にセットされて、プロジェクトも 6 にセットされて、macOS のデフォルトは Unspecified。こんな感じですが、とにかく Resolved されているので OK だと思います。あと考えられるのは、どのビルド、どのターゲットかというところ。macOS は 6 ですよね。他にないから良いと思います。watchOS も 6 ですね。iOS はいろんなプラットフォームに対応ということになっていますが、ここも 6 です。そうすると問題ないはずです。macOS と iOS で Swift Strict Concurrency Checking が変わる、なんてことも考えにくいのですが、なぜパスしてしまっているのか。

Foundation の `Formatter` はオープンクラスで Foundation にあるものです。もう一回さっきも見ましたが、念のため確認します。`Formatter` は `NSObject` で、`NSCopying` と `NSCoding` に準拠しています。これらは別に `@MainActor` で保護されているようには見えません。そうすると、ここはコンカレンシーチェックでエラーになるはずです。これ、`@MainActor` になっているのかな。`nonisolated` にしたときにはエラーになりますね。では、`@MainActor` なのかをまず調べてみます。やり方は非常に簡単で、`Task { @MainActor in ... }` です。メインアクター上で使ってみれば良いと。`print` で、`self` の …ではなく、良いほうが良いかな。グローバルの `formatter` を使ってみます。これが普通にまず使えますよね。別のエラーで赤くなっていますけれど、それは今は関係ないので無視します。

これをメインアクターで縛らなかったとき。つまり `Task.detached { ... }` のほうが良いですね。このときに `formatter` を使うと、メインアクター縛りになっていますね。だから、これはデフォルトアクター（既定のアクター隔離）がもう導入されている、という扱いになっているのでしょうか。 ビルド設定を見てみると、Swiftコンパイラのオプションに「Default Actor Isolation」がありますね。ここで`MainActor`を指定しておくと、特に明記されていない、または推論されるべき箇所が`MainActor`で隔離されるようになります。これは、最近登場したSwift Concurrencyを楽に導入するための仕組みで、よほど詳しい人でなくても扱っていけるようにするための機能だと思います。図では`MainActor`になっていました。macOSではそうなるんですかね。

普通は`MainActor`でやれば十分だと思うのですが、個人的な興味もあって、これが導入される前の`nonisolated`でやってみたくなるタイプです。今回は、macOSのアプリ設定だけ`Default Actor Isolation`を触って、ほかは`nonisolated`にしてみたり、watchOSは`MainActor`、iOSは特に設定していなかったりと、プロジェクト全体では特に統一の指定をしていない状態になっています。

さて、問題はここをどうするかです。オープンクラスの`Formatter`なので、これが`Sendable`であるという保証はありません。安心して使うための選択肢としては、まず`@MainActor`で保護する方法があります。もう一つはロックを使って排他制御を行い、フォーマッターへのアクセスを同時にさせない方法です。

さらに、フォーマッターを使うたびに初期化する、という方法もあります。インスタンスを使うときに都度作るわけですね。ただ、一般にフォーマッターは生成コストが高いと言われるので、その場で毎回作るのはあまり見ません。とはいえ、パフォーマンスを度外視してローカル変数として`MeasurementFormatter`を生成する、というのも一つの手ではあります。

また、フォーマッターを使うだけなら`nonisolated(unsafe)`でもいけそうな気がします。今回は完全に読み取りだけで使う想定ですし、`distanceText`というのは明らかにSwiftUIのテキスト表現で使うものなので、`@MainActor`で保護しても問題はなさそうです。ブロック（ロック）するより、`@MainActor`で保護した方が最適化の余地もありますし、そちらのほうがおすすめかもしれません。

とはいえ、`nonisolated`も悪くない気がしますし、Actorで包んでブロックするのは今回はあまり合わなさそうです。`private static let`でフォーマッターを用意して`nonisolated`にしておき、`distanceText`が同時に呼ばれても読み取りだけしかしていないので大丈夫、という判断もありだと思います。つまり、`nonisolated(unsafe)`という感じですね。良さそうでもあり、少し怖くもあり…といった印象ではありますが。

ほかに、ここだけ同期的に、Objective-Cのときに使っていた`dispatch_once`のような初期化方法を使う、というアプローチも考えましたが、今回は見送りました。最終的には、`nonisolated(unsafe)`でいくことにしました。 パフォーマンスと安全性は若干自信はないのですが、大丈夫だと思います。まあ、落ちることはないでしょう。もし落ちたらそのとき考えればいいでしょう、ということで、これで配列はOKですね。

次に、配列の処理についてです。エレベーションとベースとオーバーレイを `Range<Double>` で持っていて、グラフの描画に使う要素が大事ですね。`Sequence` の `Range<Double>`（つまり `Range<Double>` のシーケンス）に対して、最大値の指標を求めるために、`lazy.map(...).max(...)` のように、遅延評価で `map` してから `max` を取っています。最大を取るときに絶対値（magnitude）を使って計算していく、ということです。まるっとまとめるよりは、このほうが良さそうですね。

これでだいたい位置を取るわけですが、戻り値がオプショナルになっています。`lazy` の `map` は遅延シーケンスになり、そのまま `max()` を呼ぶと、シーケンスが空の場合は `nil` を返す仕様なので、オプショナルになるわけですね。良いと思います。

`Sequence` の `Element` が `Range<Double>` である、という読みが少しわかりにくい気もしましたが、そういうものですよね。`Range<Double>` に名前（型エイリアス）を付けるかどうかは悩ましいところですが、まあこのままでいいですかね。これでOKです。

次にイメージです。`Image` は名前を取り、その名前から `Image(name)` でそのままインスタンスを作るようにしています。ランドマークの「Feature Image」を取得するために、`featureImage(of: Landmark)` のような形でアクセスできるようにしました。`park` や `state` などのプロパティもあって成り立っています。ランドマークの拡張で `CodingKeys` を定義していますが、初期のときに `private` なエクステンションでやっています。`Codable` に必要なものは `private` で大丈夫なので、こういう定義にしています。

イメージだけは少し名前を変則的にしていて、`imageName` から自動的に変換して `Image` をプロパティとして持っておく、という方式になっています。

`bindingLandmarksByCategory` では、`categories` プロパティを用意することで、キーを取得できるようにしました。これは完全に防御的な用意ですね。`keys` と言われても文脈が伝わらないと困るので、`categories` と名付け直した、という感じです。

`Binding<[Landmark]>` を扱うときには、個々の `Binding<Landmark>` をまとめることができるようにしてあります。パススルーのセッターを用意して、その `Binding` を設定する、という感じですね。そんなに難しくはないと思います。

次に、`Element` が `Identifiable` である `Sequence` に対して、ID で要素を取るためのユーティリティです。`elementByID`（たとえば `element(id:)`）のような名前で良いのですが、もう少しわかりやすくしたい気持ちもあり、`landmarkByID` のような、ドメインに寄せたラッパーも用意してあります。これは `Landmark` のリストに対して `element(id:)` を呼ぶだけの関数です。

あるいはサブスクリプトで ID から要素を引けるようにしても良さそうで、実際サブスクリプトも用意してあります。つまり、`landmarks[id]` のように書けるわけですね。`landmark.elementByID(...)` とどちらが直感的かは悩ましいところで、記号（サブスクリプト）対文字（メソッド名）という別の問題でもあります。サブスクリプトにすると `self[...]` の記述が増えて書き方が少し紛らわしく感じる場面もあるので、ここは現状のままで良いかなと思います。

そうしてあげたら、次は `LandmarkCoordinate`。一通り見ました。 ランドマークについては、カテゴリーに準拠しているかどうかを見ています。また、同じカテゴリーかどうかを `isSameCategory(as:)` で判定しながらイテレーターを回していき、カテゴリーが得られたら、それに対して同じカテゴリーかを `isSameCategory` でチェックしてフィルタリングします。これで問題なさそうです。

次に、コーディネートです。`CLLocationCoordinate2D` は外側にイニシャライザーを持たせたので問題ありません。同様に `CLLocation` も外側にイニシャライザーを持たせていて、こちらも大丈夫です。

マップズームについて。こちらはマップビューのズームを表す型で、`RawRepresentable` の `RawValue` として `String` を採用しています。「`String` に `rawValue` がある」という理解だと引っかかるのですが、正しくは「ズーム型の `RawValue` に `String` を使っている」ということですね。`CustomStringConvertible` にも準拠しているので、テキスト表現はそれで十分です。

一度、`String` を `RawValue` に使う実装を外してみましたが、その場合は `rawValue` がなくなるためイニシャライザーも存在せず、`@AppStorage` が要求する `RawRepresentable` を満たせなくなります。`@AppStorage` は `DynamicProperty` で、内部的に `RawRepresentable` の `value`（正しくは `rawValue`）を利用します。したがって、ここは `RawRepresentable` にして `RawValue` を `String` にするのが正解です。せっかくなので `rawValue` もきちんと実装して、これを永続化に使っていく、という形にしています。

さらに、`Identifiable` にも準拠させて `id` を返す性質を持たせています。`CustomStringConvertible` によって、`Text` にズームを渡せば、そのテキスト表現が得られるようにもなっています。これで OK です。

次に `MapViewZoom`（先ほど見たもの）です。モデルデータは `ObservableObject` で、`final class` にしてあります。中身は `var` で、`@Published` にしているはずです。`static let defaultProfile` を持っていて、`profile` と、`defaultProfile` を取得するためのプロパティを便宜上用意しています。ほかに、`@Published` のプロパティと、イニシャライザーで `Bundle` からデータを読み込んでいます。

`ModelData` の `extension` では、`bindingLandmarks` を用意して取得できるようにしています。名前が少し分かりにくいかもしれませんが、`bindingLandmarks` からカテゴリーを取り出してグルーピングする形（カテゴリ別のバインディング）でも同様に書けます。加えて、`bindingFeaturedLandmarks` は、`bindingLandmarks` を `isFeatured` でフィルタして実装しています。プロパティラッパーのプロジェクテッド値（`$`）を使わなくても書けるのでは、という気もしますが、ここは一旦このままにしておきます。 `.filter(...)` を使って、`Optional` の Wrapped Value に対して `isFeatured` でフィルタするようにします。こうすると、一つ上と同じノリになるので収まりがいいですね。

あとは、`Bundle` のエクステンションで `ModelData` を扱います。`ModelData` として、`URL` からデータを取得し、`JSON` デコードして返すくらいですかね。なるほど。これはこれで良いのですが、`ModelData` はどこで使っているのでしょうか。`ModelData` は一箇所だけで使っていますね。`ModelData` の中で、`main` バンドルから呼び出すのに使っている、と。

ここで思ったのは、このバンドルは必ずしも `Bundle.main` にあるとは限らない気がすることです。なので、`Bundle` を引数として受け取り、デフォルトを `.main` にして、指定されたバンドルに対して実行する方が、この `ModelData` としては汎用性が高そうです。これで良いでしょう。

ファイル名などもここで固定していますが、ここで縛ろうとしないなら良いのでしょう。`extension ModelData` で、`Binding<Landmark>` とか、`Binding` 関連も見た気がしますが、今データを取ってきたからかな……そんなことはないか。`JSON` デコードしてデータを返す。エラーだった時には `DecodingError` を `catch`、でまた別の `catch`。`let error as DecodingError`、`unknown default` か。ふむ。

`let error as DecodingError` のときに二段階の `switch` をしているのですが、`unknown default` も問題なく使えるようなら、この二段階の `switch` はいらない気がします。`switch` 文が複雑になっているように思うので、理由（`reason`）のところで `content`、`typeMismatch` とか色々やっていますけれど、この理由は、いっそ `DecodingError` 自体を `LocalizedError` に準拠させてしまう手もあります。`DecodingError` にそんなことをしていいのかという話ですが、アプリケーション内なら大丈夫ですね。とりあえずやっておきますか。

`DecodingError` 周りを追加するために、まずここですね。この辺の文字列をコピーしておいて、`DecodingError` はどこに入っている？ 標準ライブラリです。どこでも良いので、新たに場所（ファイル）を作りまして、そこで `extension DecodingError: LocalizedError` として実装を載せます。保存場所はとりあえずルートでいいですかね。コピーしてきたものを貼って、エクステンションにして、`LocalizedError` に準拠させて、返すのは `errorDescription`。これはコード（理由）に応じた文字列で返してあげます。こうしておくと、モジュール全体から扱えるようになります。

ここでの `error` は `self` ですよね。これ、`reason` と言っていますけれど、変数に受ける必要がない規模感です。なので、これで OK。他の `UnexpectedError` は `self` か。`self` で、`self` でしょうがないのかな。`LocalizedError` の実装で無限ループすると怖いですが、多分大丈夫なので `self` でいきます。

そうすると、`DecodingError` がローカライズ表現できるようになったので、さっきの `let error as DecodingError` の場合には、`error.localizedDescription` を使って、そのまま `fatalError(...)` に渡して落としてあげれば良い感じですね。これは悪くない気がします。これで `ModelData` は終わり。

次は `Profile` ですかね。この `Profile` の方は、`Profile` 型があって、`username`、`prefersNotifications`、`Season.winter`、`Season.unknown`。これを見るからに `Sendable` ですね。 なので、`Sendable` にしておきましょう。問題は出ていないのですが。`Sendable` は、型の内部が条件を満たしていれば暗黙的に（自動合成で）満たされるはずですよね。自分は見通しを良くするためにあえて書いていましたが、書かなくても成立するケースもあると思います。今回は入れておきましょう、`Sendable` を。

`Hashable` もいけますが、使っていないので今回は外しておきます。

プロファイルはユーザー名など、いろいろ持っています。ここでふと思ったのですが、`Sendable` は内部の型が適合している時点で、暗黙的に `Sendable` として振る舞ってくれます。さっき「グローバルアクター」と混同してしまいましたが、関係ありませんでした。つまり、`Sendable` と明示的に書かなくても良いのでは、と一瞬思ったのですが、見通しが取れているなら明記しても良いと思います。というわけで今回は入れておきます、`Sendable` ね。

次に `id` です。この `id` は必要でしょうか。とりあえず `Identifiable` だけ消してみます。ビルドは失敗……あ、違いました。「`LocalizedError` がない」と言われました。これは `import Foundation` が抜けているからですね。

上に遡って確認したり、プレフィックスの話に寄り道してしまいましたが、全然別の機能の話でした。確かコンパイラのエラーで教えてくれましたよね。

プロトコルの名前が出てこなかったのですが、`…Convertible` みたいなやつ（たとえば `CustomStringConvertible`）のことを考えていました。意味としては「ひっくり返す」に近い感じのやつです。いずれにしても、「ある型が別のプロトコルに準拠する」という表現で良いですね。

`LocalizedError`、`errorDescription` はもう知っている前提で進めます。問題は、「`LocalizedError` が見つからない」と言われる点で、これは `Foundation` をインポートしていないことが原因です。`LocalizedError` は `Error` の拡張プロトコルです。

では、`DecodingError`（「デコーディングエラー」のことです）について。`DecodingError` を `LocalizedError` に準拠させて、`errorDescription` を用意してあげれば良い、という理解で合っていますよね。検索するとスライド資料ばかりで、不思議とまとまった解説が見つからなかったのですが、「自動合成」や「レトロアクティブ（既存型への後付け適用）」の話が出てきました。結局のところ、`DecodingError` を `LocalizedError` に準拠させて、`errorDescription` を実装すれば良いはずなのですが、なぜか解消しないのが気になります。

とにかく、`DecodingError` ですよね。なので、`DecodingError` を `LocalizedError` に準拠させてみて、ちゃんと動くかどうかを確かめる、という流れになりそうです。 デコーディングのエラーを意図的に起こせるとしたら、どの方法でしたっけ。Reason とか、プロフィール……でしたっけ？ ローカライズエラーだから、かな。エンコーディングのエラー……ではなく、JSONデコーダーでモデルデータを復元するにあたり、モデルデータなのでデコーダーがある、という話ですね。ここですね、モデルデータって。これで、型などの復元に失敗するのが大事なのかな。

Landmark で復元を失敗させる方法としては、この `coordinates` が良さそうですね。この `coordinates` で、これは良いとか、これは良いです。Landmark で `CodingKeys`。ここで全然違うキー名にしてあげて、それで実行してあげればエラーになるでしょう。その時、エラーメッセージがちゃんと出るかどうか。

うん。エラーで "checked into first" と出て、reason が "The data couldn’t be read." というふうになったのですが、これは普通の、Swift Concurrency のエラー……ではなく、`Codable` のエラーですね。あ、コンカレンシーじゃない、`Codable`。`Codable` のエラーだから、それはそれで良くて。

今やっていたエラーは何でしたっけね？ デコーディングエラーか。あ、デコーディングエラーでいいのか。デコーディングエラーで、"checked into first" みたいなことをやっていましたが、まだダメな気がする。`Codable`。うん。そうですね。だから、この辺をやるとしたら、`typeMismatch` か。`typeMismatch` をやるとすると、モデルデータの中で、Landmark でいいのかな。うん。と、`typeMismatch` か。難しいな。あとは、`valueNotFound`、`valueNotFound`、うん。そして `keyNotFound`。この辺が、さっき実行した時に選べるかと思ったんですけどね。うん。実行した時ね。まあ、この辺はどうしたらいいか。

ちょっと私、Playground で試しておきますか。こっちの方がなんか良さそうですね。やりたいことはデコーディングエラーですよね。なので、Playground は……これがあってもダメだ。これですね。で、これでこの中で試していけば良いと。

この試し方としては、インポートはいいのかな。例えば、`extension`。で、`LocalizedError`。あ、やっぱり `Foundation` ですね。`import Foundation`。で、`LocalizedError` に準拠させます。`errorDescription`。これを `String?` を返す形のプロパティですね。で、これで、例えば「テスト」みたいな感じにして。で、これで、`LocalizedError` じゃなきゃ……えーと、デコーディングエラー。で、こうしてあげて。その上で、`print`。というか、デコーディングエラー。イニシャライザは何かある？ あー、そっか、`rawValue` か。 なので、これにしました。コンテキストね。コンテキストは、まあ何でもいいや。こういうふうにして、`localizedDescription` じゃない、`LocalizedError`。これで表示してあげようと思ったんだけど、ダメって言われますね。で、これを `LocalizedError` としてあげると、やっぱりダメですね。`LocalizedError` にするには、これ一旦エラーに留めるとダメなんでしたっけ。

`EncodingError`。`EncodingError` は、Swift標準の `EncodingError` ですよね。これはエラー型だから、`LocalizedError` でもいいはずだと思ったんだけど……。`let error = …`、`EncodingError` の `init`、そうね、`init` の `codingPath`……あれ、ないな。`EncodingError`。`EncodingError` のイニシャライザ、そして……うん、何かが違う気がしますね。`EncodingError` が、コントローラとかイニシャライザじゃないですね。

で、ここは `EncodingError.Context` です。ここでコンテキストとしてイニシャライズして、`codingPath` は特になく、`debugDescription` が、まあ何か文字列です。で、これでエラーが作れたところで、このエラーを使っていく。`error.localizedDescription` とですね。こうしたときに、メッセージが「test」って出れば、ちゃんとエラーディスクリプションが動いている。なので、コードとして間違いないということがうかがえてくると。まあ、そういうことになりそうですね。

で、これでなかったとすると、`LocalizedError`。これの準拠が、うまくできない。`EncodingError` は、もはや既にそれが取られた、という状況になるんで、他の手段を取らないといけなくなってくる。まあ、そういった面倒さがちょっとありそうですね。こうやってうまくいくといいんですけどね。で、うまくいったらどうしますかね。うん。まあ、それよりもまずは、これがどうなるか。

あと、原因ももうちょっと探りたいんですけど、多分どこかで `LocalizedError` に準拠させちゃってると思うんですよね、`EncodingError` をね。まあ、それをたどってみればいいのかな。でも、`EncodingError` は Swift の標準ライブラリにあると思うんですよね。なので、できれば、というか、実際のところは多分 Foundation で設定してると思うんですよね、これ。今、普通に `EncodingError` は Swift の中にありますよね。で、この中でエラーで確認をしている。それぐらいか。うん、それぐらいか。

でも、やっぱり Foundation ですね。Foundation の中にズバッとあれば嬉しいんですけど。Foundation の import の中にあるのは、`Foundation` とか、`FoundationErrors`。この辺かな。`FoundationErrors`。この中でエンコーディングの何か……。あとは、`NSError` とかじゃなくて……いや、`NSError` じゃない気がするけど。エンコーディングはないですね。じゃあ、この他だと、これっぽいのはないですかね、今のところね。`NS` なんたら、`NSObservation` と `System`。`System` かな。`System` はまた違いそうですかね。

お、何かあったと思ったら、`String.Encoding`。うーんと、これはでも関係ないですね。`String.Encoding` なんていうのがあるんだ。それで終わっちゃったね。該当箇所を探していくのは難しいですね。動いてない、動いてない。早く動いてほしいな、今。狙いは `localizedDescription` か。これを例えば、何か分からないけど、エラーの拡張として、Foundation が `Errors` としてですよね。これで `EncodingError` の拡張……あー、ありましたね。`LocalizedError`。ありました、ありました。

で、これで特に何も定義してないってことは、`errorDescription`。これは省略されてる感じですね。なので、省略として既定のディスクリプションが使われているので、後から追加したものはちゃんと活用されるはず。動いてほしいですけどね、そろそろ動かないかな。Playground、うーんと、Playground の iOS 問題なんですかね。今はまあマルチプラットフォームでやってるから、別に iOS じゃなくてもいいから、ちょっと macOS にしてみましょうか。macOS にした上で実行させて、この「test」という文字列が `localizedDescription` で取れればと思ったけど、どうだ。読み取れなかった？ 適切なフォーマットではない。`localizedDescription`……いや、そんなことないです。 ローカライズドディスクリプションが取れなかったですね。`DecodingError` でもう一回やってみますか……あ、ダメですね。これは基本のエラーになるから、`localizedDescription` が取れなかったのか。自分の中ではちょっと予想外でした。これをオフにしても同じ、ということですよね。

ほかに考えられるところとしては、エラーメッセージを `DecodingError` 側に持たせる方法です。`localizedDescription` がダメだとすると、もう一つの方法としては `CustomStringConvertible` に適合させるやり方があります。ただ、これはあまりよくない気がします。`description` を実装して、その中でテキストを返せば、既定のエラー表示で使われてしまいます。Playground を動かすと、これも既定のエラーのローカライズドな説明として使われるはずです。逆に、それを使わなければ別の値で置き換わる、という挙動になります。

では、エラーに対して `errorDescription` を直接呼ぶとどうなるでしょうか。`errorDescription` が定義されているのは `LocalizedError` の拡張ですよね。なので、型にその実装を追加してあげれば大丈夫だと思っていたのですが、別のモジュールだから反映されていない、そういうことなのかなというのが気になります。たとえば、`DecodingError` に対する `extension` で `errorDescription` を実装してみても、`error.localizedDescription` にすると取れなくなる。`DecodingError` への拡張としてうまくいかないのか。そうなるとちょっと厄介ですね。

どうしますかね。リファクタリングの話で、要はこのエラーの表現をどうするかです。`localizedDescription` を使って、`DecodingError` だったときにはそれをエラー表示に出していく。さっきのように別のエラーメッセージを出すための工夫を入れる方法もありますが、`DecodingError` のときだけ特別扱いしないといけない、ということになってしまいます。とにかく分岐が非常に増えてしまうので、それはやりたくなくて、`localizedDescription` にまとめたかったのですが、どうもできないのかもしれません。そうすると、この中で推定を書いていくか、パターンマッチングをもう少し細かく入っていくか、というところですね。これは結構悩ましいです。

もう一つ考えられるのは、ここで `errorDescription` ではなくて `CustomNSError` に適合させる方法です。これならいけそうですね。やってみましょう。`NSError` は `userInfo` を持てるので、この中にメッセージを入れます。まず、これまで作っていたメッセージ生成の部分をコピーしてきて、`errorDescription` をやめて、`message` という変数に入れます。`message` が取れたら、ここで `return` ですね。`userInfo` のキーは何だったか……`NSError.UserInfoKey` ではなく、`NSLocalizedDescriptionKey` を使えと言われました。助かりますね。Xcode の Fix-it を適用してあげます。キーに `rawValue` はないのかな？ ここはそのまま `String` で良さそうです。これで `NSLocalizedDescriptionKey: message` という形で入れてあげれば大丈夫そうです。これで `String` です。 結局のところ、レコーディングエラーが原因で、これがちゃんと取れるかどうかを確認したいです。それか、プレイグラウンドはまだ残っていたかな。プレイグラウンドはこれですね。

これでレコーディングエラーではなく、`CustomNSError` での特定にして、エラーがちゃんとメッセージを出しているかどうかを見たいです。出ないのか、やり方を間違っているのか。それとも、これを `NSError` にすべきですかね。ここでイコールにして、まず `NSError` にブリッジしてどうなるかを試します。この場合もダメか。

`errorUserInfo` じゃなかったかな。`CustomNSError` の型だとどうなるかを確認しておきましょう。`CustomNSError` の型ですね。これを使って `CustomNSError` を実装して、それで `errorCode` と `errorUserInfo`。ここでいったん `errorUserInfo`。ただ、これはちょっと例になっていないな。これじゃなくて、Apple のドキュメントに書いてあるかもしれません。`errorUserInfo`。ここが `errorUserInfo` ですね。この辺で使い方としてどんどん書いてあるかな…書いていないですね。

ほかに `NSError`。これも何か出てきそうな気がしますね。`LocalizedError` じゃなくて、`NSError` のブリッジはこれですね。これは `NSError` はそのまま投げるのか。`CustomNSError`。これはどこで投げるかな。Apple かな。惜しい、どうする？これは土曜の勉強会のときのものですが、内容が出ないですね。ここを見れば出てくる気がするけど、まだ公開していないか。

あとは、`NSError.userInfo`。この辺を見返すと、`errorDescription`。これは `LocalizedError` ですね。これじゃなくて、`CustomNSError`。こうなっているので、細かく両方欲しい場合は `LocalizedError` プロトコルを使う。これはいいのですが、他のエラーとして `NSError` ですね。それの `NSError` 変換（ブリッジ）の説明のところは、上のように細かく書いてありますね。`Localized` というのは違う。これじゃなくて、`RecoverableError`。`RecoverableError` とかこの辺は使ったことがないな。なるほど、もっといろいろ書くか。

それではそれとして、`CustomNSError` が出てくるのか。検索したほうがよかったですね。`CustomNSError`。これで事例しか出てこないのかな。`CustomNSError`。これでいいのか。`CustomNSError` で `errorUserInfo` で、登録とカスタム…このキーじゃなくて、`LocalizedError`。`userInfo` の `NSLocalizedDescriptionKey` を出したいんですけどね。それは載っていなかったか。詳しい方から載っていったらよかったんだけどな。

これで「`CustomNSError NSLocalizedDescriptionKey`」とかでやれば出てくるかな。出てきそう。ローカライズドディスクリプションを設定するのに…`NSLocalizedDescriptionKey`？ローカライズド…これじゃないな。出てきそうで出てこないですね。`NSError` のローカライズド…。これを調整するときにはこの辺ですよね。それで出てこないですね。GPT のほうが早そうです。ちょっと GPT に行ってみましょう。

この続きでいいかな。新しくしますか。えっと、やった。「`CustomNSError` でローカライズドディスクリプションをカスタマイズする方法をください」。こんな感じで続けてみれば、サクッと出てくるんじゃないかな。そんなにマイナーなことじゃないはずです。ブリッジされる際の情報でしょ？というのもらえてきた感じですよね。

それで `errorDescription` でこうやって return する…あれは `LocalizedError` ですね、もっとも一般的。それはいいんですよ。これを作るときには `CustomNSError` で、`errorCode`、`errorUserInfo` で、`return` で `NSLocalizedDescriptionKey`。あとは `errorCode` と `errorDomain` ですかね。これを忘れたからなのか分からない。ちょっと書いてみます。 まずは `userInfo` のキーが正しいことを確認します。今は起きていて、実行しても大丈夫ですね。あとはエラーコードとして、例えば `1` を返すようにします。そうですね。さらに、エラードメインはここでは何がいいでしょうか。デコーディングエラーなので、`DecodingError` ですね。これでやってみましょうか。実行させて……あ、動かないですね。

`localizedDescription` でしょうか。`userInfo` はここに入っているのかな。`NSDebugDescription`……入っていない。入っていないか。間違えたかな。`userInfo` ですね、`userInfo`。ここでもそうですけど、この中に入っている気がするんですけどね。これがなかったとすると、要はラップされていたとすると、何も合わないし、何も入っていないですね。入っていないですね。`userInfo`、`errorUserInfo`。エラーですよね。`NSError` にブリッジしたときに `userInfo` が入っていない。これはちょっと予想外ですね。どうしようかな。

`NSDebugDescription` は入っていました。で、エラーとして……あ、本当だ。さっきの `errorDescription` は、ここでは効果があるのは `NSError` のエラーではなくて、`DecodingError` の方に効くということなのかな。そんな気もしてきました。とにかくカスタマイズは失敗ですね。そうすると、この辺をどうにかするには、これでもダメだったからしょうがないですね。`DecodingError` が Swift 側で用意されているものだというのを踏まえると、`Codable` 準拠ではなくて、一から作るしかないですかね。プロトコルの中で……。 プロフィールと違っていましたかね。違わないかな。モデルデータでしたっけ。この中にモデルデータ、つまり文字列があります。ここですね。ここをなくしたかった、という話をしていました。しかし、もしそれができないとなると、デコード時のエラーが起きた場合には、そのそれぞれに対してエラーメッセージを作っていく必要がある、ということになりそうです。

デコーディングエラーが起きたときにここを直すとすると、エラーを受け取って、そのエラーからエラーメッセージを生成していく形になります。これで捕捉、というか、やっておくべきなのはコンテキストですね。これをフラットにする方法もあって、例えば `catch DecodingError.dataCorrupted(let context)` のように `DecodingError.dataCorrupted` をコンテキスト付きでキャッチして、その中で `print` していく、というやり方です。フラットにする方法もありますが、これだと型安全にならないので、やめたほうがよさそうです。そうすると、今の形で良いですかね。エラーがないなら仕方ない。これで良しとして、`Codable` 用の拡張が嫌だということになると、こんな感じでやるしかない、という落としどころでしょうか。

ふと思ったのですが、throwing function ですよね。`Codable` で良いのか、まあ良いか。そんな感じで、ここはあまり好きなコードにはなっていないのですが、デコーディングエラーで詳細な情報が取れないということで、OK ということにします。残りの `catch` も `fatalError` にしておきます。これでモデルデータは OK ですね。

次はプロファイルです。上から見ていくと、`Sendable`。これは OK ですね。`Sendable` は見ましたよね。`Sendable` いらないのかな、という話もしていました。それから `Identifiable` と `CaseIterable`。`Identifiable` を外すとどうなるでしょう。とりあえずビルドをかけると、通りそうですね。ID がなくてもどうでしょう。ビルドをかけると通りますね。これで良い気がします。うん、大丈夫。これで良くて。

プロファイルに既定値が入っていますね。この既定値ですが、今どうしていましたっけ。プロファイルに既定値も何もないのが普通ですよね。イニシャライズ時に「デフォルトプロファイルのユーザーネームはこれです」と言っているのか。つまり、ユーザーネームだけではなくて、「通知が欲しいか」はデフォルトで false にしておく、シーズンはデフォルトで Winter にしておく、ゴールデートは……これはゴールデートが何か、という感じですが。ここがちょっと気になります。

特に既定値は、本当にそれが一般的なものなのかがとても大事です。もし無いのに、セットアップするためだけに既定値を載せることになると、その既定値が適当でも変えづらくなってしまいます。既定値を変えるのは影響が大きいので、安直に選ばないほうがいいです。API デザインガイドライン的にも、既定値が設定されているプロパティはあまり重要ではないもの、普通こうだよね、という程度で、ちょっと試すときだけ使う、といった位置づけが似合います。要は、オプショナルで省略できる形が似合う、そういうプロパティに向いています。

なので、安直にプロフィールの既定値を型のほうに用意するよりは、型をちゃんと明示するだけにして、実際の値をどうするかは別で考える、という状況を作ったほうが良いと思います。そうするとビルドが失敗したときにもはっきり分かりますし、`defaultProfile` のような場所にだけ既定値を用意すれば良いわけです。例えば通知を `true` にして、シーズンは `Winter` をデフォルトにして、更新日時を「今」にする、というふうに書いておけば、型のほうで既定値を縛ってしまって全てで同じ既定値になる問題を避けられます。`defaultProfile` においてはこう、という話にできるので、もし `defaultProfile` の既定値を変えたいとなったときには、その `defaultProfile` の影響範囲にしか変更が及ばなくなります。絶対にこのほうが良いですね。

こちらは何でしょう。`defaultProfile`、`ModelData.defaultProfile`。これは大丈夫かな。ビルド通りますよね。通りましたね。こんな感じで、良いリファクタリングができた気がします。既定値をむやみに使わないこと、大事ですね。

`Season` のシンボルについては、以前は `rawValue` で設定していましたが、どう見てもこれは `rawValue` ではないので、別の名前を割り当てて返すようにしました。`rawValue` ではないですよね、どう考えても。そんな感じで OK です。

ここまでできて、結構時間が経ってしまいました。ではこのくらいにしておきましょう。まだまだ全然コードがあるので、次は Notification この辺からリファクタリングをしていこうと思います。今日はこれで終わりにしましょう。お疲れ様でした。
