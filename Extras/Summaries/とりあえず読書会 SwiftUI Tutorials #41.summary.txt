Transcription & Summarize : とりあえず読書会 SwiftUI Tutorials #41

はい、では「とりあえず読書会」を始めていきます。SwiftUI Tutorials を読んで、実アプリのコードはだいたいできあがった感じです。リファクタリングも含めていろいろやって、この中でほぼ完成かなという気もするのですが、もう少し触っていくと、もっと良い答えがありそうだという感じがします。細かいところを見ていく、というスタンスで進めたいと思います。

どこまでリファクタリングするかという機会は、自分でコードを書いていてもあまり多くはなかった気がします。書いている最中に直す、ということは確実にありましたが、広く細かく見てリファクタリングすることにどこまで価値があるかは、実務ではケースバイケースかもしれません。とはいえ、こういった練習のときに考え方を身につけておくのはとても大事だと思うので、そんな気分でやっていきます。

では、さっそく見ていきましょう。まずは macOS で一緒に見ていきます。他のプラットフォームもちゃんと見ますが、実行のしやすさの面で macOS を使います。では、通知まわりのところからですね。`UNNotificationContent` を使って通知コンテンツを生成し、情報を持たせます。`userInfo` を `String` に変換して、できなかったら `userInfo` をそのまま持っておく。`userInfo` に対して文字列でキーを指定するのではなく、プロパティでアクセスできるようにする、という仕組みを作っています。

ここでふと思ったのですが、これはマクロで作れるのではないかという気がしました。マクロでなくても、プロパティラッパーで作ってもよいですね。プロパティラッパーのほうが簡単ではありますが、マクロで遊んでみるのも面白いかもしれません。ではマクロでやってみましょう。

名前はどうしましょうか。`LandmarksMacro` にしてみます。マクロはマルチプラットフォームで OS には関係ないですよね。Xcode でマクロを作るのはターゲットですよね。どれだっけ…さっき見たのを忘れてしまったので、調べてやってみます。Safari で「Swift マクロ 作り方」を検索します。

Xcode で作る方法としては、File > New > Package で良さそうです。これで Swift Macro のパッケージを作ります。マクロ名は `LandmarksMacro`。テストはひとまず省略します。保存場所はドキュメントフォルダにしておきます。

まずはこの時点でビルドして、エラーがないかを確認します。最初の段階でエラーがあると、あとで筋違いのエラー対応が発生してしまう恐れがあるので、ここで一度ビルドが通ることを確認しておきます。無事にビルドが成功しました。

では、今から作りたいマクロは、この `UNNotificationContent` 周りの実装です。`userInfo` に文字列キーでアクセスするのではなく、プロパティで型安全にアクセスできるようにするためのマクロを作っていく、という方針で進めます。 どういったマクロの名前がいいですかね。あれ、これはプライベートか。プライベートで、あ、これはいいんだ。あと、この辺はローカルにしたかったんですね。なるほど。そうすると、ちょっとマクロで作ろうと思ったんですけど、そのままではできないですかね。

`userInfo` をディクショナリにして、そのディクショナリからタイトルを取っていく、という感じになっていくから、あれ、階層をたどらないといけないのか。そうすると、マクロで実現するよりは、こうやって愚直に書いたほうが楽な感じがしますね。別のやり方としては、`userInfo` が階層になっていると考えて、そのあたりをいい感じに表現するという方法です。これをするとしたら、どんな感じだろう。ドットで連結されているとして、それによって掘り進んでいって、具体的なキーが定められていく、みたいな感じでやるとどうなんだろう。あ、でもドットはダメか。ドットは普通の構文上意味がありますからね。そうすると、どういう表現にするとわかりやすいですかね。

多分、列挙型で書いて、その列挙型に応じてプロパティを生やしていくスタイルになると思うんですけど、そのときは `enum`、コンテンツだから `Items` みたいな感じで、`case aps`、`case alert`、`case title`、`case message`、`case landmarkID` みたいに続けていけば実装できる、そういったマクロがいいのかなと思いました。ただ、この辺が階層構造じゃないですか。だからそれをどうしようかなと。階層構造を表現するとしたら、例えば、ここをそのまま取っておくわけにはいかないですよね。アンダースコア区切りで `title` とかにして、ルートには `aps` があって、その下に `alert` があるので、これを `aps_alert` のように表現する。`aps.alert` のパスを書く、という感じですね。`aps.alert` をこういうふうに表現して、文字列として扱う。この立て方でいってみますか。

これでタイトルはどこだ。タイトルは `alert` のタイトルですね。なので、`aps.alert.title` という感じ。メッセージは `aps.alert.body`。そして `landmarkID` は `userInfo` に用意されていますね。なので、これはしなくてもいい、と。そんな感じになってくるんですかね。これで作っていく感じをちょっとやってみますか。無意味なタイトルもあるかもしれないですけど、とにかくこれでやっていくとすると、これは `AttachedMacro` というのが入ってきていますよね。なので、それを定義していきます。どこにしようかな。

`LandmarkMacros` の中の freestanding じゃなくて…この辺、ちょっと書き方を覚えていないので、調べながらやっていきますが、freestanding macro、attached macro、この辺を見ていきましょう。マクロとして、attached macro はプロトコルなのか、その辺も見てみますかね。`SwiftSyntaxMacros` ですね。名前も決めないといけないですね。`UserInfoMacro`。戻り値の型、これが何を示すかも指定しないといけないので、これを `enum` で表現しますかね。`aps`…この中間はいらなくなりますね。今回のやり方だと、タイトルは `String`、メッセージも `String`、`landmarkID` は `Int` みたいなふうにして。これで作ってみたら、あ、`rawValue` だ。`rawValue` を入れちゃったから、これだとダメなんだ。ちょっと無理があった、という感じになりますかね。

別の方法としては、`enum` のケースに関連値を持たせてやってみる、というのもありますかね。あるいは `struct` で `Items` を定義して、例えば `var title: String` というふうにして、その値を止めて…でも、これも文字列を渡さないといけないから、結局都合が悪いですね。パラメータは `String` にしないといけないし…。そうですね、これダメか。マクロは向かないですかね。

あと考えられるのは `KeyPath`。`KeyPath` もダメか。`KeyPath` は関係ないかもしれないですね。何かいいアイデアが出てくるかなと思ったんですけど、難しいな。データの持たせ方を、Swift の標準的な言語構文で表現して、それを解析してコードを置き換える、あるいは追加する、という形で取っていくのが Swift のマクロの基本ですよね。 それをうまく活かして、実装を簡単に行いたいという気分なわけですが、これをするには戻り値のパターンというか、そのプロパティのパターンと、あとはそのプロパティのパース、この2つが要になってくる、という感じですよね。そうすると、あまり複雑な構文にしてしまうと使い勝手が悪くなってくるので、その辺りもまた難しいところなんですけど。

データとしてのパターンとしては、構造を特定しているのがダメか。パスとパスがあって、そのパスと戻り値のパターンですよね。あ、そっか、マクロって難しかったですね。困った感じですね。

ランドマーク、ディクショナリ、ディクショナリパターン。ディクショナリパターンだと文字列と値が紐づいていますが、文が欲しくて、文のほか階層構造で表現されるというのもありますけど、それだと大げさな感じがしますかね。enumパターンもちょっとやってみますか。

例えば、`Items` でしょ。列挙体の `enum Items` で、この中でまた `enum` を入れ子にして、`APS`。同時にしないと Swift っぽくないですよね。`APS` の中で、`case title(String)` と `case message(String)`。あとは `APS` じゃなくて、`Landmark(id: Int)`。構造はいいですね、これね。とてもね。これでちょっとやってみますか。

なので、これはフリースタンディングではなくて attached マクロですよね。attached マクロはどこにアタッチするのか。メンバーとして追加していくわけだから、`NotificationContent` に対して付与していく感じで良かったのかな。ちょっとマクロの種類を見てみましょうか。

マクロの種類として、attached マクロ、freestanding マクロ、peer マクロ、member マクロ、accessor マクロなどがあって、peer マクロはプロパティやメソッドに対して付与して新たなプロパティやメソッドを追加する。これじゃないですね。あとは member マクロ。これは `struct` や `extension` などの型に対して付与して、新たにメンバーを追加する。これを使うとしたら `Content` の方に添える感じですね。あとは accessor マクロはプロパティに対して付与するもので、今回は目的ではない。あとは conformance。これも今回関係ないですね。

そうすると、プロパティを増やしていくということになるので、やることとしては `NotificationContent` に対して付けていく、という感じになりそうですね。`NotificationContent` は `userInfo` を持っている点でいけますかね。例えば、`@UserInfoAccessor` みたいな感じで。要するに、この列挙型を管理して、自動的にこういったプロパティを増やせるように、というのを作ってみようかな、という感じでやってみますか。

そうすると、やることとしては、まずは `UserInfoAccessor` というものをここに作っていく。これで Swift ファイルを `UserInfoAccessor`。まずは `LandmarksMacro` のここに。デフォルトで用意されているものはそのままでいいとして、前のものは一部残しておきますが、member マクロだけど、`@`…マクロの作り方は、どうするんでしたっけね。マクロの作り方、ドキュメントを見てみますか。 まずは定義のところですよね。そこでマクロの実装として、まずはどこにこのマクロがあるかを示してあげるわけですが、出てこないですね。出てこないとすると、Swift の標準ドキュメント、The Swift Programming Language に載っていたと思うんですよね。ここにマクロの話が載っていたはずで……ドキュメントはどこだ。あ、これですね。この中に「マクロ」というセクションがあって、超ざっくりとですが書いてあったと思います。

今回は `freestanding` じゃなくて `attached` マクロです。`attached` の member macro、そういった書き方をするんですね。`attached` の member macro。それに対して、`attached` の member macroで、マクロとして OptionSet の `RawValue`…あれ、なんだろう。こんな書き方したかな。とにかく `attached` マクロですね。

これはいらないですね。上の説明は一旦よいか。このファイルも、とりあえず最初から作られたやつは要らないですね。そうした上で、ここで `@attached(member)` を付けて、`macro` を定義します。例えば `macro UserInfoAccessor() = #externalMacro(module: "LandmarksMacros", type: "UserInfoAccessor")` のように書きます。モジュール…モジュールでしたっけ。えっと、`SwiftSyntax`…あ、そっか。

ここでの話としては、モジュール構成がポイントですね。このマクロは2つのモジュールで作られていて、ライブラリとしての「LandmarksMacros」と、それを実際に担当する実装側のモジュールがあり、前者が後者に依存している形です。インターフェースを「LandmarksMacros」で定義して、その実装を実装側のモジュールで定義する、という感じですね。これで実装側モジュール内の `UserInfoAccessor` をここに入れていく。それで「型が見つからないよ」と言われるんだ。すごいですね。

`UserInfoAccessor`…これがマクロのモジュール名だったかな。`SwiftSyntaxMacros`、`SwiftMacros`…インポートすべきはどれだったかな。インポートは出てきてないですかね。マクロの……とりあえずパッケージの方は置いておきましょう。`SwiftSyntax` は入れてありますね。大丈夫です。`SwiftSyntax` が入っているから、これでいいはずです。

これで member macro を指定して、member macro に必要な実装、いわゆる expansion を実装してあげます。`expansion(of:providingMembersOf:in:)` ですね。`providingMembersOf … in some MacroExpansionContext`。その下は、こっちで良さそうですね。この中でいろいろ実装していくという感じです。今いろいろ悩んでいるのは `SwiftSyntax` ですね。`import SwiftSyntax`。

これで、あとは……リプリケイティブ。あ、これリプリケイティブだったんだ。なので、`expansion` のこっちが今必要なのか。こんな感じで、テンプレートだけ作った感じです。

これでビルド……ここは `=`……まだダメか。`macro = #externalMacro(...)`。`value-like macro expected parentheses` と言われますね。実装ファイルはまだ同じだから……ビルドかけてみましょうか。ビルド成功した？ビルド成功したのかな。マクロは、まず当ててみますか、最初でもね。これでビルドかけて、やはり失敗ですよね。ここを形変しないといけないのか。そんなこと昔やったか、あまり覚えてないですけど。

ここですね。この中でマクロの……さっきの OptionSet がありましたよね。なぜだったか分からないんですけど、OptionSet の `RawValue`。これはなんだっけ、って感じですが、これは何だろう。`OptionSetMacro` ですよね。`OptionSetMacro` を定義する。`UserInfoAccessorMacro` を定義する、だったと思うんですけど、`attribute` がいるのかな？`attribute` マクロ。`attribute` は重要ですよね。でも、これじゃなかったね。`ExpressionMacro` で `UserInfoAccessor(...)`？`ExpressionMacro`。`ExpressionMacro` の使い方。Swift のマクロ、`ExpressionMacro` で……。

この辺でいいですかね。マクロの書き方として、`freestanding` じゃなくて…。 まずはエクスプレッションマクロですね。これをやるにあたって、まず字が書かれていないか確認します。アタッチドマクロがあって、定義の仕方を知りたいのですが、フリースタンディングマクロの方も見ておきます。ここですね。フリースタンディングマクロは、たとえば `ExpressionMacro` を使って定義できます。エクスプレッションマクロはフリースタンディングの一種で、新たなマクロの説明として、たとえば「マクロ `string` イコール `ExpressionMacro` という感じで書けますよね」といった確認です。そんな感じですね。

ただ、今やりたいのはそれではなく、アタッチドとしての定義、つまりアタッチドマクロの定義の仕方です。マクロの定義で、ここがフリースタンディングではなくアタッチドマクロになるわけで、`extension` に対するものや `Conformance` に対するもの、`Member` に対するものなど、それぞれに対応するプロトコルがあります。エクスプレッションマクロは別枠ですよね。なので、「モデルコンバート」というものを定義するとして、これはどう作るのか。モデルコンバートのマクロとして使い方を見ていきます。使い方はこれですね。実際に文字から定義していくという感じかもしれません。ユーザーマクロからコーディングしていく形です。

そうしたときに、アタッチドマクロの `name` は任意（アービトラリ）にできるので、独自の名前を自由に追加していけるようなマクロも必要です。その後、`UserInfoAccessor` が丸が多いと思うんですけれど、これでもダメでしょうか。`LandmarksMacros` のマクロ実装の中にある `UserInfoAccessor` が見つからない、というエラーになります。これはアクセスコントロールの問題かもしれません。`public` を付けてあげるとよいのでは、ということで、こちらにも `public` を付けます。これも `public` じゃないとダメですよ、ということかもしれません。`public` を付けてあげて、これだとどうでしょう。リビルドをかけます。エラーは出ないでしょうか。

それでも、`LandmarksMacros` の `UserInfoAccessor` が見つからないというエラーが出ます。`LandmarksMacros` の中の `UserInfoAccessor` はありそうですよね。`MemberMacro` かもしれませんが。これはちょっとわかりません。`MemberMacro` ですよね。実装は置いてありますよね。それなのに見つからない。`UserInfoAccessor` の実装はあるのに、見つからないみたいです。これはどうしましょう。`public` にもしてあります。難しかったでしょうか。マクロの方の話はどこに書いてあるのでしょう。

まずこれを見ていきますが、これですよね。アタッチドマクロ。アタッチドマクロ、アタッチドマクロ。これが形としての `extension` ですね。なので、これはこれでいいという知識ですよね。マクロの定義としては大丈夫な気がするんですけれど、これじゃダメなのでしょうか。

あと考えられるのは、マクロのコンパイルの問題でしょうか。マクロクライアントに一応してみますか。クライアント側でも同じですよね。これでいいかな。これでアタッチドの展開（エクスパンション）を定義して、マクロの方で……。`import` とか要るんでしたっけ。要らないような気がしますが、多分ここにドキュメントもありますよね。こうした上で、どうしますかね。マクロが Swift マクロで、自分でも調べて書いて飛んだんですけれど。

「Swift マクロ」で検索してみます。自分の作（記事）が出てくるかな。ブログでは書いてないですよね。スライドとかでは書いたんですけれど。これじゃないかな。ボイラープレート、マイクが出てきたから、全然自分のとは関係ないですけれど、これを見てみますか。`extension` でいろいろマクロ、すごいな。アテナのマクロとか出ますね。作り方、いいな。Swift マクロのドキュメント、もう一回見直します。 まずはマクロを作りますね。カスタムアトリビュートで、マクロの宣言から始めます。`OptionSet` というまとめを作っていきます。`attached` と `member` という感じで作っていって、extension マクロって何でしたっけ？ Swift マクロです。Swift マクロの extension、だから Swift Macros の extension マクロ。Swift マクロ、expression だ……expression。あ、これを繋ぎ込んだのか。extension マクロでもいいですね。extension 専用版です。

extension マクロで extension を増やそうとすると、名前付きパラメータの制約に引っかかる可能性があります。extension マクロは付与した側にしか行えない。でも、これで extension マクロはできる気がしますね。なので member というか、extension マクロにして、それで準拠も。ファイルはこっちか、extension マクロですね。

extension マクロを搭載すると、extension マクロの実装の `UserInfoAccessor` が見つからない、`UserInfoAccessor` 用の `UserInfoAccessor` が見つからない、といったエラーになります。`LandmarksMacros` ですね。これがアプリですよね。できていそうな気がするんだけどな。できはするんですけど、それにしても警告が出ていますね。とりあえずこういうふうに作っておきます。extension マクロです。

この辺は名前付きパラメータの追加。これで、さっきの自由な名前を追加するということを今やっています。まずはここまでか。import じゃないよね。やってみますか。`import LandmarksMacros`。import ですね。いいということにして、これで実装が終わっていくということになるんですけど、ここから次は実装のほうですよね。

それで `expansion` で `node` が `AttributeSyntax` として来て、`declaration`、`DeclGroupSyntax`、`providingExtensionsOf`……だいたい言葉から分かりますね。この辺は定義を見ると開いてあって、まず extension マクロというのは、`attached` マクロのさらに発展形態を開いたもので、macro extension、その `attached` に対して宣言、アプリの extension を使っていく感じですね。で展開する。`attached` された extension マクロ、これを extension のセットとして展開します。

node としてはカスタムアトリビュート、`attached` マクロのカスタムアトリビュート。宣言が、アタッチされた……拡張が型に付きますね。型に付くから、`attached` が型に付くのか。`attached` マクロ。extension、`attached` マクロと、`attached` マクロがアタッチしていくやつで、型に対して、または extension に対して。`attached` のメンバーは……extension マクロは extension を増やしていくのか。extension に対して付けられるんですかね、これね。その辺が微妙になってきましたけど、作り替えはそんなに難しくないだろうから、いいですかね。

それでタイプを提供する、extension が提供する型というのが、type、`TypeSyntaxProtocol`。プロトコル数は準拠させるプロトコルリストですね。これは今回は特にいらなそう。あとはコンテキストとして、コンテキストのね。だから今回やることとしては、アタッチする型。これに対していろいろとやっていくという形というか、open ですかね。

なので、これをやるには `print` で、ちょっと一旦出すだけ出しますけど、どれだ、`declaration` か、`declaration`。これの `description` でよかったな、`description`。で、ちょっとログを出しつつ、デバッグで何が渡ってくるかを見て確かめてみたいと思うんですが、Find Symbol: `main`、何かおかしくなっていますね。`main` が見つかっていない。

ユーザー定義アトリビュート、これは import ですね。`import Landmarks`、`LandmarksMacros` かな。あ、ないですか。`LandmarksMacros` が取り込めていないからかな。`LandmarksMacros` ですね。`Macros` ってやりましたっけ今。これがマクロ。でもないですね。そうすると、これはビルド設定ですかね。ビルド設定で `LandmarksMacros`。これに対して、General。ここでフレームワークを足していくというプロジェクトになりました。 インポートではないですね。なので、ターゲットを macOS にして、Xcode の General タブの Frameworks を開きます。ここで追加ボタンを押して、フレームワーク（ライブラリ）を追加します。`LandmarksMacros` を入れて、OK を押します。本当は他の2つも入れておいたほうが良いのですが、いまは `Basic` しかないですね。iOS 側かな。では iOS ターゲットの General でも同様に設定して、`Landmarks` と合わせて `LandmarksMacros` を追加します。iOS 側には Framework のリンクがすでにあって、単に見落としていただけでした。

これでビルドできるかと思ったのですが、`LandmarksMacros` のパッケージが見つからないと言われて失敗します。クライアントではなく macOS ターゲットをビルドしてもビルドは失敗です。エラーを見ると、シンボルが見つからないと言われています。`LandmarksMacros` のシンボルが見つからないということですね。さっき何かを1つ消したのがまずかったかもしれません。ゴミ箱から戻せるか確認してみます。手元で変更日を見ていますが、せっかくなのでコードを持ってきて貼ってみます。

`SwiftSyntax` 周りが必要そうです。インポートをコピーしておきます。全部は要らない気もしますが、とりあえず貼っておきます。`import SwiftSyntax`、`import SwiftSyntaxMacros`、`import SwiftCompilerPlugin` ですね。ほかにゴミのようなものもありますが、必要かどうかは後で整理します。`main`、`LandmarksMacros`、`Plugin` は必要なので、ファイルを作っておきましょう。まず `LandmarksMacros`（や `LandmarksMacrosPlugin` のような）ファイルを作って、この中でメインを定義します。`LandmarksMacros` の中でこう書いておいて……プラグインですね。余計なものは除外したい性分なので、`SwiftCompilerPlugin` は外して、こちら側に入れれば解決するはず、という考えです。

まずはマクロです。インポートは `SwiftSyntaxMacros` あたりでしょうか。`Stringify` は使わず、このプロジェクトでは `UserInfoAccessor` を使えばよさそうです。`UserInfoAccessor` の定義側のビルドはまだ書いていないと思いますが、マクロ化の可能性もあるので、いったんこれで良さそうです。ビルドしてみましたが、やはり成功しませんでした。エラーは、`SwiftCompilerPlugin` のサーチパス関連で失敗しているように見えます。`LandmarksMacros` を読み込もうとして失敗している感じです。

コード自体はそこまで悪くないと思うのですが、`SwiftSyntax` や `SwiftDriver` などの依存関係、あるいはサーチパスの設定が怪しいです。Xcode がアップデート時に自動生成したファイルや設定が影響しているのではないかという気もしますが、はっきりとはわかりません。まあ、もう少し調べてみます。 とりあえず、ゆっくり見ていきましょう。このために、まずは純粋にマクロだけをビルドしてみたのですが、ビルドは失敗しました。問題になっているのは、`LandmarksMacros` の場合ですね。

この中で、サーチパスがモジュールの依存関係を解決できず、`SwiftCompilerPlugin` などが解決できなかった、という状況になっています。`SwiftSyntax` も `SwiftSyntaxBuilder` も `SwiftSyntaxMacros` も、関連するモジュールが一通り見つからない、ということのようです。もちろん、モジュールが見つからないのはかなりまずいです。

`SwiftCompilerPlugin` をここに追加するのかな……どこに入れるべきでしょうか。`SwiftCompilerPlugin` はメインのマクロ実装側（`LandmarksMacros`）に入れる想定です。`LandmarksMacros` の中を確認すると、こういう指定はすでに入っていました。今見ていたのがそれなので、ここは大丈夫そうです。`SwiftSyntax` も依存関係にちゃんと入っています。

ターゲットはマクロで、これだけでいけそうに見えます。`LandmarksMacros` ではなく、使用側のターゲットも見てみます。依存関係として `LandmarksMacros` を参照しています。問題はこのあたりでしょうか。

下のほうにアクセッサー、いわゆる `userInfo` アクセッサーがあります。これを変更してみましたが、それでもビルドが通らない理由がわかりません。もっとサクサクできると思っていたのですが、クリーンしても直る類の問題ではなさそうです。

マクロ側のターゲットを見ても、やはりこの部分が怪しいです。Swift モジュールの `LandmarksMacros` で、Swift のサーチパスに関するエラーが出ています。モジュール依存関係を解決できず、`SwiftCompilerPlugin` が見つからない、といったサーチパスのエラーです。ビルド時に必要なモジュールが見つからなかった、ということですね。

依存関係の設定か、ビルドプラットフォームの違いが原因かもしれませんが、はっきりしません。どの環境でもビルドできないというのは、なかなかきついですね。これはどうしたものでしょうか。`LandmarksMacros` と `SwiftSyntaxMacros` は必要でしたよね。

ビルドが通らず、エラーが5つ出ていて、どれも同じようにパスが見つからないという内容です。原因をちょっと GPT にでも聞いてみますか。

`Swift` のマクロを使ったターゲット（フレームワーク）と、マクロを提供するターゲットを用意しました。いわば最小構成を作っています。ただし、これをコンパイルすると、次のエラーが発生します。 そんなふうにして、報告を貼って分けておきます。あと、Xcode との連携もしておきますか。こんな感じで設定して、これで効いてうまくいくかどうか。いや、今すぐ確認しないと嫌ですよね。今、確認しないとできなくなっているのかな。そんなに難しくはなかったはずなんですけどね。やってみたのはだいぶ前ですけど。

もちろん、`import SwiftSyntax` の解決に失敗して、Builder が見つからないと言われることもあります。`SwiftSyntax` が不足している可能性があります。`5.9` と `6` の違い、あとはツールチェーン周りですね。この辺はそんなに問題にはなっていなさそうですけど。

バージョン `6` 系のパッケージの dependencies で、product に対して付けてあげて、プラットフォームのバージョンなどに気をつけましょう、という感じですかね。ツールチェーンに応じて厳密にバージョン指定するのが困難である、と。なるほど、こういう感じですね。

そういったところを考慮して設定するとなると、まずパッケージです。Swift のモジュールとして、プラットフォームはこの辺は `10.15`。Xcode の今って何番でしょうね。`26` って何、という感じですよね。`10.15`、あとは Xcode か OS ですね。OS も結局 `26` ってなるわけですけど、この Mac は `26` ですよね。バージョンがわからない。まあいいか。

それで、dependencies で `SwiftSyntax` ですよね。`6.0.2`、今は `6.2` ですよね。こうするとどうなるんでしょうね、ビルド。これも関係ないですよね。コンパイラーのパスですもんね、`6.2`。だから、`6.0.2` でリンクがわからないと怒らせておいて、それで `Macros` でマクロとプラグインがあって。

それで、マクロはライブラリとマクロに分けていて、`LandmarksMacro` は `LandmarksMacroMacros` に分かれる。あとは、これとか。`LandmarksMacro` と `Macros` がライブラリとしてありますね。で、`Macros` は、これで `SwiftSyntaxMacros` がプラグインしていますよね。

そうか。できているのにうまくコンパイルができていない。これは困りましたね。`LandmarksMacro` モジュールがない。これはさっきの話でした。まあいいとして。これで `LandmarksMacro`、`LandmarksMacro` プロジェクトから、ここでパスが解決できない。Swift コンパイラー。マクロの中でプラグインですよね。`LandmarksMacro` の中でプラグインは書いていないですね。どこの `import` がおかしいのかな。`Macros` しか書いてないですね。これは困りましたね。どうしようかな。モジュールが見つからない。モジュールが見つからないというと、大したことはやっていないんだけどな。`SwiftCompilerPluginSupport` とかを書きました。 というのはありますけど、これはないとビルドをかけたときに変わらないか……。ちょっと戻しておきますね。Swift マクロでしょ。これでマクロでしょ。ユーザー側のアクセサーとしてこの3つでしょ。で、`Macros` でこの2つ。で、これがリストで、うん。で、ビルドが通らないと。

モジュールの依存関係、Swift コンパイラープラグイン……これをネットで調べてみますかね。AI はどうしたんだっけ？依存関係とか。そうですね、これは調べたからいいはずなんですが、どうしよう？どうしよう？

Xcode 10 がプラグインを見つけられない？嫌な経験談の方が出てきましたが、ここは Pods？ここは Pods で同じエラーが出ている。そして `Only Active Architecture = Yes`。で、Xcode 10、プロジェクトの Swift Package 依存関係。この人はとても質問者じゃないね。この人が同じ問題が起こっているって言ってる人がいて、「それで同じ問題がありますよ」と言っていて、Xcode 16、エラーですけど、Xcode 16 で、これでローカル Swift Package。このエラーのみビルドで、パッケージのひとつがワーニング。手動の依存関係。それで良い方法がない。手動で Foundation Pods を導入する……。

というわけで、Target の Dependencies。で、Missing Module がこの辺は……このページは無いか。これで Missing、もちろん Known path found が出てあって、Dependency を追加しないといけないとか、いろいろ言われているけど、これは難しいですね。

とにかくやりたいこと。Swift のプロジェクト。`LandmarksMacro`、`Macros` で、これが見つからないですよね。やったと思うんですよね。`Landmarks` パッケージですね。パッケージの中で、`LandmarksMacros`。これはリトーン関係が書いてありますよね。今調べたのがコンパイラープラグインの話ですよね。`SwiftSyntax` の中に入っている。`SwiftSyntax` は、あれですよね。おかしいな。

これで、あと考えられるのは `LandmarksMacro` ですね。今見ているのはね。ここにリトーン関係をちょっと1個書いてみますが、そんなことをやっても変わらないんだろうと思うんですよ。ビルドをかけて、これでエラーが6個になった。6個になったというのは、もしかすると増えた。でも4個はここだったね。4個で、あとはこれか。パッケージ。それとコンパイラープラグインが `LandmarksMacro`。

`LandmarksMacro` のターゲットで必要で、`LandmarksMacros` が見つからない？`LandmarksMacros`。あ、結果ですよね。今追加したのがここですよね。`LandmarksMacros` ですよね。ここで、見つからなかったということで解消しましたけど。

`LandmarksMacros` で、`LandmarksMacros` は `SwiftSyntax` と `Swift Compiler Plugin` に依存しているって書いてあるんですけどね。ライブラリがターゲットでしょ？それで、パッケージが `SwiftSyntax` でしょう。で、`LandmarksMacros` がこの2つに依存しているでしょう。で、ターゲット `LandmarksMacro` が `LandmarksMacros` に依存するでしょう。`ExecutableTarget` は `LandmarksMacroClient` で `LandmarksMacro` に依存するでしょう。合ってると思うんですよね。あれ、これはプライベートヘッダーの関係なんですね。あとは、うん。

遊びでマクロに手を出したら、なんか微妙にタイミングを見ているような気がしないでもないですが、これは何だろうな。10.15 とかこの辺かな。`LandmarksMacro` じゃなくてアプリ自体をちょっと見ていくと、ここの一番上にあるのかな。iOS 16 ですよね。16 だと思うけど、バージョンいくつでしょうね。10.15 というやつ。10.15 は一番新しいのかな。バージョン、16 ありますね。16 に限定しちゃってみましょうか。tvOS は要らないですね。watchOS も 16 で……プラットフォームリストのほうがいいかな。iOS でも動かない iOS アプリね。まあいいや、なし。まあいいか、16 にしておきますか。

これでビルドをかけてみて、これもビルド失敗ですね。一緒か。`LandmarksMacro`、ここですね。これの中のビルドの一緒ですね。結局ね、起こっているところは `LandmarksMacro` の中ですね。

`Swift Compiler Plugin can’t be found via the Search Paths that were specified when building the module.` `LandmarksMacros` をビルドしているときに特定されたサーチパスで探すことができない、と。つまり、このサーチパスが足りないということですかね。`LandmarksMacros` のサーチパス。`Library/Developer/.../DerivedData` のビルド作業の場所ですかね。それで、この辺がモジュール。`arm64` ですね。`arm64` のやつ。`arm64` です。

`Search Paths` が設定されていない。親のコンパイルでサーチパスが指定されていないということになりますね。だから、そうすると、Swift コンパイラ、Swift Package、Swift Package Manager のサーチパス。これの指定の仕方を調べれば、もしかすると何か出てくるかもしれない。サーチパスが減ったサーチパス。何かサーチパスを見ますが、これが分かれるところは、C++ か、Swift のフレームワークのサーチパスですね。`FRAMEWORK_SEARCH_PATHS`、パッケージの Swift。ここで追加する方法としては、コンパイルフラグかな？本当かな？リンカー設定。確かにリンカーですね。ターゲットに対してリンカーを設定する。その辺まで軽くやってみました。 これでパッケージファイルの中で、プロダクトのライブラリ、Swift のマクロですよね。リンカーはここではないか…ターゲットの中かな？ ターゲットのマクロではなくて、マクロかな？ `target`、`macro`、`name`、`dependencies`。あとはリンカー。リンカーはないか。ここじゃないですね。ターゲット、こっちかな。

これで、例えば `name` と `dependencies` の後ろあたりに…カンマが要りますね、カンマ。`linkerSettings`。この中で `linkedFramework`、パスはここには入らないか。`linkedFramework`、または `linkedFramework` と…ここに書いてみましょうか。`swift-compiler-plugin`。

ビルドを走らせたときに、エラーは5個のまま変わっていなさそうですね。エラーの内容も多分変わっていないのでしょう。変わっていないですね。パスは入れるけど、`Package.swift` は読んでますよね。そうですよね。

これがなんか気になりますね。今、Swift の言語バージョンはいくつなんだろう。Xcode のセッティング、ツールチェーンだ。Xcode のツールチェーン。これで、Xcode 16 ですね。Xcode 16 の Swift バージョンは 6.2 だったと思うんですけど、また、SwiftSyntax を見に行ってみました。SwiftSyntax を GitHub で見て、新しいタグは何が出ているか。6.0.2 ですね。6.0.2 か。6.0.3 がプレリリース。6.0.2 は何用なんだろう。さっきの情報を見ると、6.0.2 って Swift 6.0.2 用なのかなと思うんですけど、こういう話じゃないのかな。6.0、6.0.3、6.0.2、6.0.1、Swift 6.2.0 みたいなのがあるのかな。でも、そうすると 6.1 いくつもないですね。5.9 とか書いてありましたよね、さっき。5.10 リリース、5.10 みたいな。だから、これが気になっていて、仮にツールチェーンのバージョンに合う SwiftSyntax がまだ出ていないとかだったら、SwiftSyntax を使うのはすごくヤバいですよね。最終的にはね。だから、そこはさすがにないんじゃないかなと思っているんですけど、タグがいい感じのが見つかっていないなという。

6.2 development。6.2 の development じゃなくて…6.2 development は4時間前。6.2 の development が4時間前のスナップショットがそうなのか。development スナップショット。バージョン・スペシフィックが言ってましたけど、これを main ブランチにしてみましょうか。それも怖いかな。main ブランチでマクロ、Swift マクロの `from`、これが 6.0.2 です、とか。これで今やっているけど、これを1個コピーしておいて、`from` じゃなくて `branch`。`branch: "main"` にしてあげると、6.0.2 が main になりましたね。

で、ビルドをかけてみたときに、これで通るのかな。どうでしょうね。今のところ進んでいて、まだ最後のほうにエラーがあるので、まだわからないですが、これで通れば…あ、通らなかった。でもエラーが2個になりましたね。2個のエラーは何だろう。ビルドのマクロ、これですね。この2個のビルドエラーは…えーと、なんかすごい長いエラーが出てる。モジュール `SwiftSyntax` が見つからない、みたいな。とにかく別のを見つからない。新しすぎた感がありますね、これね。そうですね。これはダメで、予想すると、やることとしてはパッケージを…あと何で指定できるんでしたっけ。ブランチじゃなくて `exact`、`revision`。`revision` ってなんだ。`revision`。ブランチ、`exact`、`from`、`revision`。`revision` は、パッケージマネージャーで使うコミットハッシュですね。`revision` は今のところのコミットハッシュです。ここだけ見てますけど、これでいいかな。

そしたら、もう一回、Swift マクロの定義…定義じゃないや、Swift マクロのコンパイラのほうを見て、タグ。タグの中で、development スナップショットではなくて、リリース系ですね。でも、なんで 6.2 なんだ。今、6.2 じゃないのかな。development スナップショットではなく、スナップショットのプレリリース。6.0.3 プレリリースのほかは development スナップショットか。6.0.2 がさっきダメだったやつですね。あとは 6.0.3 プレリリースか。これをちょっともう一回やってみたい気もしなくもない。ブランチは何なんだろう。コミットハッシュでいいや。コミットハッシュをコピー。リンクじゃない。コミットハッシュは、これを押せばいいんだな。これを押したときのコミットハッシュ、これですね。コミットハッシュを取って、それで `revision` のところにコミットハッシュを入れてあげれば、たぶん大丈夫。やったときに、ここのね、`revision` が入ればいいわけですよね。あ、ありましたね。

どうなんだろう。プレリリースか。プレリリースといっても、Xcode というか、macOS 向けのアプリって、もう正式リリースなわけじゃないですか。ビルドが結局ダメか。えっと、じゃあ、自分の的が外れている可能性もありますからね、これはね。で、エラーが上のほうで…この辺。さっきと変わってなさそうですね。`SwiftShims` というものがないと。まあ、そんなことを言われちゃうという状況か。アプローチをいろいろ試そうと思ったために、全然進んでいない。これは `revision`。うん。もう一回、ちょっと `revision` 指定で、プレリリースじゃない版、これを出してみますかね。これですよね。これが…いやでも、そんなことですよね。基本変わらないと思うんですけど。6.0.2、6.0.2.0 か。これの…えっと、これだ。コミットのハッシュ。これを取ってきて、それでここに入れてあげると。で、そうすると 4799 なんだな、みたいなのにここが変わる。で、変わったのでビルドをかけて。で、ビルドがかけ終わると、どうなるかなっていう、そういったところですけど。うん。これで、もうやっぱり終わらない。でも、エラーの数も変わりましたね。さっきのね。真っ黒でしょ。で、それで同じでしょ。つまり…そうですよね。だからなんか、よくわからないことが起きている。 これはそのまま取っておいて、6.0.0のリリース…6.0.2になりますね。6.0.2の最新って何だろう、という感じです。ひとまずビルドをかけてみます。同じなら、一度クリーンしてからビルドをかけます。そうしたところ、エラーが5つに戻ったようです。ということは、さっきのもともとの状態と同じ5個のエラーだと思います。同じなので、どうなっているか見ていくと、これはこうなって…今度は2個のエラー。なるほど、マクロができなかったようです。これは困りましたね。どうしましょうか。スイフトマクロのサンプル、スイフトマクロがちゃんと動くかどうかをテストしたい、という状況なのですが、進みません。

ツールチェーンを6.0.0にしてみるとどうでしょう。v26がダメなのかな。こうすると、マクロでまた違うエラーになりますね。クリーンをかけてビルド…という流れで、どうなるか。できれば最新にしたいのですが、ツールチェーンをv26にしてしまったら動くのかな。ビルドは失敗でエラー2個です。こちらを最新に戻してクリーンをかけます。

それで、パッケージがちゃんと回ることを確認したいのですが、変わっていないですね。パッケージのアップデートで良いですかね。これで4,799…これはアップデートされているのでしょうか。いったんパッケージをクリーンしましょう。パッケージキャッシュをリセットします。こうしておくと、もう一度ビルドしたときにパッケージが取り込まれるはずです。これからやることとしては、ここでパッケージをリゾルブして、それによってパッケージが認識されるはずなのですが…あれ、されないかな。ビルドがパッケージを認識しなくなってしまいましたね。クリーンをかけても変わりません。これで、パッケージ（フレームワーク）はここまでしかありません。Landmarks のマクロのところでエラーが出ています。6.0.2の最新ではなかったのかな。6.0.2というタグがとりあえずあるのと、あとはリリースタグですね。上はリリースと6.0.2。latest なんて付いていないですね。6.0.2ですね。これ、機能制限かな。まあ良いでしょう。こうしてあげれば、これでパッケージが読み込まれるはずですが…読み込まれたのかな。出てこない気がします。

ファイルの「パッケージをアップデート（最新に更新）」を実行して、ビルドをかけます。やっぱり、見つからないものが出ていますね。Missing package product（Swift パッケージの Macros 関連）あたりです。この辺りは合っていると思うのですがね。リンク周りで何か設定を入れたんでしたっけ。リンカー設定か。ここでフラグを付けようと思っていたんだ。これでアプリ化して、何もオプションを付けない状態にして、ビルドをかけたいのですが…これもダメか。依存関係がこうなって…あ、読めなくなった。

あとは、ツールバージョン。これを変えましたよね。6.2とかにして、これで実行すると「パッケージをフェッチした」と出ます。そこから「パスがない」というエラーに戻った、というか、マクロができませんでした。うまくやりたかったのですがね。

まず、やる方法を調べて、ここで SwiftSyntax 系を取り込んで、それを依存関係として設定して、さらにパッケージの中で設定して取り込んでいく、という流れは合っています。ただ、フレームワークが取り込めないことにはどうにもならないので、そのあたりをまた少し見ていくことにしましょう。

そんな感じで、今日は全然進みませんでしたが、ここで終わりにしておきます。ありがとうございました。
