Transcription & Summarize : とりあえず読書会 SwiftUI Tutorials #8

はい、ではとりあえず紹介を始めていきましょうか。次はチュートリアルを拾っていきます。前回ですね、なんだっけな、うまく動かなかったやつ…そう、`@Bindable` だ。`@Bindable` プロパティラッパーを使ってもうまく動かなかったんですけど、そもそもそれを持ち出したのは、ふと思い出してチュートリアルの流れを少し無視して進めた、という経緯があったからなんですよね。最近はときどきそういうことがあります。そういった流れの中で、「`@Binding`、`@Bindable` ってあったよね」という話をしていろいろ試していたんですが、この話がちょうどバッジのチュートリアルの最後のほうに出ていました。出てはいたものの、その説明どおりにやってもうまくいかなかった、という結末になりました。

ちょっと悩ましいところですが、出てきた箇所を一応紹介しておきます。チュートリアルの最後、つまり一章「Handling User Input」の一番最後に出てきていました。`Binding` じゃない、`@Bindable`。チェックの前、つまり `body` プロパティ内でモデルデータに対して `@Bindable` ラッパーを使い、モデルデータを更新していく方法ですね。12行目あたりで、モデルデータというものを `@Bindable` で扱うと、`isFavorite` プロパティをドル記号の `$` を使って、バインディングとして扱える、という説明がありました。やり方自体は間違っていなかったと思うのですが、そのやり方で試すとうまくいかなかった、という話です。

結局のところ、検索して調べたところでは、自分で `Binding` を作ってあげて、ドル記号の `$` を使わずに書く方法でうまくいきました。つまり、別のアプローチに切り替えたら通った、ということですね。`Binding` をもう少し突き詰めていくと、今の自分のレベルでは手に負えない部分もあるので、また同じ問題にぶつかったときには改めて頑張る、ということにしておきます。

まずは、コメントアウトしているほうが本来のやり方に近いとは思うのですが、これだとなぜか `isFavorite` がうまく動いてくれなかったので、今回は下のほうの、つまり自分で `Binding` を作る方法で進めます。この先で何かあって新展開を迎えたときには直すかもしれませんが、今のところはそれで次の章へ行こう、という感じです。

次はこれですね。パスとシェイプを描く、つまり「Drawing Paths and Shapes」。このあたりの話に入っていくみたいです。ユーザーは、ランドマークのリストの中のランドマークを訪れたときにバッジを受け取る、という機能を作るらしいです。もちろん、ユーザーがバッジを受け取れるようにするのは、プログラマーである自分が作ることのひとつですよ、ということですね。今回はそれを作っていくわけですから当然です。

このチュートリアルでは、パスとシェイプを組み合わせてバッジを作り、その上に場所を表す別のシンボルをオーバーレイする、という流れになります。さらに、複数のバッジを異なる種類のランドマークごとに作りたいときには、シンボルのオーバーレイや繰り返し（repetition）の数、角度やスケールを変えて試してみましょう、という指示があります。いろいろ実験してみよう（Try experimenting）ということですね。

では、次のステップに進むために必要な素材をダウンロードしておきます。これは後で使うことになるでしょう。まずはセクション1に行ってみます。えーと、… まずは、描画（ドローイング）のために、バッジのビューに描画するデータを作成します。バッジを作るために、まず定義しておくべきデータがあります。基本的には、背景として使う六角形（ヘキサゴン）の形を描画します。そのためのデータを用意します。

具体的には、`Views` グループに新しい Swift ファイルを作成し、そこで `HexagonParameters` というものを作ります。この構造体で、六角形のシェイプを定義します。新しいファイルの中で `struct HexagonParameters` を定義し、その中に `Segment` という名前の構造体も定義します。

`Segment` 構造体では、3つのポイントを表現します。六角形の各辺について、直線で結ぶポイント（`line`）、次のポイントへ向かうカーブの終点（`curve`）、そしてカーブの形を調整する制御点（`control`）という3つです。これはベジェ曲線を使ったパスの一般的な考え方ですね。自分はこのあたりの図形系の表現にあまり詳しくないのですが、パスの常識として覚えておくと良さそうです。

このとき `CoreGraphics` をインポートして、ポイントの表現に `CGPoint` を使います。ここはちょっと面白い話があるのですが、それはこの説明を読み終わってからにしましょう。

各サイドは、以前の中点から始まり、直線で次のポイントへ移動し、その後コーナーのベジェ曲線を描いて次のポイントへ移動していく、という流れになります。制御点でカーブの形をコントロールします。まあ、これはベジェ曲線を使ったパスの一般的な作法だと思います。

ところで、タートルグラフィックスのドキュメントも少し見ました。タートルグラフィックスは、キャンバス上で「タートル」と呼ばれるカーソルを移動させて線を描く手法で、1967年に開発された教育向けの描画の仕組みです。画面上の点（タートル）を移動させ、その軌跡を線として描いていく、いわば一筆書きのような考え方ですね。交差しても問題はありません。細かい説明は省かれているようですが、雰囲気としてはそんな感じです。

では、実際に作っていきます。`HexagonParameters` を `Views` に作ると言っていましたが、`Views` グループの中に Swift ファイルとして `HexagonParameters` を作成し、これを `struct` で定義します。`struct` を書いて、その中にさらにパターン（パラメータ）を作っていく形です。パラメータの名前、なんでしたっけ。 セグメントを作っていく、という流れですね。`line`、`curve`、`control`という感じになっています。まずこの時点で気になるのは（まあどうでもいいのですが）、あえて置いておくとして、`HexagonParameters`です。自分は、`HexagonParameters`の中に新たに`Segment`というのを定義します。`HexagonParameters.Segment`、まあこれでいいでしょう。

では、`line`。ここで`CGPoint`を使ったと思うのですが、Swiftはちょっと面白い仕様がありまして、`CGPoint`と`Double`型は暗黙型変換をするという、Swiftにしては非常に珍しい仕様があります。その都合で、ここはまずは`Double`でいいですね。`curve`は`Double`、`control`も`Double`。上で定義予定でしたね。こんな感じでたぶん大丈夫。ダメだったらあとで直します。`line`、`curve`、`control`。で、`CGPoint`は暗黙型変換できる、という話でした。なので、今回はダメですね。つまり、`Core Graphics`を使わないとダメ。あ、`Core Graphics`の`CGPoint`。まあいいか。`Core Graphics`は、iOSとかmacOSの中で低レベルな描画をできるようにするためのAPIです。その中にポイント、つまり座標を表現する型が定義されているので、それを使うというお話ですね、今回はね。これで`Double`が…これでOKですね。

はい、じゃあ次。チュートリアルに戻って、セグメントを保持するために、`static let segments = ...`を定義します。それでロゴのデータを作っていくと。ああ、六角形だからね。これらの値は「fraction of a unit」、つまり単位に対する比率です。フラクションっていろいろ聞きますけど、浮動小数点数のときにもフラクションが出たりしますよね。ああ、「部分」ね。はいはい、全然違った。単位正方形における座標で、原点はアッパーレフト（左上）、X の正方向は右（to the right）、Y の正方向は下（down）です。ちょっと分かりづらいですが、そういう約束です。

このあたりは単位正方形の…これを手入力していくのは間違う恐れがあるので、今回はコピーしちゃいました。で、これは`HexagonParameters`に持たせるということなので、こちらですね。`extension`を使ってもいいですが、`Segment`と一緒にここに持たせるようにしましょうか。`Segment`はこうやって、セグメントをいっぱいあらかじめ定義する、という感じにしています。

このときに、ここをコピーし忘れたかな。ここですね。これで、なんか描画が気持ち悪い気がするな…ああ、そうね。ここですね。うん。

この中で考えるべきこととしては、`Segment`は`let`で、そしてこの中で`Segment`をイニシャライズして、`CGPoint`も`let`ですよね。 これはこれで成り立っていますが、もう少し厳密に言うと、このセグメント自体は明示的に絶対値も決め打ってしまって問題ないだろう、ということが型の様子からうかがえます。今回は `public` にするわけではないので書かなくてもよいとは思うのですが、せっかくなのできちんと書いておきます。決まりきっているところですからね。

それで、`adjustment` という、`Shape`、ヘキサゴンのエッジを調整するための値を作るらしいです。`static let` ですね。少し気になるところはありますが、`static let` でいきます。

ここはわざわざ書き換える必要もないのですが、さきほど言ったように、`Double` 型と `CGFloat` は暗黙の型変換が行われるという、Swift にしては珍しい仕様があるので、今回はそれを使うことにして、型推論で `Double` 型にしてしまいましょう。

そのうえで、次は `adjustment` を足したり引いたりしていきます。これはコピペが早いかもしれません。`adjustment` が影響、つまりカスタマイズ性を与えていくものになるらしいですね。直感的に「作りが悪そうだな」と感じるのですが、まだ分からないので、具体的に見えてき次第コードを直していきましょう。

次に、バッジのバックグラウンドを描画していきます。Graphics API と SwiftUI を使って、カスタムバッジシェイプを作っていきましょう。そのために、新しくファイルを作成して `BadgeBackground` というものを作っていきます。どこに作るのかは書かれていませんね。テンプレートでもフォルダが指定されていないので分かりませんが、ひとまずプロジェクト内の適切な場所に作ればよいでしょう。それを作ったとして、進めます。 まずは、バックグラウンドビューの中で、`body` で `Path` を作り、`fill` で塗りつぶすコードを書いていきます。`Path` の作成や `addLine(to:)` など、必要な API を使って、バッジのヘキサゴン背景のような複雑なシェイプを描いていくイメージです。ここでいろいろ作業していくことになるので、まずはその手前まで実装してみます。

この場所に `BadgeBackground` という `View` を作ります。カスタムビューとして、`BadgeBackground` の中で `Path` を組み立て、`fill` で塗りつぶします。`Path` では、最初にスタート地点を指定し、その後に線をつないでいきます。開始点の指定には `move(to:)` を使い、いわゆる「イマジナリーなペン（鉛筆）」を開始位置に置くイメージです。この時点では描画を開始するだけで、まだ線は引かれていません。ここはドキュメントのコードを参考にして、そのまま貼り付けてもよいと思います。

座標系については、ビューのジオメトリ（幅と高さ）を使ってスケールやオフセットを決め、開始点に `move(to:)` でカーソル（ペン）を移動します。とにかく、`var width` や `height` を取り出して、開始位置に移動させた、というところまで済ませます。

数値型については、`CGFloat` と `Double` が混在しがちですが、Swift では数値リテラルやイニシャライザで吸収されるので、ひとまず `Double` を使って試してみます。本来はデータサイズなどを考慮して `CGFloat` にそろえるのが最適だと思いますが、今回はあえて `Double` と `CGFloat` を混在させて、変換まわりをコンパイラに任せつつ手早く進めます。

続いて、`HexagonParameters` のセグメントを `forEach` で回し、それぞれの点データを使ってアウトラインを描画していきます。各ポイントに対して、`addLine(to:)` を呼んで1点ずつ線を引き、連続して呼び出すことで、直前のポイントから新しいポイントへと線をつなげていきます。ここもドキュメントのサンプルコードを写経しながら読むと理解が進みますが、少し時間はかかりますね。

まとめると、`move(to:)` で初期ポイントを指定し、その後はセグメントを `forEach` で回して、各セグメントのラインの `x`, `y` を使って `addLine(to:)` で順に線を引いていく、という流れで進めていきます。 とりあえず、これでどこまでいけますかね。心配ないですか？ 何の心配でしょう。ヘキサゴンは少し珍しい形なので、一般的には見慣れないのかもしれません。描画の話ですね。ここではコーナーのカーブの部分は一旦無視して進めて、後で順番に対応していくことにします。

「アカウント」という言葉が出てきましたが、ログインのときの「アカウント」ではなく、「考慮する（account for）」という意味のようです。つまり、後でその点を考慮していく、ということですね。

それから、`addQuadCurve` というメソッドを使って、コーナーにベジェカーブを設定していきます。その前に、一度描画して様子を見ましょう。前の問題をまだ見ていないので、実際どうなっているかを確認して、うまくいくか見届けていきます。今ビルド中なので、もうじき出てくると思います。その間にコピペ用のコードを用意しておきます。

`addLine` で回しているループの中で、ベジェカーブを作っていく、という形になるみたいですね。ではコピーして、次のところへ行く前に試してみます。おお、なかなかすごいですね。かなりひどい感じの図形になっています。角ばってノコギリの歯みたいになってしまっていますが、ここを1カ所いじったものに差し替えると、少しだけ良くなりました。これで大丈夫なのか、少し不安ではありますが。

とりあえずここまでできました。次は、`Path` を `GeometryReader` の中に入れて、バッジを含むビューのサイズに合わせていきます。これは SwiftUI の定石のようなもので、外側のサイズを見るときに `GeometryReader` を使う、というのはよく聞きますが、この認識で良さそうです。今はサイズを 100 にハードコーディングしているので、それを `GeometryReader` に置き換えます。

つまり、`GeometryReader` で `geometry` を取り、幅は `geometry` の幅、高さは `geometry` の高さとし、そのうち小さい方を使う、ということのようです。smallest of the geometry’s two dimensions、つまり2つの次元のうち最も小さい方を使います。これはバッジのアスペクト比を保って、バッジを持つビューの中にきちんと収まるようにするためですね。では、ここをやってみましょう。`Path` の外側に `GeometryReader { geometry in ... }` を置く形です。

ところで「ジオメトリ（geometry）」ってどういう意味でしょうか。幾何学、あるいは幾何情報という意味ですね。なるほど、かなり汎用的に使えるのですね。普段は幅を取るなどしか意識していませんが、`GeometryReader` ではセーフエリアやサイズ、`frame(in:)` なども取得できます。いろいろできそうです。まあ、細かいところは一旦置いておきましょう。 とりあえず `GeometryReader` を使って、まずはここで閉じてあげます。そうした上で、ジオメトリリーダーのサイズを取得して、この六角形の表示をアスペクトのサイズ感に合わせていきます。最小、ミニマムのジオメトリのサイズの幅とジオメトリサイズの高さ、こんな感じでしたっけ。Mac も大丈夫そうな気がします。

これで、とりあえず色を Red にしていこうか。ずっと同じ色でしたよね。気になっているんですけど、また後で調整していきますか。今ビルド中かな。うーん、どうなっているんだろう。今頑張っているのか、ビルドは成功しているでしょうか。成功していないかな。再ビルドしていないか。まあいいや、とにかく表示には載った。いびつなままではあるが、みたいな感じですね。

とにかく、幅はジオメトリサイズの `size.width`、高さは `size.height`。このあたりは自体は OK ということでいいですね。

次に、スケール、シェイプ、x 座標のシェイプのスケールです。これを `xスケール` と `xオフセット` を指定して、ジオメトリの中に出して、その感じで座標を整えていくイメージです。これは単純にプレビューかな。これですね、`xスケール` と `xオフセット`。これを `GeometryReader` のパスの中で定義して、それで x 座標のオフセットを出してあげて、全部に適用している感じかな。x に対しては出している感じで、`xスケール` はここでオフセットを出すのに使っている感じか。

だからこれでパスの中で、パスの中の幅と高さを用意して、それで x の中と、あとは x の座標と、あとはここら辺の x に足すやつと、ここもそうかな。これとここもそうかな。これぐらいですかね。これにパス、`xオフセット` かな。こういうふうに出してあげると……これで、なんかまだ微妙ですね。`xオフセット` とか引いてるね、これね。計算した後に、出している、出している、出している。あれ、全部出してるね。この時にプレビューはどうなっているのかな。まだそんな話になっていないコードに見えるか。`replace`、`solid black`、その前にこの座標ですよね。ここが気になる。`xオフセット` は x に対して全部出している。ここも出してますね。出してるね。幅と高さの最小値でしょ。なんか良さそうですけどね。なんか変な感じ。

とりあえず次として、`solid black` のところをグラデーションで、デザインにマッチしたグラデーションで表示します。そのためにグラデーションのためのコードがこれらを使っていくということになるので、とりあえずコピーします。`fill` をどこに指定しているのか。ジオメトリの次、パスですかね。そうですね、パスに対して `fill` していく。`fill(.black)` の丸カッコですね。つまり `fill(LinearGradient ...)` で——あれ、今選べるね。丸カッコじゃないですか。頭じゃないね。ここか。ここに丸カッコが必要か。コピーすると間違えた気がしますね。パスにつけるんだからいいのか。波カッコがいいのか分からないのかな。そんなことなさそうだ。丸カッコが 1 個必要で、それで波カッコが 1 個余計なのかな。違う、適当なこと言ってますね。

これでジオメトリ、というか `Path` があるでしょ。`Path` を閉じてみますか。`Path` を閉じて、パスに対して `fill` をして、`fill` のこの丸カッコは上の丸カッコで、さらにこの `fill` の丸カッコと違って、この波カッコは `GeometryReader` でしたね。`GeometryReader` であって、その後に `body` ですね。ここですね。ここに波カッコが 1 個コピーされてきたって感じ。もう 1 個が波カッコですね。これでいいですね。こうすると色が付くというのは間違いなくて、色はいいんですけどね。色はいいけど何かが違う。で、… とりあえずここをやっていきましょう。アスペクト比を1にして、`contentMode: .fit`にします（`.aspectRatio(1, contentMode: .fit)`）。これは`Path`かな。こっちは`Geometry`かな。`Geometry`に対して付けてあげると、この辺が真ん中にくる感じですね。これはちょっと予想外だった気がしますが、とりあえず中央に寄りました。

リサイズ時の挙動として、1対1のアスペクト比を保つために、`Path`は`position`がセンター、つまりビューの中央に留まるようにします。また、`ancestor`（祖先ビュー）の向き（縦横）がどうであっても、ちゃんと1対1を保ってくれるという話らしいです。ということは分かったので、この状態でアスペクト比を入れて…でも次に行くと全然ダメですね。何か間違っているんでしょう。これは目で見て確かめますか。

どうしようかな。この辺の数字がちょっと違うだけなんじゃないかなという気がするので、まるっとコピーしちゃおうかな。出力先が間違っているだけですよね、という期待を込めまして。ただ、全体から`BadgeBackground`全体をちゃんと上書きしていなかった気がします。

あー、できた。何が違った？ `Geometry`の作りが違った、みたいなどうでもいい話のほかに…どっちだ。もう一度見ていってみようかな。`Geometry`。ちょっと表示を近づけますね。表記を全部入れたい。全部は無理か。これで…あー分からないな。分からない。まあ、とにかく、どこかが正しかったということですかね。そうね。ということで、いいかなという感じです。

1個思い浮かぶとすると、ここを`CGFloat`をやめてみる。これで影響は出ないですよね。ここの`minimum`も別に影響は出ないですよね。で、`scale`とかもOKで、描画もOKで、いろいろOKですね。これでうまくいったということで、次に行くのかな。次は図形をいろいろ描いていくという話になるので、まずはここまでですね。

なんか無駄だなと思うところがあったので、`BadgeBackground`を調整していきましょう。まず幅が決まって、その高さが決まって、これはいいですね。`Geometry`のサイズから最小値。なので、これはいいんですけど、なんでここ、`width`を`var`にしてるんだろう。で、`let`って書き換えてるのか。あーなるほど。`xScale`を掛けても、これやり忘れてたかもしれないですね。やり忘れてたのはいいんですが、これは`scale`、`scale`は定数ですよね、これね。`width`はスケールを掛ける前に計算で使ってるのか。なるほどね。だから、後でまとめて上書きをするという手法を取ったということなのね。おそらくね。

なんとなく間違っていることは何にもないと思うんですけど、なんか気になりますね。なんだろう、`offset`があって、`offset`はこれでいいでしょ、これで。でも、そのまままずは`offset`で計算して。だから、この幅というのは、`width`にスケールを足すのか掛けるのか。全体の幅ですね、これね。だから、幅、幅。で、この`width`は全体で使ってますね。`scale`が使われているのは、そこともう一箇所だけですね。`scale`が決まって、`width`が決まると、幅、幅と、えーと、そうね。例えば、なんて言ったらいいんだろう、これは。

もう1個の幅というのは、x が 幅×実際の 0.95 とかいう幅だから、この幅は実際のところ…うーん、何になるだろう。ライン。ラインは、`HexagonParameters`の中で、x が 0.6 とか 0.05 とか 0 とかですね。y もそうかな。0 とか、0.05 からか。間違った、ラインの…あー、0 ありますね、とか。そうすると、うーん、なんか微妙だな。えーと、バッジの幅のように見えますかね、なんとなくね。 なので、ちょっと場所を変えてみます。全体の幅って何て言うんでしょうね、`clientWidth`かな。よく分かりませんが、これを`let`にして、例えば、ここをさっきの 8 なので、まあどこでもいいか。これを例えば一回、`badgeWidth`ね、`width`。あ、これにしてあげて、その上でこの`badgeWidth`を掛け算代入（`*=`）で`clientWidth`を掛ける、みたいなふうにして、最初は`clientWidth`にしておきます。これで`clientWidth`を同じにして、それで、バッジ…じゃない、クライアントの幅、つまり`clientWidth`というふうにやる、と。

もうちょっとできそうですね。ジオメトリーだから、ジオメトリーの中でパスを描くときに、これ、ジオメトリーって変わらなくないですか。ジオメトリーの幅とかは変わらないですよね。これ、外側に持っていても何の問題もないんじゃないのかな。通常そうですよね。何やってんだろう、これ。まあいいか、`let`という形にして、これで良さそうです。

もう少しまとめるなら、計算型プロパティにするのはどうでしょう。どうしようもないということはないけれど、結局どちらが良いかは分からない。`function`にするか、プロパティにするか。ジオメトリーに対してクライアント幅を取れるようにして、これを使っていく…。どれがいいかな。ここはもしかして`lazy var`…いや、そんなの使わなくていいですね。

そうすると、`geometry.size`の`width`と`height`でしょ。これを計算していくのに、まずは計算型プロパティでいきますか。`var client…`えーと、`bounds`…いや、その前に、`client…`ではなく、`canvas`。`canvas`でいいのかな。`canvas… size`、`size`でいいかな。ということで、`canvasSize`として`CGSize`を取得するようにします。

それで、幅、この辺を拝借して…`size`というより`length`でいい気がしますね。ジオメトリーの幅と高さから対象となる値を取って（ここでは正方形にしたいので一つの`length`にまとめる）、戻り値として`CGSize`の`width`と`height`をどちらも`length`にします。`length`って名前はちょっと微妙かな。まあ、こういうふうにしてあげると、これでクライアントのサイズ…いや、`clientSize`にしようかな。描画の展開サイズ…まあいいか、`canvasSize`でいいですかね。

この`canvasSize`を使って、この辺の計算ができてきます。`x`のオフセットは`canvasSize`の…と。正方形を想定しているなら、わざわざ`CGSize`にしなくても元の値ひとつで良い気はしますけど、今回は長さをちょっと変えたいことがある可能性もないとは言えないので、この形にしておきます。これでサイズを取っていけると。

ただ、このときに、これがしょっちゅう再計算されてしまうのが気になりますね。本当はキャッシュしたいところですが、まあいいか。うん、まあいいや。 とりあえず、そこまでの効率化はあまり考えなくてもいい気がします。まずは論理的に整理だけしておきます。キャンバスサイズの幅に `1 - xスケール` を掛けて、さらに `2` で割る、という形にします。ここでいろいろ気になる点はありますが、数値リテラルは型に応じて自動的に推論されていくので、普通は `1 - xスケール` を `2` で割れば大丈夫ですね。Rustらしく書くならこちらのほうが良いです。

これで、全体を `2` で割って `xオフセット` を計算します。あとは、バッチ幅はキャンバスサイズの幅に対して `xスケール` を掛けたものにすると良いです。こうしておくと、このあとはハイト（高さ）についても考える必要があります。なるほど、最終的にはバッチハイトも必要になる、という感じですね。

`CGPoint` は、`CGPoint` 同士の掛け算ができるんでしょうか。`CGPoint` の定義を少し見ますが、`struct` としか書いていないので、そこからはわからないですね。とりあえず、ここはこうかな、という感じで考えます。掛け算、掛け算……ということで、`batch_width` に係数を掛けて、それに加えて、幅に対してこの `adjust_point` を足している、という形です。`batch_width`、`width`、`height`……うーん、なんか思っていたのと違いますね。

`batch_width` と `batch_width`……確かに、別にこんなことをしなくても良さそうです。`CGSize` はよくわからなさすぎますかね、これは。なので、普通に少し書き換えていきましょう。

まずは、`client_width` を最小として、キャンバスを用意します。`canvas_width` と `canvas_height` を作り、これは普通にキャンバスの幅・高さそのものとします。そのうえで、`batch_width` は `canvas_width` にします。X と Y をまとめたい気もしたのですが、ちょっと欲張りだったかもしれません。なんとなく切り離せるものではない気もします。

オフセットをどう計算するかはそうとして、`batch_width` と `batch_height` は、基本的にそれぞれキャンバスの幅・高さと同じにする、という感じですね。ということで、`batch_height` もキャンバスの高さに合わせます。これで良さそうです。 とりあえず、ここは height もバッチリで、height を掛けて、セグメントラインは x と y にオフセットを足す形で処理しました。これで描画はできましたね。OK です。ただ、この辺の計算が少し気持ち悪いんですよね。本来はこの場所以外に影響しない計算に留めるのが良いのでしょうけど、例えば座標に対して x と y を掛けるなど、演算をもう少し美しく書きたいような気分があります。

というわけで、今回はいろいろ余計なことも試してみましょう。まずは演算の書き方から。これが正しいやり方かどうかは分からないのですが、`CGPoint` 同士の掛け算のようなことをやってよいのか、練習がてら考えてみます。まずは練習として、`let x = CGSize(...)`、`let y = CGSize(...)` のようにサイズを用意して、`let z = x + y` のような計算をしたときに、果たしてどう解釈されるのか、という話です。現状だと加算は定義されていない、という状況ですね。座標が2つあるので、サイズに対する演算もしたくなってきます。

今回の対象は `CGSize` です。こういう型に演算を定義するとき、特に加算・減算・掛け算をやりたくなりますが、`AdditiveArithmetic` は加算と減算だけを提供します。掛け算は誰が持っているかというと、`Numeric` が持っています（`BinaryInteger` も `Numeric` に適合しています）。ただし `CGSize` は `Numeric` ではないので、掛け算は自前で頑張るしかありません。別にプロトコルに頼らなくてもよいので、ここでいきなり演算子を定義してしまいましょう。

このサイズ同士の演算が体感的に妥当かどうか自信がないので、`private` にしておきます。そうすればこのファイルの外には出ませんし、「あくまでこの中で使う演算です」という主張も微妙にできます。たとえば、`extension CGSize` に次のように書きます。

- 加算: `static func + (lhs: CGSize, rhs: CGSize) -> CGSize { .init(width: lhs.width + rhs.width, height: lhs.height + rhs.height) }`
- 減算: `static func - (lhs: CGSize, rhs: CGSize) -> CGSize { .init(width: lhs.width - rhs.width, height: lhs.height - rhs.height) }`
- 掛け算: `static func * (lhs: CGSize, rhs: CGSize) -> CGSize { .init(width: lhs.width * rhs.width, height: lhs.height * rhs.height) }`

返す値は普通に `CGSize` の `width` と `height` をそれぞれ要素ごとに計算します。左辺と右辺の幅・高さを対応させるだけなので、書いてしまえば悪くはない気がします。こういったものは論理の話なので、うまくいかない場合もあるでしょうが、まずは実装してみます。

行列ではないので要素ごとの掛け算で良いだろう、という扱いです。これで加算ができるようになるので、できることが少し変わってきます。いまはここで加算していますが、`width` と `height` 周りはサイズで表現した方が都合が良くなってくるはずです。 バッチサイズは `CGSize` として扱います。経路を考慮した X 座標と、特に何も考えない Y 座標をこのように定義しておき、これでバッチができます。これを `move2` で使います。バッチサイズはイコール `CGSize`、`CGSize` は明らかな構造で、`width` と `height` の2つの値を持つ構造体です。つまり `CGFloat` を2つ取る構造体ですよね。

ここで、普段はあまりやりませんが、今回はかけ算のほうをやってみます。`CGSize` に対して右辺をタプル（たとえば `CGPoint` のように `x` と `y` を持つもの）として受けられるようにして、演算子を定義します。右辺をラベル付きのタプル、つまり `(x: ..., y: ...)` のようにしておき、たとえば左辺のサイズと右辺のスケールを掛け合わせる、という意図です。コードとしては、`lhs`（左辺）と `rhs`（右辺）を取る演算子実装を用意して、`lhs.width` と `rhs.x`、`lhs.height` と `rhs.y` をそれぞれ掛ける、という形になります。

最初に `Int` を使おうと考えましたが、`CGSize` の `width` と `height` は `CGFloat` です。`Double` ではなく `CGFloat` を使うのが正しいので、ここは `CGFloat` にそろえます。`canvasWidth` なども `CGFloat` です。

次に、`CGSize(width: ..., height: ...)` の呼び出しでエラーになっていたのは、単にラベルを抜かしていたためでした。`width` と `height` のラベルを付ければ解決します。ここで `width` は `canvasWidth * xScale` のように書き、`height` は同様に計算します。ラベルが抜けていただけで大したことではありませんでした。

一方で、X は 0.95 のようにスケールを掛けたいとして、処理の順序が少しややこしいです。たとえば「こっちの `height` は掛ける前に出している」「こっちの `width` は先に掛けている」といった違いがあり、丸括弧の付け方も含めて少し複雑ですね。とりあえず `0.2` を掛ける、といった形で試します。まず掛けて、掛けた上でオフセットを `0` にする、というコードにします。これでパスのムーブがだいぶ良い感じ…のはずですが、実際に見るとあまり良く見えなくなってきました。

ビュー側のコードが崩れていなければイメージどおりのはずでしたが、まだ間違っていました。`x` と `y` で出しているところは、`CGSize` ではラベルが `width` と `height` なので、その対応を直します。ラベルを付けるのが煩わしく感じてきたので、右辺のタプルはラベルなしでもよいかもしれません。丸括弧の付け方を変えるとだいぶ挙動が変わりますね。いったん戻してみたら間違いに気づいたので、編集で修正します。`width` と `height` をきちんと合わせ、計算できるように直しました。

このように計算自体はできるのですが、呼び出し時にタプルのラベルを書く必要があって、ここがとても煩わしいです。たとえば右辺をラベル付きにしていると、呼び出しが `size * (x: ..., y: ...)` のようになり、毎回ラベルを書く必要があります。用途次第ではラベルなしのタプルにして、`size * (sx, sy)` のように位置引数で受けるほうが書きやすいかもしれません。 引数ラベルは省略したいなという気がしてきました。ただ、ここでラベルを省略すると許されないでしょう、きっと。たぶん変換できると思うんですけどね。とりあえず両方消してみましょう。こんな感じです。そうすると、xオフセットとパス……あ、そっか。これは足し算の演算子のオーバーロードがまだできていないからですね。

なので、この辺はコピーして普通に実装を追加してあげます。足し算の場合は普通に足し算……あれ、足し算、引き算……足し算が間違っている、危ない。こうですね。実行すると、この辺がいろいろパースされていって、あ、でもこの足し算はダメですね。`CGFloat` から `CGPoint` に変換、`CGSize` から `CGPoint` への変換ができなかった、と。xオフセットは……これは `Double` ですね。大丈夫です。うん。ちょっと型が出ないけど……あれ、もう一回。待って、わからない。

えーと、これは一回、足し算を省いてみますか。あ、そうすると足し算もダメですね。なるほど。そうすると、ここにラベルが要るという感じですかね。`width` と `height`。うん。まあでも、それもダメか。えーと、これで、`CGSize` から `CGPoint` に変換できない……`CGSize` から `CGPoint`? えーと、`badgeSize`。`badgeSize` は `CGSize` ですね。それで……とか、なんか、あ、違うな。自分がしているみたい。`CGSize` を返しているのが良さそうですけどね。えーと、レフトハンドとライトハンドで、`width`、`height` が `Double`、`Double`。うん、良さそうな気がします。

なので、一回この辺をコメントアウトして、この状態で。あ、`move(to:)` って違うね。`move(to:)` はポイントですね。`CGPoint` を取っていますね。だから、そうすると、`badgeSize` かけるなんたらかんたらを、`CGPoint` の `width` と `height` から計算しているのか。あー、なるほど。そうするといろいろと厄介なのかな。`badgeSize` というのがあって、`badgeSize` の幅と高さを元に計算していくのか。うん。

で、一般的にはこういったものですよ、と考えると、まずバッジの幅とこれと、オフセットとかやっているから……うん、なるほど。これは、いろいろ余計なことをしようとしましたが、シンプルなままが良い感じがしてきましたね。直していきますよ。戻していきますね。これで、どこまで行くの？ これで、まあ全然……あ、演算子を消していって、ここら辺だ。うん、そうですね。

で、`badgeWidth` と `badgeHeight` が `badgeSize` になっていて、`CGSize` で `width` と `height` ですね。これで良くて、`badgeSize` の、この辺の `badgeSize` が全体的に……えーと、`badgeSize` が全体的にバッジの幅、こうですかね。で、それで `badgeHeight` の方が、全体的に `badgeSize` から手に入れる高さですね。いいですね。うん、これで良いですね。

で、これで `badgeSize` とセグメントカーブと、場合によってはオフセット。うん、良いですね。そうね、これで良いか。おお、だな。はい、じゃあこれで良いとして、この辺が複雑すぎるので……いや、複雑すぎるは言いすぎかな。パスがあって、これで `fill` をしていますね。このパスをちょっと切り出してみましょうか。`body` ではなくて、例えばこの型で……うーん、例えば `struct` と。あ、バッジの中に作りたいですね。まずこのパスを丸ごと切り出しちゃって。そうすると UI はこうやって、インデントがね、深くなっちゃうのが気になるという場面が多いみたいですね。 `BadgeBackground` の中に `Path` を作って、`View` で返すようにします。`body` を定義する中で、この中に `Path` を作って返す、という流れです。さらに `Canvas` を使うので、その中でパスを作って返すようにします。

`Canvas` のサイズが必要ですね。`@State` でいいのかなと思っているのですが、`@State` が何に使われるのかはまだ完全には分かっていません。値が変わったら中身が再描画される、という話は分かるのですが、意外と理解が甘い気がします。とりあえず書き換え可能にしておけば良さそうです。

変数名は、たとえばビューのサイズを取って `canvasWidth` とし、同様に `canvasHeight` も用意します。`Canvas` 自体は `Canvas` のままで良さそうなので、わざわざ「サイズ」と付けなくても良いでしょう。つまり、`canvasWidth` と `canvasHeight` を使って値を取得します。地味に名前を直してそろえておきます。

ここでビルド時に使う名称は、正方形の「辺の長さ」を表すものにします。英語では「side length」と言うので、`sideLength` で良さそうですね。正方形は英語だと square なので、厳密に言うと `squareSideLength` のようになりそうですが、そこまではこだわらなくても良いと思います。

`fill` がどちら側にあるかを確認していて、`LinearGradient` が使えるのかどうかを見ています。`Path` に対してそのままではダメな場合でも、`Path` の中に入れてしまえば済むので、その方針でいきます。コードのこのあたりは、さくっとカットして整理します。丸括弧の対応が微妙に崩れていたので直します。ここが `fill` の全体ですね。この `fill` は `Path` が持っているようです。

そのため、`エクイサーコンパス` はこれにして、`エクイサーコンパス` の中で最後に色を付けてあげます。ここですね。`gradientStart` と `gradientEnd` の2つは、今回の変更により `エクイサーコンパス` が持つことになりました。 これで描画ができるんでしょうか。おそらく、そうだと思います。今ちょうど描画中なので、この間に少し見直しておきたい点を確認します。できましたね。いろいろ気になるところがあるのですが、まず相変わらずネストが深いですね。

パスとして扱うにしても、このパスは、ええと、パスで初期化していて、グラデーションはバックグラウンドでよいだろうというのが一つあります。あとは、キャンバスの幅からオフセットを計算するときに、別にパスに移動しているわけではないですよね。`badgeSize` も同様です。なのに、これらがなぜかパスの中にあるのが気になるので、外に動かします。これでも描画は大丈夫ですよね。

そうすると、キャンバスのオフセットはあちこちで使うのでそのままで良いとして、`badgeSize` は `scale` を使って計算します。`scale` と `badgeSize`、オフセットはここでは使わないので、順番を入れ替えても大丈夫ということですよね。だいたいその整理で合っていそうです。

ここで気になっているのは、サイズをパスの中に持つべきかどうかです。`badgeSize` は、バッジパスやヘクサゴンのパラメータ（おそらく `HexagonParameters`）にとっては、インスタンスのプロパティというよりはボディの中だけで使えばよいものだと思います。`scale` も含めてここにまとめましょう。描画上で必要なだけですしね。

これでパスが書かれていて、パスに対して `move` などを行い、セグメントに対して `for-in` で処理しています。セグメントを取って、あれこれやっている部分も、このままでよさそうです。今は特定の箇所にしか意識が向いていないので、余計な調整が入りがちな可能性はありますが、ひとまずここまでで。

例えば、`HexagonParameters` の中、もしくは `BadgeBackground` に対する `private extension` の中に、この辺の実装を作りましょう。`private extension BadgeBackground` で、`HexagonParameters` を使いつつ、アクションとして `makePath` を実装します。これで受け取るのは `Path` です。コードを書けば分かりますが、`makePath` で `Path` を受け取る形にします。

`Path` のイニシャライザをよく見ると、クロージャでパスを受け取って、組み立てたものを返す、というインターフェースになっています。そういうコールバック的な使い方をするので、名前は `makePath` のように、「パスを作る」ことが分かるものを付けるのがよいですね。先ほどは「コールバック」と言っていましたが、`pathMaker` のような名前は少し雑に聞こえるので、もう少し自然な命名にしたいところです。まあ、その辺は追って調整します。 とりあえずこんな感じにして、その中でパスとバッジサイズ、そして `CGSize` を受け取る形にします。別の情報はオフセットですが、バッジサイズとオフセットはインスタンス変数にないので、このようにしないといけないのですね。つまり、ヘキサゴンのパス（ヘキサゴンパス）に対して、バッジサイズはこのサイズをインスタンスの計算型プロパティから得る、という方針にします。`CGSize` についても同様です。これは計算型プロパティにします。`lazy var` という選択肢もありますが、`lazy var` はむやみに使うものではないので、ここは普通に計算型プロパティでよいでしょう。もし気になるところがあれば、必要に応じてキャッシュする方針にします。

次に `xOffset` ですが、これも同様に計算型プロパティにします。スコープは `private` とし、型は `Double` にします。`xOffset` はそのまま値を返す実装で構いません。

名前付けも少し見直します。`xScale` のようにスケール係数があり、パスがある、という前提ですね。ここまでくると、外部から渡すべき引数、例えばバッジサイズのようなものをわざわざ渡さなくても、インスタンスでちゃんと管理できています。関数名も `pathMaker` はあまりよくないので、生成処理であることが分かるように `makePath` にしましょう。パスをムーブして書いていくので、`makePath` が自然です。ということで、ひとまず `makePath` に統一します。

実装では、`move(to:)` で指定ポイントに移動し、座標を計算します。バッジサイズに係数を掛け、そこに `xOffset` を足す、といった形ですね。たとえば、プライベートなヘルパーで `makePoint(xCoef:yCoef:)` のように係数を受け取り `CGPoint` を返す、というアイデアもあります。引数の `x` と `y` は `CGFloat`（あるいは内部では `Double`）で受けて、各計算に `xOffset` を加える、という形です。ただ、この方法は、たまたま今回の実装に一致しているだけで、汎用性や見通しの面でよくない気がするので、今回は採用しないことにします。

もう1つ気になるのは、スタティック変数をやたらと使っているところです。基本的に悪くはないのですが、例えばヘキサゴンのグラデーションはその型の中でしか使っていないので、スタティックメンバーをその中に閉じ込めてしまってよいと思います。`static let gradient` のように定義し、`colors` はカラーの配列で管理します。スタートからエンドまでなので、`startPoint` と `endPoint` を `UnitPoint` で持たせ、`LinearGradient(gradient:startPoint:endPoint:)` に渡します。カラーの配列は `colors = [...]` として、必要ならカラーリテラルで与えても大丈夫です。

実装中に丸括弧が足りずにエラーになっていましたが、丸括弧を正しく補えばコンパイルエラーは解消します。ビルドして動かすと、描画は問題なくいけますね。こちらの方が煩わしくならないので、余計なことを気にせずに済みます。

最後に、線形グラデーションは `LinearGradient` に `gradient` と `startPoint`、`endPoint` を渡すだけです。`UnitPoint` を使ってポイントを指定すれば十分です。これでひととおり良さそうですね。 とりあえず、ここのパスが個人的に気になりますが、この程度のグラデーションなら問題ないですね。パターンによってはグラデーションカラーが変化する可能性もゼロではないので、その点は気になります。今回は別に良いのですが、そこまで `static` 変数にこだわらなくても良いのではないかとも思います。インスタンスを作りすぎるとパフォーマンスに影響するかもしれませんが、`static` なら色さえ変わらなければ問題ありません。その辺は少し悩ましいところです。

それよりも、`ヘキサゴンパラメータ` が非常に気になっています。これは何者なのでしょうね。別のウィンドウに出したいのですが、Navigate > Open In で…あ、これでいいですね。これはそれとして、この `ヘキサゴンパラメータ` は構造体で作っているので、中身はすべて構造体です。`Segment` があって、パラメータも活用していますが、全部 `static` になっているのが気になります。本当にそこまでの必要があるのか、という感じです。

例えば `HexagonParameters` の `adjustment`、`HexagonParameter` と `HexagonParameters` のあたりですね。ここはインスタンス変数で良いのではないでしょうか。`HexagonParameter`（あるいは `HexagonParameters`）の背景として `HexagonPath` を拡張し、その `Path` を拡張する形にして、この `ヘキサゴンパラメータ` を紐付けます。そのうえで、最後に `Path` の `Segment` がありますよね。`Path` の `adjustment` もあります。`adjustment` は数値で、`Segment` があって、つまり `Parameter` がある、という関係になります。

こうすると、`HexagonPath` に対して `Segment` と `Parameter` を持たせる構成にできます。`Parameter` の中身は `Sendable` で良さそうなので `Sendable` にしておき、これまで `static` で用意してあった値をその `Parameter` の中に2つ持たせます。コードが狭いので一気に広げますが、これらは `let` で良いかな、という印象です。`adjustment` と `segment` をそんな感じで定義します。`parameter` は、ここでは `adjustment` が引数になっていないので、イニシャライザで受け取る形ですね。

つまり `struct Parameter` を作り、`let` か `var` を選びます。`adjustment` は `let`、`segment` も `let`。`adjustment` から生成される値であることを踏まえると、ここは計算型プロパティにできます。なので `var` の計算プロパティとして `segment` を用意して、中身を実装します。

こんな感じで `adjustment = ...` として、配列は `var` にします。`segment` はここではなく、背景側の `HexagonPath.Segment` になります。名前が少し長いので、`typealias Segment = HexagonPath.Segment` としておくと良いでしょう。これで `Segment` は `HexagonPath.Segment` の別名になります。

そうすると、計算型プロパティで計算するようにしたので、`adjustment` が変われば計算結果も自動的に変わります。その前提なら、`adjustment` は `var` で表現できますよね。これで `Parameter` ができました。 という状況を作ったうえで、この状況ではバックグラウンドがここに戻ってきます。パラメーターを誰が持つのかという点については、ここでバックグラウンドのヘキサゴンのパスをプロパティとして用意し、そこにパラメーターを持たせる形にします。イニシャライザを作り忘れていないか確認しておきましょう。どこへ行ったか追いかけつつ、ここから考えます。先ほど定義したものを使いますが、値のアジャストメントが少しありますね。ですので、これはイニシャライザで対応します。メンバーごとのイニシャライザ（memberwise initializer）でいけるはずなので、パラメーターは型推論でいきます。

今回はデフォルトのパラメーターを使って実現します、と書いておきます。大事なのはキャンバスです。ここは`var`でも`let`でもどちらでもいいのですが、今回は変更しないのでパラメーター固定という意味も込めて`let`にしましょう。さらに`private let`でこれを2つ持たせておけば大丈夫ですね。グラデーション側からはパラメーターの変化を掛けられますので、その前提で進めます。

とりあえずここまで書いたら、ヘキサゴンのパラメーター、つまりパラメーターのアジャストメントをこのようにして、これもパラメーターのセグメントを`ForEach`にしてあげます。これでプレビューを出しますが、これでもちゃんと動くはずです。きっと動きますね。

これとパラメーターアジャストについて、個人的に気になっていたのがこのひとつで、`ForEach`で何の問題もないのですが、好みの問題です。あと、この演算はもういらなくなったやつですね。これは消しておきます。

こうなって、あとはここ、改行がなかったような気がします。それで、ここはグラデーションから。グラデーション側もやはりパラメーターにしたほうが良さそうなので、先に持っていっておきますか。そうすると、スケールとかもパラメーターに流していけますね。全部持っていってしまいましょうか。 パラメータに対してアジャストメントとグラデーションのパラメータを `var` で持たせて、`XScale` も同様に `var` でよいのかな、という方針にしました。`XScale` は R ではなく `var` ですね。`SwiftUI` が必要なので `import SwiftUI` を入れます。これでパラメータは良さそうです。

さっきのコードの中では、パラメータから `xScale` を取り出して使えるようにします。例えば `private var xScale: Double = parameters.xScale` のようにしておくと、これで問題なく参照できます。グラデーションも同じ感じでよいのですが、たまに「パラメータがちゃんと生きていないのでは？」という気持ちになることがあって、わざわざプロキシをかませるのが面倒にも感じます。なので、いっそ全部パラメータに寄せてしまうのがわかりやすいだろう、という判断にしました。グラデーションも含めて、基本は「全部パラメータにある」と把握できるほうが意味が明確です。

この状態で一度評価してみると、いい感じに動きました。エラーもなくなりましたし、すっきりしたかどうかは主観もありますが、大きな問題はなさそうです。`xOffset` をキャンバスの半分にする、というあたりも良いですね。これはパラメータではなく決め打ちでよいので、このままで OK です。

次にループ部分ですが、最初は `forEach` を使っていました。ただ、個人的には `for-in` が好きで、特に今回のように関数の中で早期リターンをしたくなる可能性がある場合は、`forEach` だとクロージャからのリターンになってしまい、関数自体を抜けられません。一方、`for segment in parameters.segments` のような `for-in` であれば、`return` で関数から抜けられます。今回は `makePath` で早期リターンを使う場面はありませんが、関数スタイルやメソッドチェーンにしていないなら `for-in` で十分だろうということで、`for-in` に変えました。これでパスの描画も問題なく動きました。

このあたりで、キューブの座標を `x` と `y` で取っていて、さっき「以前作った `CGPoint` を計算する関数でまとめてもいいかな」と一瞬思ったのですが、たまたま形状が似ているだけで意味的には別物です。バッジサイズやセグメントのオフセットなどを無理にひとつにまとめようとすると、かえって重たくなります。なので、今回は無理に共通化しない判断にしました。

バックグラウンドについては、今回作っていたのは `BadgeBackground` です。`GeometryReader` でビューのサイズを取得し、その中で正方形を基準に計算するために「辺の長さ」を出すことにしました。変数名をどうするか少し迷いましたが、`length` だけだと何の長さかわかりにくいので、`squareSideLength` にします。これなら「正方形の辺の長さ」だと明確です。

さらに API デザインとして、キャンバスに関する引数名も見直しました。単に「キャンバス」とするより、`canvasSize` としてサイズを渡すほうが意味が合っています。`canvasSize` を計算して、それを基にヘキサゴンのパスを描く、という流れにしたほうがデザイン的に良いと感じます。結果として、`canvasSize` を受け取って `HexagonPath` を描く形にし、`BadgeBackground` ができました。全体としてスムーズに理解と実装が進んだと思います。

ヘキサゴンのパス自体は、パスに対してグラデーションを塗る処理をどこに置くか少し悩みました。バックグラウンド側で塗りたいのですが、先ほど「全部パラメータにまとめた」ことの影響で、少し取り回しにくいところが出ます。ただ、今回は「`BadgeBackground` は `HexagonPath`」という説明ができていれば十分と判断し、このままでいきます。ヘキサゴンパスは問題なく描けました。やりすぎ感がゼロとは言いませんが、チュートリアルの「ヘキサゴンパスを描く」ところまでは完了です。

時間的にも区切りが良いので、今日はここまでにします。次回はバッジのシンボルを描くところから進めていきましょう。今日はこれで終わりにします。ありがとうございました。
