Transcription & Summarize : とりあえず読書会 SwiftUI Tutorials #42

はい、では、とりあえず読書会を始めていきましょう。とりあえず読み終わったわけですが、リファクタリングをしていこうという中で、せっかくならいろんなことを試してみたいなと。より良くなる方向を一応は目指していますが、その中で、お試しでここでRustのマクロを使ってみようか、みたいなことをやり始めたところ、なぜかコンパイルができないままで終わってしまったのが前回でした。そのあたりの原因究明ですね。 とりあえず何も見つけていない状態なので、ここからは手当たり次第に様子を見ていこうと思います。見つかれば、原因究明の良い進め方として紹介できるのですが、見つからない恐れもあります。そういったときは少し不毛な回になるかもしれません。ただ、プログラミングはそういうものでもありますので、同じ方針でやっていくことにします。

ということで、さっそく見ていきます。ここからコードを確認しますが、`SwiftSyntax` を開けていませんでした。ディスプレイの配置がずれていて、メインとプライマリとサブのディスプレイが逆になっているように見えますが、そこは気にせず進めます。マクロを書こうとしたのですが、うまくいきませんでした。何がダメだったかというと、フレームワークが見つからない、といった類の問題です。

もう一度ビルドして様子を見ます。本当は最初からちゃんと動画を見ればよかったのですが、今さらですね。エラーはこれです。“Unable to find a module, a module dependency …”。`LandmarksMacros` が import されていない、という感じの問題に見えます。よく考えると、`macros` を import しないといけないのかどうか悩みますが、まずは一番軽量なサンプルで試してみます。

新しくプロジェクトを1つ作ります。macOS 向けで「TestMacros」という名前にして、ドキュメントフォルダに作成します。Swift Macro のテンプレートで作れば、`SwiftSyntax` がパッケージ依存として入り、`MyMacro` がモジュールとして追加されます。パッケージとしての設定もその辺は自動で整うので良いですね。

`MyMacro` の定義では特に import はしていません。自分が触っているのは具体的には `LandmarksMacros` ですが、ここでも `LandmarksMacros` を import していませんでした。以前はこれでビルドがダメだったはずなのですが、今回はビルドが通って、「ユーザーインフォーアクセサが見つからない」という状況になったように見えます。`LandmarksMacros` のビルドが失敗していそうにも見えるので、まずはマクロだけ、ビルド対象をクライアント側にしてビルドしてみます。

すると「`Stringify` がない」と言われます。そりゃそうです。加速のためにそれは抜いていたので、該当箇所を外します。改めてビルドをかけて、ターゲットは macOS にしておきます。するとビルドが通りました。前回は何が問題だったのか…結局、import を間違えていただけだったようです。うまくいくならありがたいです。

ただし、実装はまだ作っていません。まずはセットアップだけ、マクロ用パッケージ側で進めます。やりたいことは、今 `Notification Content` を仕様に沿って整理しているのですが、その中で `userInfo` の扱いをマクロで楽にしたいという点です。頭の中だけで構造を組み立てるのは意外としんどく、ミスると厄介です。たとえば列挙型の中、コンテンツの `userInfo` の中の `aps` の中の `title` は `String` 型で…というような構造を、型で安全に表現できるようにしたいイメージです。

ここを見直すと、`userInfo` が `var` である必要はまったくないですね。ちゃんと動くようにするために、この「ユーザーインフォーアクセサ」、つまり `userInfoAccessor` の部分を作っていきます。作業は、まさにマクロを作るためのパッケージである `LandmarksMacros` の中、そのマクロクライアント側で進める形にします。

本来はマクロのテストを書いて進めるのが良いのですが、今回は省略します。まずは `extension` …と言いつつ、ここでは `final class` として、型に対して `userInfoAccessor` を持たせます。オプショナルにするかどうかで挙動を制御することもできますが、今回はそこまで汎用的なものを作るつもりはないので、最低限の形にします。

名前については少し悩みます。`userInfoAccessor` でもいいのですが、`userInfo` を別名（ディクショナリ、あるいはプロパティリスト…とまでは言いませんが）で表すか、もっと汎用的な名前にして、`userInfo` に対してプロパティ名を指定してアクセスする、という作りにもできます。プロダクション用に作るならもっと汎用的にしたくなりそうですが、今回は固定でいきます。たとえば `let userInfo: [String: Any]` のようにして、両方の側で同じ情報を持たせる形です。まずはこれくらいにしておきます。

この中でテストできるように情報を保持しておきたいので、本番環境に倣って用意しておきます。Landmarks の…何でしたっけ。 APSというのがあって、`aps`に対してディクショナリが用意され、その中に`alert`があります。`alert`はディクショナリで、`title`と`body`という文字列を持ちます。`title`はたとえば`testTitle`、`body`は`testMessage`という感じにします。これがまず`[String: Any]`ですよね。ここも`[String: Any]`で統一します。

`landmarkId`が`userInfo`直下にあるのがここですね。`userInfo`に`landmarkId`として、値は`String`型で、`"1001"`のような感じでしょうか。ほかの入力との定義のバランスが悪いので整えておきます。こうしておくと、`[String: Any]`が山ほど出てくるので`typealias`しておいたほうが良いと思いますが、今回はテスト、つまりマクロの動作確認のために入れているだけなので、とにかく本番環境の`userInfo`と同等のものを作ります。これからこの本番環境と同等のアクセサをマクロに任せて実装する、という方針です。

マクロへの任せ方はこういう形ですね。実際には`userInfo`は別のところから与えられていて、中身はもう一回も見ない、という想定に近いので、これはこれとしてこの中に入れておきます。ただ、この状態だと「わざわざそんなのをマクロでやる必要あるの？」みたいな感じになってしまいそうです。なので、むしろ内部の`enum`を外に出しますか。これで`AppUserInfo`ですね。これを外に出して、`extension UNNotificationContent`として、この中に実装していきます。

このとき、内部`enum`は外に公開するものではないので、`private enum`にします。その中身はこんな感じで用意して、これで基本コードができます。これを実装していくわけですが、その際にこの`userInfo`アクセサを生成するコードがどういう構造なのかを把握しておかないと、SwiftSyntaxを使ったアクセスが難しくなってきます。ここはしっかり見ていかないといけません。

そのときに、Swift AST Explorerという便利なサービスがあるので、これにアクセスして、さっきコピーしたコードを貼ると、右側に構造が表示されます。これを基にSwiftSyntaxでアクセスしていきます。まずは`CodeBlockItem`の中から、`userInfo`という列挙型を見つけていく、という感じですね。`MemberBlock`の中をたどって見つけていく、という形を取ります。

その際には、`SyntaxVisitor`を使うと良かったはずです。テストマクロは……いや、あっちですね。この中で作っていきますが、まずターゲットを`LandmarksMacroClient`にしておくことで、軽量なビルドができるようにしておきます。そのうえで、この中で`LandmarksMacros`の定義を作っていって、`UserInfoAccessor`をここに実装していきます。

`UserInfoAccessor`のエクスパンション、これですね。少し長くなりますが、これを作っていきます。この中で大事になってくるのが、ノードは`AttributeSyntax`、アタッチドな宣言、`DeclSyntax`です。ここに、さっきのASTが入ってくるイメージですね。`ExtensionMacro`なので、どの型に対して適用しているか、つまり「Providing Extensions of Type」系の情報が重要になってきます。どれに適用しているか、エクステンションしている先の型の情報を見ながら進めていく、という感じです。 とりあえず、この辺りにデバッガでブレークポイントを仕込んで様子を見てみましょうか。どんな情報が入っているのかを見たいところですが、ビルドに失敗しました。「このデクラレーションコンテキストに貼り付けることができない」というエラーです。エクステンションマクロ、つまり拡張に付与するタイプのマクロは、拡張そのものにはアタッチできないのかもしれません。エクステンションマクロではなく、メンバーマクロなのではないでしょうか。やはりエクステンションマクロではないですね。まあ、ここは一旦よしとします。

マクロの種類はこの前調べましたよね。フリースタンディングな宣言マクロや式マクロ、アタッチドマクロ（メンバーマクロ、アクセサマクロ、ピアマクロ、コンフォーマンスマクロなど）があります。アクセサマクロはプロパティ宣言に付与して使うタイプです。今回はメンバーマクロで、継承やさまざまな追加ができます。ここでいろいろなものを追加できるのはメンバーマクロかもしれません。ピアマクロでもないですね。同じスコープにいろいろ書いていくことができるので、これでもよいのかもしれませんが、エクステンションマクロは型宣言に付けるものなので、やっぱり間違っていました。コンフォーマンスマクロでもありません。もう一回進めていきましょう。

とにかく、マクロの種類を間違えたことが分かったので、実装の前にマクロ宣言を直します。エクステンションマクロではなくメンバーマクロにします。マクロの名前はこのままでよくて、`MacroMacros` というタイプアクセサを指定する形のままで構いません。型はメンバーマクロですね。そうすると、要求されるインターフェースが変わるはずなので、一回余分な実装は消しておきましょう。これでビルドは失敗するはず……あ、通ってしまいましたね。

メンバーマクロはデフォルト実装が提供されているセットがあって、`expansion` が入らない（未実装）状態でもコンパイルできるのかもしれません。メンバーマクロの要求をもう一度見ていきます。`expansion` が2つありますね。1つ目が `node` と `providingMembersOf` と `in: context` を受け取るもの、もう1つが `node` と `attachedTo` と `in: context`（あるいはそれに類するシグネチャ）のものです。`providingMembersOf` があるかないかの違い、という理解で良さそうです。とりあえず上の方、今コピーしたほうのシグネチャを使うのが良さそうです。

`node` はマクロのカスタムアトリビュート（`@...`）のノードで、`declaration` 側がマクロを実装した対象ですね。今回は `declaration` のほうを見ていきたいので、該当のシグネチャを貼り付けてそれを実装していく、という流れにします。ビルドをかけるとエラーです。`providingMembers` なのか `conformingTo` なのか、どちらを付けるべきかを指摘されています。どっちなのか分かりづらいですが、とりあえず上のほうのシグネチャをコピーして、この宣言に貼り付けます。中身に仮の処理を入れてビルドすると、戻り値の型が合っていないというエラーですね。なるほど、これはこれで想定どおりです。ひとまず何も返さない（空配列などを返す）ようにしておくとビルドは通ります。

ここから中のデクラレーションをたどっていきます。たどり方としては、いわゆるウォーカーで歩かせていく感じだったと思いますが、とにかく `ExtensionDeclSyntax` の中の `MemberBlock`、その中の `MemberBlockItemList`、さらにその中の `MemberBlockItem` を見ていくと、`EnumDeclSyntax` が見つかるはずです。これを探していくわけですね。ただし、`enum` が必ず1個だけとは限らないので、ちゃんと目的のものを探し分けないといけません。

実際にどうやってやるかというと、`MemberBlock` から `MemberBlockItemList` を取り出し、各 `MemberBlockItem` を順に調べていくのがやりやすいと思います。`EnumDeclSyntax` を見つけたら、そこから先の処理に進む、という流れで実装していきます。 とりあえずメンバーブロックは絶対ありますよね。ここですね。メンバーブロックから始まっているのかを、まず確認してみたい気がします。これを実行してみて、そうするとデバッグが止まると思うんですけど……これで動いて、終わりました。

マクロの展開はどうなるのでしょうか。そしたら、この戻り値の中で、ここで行として――コメントの行としてのデクラレーション、`declaration.description`かな。これでビルドをかけると失敗します。デクラレーションがファイルスコープだけと言われているのかもしれません。これをちょっと展開してみましょうか。マクロ、Expand Macro。そうすると、別に何も出てこなかった。ここは関係ない。ここは日本語だからこれはいいな。問題はこっちですね。ここをExpand Macro。

`UserInfoAccessor`の中で、一応展開をやってみますか。Expand Macro。展開はされていますよね、これでね。これでした。コメントじゃなくて、コメントなど全部が得られているのか。なるほど、どうなるのかな。`UserInfoAccessor`で、これがコメント行など全部展開された。raw にしたからいけないのかな。これを raw じゃなくて対応になっているのがいけないのか。だから、これをコメント行として扱うようにして、コメントのコードを書いてあげれば、これでコメントになりそうですね。

このバランスが悪そうに見えるのはどうすればいいのか。調整してあげて、ビルドをかけます。これは外に出ちゃっていますね。コメントの中で、ここから始まり最後に終了するように直します。これでビルドをかけると……キーを間違えました。ビルドをかけると、ビルドは通りましたね。

そしたら動作テスト。クライアントの`main`ですね。この中で、これを Expansion、Expand Macro。そうすると何も出てこない。`NotificationContent`、出てこなかったか。ビルドをもう一回かけて、これで Expansion、Expand Macro。出てこなかったですね。これがうまくいかなかったか。どうしましょうか。RawDeclaration。これでできないか。これ、raw がおかしいのかな。raw をちょっとやめてみてビルドをかける……ビルドは失敗しますよね、これだとね。やはり raw が必要ですか。raw が必要で、これで出力してほしいなという感じなんですけど、できなかったですね。ビルドをかけて、このマクロの Expansion……出てこないな。

この前にちょっと変えて、コードというか書き込んでみます。そうすると無視するわけにもいかないだろうと思いましたが、そんなことはないな。`DeclSyntax`。これで概要というか要素でしょうね。これで中身がこんなに畳めるものでしょうか。これが邪魔そうかな。調整して、ビルドを押してあげたときに Expand できるといいんですけどね。Expand……なぜか、ここになんで AI が出てくるんだ。Explain Document。まあいいか。分かれているとダメなんでしょうか。どうかな。

そうすると、コメント行を行単位で使えるのかな。やることとしては、ここはざっくりとやってみていいのかな。それで `declaration.description` の……ちょっと長くなるから、今日は変えますかね。`map`……いや、`split`で、`separator`が`\n`かな。それに対して`maxSplits`でもいいですね。`omittingEmptySubsequences`は`false`ですね。こんな感じにして。こうしたら`map`ですね。`map`の中では、ダブルクオーテーションで始まり、コメント行として、その中に文字列……だから、0でいいんですかね。こういうふうにして、これでデクラレーションしたやつを`ExprSyntax`にして返せばいいですよね。 なので、これは`LowValue`とか`Low`ですね。こうすることによって、各行をコメントで出せるんじゃないかなという状況です。これで`Expand Macro`…出てこないか。一回閉じないとダメみたいですね。いったん`main`をもう一回開き直して、ここで`Expand`を押してあげても出てこない。これではダメなのか。

この中で`map`するんですけど、まず一回ここで「テスト」というふうにコメントを書いて、この後の行をコメントアウトしちゃうとします。例えば、これだけだとダメで、これは配列にしないといけないんですよね。こうやって入れると。さっきはうまくいっていましたよね。これでビルドしてから`Expand Macro`をすると…あれ、出てこないのか。`Expand Macro`はここですよね。ここでうまくいった気がするんだけどな。“Expansion of …”で、ここで展開がされていない。もう一回…やっぱり出てこなかった。いったん閉じて、もう一回開いて`Expand Macro`。これを展開…出てこないですね。

でも、ここを間違って「テスト」だけみたいにすると、たぶんこれでエラーになると思うんですよね。そうするとエラーになりますよね。キーワード`instance`。とにかく、ここの「テスト」というか、マクロが展開できない。展開できないと困りますね。展開しないんですよね。展開できないのか…なんでだろう。もう一回手直しして、これで。クレートのクライアント側の`main`で`Expand Macro`。出てこないね。`Expand Macro`したときにAIが補完しようとしているけど、出てこないな。

さっきのエラーの場所を見れば、何かいいことがあるかもしれない。ここ…出てきた。押したら出てきましたね。このときのこれは`Expand`じゃないのか。`UserInfo`。どこに展開されているのか。ここにパーツが出ていますね。中身としては拡張の中ですね。だから、これのはずなんですよね。`Expand`…あれ、何か違うのかな。`Expand Macro`は合ってますよね。うん、合ってる。わざとエラーを出さないとダメかな。

そうすると、やるべきことは、わざとエラーを出すためのコメントを追加すること。一応ここに波括弧を入れておきますか。これでビルドをかけたときにエラーになって、このエラーを見ると、「テスト3だけ」…テスト3だけらしい、とか。テスト3……テスト3は今適当に言いました。自分が「テスト」「テスト」など3つ出てきているだけで、この宣言（declaration）が動かなかったという感じか。

そうすると、どうしますかね。もう1個改行を入れてビルドをかけて、エラーの部分を確認しても、もう「テスト」しかないですね。あとは考えられることとして、同様にここで宣言（declaration）や記述（description）を付けて、改行を入れて、もう一回かけますか。こうすれば余計なエラーが1個出ますよね。どうも「テスト」などは出るけれど、あとはコメントにならないのが良くない。もう、こうやって全部ですね、とにかく。

なので、エクスプローラー的に見られるのはここからですね。ここからどころか、この上からですね。そうすると、その上からエクスプローラーでちゃんと見ておけますか。こうしたときに、`CodePropertyList`から始まって、それでエクステンションのベクタをまず探したいという感じですかね。クラスやパターンの場合もあるので、そうするとベクタですよね。だから最初に見つけたいのは、この中のベクタ、その中のメンバーブロックですね。このメンバーブロックを探すにはどうするといいんだろう。昔マクロをやったときはどうだったかな。とりあえず探してみると。コードに戻れない…`macros::code`ですね。この中で探していくというか、`UserInfoAccessor`、この中ですね。これでどうやっていくか、この出力は…。 とりあえず取っておきますかね。どうでしょう。たくさんなくしてしまっても、とにかくこの宣言（Declaration）ですね。

宣言の機能として何があるかをまず調べられるのと、メンバーブロックがあります。メンバーブロックをだいたい取ってあげて、これを出力するとどうなるのかを見たいです。出力用のものは関数で用意したいですね。

どうしましょうか。まだ実装の見通しが立っていないので、ファイルを適当に作って、まずはここに書いていきます。なので一旦テンポラリにします。とにかく今はどうでもいい感じで、あとで整理するということで。あからさまに分かったほうがありがたいので、これで良しとします。

この中で import を拝借しておいて、関数で `make_*_syntax` みたいな感じで `*_syntax` を作っておきます。何を出したいかというと、意外と面倒ですね。`syntax_make` みたいな名前にするかどうするか……。これも意外と面倒なので一旦置きます。

とにかく、今見ているものが本当にメンバーブロックなのかを確かめたいです。例えばオプションになるかもしれないので、メンバーブロックは `get`/`set` しておきます。こうしておけば、メンバーブロックは取れているはずです。中身を見たいので、返り値は配列にして、その中でさらに見ていきます。`raw` にして `declaration.member_block.description` みたいな感じで見たいわけです。

これでビルドするとおそらくエラーになりますが、エラーになった箇所を見ると、ブロック自体は取れていますね。この中からレキシカルなトークンを取りたいです。

メンバーブロックの中は、ブロックアイテムリストですね。この中にメンバーブロックアイテムとして、enum 的なものがいろいろ出てくるはずなので、これを調べます。何かいいメソッドがありますかね。`Members`。`Members` いけそうですね。`MemberBlockItemList` にしたら、それっぽいです。

`members` に対してできることというと、`First` や `Where` がなくて、フィルターが効く感じでしょうか。できるとすると、メンバーを取っていきますか。`members` をループして、その中で `Where` 的なことをしたいのですが、`member` のメンバーがここで取れないですね。`members` は……これだと分からないな。一旦ビルドをかけてみます。ビルドは通りますよね。メンバーの補完を期待しているのですが、なぜ補完できないんだろう。

ナビゲーションの `with` オプションやセパレーター、エディターページ、`Next` とかが出ていますが、さてどうでしょう。メンバーブロックシンタックスの中は、これがシーケンスになっているはずで、`SyntaxCollection`……まあいいや。それで、`children` としていろいろあるのかな。

どちらか間違えていました。コメントを見ると間違えていましたね。上のほうで、`MemberBlockItemListSyntax`……これだ。`MemberBlockItemSyntax`。`MemberBlockItemSyntax` の定義を見ると、取れているはずで、これが持っているメソッドとしては `Has*` とかは持っていないのかな。`Kind`？`Kind` を持っているのか。そうなんだ、`Kind` が取れればいいですね。 ここではまず、`MemberBlock.members` でメンバーを見ていきます。メンバーが `decl` を持っているかどうか…ここで `has` を使うかどうかを考えましたが、`where` ではうまく絞り込めなさそうです。`where` でやるのは諦めて、このまま進めます。

この中では、`if let` か、あるいは `guard let` を使って、`decl` を取り出します。`enum` かどうかを判定したいので、`EnumDeclSyntax` にキャストしてみます。`EnumDeclSyntax = decl` と書いてもよいと思うのですが、`SwiftSyntax` の流儀からすると、ここはそうしたほうがよさそうな気がします。もっとも、そうでもないかもしれませんが…。API デザインガイドライン的に言えば、`enum` の宣言は `EnumDeclaration` のような名前になりそうですよね。

ということで、`decl` が `EnumDeclSyntax` かどうかをチェックします。`DeclSyntax` の中に `has` があったはずなので、それを見ます。`hasProtocol` みたいな名前ではなく、単に `has` だけだったと思います。`is` があって、その次に `has` が来るやつですね。ありました。これで、`EnumDeclSyntax` に適用できなかった場合には `continue` します。つまり、この時点で列挙型を探す処理になります。

列挙型が見つかったら、次にやることは名前の確認です。今回の仕様では `UserInfo` を探したいので、その名前を照合していきます。上の条件と一緒にまとめてしまうのもアリではありますが、そうすると「`EnumDeclaration` ではなかったのか」「それとも名前が一致しなかったのか」が分からなくなるので、ここは分けて書いたほうが頭の整理としてもよさそうです。まとめても動作上の問題はない気もしてきましたが…。

さて、どうしましょう。`EnumDeclaration` に `name` があるはずです。他に何があるか…`declName` と `name` が両方ありますね。`name` と `declName` の違いには悩みます。`enum` の `UserInfo`…どちらを使うべきかの明確な説明が見当たりません。とりあえずは `name` を使ってみます。

そして `name` が `UserInfo` かどうかの条件を付けます。一致しなかったら `continue` です。見つかった場合は `return` してみます。それから、`throw` のところは…もう少し良い書き方があるはずですが、いったんこのままで。

この中では、`EnumDeclaration` の `description` を返せば大丈夫でしょうか。ビルドをかけると、ここで `throw` が…あ、そうか。うまく引っかかったようです。こうしてあげて、もう一度ビルドします。

すると、展開エラーになります。展開結果を見ると、ブロックに入ってしまっています。ええと、でも `enum`…あ、これはブロックのほうですね。意図しないほうに行ってしまった感じです。なので、これをテスト用に少し形を変えてみます。こうしてビルドをかけると、こちらの結果に安全に切り替わるはずです。

一回閉じてから、もう一度展開。展開されなくなっているのはバグですよね、きっと。`description` になってしまっていますよね。 では、いま上の条件を変えるにあたり、いったん `UserInfo` の条件を外してみます。これでビルドをかけて、どんなエラーになるかを確認します。すると検出されましたね。つまり `name` が間違っています。いずれにせよ、展開されたのはプライベートな `enum`。これが展開されたということは、該当箇所は見つけられているということです。ここまではかなり良いです。

となると、`enum` 宣言の `name` ではなく、`DeclName` なのか？ あれ、どっちでしたっけ。`name` の `name`、つまり `DeclName`。`TokenSyntax` でしたよね。`TokenSyntax` の `DeclName`。両方を見てみるのが良さそうです。まずは `DeclName` や `Declaration` 周りは一旦やめておきます。

このとき、`guard` のところの `EnumDeclaration` の `description` ではなく、`EnumDeclaration` の `name` の `description` をまず見て、どんな `name` が取れているのか確認します。`UserInfo` が取れていますね。やはり、トークンが間違っているのか、それとも `DeclName` とは何なのか、という話です。

ビルドしてみると、どちらも同じに見えます。`name` は取れていそうなので、`EnumDeclaration` の `name` の `description`、これが `UserInfo` かどうかを見れば良さそうです。これならうまくいくはず。いったん閉じて開き直して、宣言名の `description` が引っかかるかどうかを確認します。いろいろまとめるのは一旦やめておきます。

ここでは `switch` にします。`enum` の宣言……長いですね。早く書きたくなってきましたが、まあいいでしょう。`name` が `UserInfo` だったら `return A`、そうでなければ `return B` という形にします。要素を見てみましょう。

これで `A` に当たってほしいのですが、ビルドしてマクロ展開を確認しても、一度閉じて開き直してもダメですね。ではファイル自体を開いてエラーを確認すると、`B` になっています。失敗しています。ここを何とかしたい。`B` のときは分かりにくいので、`B` の後にこうしますか。

これで `enum` 宣言……`A` にヒットしたとき、この `B` の値は――いや、`B` ではなく、必要なのは `enum` 宣言そのものではなく `name` ですね。欲しいのは `name` です。

この状態でビルドして、もう一度一つずつ確認してもダメですね。何か別のものが出ている気がしないでもないですが……ファイルはここにあります。ここです。いったん閉じて、もう一度開きます。

そうそう、`B` の `UserInfo`。取れているはずなのに、この `UserInfo` が一致しないのは、型の問題ですよね。宣言の `name` の型は `TokenSyntax` です。なので、`TokenSyntax` を文字列にする必要があります。たしか、`TokenSyntax` には文字列を取り出すための手段がありました。イニシャライザではなく、`text` が使えますね。そう、これです。`name.text` が `UserInfo` かどうかを見ます。

これでビルドしてみると、`A` になりました。はい、一致しましたね。では、ここは `guard` に書き換えましょう。`guard` で、そうでなかった場合は `continue`。`UserInfo` でなければ次へ進みます。ここはまとめても良さそうですが、`EnumDeclaration` を取るところと分けておきましょう。こうしておくと、`enum` が取れました。`UserInfo` の `enum` が取れました。

ということで、ここが起点になります。ここから `enum` をいろいろと漁っていきます。要は、解析対象になっているわけですよね。これをたどっていくには、`Walker` が使えそうです。クラスですね。 ここは`final class`にします。`private extension`で`UserInfo`にアクセスできるようにして、`enum`の宣言をたどる`Visitor`を用意します。`Visitor`なので、名前は`EnumVisitor`にしたほうが良いですかね。ビジターパターンは、どの型を目的として訪れるかを定義するやつですよね。なので、`SyntaxVisitor`の`open func`を`override`します。`visit`を開けば出てくるはずです。

引数はノードで、ここでは`DeclSyntax`です。`self`は要りません。戻り値は`SyntaxVisitorContinueKind`にします。`override`で`visit`を実装して、`visit(_ node: DeclSyntax) -> SyntaxVisitorContinueKind`という形になります。これで、`DeclSyntax`がビジターによってたどられるたびにノードが渡ってきます。ただ、これだけだと階層構造は分からないのでは、という懸念がありますが、`parent`があるので十分ですね。`parent`があれば、そこから上位をたどっていけます。`parent`は`Syntax?`だと想定してアクセスしていけば大丈夫でしょう。まずはそれで進めます。

次に、ノードのいろいろな情報を入れていきたいです。サンプルに倣って、順に探していく感じですね。`UserInfo`の中で`EnumVisitor`という名前にしていましたが、もう少し意味が分かるように、`ContainingEnumVisitor`のような名前に変えましょうか。中身を見たいので、まず`enum`の名前を見ます。キーになる部分なので、ノードの名前のテキスト、つまり`node.name.text`をそのまま使ってしまって良いかなと思います。今回はこれを小文字始まりのローアーキャメルケースにする想定です。ランドマークIDやアソシエーテッドケースなどの表示名として使う想定ですね。

ここはスネークケースでもキャピタルケースでもなく、キャメルケースでしたね。ローアーキャメルケースです。表示名としてローアーキャメルケースに変換します。Swiftでローアーキャメルケースへの変換ユーティリティはありましたっけ。特にはなかった気がします。`Foundation`を入れていなかったので、`import Foundation`します。そこまで配慮しなくていいのでは、と思うかもしれませんが、実際に作るときはここをちゃんとやらないとバグるので、やはり必要です。

`capitalized`って何でしたっけ。スペルは`capitalized`で、各単語の先頭を大文字にするやつですよね。一般的な挙動も一度確認しておきます。Swiftではとりあえず`capitalized`を使おうかな、という気持ちもありますが、サンプルで安易に作ってしまうのはあまり良くありません。ということで、「スネークケースからの変換」ではないにせよ、「ローアーキャメルケースへの変換」を用意して、それで`enum`名のテキストを変換する、という方針にします。 キャメル、スネーク、Codable。Codable の話ばかりになってしまうと思うのですが、String 拡張を見ると、標準ライブラリには無いというお話かなと思います。camelize（キャメルケース化）についてはひとまず置いておきます。まずはスネークケースから。これはまあ、できますよね。capitalize…いや、やりたいのは「先頭を小文字にする」ことです。

先頭だけを小文字にするとなると、意外と面倒ですね。関数にすると普通に落ちるんですよね。なので、先頭だけ小文字にしてテキストを得る処理を、拡張でやってしまいましょう。`extension StringProtocol` でいけるか、ちょっと試してみます。

関数にするかどうかですが、効率も考えて「使い捨て」として扱うならコンシューミング関数が良さそうです。やりたいのは capitalize の反対、つまり lower camel case で、先頭だけを小文字にする処理です。名前は `lowerFirst`、`lowerCamel`、`lowerCamelCase` などが考えられますね。to を使う命名はあまり好みではないので避けたいです。関数よりはプロパティのほうがよさそうなので、コンシューミングプロパティにして `var lowerCamelCase: Self { ... }` のように書くイメージです。少し自信はないのですが、この方向でいきます。

少し地雷を踏みそうな雰囲気はありますが、`StringProtocol` ベースでやります。`Self` を返す形でいけるのか、あるいは自分を書き換えられるのかは、まずやってみましょう。コンシューミング系のプロパティとして、先頭を見る前にガードが必要です。オプショナルではありませんが、空文字は扱えないので、`guard !isEmpty else { return self }` ですね。空文字を返すより `self` をそのまま返すほうが、コンシューミングの場合でも筋が良いはずなので、そうします。

次に、`self` の先頭要素を小文字にします。ASCII の小文字化で足りる前提で進めますが、ほかの文字はどうだったか…`Character` ですね。なので、`guard let first = first else { return self }` のように、いったん先頭文字を取り出すまでを用意します。

ASCII 前提でいくなら、ビット演算で大文字小文字を切り替えられます。ざっくり調べれば変換のやり方が出てきますが、XOR で該当ビットを反転させる方法です。ASCII コード表を見ると、大文字の 'A' は `0x41`、小文字の 'a' は `0x61` で、差分は `0x20` です。つまりビット `0x20` が立っているかどうかの違いなので、このビットを操作すれば大文字小文字を切り替えられる、というわけです。 ASCIIコードであることが分かった以上、アルファベットに対して処理した方が雰囲気的に良さそうですね。ASCIIコードなら、ビット論理演算で `|=` を使い、特定のフラグを立てることで小文字にできます。そうして小文字になったら `return self` ですね。すべて `return self` にするなら、ガードで早期リターンにするか、`if` 文にするかのどちらかになります。

この処理をコンシュームする（consuming）前提なら、その前提に基づいて進められます。`if` と `isEmpty` を組み合わせて、`self` の最初の1文字を取れるかを見ます。`first` でもいけますが、`self` の0番目を直接取る方が速い気がするんですよね……と思ったのですが、やはりサブスクリプトで `self[0]` のようには取れません。`self.startIndex` を使う必要があります。

最初の文字が1文字以上あって、その最初が ASCII 文字だった場合は小文字に変換します。あとはその結果に基づいて `return self` すれば完成のはずです。ビルドしてみると、かっこが足りない、などのエラーが出ました。修正してもう一度ビルドすると、今度はサブスクリプトの扱いでエラーです。`startIndex` を使って `self[self.startIndex]` を取る必要があるのに、`Character` からインデックスへは変換できない、という趣旨のエラーになっています。論理演算だけで押し切るのは難しそうなので、もう一度書き換える必要があります。

`self.startIndex` から最初の `Character` を取り、その文字のコードを見たいのですが、ASCII ではなく Unicode として扱う必要があります。`Character` をそのまま ASCII コードで触るのはだめで、`Unicode.Scalar` を経由するのが筋ですね。`Character` には `Unicode.Scalar` が含まれているはずなので、`UnicodeScalarView` を通してアクセスします。`Character` のイニシャライザは `Unicode.Scalar` を取れるので、スカラーを変換してから `Character` を作り直す形にできます。

小文字化は本来なら `lowercased()` を使えば簡単に済みますし、ローカライズされた小文字化なら `Locale` を渡す形になりますよね。テキスト全体を小文字にする `lowercased` と、いま作っている `lowerCamelCase`（先頭だけを小文字にする処理）は別物です。ここでは先頭1文字だけ小文字にしたいので、Unicode を意識した安全な方法で先頭の `Character` を取り、小文字化してから連結するのが良さそうです。

`UTF-8` と `Unicode.Scalar` のどちらを起点にするかですが、Swift の `String` は `Unicode.Scalar` を扱うのが自然です。`Unicode.ScalarView` の中身はバイト列を持っているはずですが、直接バイトで触ると面倒です。`Character` を小文字にする簡単な方法が用意されていればそれで十分ですし、なければ `String` に変換して `lowercased()` を使い、また `Character` に戻すなどの手もあります。

正規表現でやった方が早い可能性もありますが、いったんこのまま進めます。`else` 側では `startIndex` から `Character` を取得して処理する、という流れですね。ビルドエラーを潰しつつ、`Character` と `Unicode.Scalar` の変換を正しく使えば、目的の小文字化処理は実装できるはずです。 キャラクターを順次取っていくなら、まずは先頭文字を取りたいので、`let first = self[self.startIndex]` ですよね。そうしたら、`if first.isASCII { ... }` でいいかな。これで先頭文字が取れるかどうか、空っぽかどうかが分かるので、`where first is ASCII` という感じにすればよさそうです。

最初の文字が ASCII かどうかは分かりますし、キャラクターに格納されているのは Unicode のスカラーなので、ユニコードのコードポイントがないと辛いですね。`first` を Unicode.Scalar に変えられなかったか……。厳しければ、そこでやめるべきという感じでしょうか。Character の扱いをどうするのか、アプローチを変えましょうか。

あ、出てきました。これです。Character の中でユニコード値を取りたいわけで、ユニコード値は `Unicode.Scalar` ですね。`asciiValue`、お、`asciiValue` がありますね。`asciiValue` で良さそうです。なので、ここでは `first.asciiValue`。つまり、`let asciiValue = first.asciiValue` でいいんだと思います。これを使えば、ASCII コードならその値が取れるはずなので、`isASCII` といった判定もいらなくなって、ちゃんと取れているか確認できます。

試しに `let firstAsciiValue = first.asciiValue` として、新しい文字をセットしていけば文字になるはずです。自信はないですが、`newAsciiValue` を使う感じですね。

この Character をセットしていくので、`let newCharacter = Character(...)` として、どのイニシャライザがあるかは `.init` を見ないと分からないですね。`Unicode.Scalar` 経由で作るのが良さそうです。`Unicode.Scalar` はリテラルから作れますし、コンテンツが `Unicode.Scalar` であれば多分それで良いはずです。イニシャライザは `.init(...)`、`Unicode.Scalar` リテラルや Int から作るものなどがありそうです。そうすると、`startIndex` に対して新しいキャラクターを入れればいいわけじゃないですか。これでできた……本当かな。

ビルドしてみると、あー、これね、`get only`。ここが `get only` か。ようやくここにたどり着きましたね。`get only`。つまり、`StringProtocol` の添え字は `get only` なので、`String` に対しても代入はできないということです。そうなると、インプレース更新はいけないですね。ここまでやっておいて、インプレースな書き換えは不可ということか。配列、`[Character]` であればまた違うんでしょうけど、そういうことですね。

そうしたら、先頭だけ小文字にして作り直す、ということをしないといけないですね。先頭だけ小文字にするのはこれで良いと思うので、つまり、先頭の処理はこれですよね。プロパティにはオーダー 1 で終わるものが期待されるので、それ以上に計算が複雑になる場合には外に出しましょう、というガイドラインがありますが、これはオーダー 1 です。最初の文字だけを変える処理で、残りは文字数に依存しますが、そこまで細かく気にする必要はなさそうです。`var` にしておきましょう。

これで、`String` のプロパティだけど `String` を返すようにして、ここでいろいろ作っていきます。`consuming get` はそこまでいらないですね。普通に作り直すので。まあ、作り直すにしても、自分を破壊的に扱ったほうが速いときは十分あると思います。ただ、標準ライブラリを所有権まわりまでしっかりいじる準備ができていない感じがするので、効率はあまり良くなさそうです。 とりあえず、先頭文字の ASCII 値が取れるかどうかが重要ですよね。`guard let` で `asciiValue` が取れなかった場合は、そのまま `return self`、`String(self)` ですね。こんなふうにして、文字列を返しましょう。

今回はファーストレターだけ取りたいわけなので、先頭文字はもう取れました。`Character` を新しく作ったので、あとはこれを連結して文字列にすればいいわけです。やりたいことは、先頭の1文字だけ差し替えて、残りは元の文字列のままということです。`String` は `Character` のシーケンスなので、先頭を捨てて残りを得るには `dropFirst()` が使えます。

`CollectionOfOne` を使って最初のワンエレメントのコレクションにして…という手もありますが、連結のほうが速そうですし分かりやすいですね。`newCharacter` ではなく `newString` として、`newString = String(newCharacter)` としてあげて、返すときに `newString + String(name.dropFirst())` とすればよさそうです。ビルドもこれで通りました。

次は、このキーが本当に意図どおりになっているかを確認していきましょう。アサートとかは消して整理します。この処理は下に持っていったほうが良さそうですが、まずはいったん整理します。これでキーが取れたはずなので、キーが取れたら何を出したいのかを詰めていきます。キーが取れたら、バリューが二つになるケースはこっちですよね。つまり、`enum` のキーが取れた。まずはここまでで良いのか、という確認です。

これでキーが取れたので、ここをいじりつつ、`Visitor` で処理を進めていく必要があります。最終的に返したいのは `TokenSyntax` の配列なので、これを `Walker`（`Visitor`）の中でどんどん追加していく方針にしましょう。`final class` で `private(set) var` を用意して、`Visitor` の `expansion` かな、`[TokenSyntax]` の配列を持たせて初期化します。最初は空で良さそうです。ここに追加していく、という感じですね。

どの場面で使うかというと、実際には `NotificationContent` あたりでしょうか。`watchOS` 用ですね。`watchOS` のためだけに結構苦労している感じはありますが、演習なので良しとします。作りたいのはこれです。`enum` のものについては、`[String: Any]` に収束できるような形を作りたい。`T` が取れたら、これを使う、という流れです。 なのでここで、展開の終了を入れます。終了させる内容は文字列、つまり文字列リテラルです。そこで、アクセスレベルは `private` にするのがよさそうです。`enum` 側は `private var` にします。

ここで T が登場してきて、コロンを打って、型は `[String: Any]` ですよね。`Any` を値にもつ `[String: Any]` に対してオプショナル、つまり `[String: Any]?` というプロパティを作って、この中に `userInfo` を持たせます。これは親の名前でしたね。となると、親（`parent`）から `enum` を取ってこないといけません。親はどこになるでしょう。エクスプローラが重要で、構造が重要です。`enum` で来るかどうか、ここがポイントです。もし「親が誰これ？」という状態になって、メンバーブロックになってしまうと困るんですよね。`enum` で来る親をどう拾うかは、工夫で何とでもなりそうな気はします。

とりあえず、キーとして…バリューは何でしたっけ。`info`、`value` かな？ いや、`value` ではないですね。プロパティ呼び出し……。例えば、親の名前（`parent.name`）は取れるかな。親のこれは何だろう。シンタックスの型はルート。親の description、raw、`parentSyntaxNodeType`…。いろいろありますが、まずは親をたどって `enum` まで到達できればよいかなと思います。

なので、プロパティとしてまとめるのが少し難しいので、例えばこうします。親ノード（`parent`）。このノードは何型でしたっけ。ノードの型は `EnumDeclSyntax` ですね。`EnumDeclSyntax` なので、ここで `extension EnumDeclSyntax` を書きます。その中で、関数にするかプロパティにするか悩ましいところですが、まだデザインガイドラインが定まっていないものの、計算プロパティにするのがよさそうな気がします。ドキュメントコメントは今は書いていませんが、きちんと条件や重たい前提を書き添えて、計算量を明記しておけば、プロパティでも良いというガイドラインになっているので、今回はプロパティのつもりでいきます。

ということで、`var parentEnumDeclaration` のようにして、返り値は `EnumDeclSyntax?`（オプショナル型）にします。これを型として定義して、親をたどっていきます。実装はどうしましょうか。`guard` よりも `switch` の方が美しい可能性を感じました。`switch` は自分自身の `parent` に対して行います。まずは `nil` を先に処理しました。 ガードで行きますね。`case nil` の場合は `return nil` です。ここで値で取らないといけないので、`guard let` の方が美しいですね。`guard let parent = ... else { return nil }` のように早めに決着を付けた方が綺麗です。今回はその方針でいきます。

ガードができたら、`parent` をたどっていきます。`parent` が `EnumDeclSyntax` である場合には、それが取れたということなので返してしまえば良いです。つまり、`if let decl = parent.as(EnumDeclSyntax.self) { return decl }` という形ですね。そうでなければ、さらに `parent` をたどっていく処理を続けます。

`parent` が `Syntax` なので、命名としては「containing」よりも「enclosing」の方がしっくりきます。ということで `enclosingEnum` でいきます。わざわざ “declaration” と付けなくても通じますね。これで `parent` をたどって `enclosingEnum` を探していく、という実装になりそうです。やってみないとわかりませんが、見つかったら OK、`parent` が `nil` になった時点で終了です。

`return` を多用するスタイルは `if文` だとあまり使いやすくないかもしれませんが、今回は `if文` になりそうなので、その形にしておきます。これで `enclosingEnum` が取れたら、そこから先の話が早くなります。

ここでプロパティ名は `propertyName` にしようと思います。`propertyName` としてノードの `parent`、正確には「今持っているノードの `enclosingEnum`」を使います。ノードは `EnumDeclSyntax` ではなく `Syntax` だと思うので、`enclosingEnum` が使える想定で進めます。`node.enclosingEnum` は `nil` を返すことがあるので、`nil` の場合は「`parent` がない」という状況、つまり本来あり得ないはずの状況として強制アンラップしてしまいます。

`enclosing` でキーを扱いたいのではなく、`propertyName` の中でサブスクリプトアクセスを使い、キーの名前を入れて取り出します。取り出した値は `as? [String: Any]` のようにキャストして、これをそのまま戻り値にします。これで一行くらいで書き分けられそうです。結果として戻り値の型は `[String: Any]` を返す形になります。インターフェースが整ったはずなので、その前提で他の `userInfo` が見つかったところでも同様に扱っていきます。

次に、ビジターは `ContainingEnumVisitor(viewMode: .fixedUp)` のように初期化します。`viewMode` は厳密にチェックするかどうかのフラグのような位置づけですが、`SyntaxVisitor` の `viewMode` は `SyntaxTreeViewMode` で、`sourceAccurate` と `fixedUp` が使えます。厳密なコードの方が安全だと思うので、ここは `.fixedUp` にしておきます。

ビジターができたら、ビジターに対して `walk` します。ノードは `EnumDeclSyntax` なので、この中をウォークさせていって探していく形です。これでビジター周りはだいぶ整いました。`expansion` の処理も入れて、ビルドが通るところまで持っていきます。まだエラーは残っていますが、進捗はありそうです。

ログを見ると、`A` になっています。これは展開（expansion）して、`A` をどこで出せたのかを確認する段階ですね。 Aはしましたよね、たぶん。これでビルドをかけます。あ、この辺がいろいろダメなんですね、なるほど。P か X、m がいるということですね。m がいるというのは、こちらのプロパティの enclosing がどうなっているか、ということです。

`EnumDeclSyntax` はどうなっているかを、`decl` 系のシンタックスを当たりながら探していく感じです。`EnumDeclSyntax` は、継承関係で `DeclSyntaxProtocol`、それから `SyntaxProtocol` に準拠している、という形ですね。

`lowerCamelCase` を `text` に持たせているので、仕方なく `text` で raw を出す、という方針になっています。なので、`text` を `lowerCamelCase` にして、これは raw で、これでいいか、と。これでビルドをかけると、「識別子がない」と出ます。エクスパンションはペンディングして、あ、で `continue` ですね。`continue` はどのフローポリシーと言ってほしいので、ビルドと言うといいんですね。これを開けて、はい、オッケーです。

ビルドして、マクロが…えーと、リザルトのほう、プラグインがなんか失敗していますね。これで展開できるでしょうか。うーん。プラグインからの受信（Receive）に失敗した、という感じで、それ以上の情報が得られていません。この辺は古いやつですね。メインが、うん、なんか失敗していました。

得られたものが間違っていたということなので、名前の変換を見直します。ここで、`propertyName` と enclosing enum ですね。これはダメです。`name` の `text` にします。この名前も `lowerCamelCase` にします。そうすると、ここが raw ですね。

ではビルドをかけます。…ビルドが終わっても、まだダメですね。これ、展開できません。なぜでしょう。補完できないのか分かりません。一回 Xcode を閉じれば元気になる、ということがあるでしょうか。いったん Xcode を立ち上げ直します。

ここだけでも作れたらいいのですが、だいぶ時間が経ったので、そろそろ落ちる時間になるかもしれません。ビルドをかけて、今やられている最中に、ここを見ておきます。ここが `private var` で、プラグインのエラーですね。一回これを閉じて、開き直します。あ、Landmarks になりました。今は Landmarks の `private var` です。

ここだけを見たいので、ここでビルドをかけます。こちらで見るのは、これのエクスパンション（展開）ができれば…あれ、エクスパンション…あ、いいな。エクスパンションができればいいのですが、これがなんか機能しません。ここに AI のマークが出ていたりして、これで良いのかどうか。これが確認できないのは、ちょっと厄介ですね。 とりあえず、エクスパンション側で append する想定として、`private var` で `enum` の名前を持たせます。型は `[String: Any]?` にしておきます。型表記は角括弧が正しく、ここで使うのは角括弧ですね。あ、見つかりました。なるほど。これで `Any` の辞書にして、プロパティ名をキーに取るサブスクリプトの形にして、`[String: Any]` を返すようにします。

一旦コメントアウトして挙動を確認します。全体をコメントアウトしてから戻ってきて、再度コメントアウトを外します。変数の推論がうまくいっていない感じがするので、`var key:` とコロンで型を明示し、ここも戻り値を `String: Any` にします。`propertyName` を受け取るサブスクリプトで、引数名は `key` にしておきます。まずはこれでどうなるかを見てみましょう。ビルドをかけると、`Result` の方でやっぱりエラーが出ます。結果は真っ黒です。`Result` でエラーということは、ビジターパターン周りの問題なのですかね。

Visitor 側で、例えば `parent` を必ず `nil` にするのかどうか、強制アンラップで試してみます。テストとして `return` の扱いを確認します。`MemberDeclaration` で `guard` を使って、`enum` が見つかったら、最初に見つかったところで `return` する、という方針です。1個だけ見つかれば十分なので、これで良さそうです。

とはいえ、このメンバーを辿る意味があまりなさそうにも思えるので、ここは直すときに改めて考えます。次に、ビジターのエクスパンションを返すところが問題っぽいですね。試しに `return 1` のようにしてみると、これは当然ダメです。初期化してあげないといけませんし、`1` だとエラーが出ないと困るので、できそうな値にしてみても、戻り値の型が合わないと怒られます。

いっそビジターのウォークを止めてみます。これなら大丈夫でしょう。つまり、ビジターのウォーカーが良くないことをしていそうです。たぶん `propertyName` 周りではないでしょうか。`propertyName` のケースを読むようにすると、けっこう進みますね。ここは邪魔なので一旦消して、こんな感じで進めます。良いですね。この辺を少しずつ復活させていきます。

さっきのを戻して、要はウォーカーがこの `rawValue`、あるいは `propertyName`、さらに `enclosingEnum` を使うことが問題かもしれない、という気がします。まずは `let propertyName = "test"` のようにしてみます。これでビジターをかけると、ビルドが通って `test` が出てきます。そうそう、こんな感じ。

`userInfo` から来ていました。良いのか…いや、良くないですね。`userInfo` はプロパティで持っているので、`userInfo` からは要りません。渡すノードも違っていました。渡したいのは、`userInfo` の後ではなく、このビジターの `walk` に渡す `EnumDeclaration` の中身、つまりメンバーブロックです。`EnumDeclaration` の `memberBlock` を渡す、ということですね。

これでビルドをかけると、エラーが1個だけになります。良いですね。API だけが出力されて、`test` がまだ反映されていない状況ですが、これはおそらく `enclosingEnum` の計算が原因です。`enclosingEnum` が `nil` になっているのではないかという予感があります。`nil` だったときはオプショナルですし、`nil` の場合は `userInfo` を見るようにしておくのが良さそうです。

`enclosingEnum` がちゃんと取れているのかは少し怖いところですが、試せば良いでしょう。AST 側でさらに何か持てるようにする必要があるのかもしれません。 とりあえず、ここまでビルドしようとしていましたよね。これでエクスパンションできれば嬉しいんだけど……できました。できましたね。これでプライベート化も完了です。

ただ、フォーマットが良くないですね。エンドでリダウンするときでしたっけ？`formatted()`ってなかったでしたっけ。ないか……`formatted()`はないか。どこだったかな。`map`のフォーマットかな？これダメか。型が違うのかな。`ExprSyntax`に変えられない。`formatted()`はダメか。`ExprSyntax`ではダメ。ここはインデントがちゃんとしてほしいという話です。

`map`でどうか、`map`して`ExprSyntax`に変換できるかな……これはダメか。赤が出てダメですね。それ以外にね……`ExprSyntax`。綴り間違いなだけかな？でもダメですね。そうすると、ここでシンタックスになったものを、文字列リテラルとストリングインターポレーションでやりました。これでビルドは通るんですけど、ちゃんとできている保証はないという感じです。これを展開して様子を見て、合っていればこれでいい気がします。

エクスパンションマクロは API でやっています。フォーマットは全然連れてこられていませんね。今回は、こんなことを頑張る必要はなさそうです。`formatted()`を忘れていたっけね。`ExprSyntax`で、なんか綺麗に合わせられたような気がするんですけど、ここで`formatted()`みたいなのができたらいいのですが、やはりダメですね。まあいいか。こういう細かいところは、今回は目をつぶる感じで良いですかね。

なんていうんだろうな……エクステンション……まあいいでしょう。これでOptionalは、API の`unwrap`でないといけないんだ。API の`Optional`ね。なので、こうするとオプショナルか。オプショナルにするには、ここら辺の`userInfo`じゃなくて、`lowerCamelCase`に対して「ハテナ」を付けるか。ここで「ハテナ」って付けられるのかな。ビルドをかけて……あ、これダメか。`lowerCase`とか、オプショナルの可能性がありますね。だから`map`で、この辺は後でリファクタリングをかけるとして、`??`ですね。

これを`map`にして……で、「ハテナハテナ」は、これは演算子の優先度ですかね。丸括弧にして、これで変なことはなさそう。`map`にして……`map`が良いのか。オプショナルに対して`map`をするか。だからここが、なるほど、これが丸括弧で、ノードのところに丸括弧が必要。これは後で直しますよね。

で、これでビルドをかけてあげると……どうだろう。一回、今ので良かった。`userInfo`も「ハテナ」になったか。`userInfo`、まだ依然として`userInfo`を取ってくる。こんな状況になっていますね。`userInfo`はなんで取ってくるんだ。`visit`でノードを渡して、そのノードが`EnumDeclSyntax`のときですよね。フォーカスは、ビジターは、ここで`EnumDeclaration`の`MemberBlock`を渡せますよね。`MemberBlock`を渡しているのに、`EnumDecl`の`MemberBlock`を渡して、この中ですよね、おそらく。この中で親を見つけてきたんだろう。あっ、あっ、でも大丈夫だ。`userInfo`が取れていて、だから`parent`だ。`parent`で`userInfo`を見つけてきたってことですね、これね。なるほど、エンクロージング`enum`はちゃんと動いているってことですね。`parent`をたどって`userInfo`まで行って、`userInfo`のときには、これをなんとか……というわけですけど、だから、`parent`まで行くのか。これはオプショナルであり、必要がまずい。これをなくして……これでダメでしたけどね、さっきね。これでいいや。選択肢はこれだけ。

まあ、かっこ悪くはないね。戻ってきた。この`userInfo?`が問題だということで、この`userInfo?`は特例として扱う感じですかね。それと逆に、他の階層もオプショナルにしないというのもありますよね。どうしようかな。`userInfo`、今回は全部必須にしますかね。自分でも明記していますしね。「ない場合」というものを想定しないという形にすると、この「ハテナ」が要らなくなりますよね。それで、ここのバーでオプショナルではなくなる。で、ここが強制アンラップが……ここがちょっと怖いですね。強制アンラップ、強制アンラップ。そうすると、ここは「あるもの」とするのか。強制アンラップはやめて、安全にアンラップしましょう。そうすると、取れますよね。これでいいや。見たとなったら、このタイプができるので、これでOK。

そうすると、このマクロの展開が、ちゃんと良い感じにできているはず、今のところね。`userInfo`のAPIに対して、キャストして取ってくる。で、残りも、ちゃんとAPIに対して取ってくる。うん、できましたね。こんなふうにしてできました。ただ、さっきから言っている、このインデントだけが気になります。まあ、それはまずはいいや。

では、大元ができたので今日はこれぐらいにして、次回はこのケースに対してプロパティをできて作る、というのをやっていきますね。はい。では、これで終わりにします。お疲れ様でした。
