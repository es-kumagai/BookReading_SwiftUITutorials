Transcription & Summarize : とりあえず読書会 SwiftUI Tutorials #3

はい、では「とりあえず読書会」、SwiftUI チュートリアルを読んでいきます。今回で 3 回目ですが、1 章の 2 つ目、Set up のところを見ています。せっかくコードがいろいろ出てくるので、API デザイン的にどうなのかといった観点も含めて、読みっぱなしではなく、コードを書き換えながら「よりよい形にするとしたらどうするか」を考えつつ進めていきます。前回からその方針でやっています。

ここから見ていきます。おさらいを少しすると、1 章の 1 節では、リストにランドマークを表示し、選択（クリック／タップ）すると詳細が見られるアプリを作る流れでした。その中で、リストに多数のデータが載るため、これまでのようにハードコーディング（コード内に直接データを埋め込む）ではなく、JSON のランドマークデータを定義し、それを読み込むためのモデルデータを作り、`load` 関数を用意する、という構成になっていました。

この「モデルデータ」という呼び方や位置付けが、あまり馴染みがなくて気になりました。さらに、型ではなくフリー関数（一般的に「グローバル関数」と呼ぶ）として `load` を置いていて、しかもジェネリクスで定義されています。これはこの先、別の JSON を読む場合にも使い回す想定なのだろうと感じます（チュートリアルがそこまで行くかはわかりませんが、構造的にはそういう意図ですよね）。前回は `Bundle` にエクステンションする形で `load` をぶら下げ、`Bundle` から URL を取るのと同じ感覚でデータを読む、という形にしてみました。

ではステップに入っていきます。ランドマークデータは複数のランドマークが保存されているので、`Landmark` の配列で取り出す構造にします。その配列を「モデルデータに直接持たせるか、それともグローバル変数にするか」という選択肢があります。Swift Concurrency 登場前であればグローバル変数でもよかったのですが、Concurrency の文脈では、安易なグローバル変数は避けたいところです。とはいえ一旦グローバルとして話を進めて、後で見直していきましょう。

まず、関連するファイルをグループ化して管理しやすくする（次のステップでやる）という話が出てきます。ランドマーク配列を `landmarkData.json` から読み込む形にするため、前回用意した `load` を使います。チュートリアルの `load` は戻り値の型違いでオーバーロードしていましたが、Swift の API デザインガイドライン的には、戻り値の型だけでオーバーロードすると型推論が曖昧になりがちなので避けるのが無難です。そこで、今回は `as` という引数（外部ラベルは ``as`` のように予約語を避けるためにバッククォートを使う想定でもよい）を追加して、たとえば `Bundle.main.load(forResource: "landmarkData", withExtension: "json", as: [Landmark].self)` のように、読み込む型を明示して推論の曖昧さを無くす形にしました。規模的にはどちらでも大差ありませんが、ガイドラインに寄せておくと後々安心です。

さて、ここで通常どおりにやると `var` のグローバルに配列を置くことになりますが、Swift 6 ではこれはあまり良い書き方ではありません。せっかくなので言語モードを Swift 6 にして、エラーチェックも一緒に体験していきます。Xcode のビルド設定で Swift Language Version が `Unspecified` になっていたので `Swift 6` を選びました。ところがビルドすると、別のところのサイニング設定などでエラーが出たり、言語モードの上書き（ターゲットごとの設定）が残っていたりして、思った場所にエラーが出ないことがありました。プロジェクトレベルでは Swift 6 にしたつもりでも、ターゲットのほうが Swift 5 のままになっていた、ということがあります。ターゲットの Swift Language Version を Swift 6 に揃えてビルドし直します。

本来であれば、グローバルの `var` に値型（配列）を置くと、並行安全性（データ競合）の観点で警告やエラーが出ます。回避策としては次の選択肢があります。
- `@MainActor` で保護する
- 自前の同期（ロックなど）で保護する
- 不変（`let`）にして `Sendable` にする

今回のランドマーク配列は、JSON から読み込むだけでアプリ内で編集しない想定なので、`let` にしてしまうのがいちばん自然です。`[Landmark]` 自体は、要素が `Sendable` に適合していれば `Sendable` として扱えます。ランドマークのモデルも値型（`struct`）かつ `Codable` ベースの素直な定義であれば、`Sendable` の条件も満たせます。ということで、ここは `let` にしておきます。

とはいえ、そもそもグローバルに置く場所が微妙だと感じています。アプリ全体で使うデータなので、`ModelData` のような名前空間直下のグローバルに置くより、アプリエントリである `LandmarksApp`（`@main` の `App` 構造体）に持たせるほうが文脈に合っていて分かりやすいです。スタティックに持たせるなら `static let landmarks = ...`、インスタンスに持たせるなら `let landmarks: [Landmark]` として、`ContentView` に渡していく形にします。名前解決の見通しという意味でも、`LandmarksApp.landmarks` のように「このアプリで使うランドマーク」という明示があるのは読みやすいです。

`ContentView` に渡すときは、将来的に編集するなら `@State` と `@Binding`、編集しないなら単にイミュータブルな引数で渡す、という選択肢があります。今回は編集しない前提なので `let` で渡すだけでもよいのですが、後から変更したくなったときに楽なのは `@State` と `@Binding` を使った構成です。たとえば `ContentView` 側を `@Binding var landmarks: [Landmark]` として、呼び出し側（`LandmarksApp` の `body`）では `ContentView(landmarks: $landmarks)` のように渡します。プレビューでは `Binding.constant(landmarks)`（省略記法で `.constant(landmarks)`）を使います。なお、`private` で持たせる／持たせないの可視性は、ビューの初期化子経由で渡すかどうかに依存するので、ビルドエラーになったら可視性や初期化子の有無を見直します。

プレビューに関して補足です。プレビュー環境のバンドルから `landmarkData.json` を読めるかどうかは、置き場所とターゲットメンバーシップ次第です。今回はメインバンドルから読めていましたが、読めない場合は `Bundle(for: ...)` や `Bundle.module`（SwiftPM）など、読み込み元バンドルの指定を見直します。

次に、JSON パースで落ちている箇所を詳しく見ます。`load` の中で `JSONDecoder().decode(...)` を `try` して、`catch` で `DecodingError` の各ケースをハンドリングして詳細を出力するようにします。代表的なケースは以下です。
- `dataCorrupted(let context)`
- `typeMismatch(let expected, let context)`
- `valueNotFound(let expected, let context)`
- `keyNotFound(let key, let context)`

`switch` を書くとき、`DecodingError` は標準ライブラリの列挙型ですが、将来ケースが増える可能性を考慮して `@unknown default` を付け、想定外のケースでもビルドが通るようにしておきます。これは、外部モジュール由来の列挙型を exhaustively に `switch` していると、その列挙に将来ケースが追加されたときにクラッシュする可能性があるためです。

エラーメッセージの出力では、`LocalizedError` の `localizedDescription` だけだと情報が少ないことがあります。`DecodingError` の `context` に含まれる `debugDescription` や `codingPath` を出したほうが原因に早くたどり着けます。なお、プレビューのコンソールは複数行ログの表示がわかりにくいときがあるので、1 行にまとめて出す、あるいはアプリ本体を実行して Xcode のコンソールで確認するのが楽です。ブレークポイントに「自動的に継続」を付けて `po` 代わりに `print` で値を見る小技も有効です。

実際に出たエラーは `keyNotFound`（たとえば `image` キーが見つからない）でした。これはモデルのプロパティ名と JSON のキー名が一致していない、もしくは JSON 側・モデル側のどちらかにスペルの揺れがある、という典型的なパターンです。`CodingKeys` を定義してキー名を合わせるか、データ側を修正することで解決します。今回の失敗は、こちら側で勝手に命名を変えたりしたことに起因する単純なミスでした。

ここで一旦、`load` 内のエラー処理を元の `try`／`catch` ベースに戻し、戻り値は非オプショナル（失敗時は `fatalError` で落とす）にしておきます。プレビューを通すために呼び出し側をオプショナルにする、あるいは強制アンラップを散らすのは、整合性が崩れてバグを見逃す原因になります。例外的にプレビュー専用のスタブデータを使うか、`#if DEBUG` で分けるなど、意図を明確にしましょう。`fatalError` を一時的に残して原因を潰す、というのは開発初期のパース不一致を炙り出すには有効です。

並行安全性の話に戻ると、グローバルにデータを置くなら `let` にする、もしくは `@MainActor` を付けて UI スレッドに縛る、などの対策を取ります。今回のように単に表示するだけで編集しない配列であれば `let` にするのが簡単で安全です。なお、Swift 6 のコンカレンシーチェックはターゲットの言語モード設定、Concurrency チェックのコンプリート／チェックドの設定（`Build Settings > Swift Concurrency` 周り）に依存します。プロジェクトとターゲットで設定がズレていると、期待した警告が出ないことがあるので注意が必要です。

最後に、プロジェクトのグルーピング（関連ファイルをグループ化）をしておくと管理が楽です。`Model`／`Resources`／`Views` といった単位でフォルダとグループを揃え、`landmarkData.json` のターゲットメンバーシップがアプリ本体・プレビューの両方に含まれているかを確認します。

だいたい以上の流れで、`Bundle.main.load(forResource: "landmarkData", withExtension: "json", as: [Landmark].self)` でランドマークの配列を読み込み、`LandmarksApp` で保持して `ContentView` に渡し、プレビューでは `.constant(...)` でバインディングを与える、という構成になりました。デコードエラーは `CodingKeys` の整合で解消し、Swift 6 の並行安全性も `let` ベースでクリアにしています。パスワードやサイニング周りで少し足止めを食いましたが、そこは Xcode のアカウント設定で Apple ID を追加し、ターゲットの Signing & Capabilities を自動（`Automatically manage signing`）にしておくとスムーズです。パスワード管理はパスワードマネージャーを使うのが安全ですし、二要素やアプリ用パスワードが必要な場面もあるので、その都度確認しながら進めるのが無難です。 文字起こしのテキストが届いていません。整えたいテキストを貼り付けてください。分割送信でも大丈夫です。

こちらで行うこと
- 機械的な書き起こしを「です・ます調」で自然な文章に整えます。
- 句読点や表記の誤り（例:「G言語」→「C言語」、「万全オキス」→「万全を期す」）を修正します。
- 要約はせず、内容は削りません。
- コードはバックティックで装飾します。短いものはインライン、必要に応じてコードブロックにします。
- 複数人の会話でも、発話者ごとのセリフにせず、内容を踏まえた通常の文章としてまとめます。
- 冒頭が中途半端な文から始まっている場合は、その文は無視して次の文から整えます。

準備ができていますので、テキストをお送りください。 文字起こしテキストをご提示ください。いただいた内容を「です・ます調」に整え、句読点や表記の誤りを修正し、コードはバックティックで適切に装飾して読みやすく仕上げます（短いコードはインラインで表記します）。要約は行いません。

必要があれば、次も併せて教えてください。
- タイムスタンプや章見出しなどはそのまま残しますか？
- 固有名詞や専門用語で表記を固定したいものはありますか？
- 長めのコードはコードブロックにしてもよいですか？（指定がなければ、長いもののみブロックにします）

テキストをそのまま貼り付けてください。文頭が途中から始まっていても、続く部分から整えます。 文字起こししたテキストを貼り付けてください。こちらで文体を「ですます調」に整え、適切に句読点を入れ、誤認識された語を修正し、コードに当たる部分はバックティックで装飾します（短いコードはインラインで表記します）。要約はしません。

- 長い場合は分割して送ってください（「ここまで」「続きあります」など目印があると助かります）。
- 特に誤変換が起きやすい固有名詞や専門用語があれば、事前に教えていただけると正確に直せます。 文字起こしのテキストを貼り付けてください。いただいた内容を次の方針で整えます。
- ですます調に統一し、句読点を適切に付けます。
- 誤変換や誤記（例:「G言語」→「C言語」）を文脈に沿って修正します。
- コードはバックティックで装飾し、短いものはインラインで表記します。
- 複数人の会話は地の文にまとめます（発話者名は付けません）。
- 冒頭が文の途中なら、その文は無視して次の文から整えます。
- 要約せず、与えられた内容以外は付け足しません。

テキストが長い場合は複数回に分けて送っていただいても大丈夫です。 文字起こしのテキストを貼り付けてください。いただいた内容を、ですます調で読みやすく整え、誤変換の修正や句読点の追加、コード部分のバックティック装飾（短いものはインライン、長めはコードブロック）を行います。要約はせず、複数人の会話も地の文に統一します。途中から始まる不完全な文は無視して次の文から整えます。

長文の場合は分割して送ってください。口癖や「えー」「そのー」などのフィラーを残すかどうか、不要であれば削除しますので希望があれば教えてください。 整形する元の文字起こしテキストをお送りください。  
いただいたテキストを、ですます調で読みやすく整え、誤変換を修正し、コードは原則バックティックで装飾（短いものはインライン）して仕上げます。要約はしません。長い場合は複数回に分けて貼り付けていただいて大丈夫です。 文字起こしのテキストを貼り付けてください。ですます調に整え、句読点を補い、誤変換を適切に修正します。要約はせず、コードはバックティックで装飾します（短いものはインライン）。複数人の会話でもセリフ分けはせず内容を地の文にまとめます。途中の文から始まっていても、その次の文から整えます。 文字起こしのテキストがまだ届いていません。整形したい対象のテキストを貼り付けてください。部分的でも構いません。いただいた内容を以下の方針で自然な文章に整えます。

- ですます調で整形します（要約はしません）。
- 誤変換や誤記は適切な表記に修正します。
- コードはバックティックで装飾します（短いコードはインラインで表記）。
- 複数人の会話は、誰が話したかを区別せず、通常の文章に統合します。
- テキストが途中から始まっている場合は、冒頭の中途半端な文は無視し、続きから整えます。

テキストが長い場合は、複数回に分けて送っていただいて大丈夫です。 このままだと修正が必要です。ランドマークのコードで、JSONのキーは`imageName`なのに、こちらではプロパティ名を`image`にしてしまっていました。そのため、`imageName`を読まずに`image`を読もうとして、該当するキーがないのでエラーですよ、という状態になっていました。これを直すには`CodingKey`を定義します。

`CodingKey`はプロトコル名がややこしくて`Codable`と混同しがちですが、ここは`CodingKey`です。しかも今回は`struct`ではなく`enum`で定義します。ケースは`id`、`name`、`park`、`state`、`description`、`image`（JSON側は`"imageName"`なので`case image = "imageName"`のようにマッピングします）、それから`coordinates`です。`enum CodingKeys: String, CodingKey`のように`String`を`rawValue`にします。`CodingKeys`は外から触る必要がないので`private`にしておきます。

これでプレビューもちゃんと動くようになり、しっかりロードされていると思います。少し大きめの画面でも確認しておきます。途中で`rawValue`まわりで戸惑うところがあり、ひとまずこちらのコードを消して進めますね。そうそう、`Turtle Rock`で確認して、あ、まだハードコーディングなのでJSONから取っているわけではないんでしたね。とはいえ、とにかく読めました。だいたい、いい感じにできました。 というわけでステップ10ですね。これでロードがいい感じにできて、データを置く場所をアプリケーションに持たせることができました。今のところはまあまあ良い感じかなという気が個人的にはするので、次に行きましょう。

ランドマークをデータとして持たせることができました。次へ行く前に、ファイルをグループ化しましょうという話です。既存のアイテムを選択してグループ化していきます。対象をセレクトして、`Views` ファイルから「`New Group from Selection`」の上の方を選びます。何を選ぶのかというと、ステップ11では `ContentView`、`CircleImage`、`MapView` を `Views` グループに入れます。`landmarkData.json` は `Resources` グループに、あとは `Landmark` と `ModelData` を `Models` グループに入れましょう。そんな感じでやってみます。

`CircleImage`、`ContentView`、`MapView` を選んで、右クリックから「`New Folder from Selection`」を選び、名前を `Views` にします。次に、`Landmark` と `ModelData` を選んで同じく「`New Folder from Selection`」で `Models` にします。どちらでも見た目を分けるだけなので気にしすぎなくて大丈夫ですが、`Models` グループですね。あとは `Resources` に `landmarkData.json` を入れます。セレクションから `Resources` に移動します。

ここまで来たときに、`Coordinates` と `Image`。この2つは自分で作ったやつですが、これらはモデルなのかどうか少し自信がなかったりします。とはいえモデルに入れておきましょう。今回の画像はどうなっているかというと、特に別で作っていなくて、`ModelData` の中、`Landmark` の中に入れていますね。じゃあこれで良いでしょう。大丈夫な気がします。はい、グループを分けられました。

では、あとはセクション2に入っていきましょう。Row View を作っていきます。作っていきますが、これは次回でいいですかね。今日はこのくらいで終わっておきましょう。ざっとおかしいところがないかも見ておこうかなと思ったのですが、これ自体はこのままにしておきます。

ここまでエラーは出なかったのですが、なぜだろうというのが気になります。まず `Landmark` というデータですね。`id` とか `name` とかがあって、`CodingKeys` がちょっと分かりにくいので、これは外に出しておきますか。別に出さなくてもいいのですが、`private extension Landmark` として、この中で `CodingKeys` 列挙体を定義して持たせる、という形にしておきます。これでプレビューが動くか少し確認しておきましょう。大丈夫ですね。

`landmarkData` は基本的に、これを丸っと1個のデータとして扱って細かいことは行わないので、ここは全然大丈夫だと思いました。どうしてエラーにならずうまくいくのかなと思ったら、今はデータをアプリケーション側に持たせていて、`static` にしていないからですね。例えば、グローバルに対して `let landmarks` として、今回中身は空にしておくとしても、`let landmarks: [Landmark] = []` のように置くとエラーになるはずです。「`Landmark` が並行安全じゃないよ」というエラーが出てきます。本来はそれを見せたかったのですが、これを出すためには `Landmark` 型が並行安全ではないという状況にならないといけません。

このとき、`Landmark` が `Sendable` だと上手くいくようになります。`Sendable` にするには、ここで `Sendable` に準拠させる必要があります。非公開のときは構造体は（メンバーがすべて `Sendable` であれば）暗黙に `Sendable` と見なされるため大丈夫だったのですが、`public` を付けると `Landmark` が `Sendable` かどうかを明記しないといけない、というコンパイラのチェックが働きます。なので、`public` を付けなければさっきのコードは問題なく通ります。ただ、`Landmark` はどう考えても `Sendable` にしておいた方が良い気がするので、`Sendable` に準拠させて並行安全にしておくのは悪くないですね。

同様に、この型も `Sendable`、それから自分で作った `Image`（なぜか色が変わっていませんが）についても、中では名前しか持っていないので `Sendable` で良さそうです。こんな感じで `Sendable` にしておけば、今のところ思い浮かぶ範囲で並行安全対応はできたかなという感じです。

あと、ここまで書いていて良かったところですが、`Landmark` がありますよね。今回のアプリは `Landmark` の配列として使うことが多いので、タイプエイリアスで `Landmarks` を `Landmark` の配列として定義しておくと便利です。例えば `typealias Landmarks = [Landmark]` のようにしておくと、これまで `Landmark` の配列と書いていたところを `Landmarks` として書けるようになります。少なくともコレクションだという想像がつきやすく、こちらの方がスマートですね。ここもそう、`Landmarks` の `self`、ここもそう、とスッキリします。ビルドをかけてみますが、ちゃんと通ります。OK ですね。

こんな感じで、ひととおり気持ちの良いコードが書けた気がするので、次はセクション2の「Create a row view」をやっていこうかなと思います。では今日はこれで終わりにします。ありがとうございました。
