Transcription & Summarize : とりあえず読書会 SwiftUI Tutorials #21

では、とりあえず読書講義を始めていきます。SwiftUI を引き続き読んでいきますが、今回は UIKit を SwiftUI と連携する中で、ステート（状態）を連携させたり、そういったことをやっていきたいと思います。いろいろとリファクタリングをしながらトークが進んでいきますが、ゆっくりやっていって、少しでも記憶に残るようにしていけたら、最終的には効率が良くなるはずなので、細かなところも加えつつ進めていきましょう。今日はセクション3からです。

ページ…「Track the page」かな。意外と訳が難しいですね。表題は難しいことがありますが、これは単純に自分の英語力の問題だと思います。「SwiftUI のビューのステートでページを追跡する」、あるいは「SwiftUI のステートによってページをトラックする」といった意味でしょうか。

図を見ておきましょう。PageView があって、その中にカレントページ（currentPage）があり、それを UIPageViewController のカレントページとバインディングする、ということですね。これだけ見ると難しそうで、どうやったらいいのか想像しづらいのですが、慣れていけば見通しが立ちそうで良いですね。

準備として、カスタムの UIPageControl を追加できるように、PageView の側からカレントページをトラックする必要があります。そのために、PageView に `@State` プロパティを追加して初期値を設定し、その `Binding` を PageViewController に渡します。これは SwiftUI でもおなじみのやり方ですね。PageViewController は、このバインディングを使って現在表示されているビューを更新していくことになります。まずはカレントページの `Binding` を PageViewController のプロパティとして追加します。

次に、`Binding<Int>` の `currentPage` を、SwiftUI 側の PageView に置きましょう。それに加えて、`Binding` プロパティを宣言したら、`updateUIViewController` の呼び出しも、カレントページのバインディングを渡すように更新します。ここで言うカレントページを渡す、という形にします。これでアップデートがかかったときに、更新対象の PageView が正しく渡される、ということですね。

続いて、`@State` 変数を PageView に宣言します。PageView の中で PageViewController（これは SwiftUI と UIKit のブリッジとしてのコントローラですね）を使っています。まずは PageView に対して `pages` を定義して、それを使って PageViewController を作るときに、`currentPage` の `Binding` を渡します。ここで重要なのが、`$`（ドル記号）を付けるのを忘れないことです。忘れるとコンパイルエラーになります。

ステップ3として、PageView に定義を追加していきます。次のステップでは、`Binding` を PageViewController に渡したときに、初期値や変更がちゃんと伝播して、期待する値が届くことを確かめます。

さらに、PageView にボタンを追加します。このボタンは、PageViewController（つまりページ送りのコントローラ）を使って次のビューへ移動させる、といった練習になるでしょう。ステップ4まで進んだ、というところですね。ステップ3の内容はここまで読みました。

では覚えている範囲で、実際に手を動かしてみましょう。PageViewController があって、ここに `Binding` を渡します。`Binding` をどこに書くのがよいか、PageView の上下どちらに置くか、など少し迷いますが、必ず渡す必要があるのでプロパティとして持たせます。

UIPageViewController の `setViewControllers` は要素の配列を受け取りますが、実際に有効になるのは1つだけです。ですから、コントローラが1つと分かっている場合でも、配列で渡す必要があります。丸括弧ではなく角括弧で、1要素だけの配列を渡す、といった形ですね。

このあたりで気になるのが、アプリがカレントページをコントローラの数を超える値にしてしまった場合にクラッシュするのでは、という点です。これをどう扱うか。`updateUIViewController` で更新するかどうかの判断をするのか、ほかの手はあるのか、悩ましいところです。渡さない、という選択肢もあり得ますが、厳密にインデックスが範囲外のときには何か知らせなければならない、という気持ちもあります。理想は大切ですが、どこまで理想を通すかのバランスですよね。いずれにしても、カレントページがオーバーしていた場合にどうするかは考えておく必要があります。

今コーディネーター…ではなくコントローラの話をしていました。コントローラがちゃんとインデックスの範囲内に存在するかどうかは大丈夫でしょうか。PageViewController では、まずコーディネーターを作った際に、`pages` を実際の `UIViewController` に変換して保持します。その時点でコントローラの数は決まります。その後、`firstIndex` が見つからなければ `nil` を返す、つまり範囲外なら `nil` になる、という流れですね。なるほど、範囲外だと PageViewController は `nil` を返すのですね。

こういった状況では、`updateUIViewController` が呼ばれない可能性もあります。ページが存在しないときにはアップデートの余地がない。カレントインデックスを超えたときに既存の表示はどうなるのかというと、`nil` なので何もない、という状況になるのかもしれません。もしここが呼ばれないならそれはそれで良いのですが、別案としてはコーディネーター（`Coordinator`）側のコントローラ配列を参照して検証する方法があります。

たとえば、カレントページが範囲内にない場合は、この場で `fatalError` を投げる、という方針もあります。つまり、`fatalError("定義された currentPage が範囲外です")` のようにしておき、ここで明確に落とします。`context.coordinator` からコントローラ配列にアクセスして、その範囲内に `currentPage` があるかを判定し、ダメなら落とす。そうしておくと、この下の処理では `currentPage` は問題なく使っていける、という状況になります。

ここまで書いたところで、一度立ち止まって考えつつ、リファクタリングをしながら進めていきましょう。 とりあえず、Controllers について進めます。さっき `indices` を使った都合で、ページ番号とインデックスは、ここから見たときに直接の関係はありません。とはいえ、まったく関係ないわけではなく、今は同じものとして扱っています。

`extension` で `UIPageViewController` に対して、`private extension` を作ります。そこで、カレントページを取得するためのメソッド（たとえば `currentPage(for page: Int) -> UIViewController?` のような形）を用意します。戻り値はコントローラで、この型はなんだっけ、という話でしたが、`UIViewController` ですね。`UIViewController` ではない場合もあるので、オプショナルにします。

ページを取得して処理していきます。ここは、いきなりページを使ってしまってもいいのですが、「`index = index`」のように、インデックスとページは同じものだということを示すためのコードを書くかどうか少し迷いました。今回は書きますが、普段は書かないですね。むしろ、ページ番号の指定方法が曖昧で混乱を招きそうな印象もあるので、そこは整理しておきます。

次に、コントローラーではなく `context` を経由してコントローラーを渡す必要があります。引数は `page` と `context` にして、`context` の型は `Context` です。かなり大胆な型名に見えますが、定義は `SwiftUI` の中にあり、`SwiftUI` の `UIViewControllerRepresentable` 周りで使われるものです。`controllers.indices` を使ってインデックスが範囲内かどうかを見ます。範囲外で見つからなかったときは、単純に「なかったよ」という意味で `return nil` を返します。見つかった場合は `controllers[index]` を返します。これで、ページ指定からコントローラーを取得できます。良さそうですね。

このときに、名前（ラベル）はさておき、もう少し便利なプロパティも用意しておきましょう。`currentController`、`currentPage`、`currentPageController` といったものを `var` で作っておき、型は基本的に `UIViewController` にします。

ここで使う `viewController` は、コーディネーターの中で管理しているコントローラーで、実体は `UIHostingController` ですよね。ただ、`UIHostingController` はジェネリックで中のコンテンツの型が大事になってきます。今回のページの型は決まっているので、汎用的な `UIHostingController` ではなく、もう少し具体的に `UIHostingController<Page>` のようにしてしまって良いはずです。実際に中にはそれが入っているので、専用のプロパティを用意するときも、汎用的なものを返すより具体的な型を返す方が扱いやすいです。

その際、強制ダウンキャスト（`as!`、いわゆるビックリマーク）で済ませる手もありますが、これは業務アプリだと問題視されがちですし、避けたいところです。丸括弧でくくってコンパイラの警告を回避できるケースもありますが、すべての警告に効くわけではなく、今回のようなダウンキャストには有効ではありません。さらに、単にオプショナルダウンキャスト（`as?`）で `nil` にしてしまうと、インデックス範囲外での `nil` と、`UIHostingController` にキャストできなかった場合の `nil` が混ざってしまい、「どっちの失敗か」が分からなくなります。ここは意味を分けたいので、`guard` を使って、たとえば `guard let controller = controllers[index] as? UIHostingController<Page> else { ... }` のように書き、範囲外とキャスト失敗を別のパスで扱うのが理想だと思います。チームの方針にもよりますが、自分としてはこれが一番スッキリします。

ということで、これで対象の `UIViewController` がきちんと見つかりました。 文字起こしのテキストをご提示ください。いただいた内容を、ですます調で読みやすく整え、誤字や不自然な表記を適切に修正し、コードはバックティックで装飾して出力します（短いコードはインラインで表記します）。会話形式はセリフに分けず、通常の文章にまとめます。テキストの冒頭が途中から始まっていても、続きから自然になるように整えます。

もし見出しの付与やタイムスタンプの扱い、英単語・固有名詞の表記（英語/カタカナ）などの希望があれば、合わせてお知らせください。 エラーとして扱うなら、ここでは `expect` は要らないですね。`type(of:)` でコントローラーの型を取って、そこでキャストする想定です。もし表示させたいコントローラーがあるなら、新設計にする場合でも、この段階でどこかの変数に取っておく必要があります。とにかく `type(of: controller)` としておけば、この `controller` は上のコントローラーを指します。キャストに成功したら正当な戻り値なので、そのまま `controller` を返します。ここはちゃんと良い感じにシャドーイングしてくれますね。これで良さそうです。

あくまでも、このメソッドが `nil` を返すのはインデックス範囲外だったときだけにします。それ以外の、そもそもの作りのエラーはフェイタルエラーで落とす、という方針です。体裁としてシンプルにしておきます。

次に、この型も同じように値を返すのですが、そのときどうしましょうか。`parentPage`／コントローラーが見つからないケースを想定するかどうか、という点を考えたいです。`parentPage` が絶対に存在するページを指定してくれるなら、必ず取得できます。ただし、`parentPage` の指定が間違っていた場合、それをどこで処理するかが問題です。`parentPage` の制御はバインディングで外部から渡ってくるので、完全に外側の責務ですね。外から渡されたときにちゃんとチェックする、というのが筋です。

コーディネーターが `self` を渡していて、`parentController` があって、ページが元になっている、つまり `page` と `parentPage` の2つが矛盾していないかをどこかでチェックします。矛盾があればロジックエラーとして例外にしてしまう。どこで例外にするかというと、コーディネーターを作るところが一案です。

今回の場合、多分 `nil` を渡すと「ページが何もない」という状態で進んでくれる作りになっていそうです。フラグが全部オフだとページが無くなる、という可能性は考えておいた方がいいですね。さらに、ページが空だったときの `currentPage` の表現は難しいです。そこまで考えないのが普通かもしれませんが、設計としては、ページ数がゼロなら `PageViewController` のインスタンス自体を作れないようにする、という方法があります。

そうするなら、ページはイニシャライザーで渡すようにして、`init` で基本となる `pages`（ビューではなくページの配列）を受け取り、その上で `currentPage` を決める形にします。この段階で許さない条件があります。`guard` や `fatalError` ではなく、`precondition` で表現するのが適切でしょう。つまり「`pages` が空ではないこと」を前提条件にし、空だった場合には落とします。例えば、`precondition(!pages.isEmpty, "ページは1つ以上必要です")` のようにします。空だった場合には「ページは1つ以上必要です」として処理を止める、という方針です。 プログラムを組んでいる最中に、プログラマがページ数をゼロのままこのページビューコントローラーを作ろうとしてしまうと、ランタイムエラーで落ちます。ページコントローラー用にページの配列を用意する手もありますが、それも結構難しく、扱いがややこしいので、今回はこの程度のプレコンディションで妥当でしょう。

もう一つ条件があります。プレコンディションとして、`pages.indices.contains(currentPage)` のように、カレントページが有効なインデックスに含まれているかを確認したいのですが、今回は余計なことをしていて、ページからインデックスに変えたいんですよね。やろうとすると簡単で、`currentPage - 1` なのですが、0から始まるインデックスに変えたいだけです。

Binding の中に用意してもいいのですが、変換用のものも含めて、ページ型といいますか、今はインデックスもページも両方が `Int` 型なので取り違える心配があります。これは意外と無視できない状況になるはずで、そういった取り違えは厳刻な問題を引き起こしがちです。そこで、ページビューコントローラーを拡張する形で、`struct PageNumber` を用意します。`PageNumber` の中ではプロパティとして `var value: Int` を持つようにします。`number` という名前は少し冗長なので、ここでは `value` にします。イニシャライザはメンバーワイズイニシャライザに任せます。

さらに、ちょっとしたユーティリティも追加しておきましょう。`PageNumber` はどう見ても `Sendable` にできますし、`Hashable` にもできます。`next` と `previous` も用意しておくと扱いやすいです。たとえば、右辺の値を使って `var next: PageNumber { PageNumber(value: self.value + 1) }`、`var previous: PageNumber { PageNumber(value: self.value - 1) }` のようにしておくイメージです。

これでページができたら、`controller(for page:)` の引数を `Int` から `PageNumber` に変えられます。こうすることで、インデックスを意味する `Int` 型と、ページ番号を意味する `Int` 型とを、型として明確に分けられるので、取り違える心配がなくなります。こちらのほうが一般的な設計です。

ただし、引き算をしている箇所や `offsetBy` を使う箇所では注意が必要です。オフセットはインデックスに対して行いますが、こちらはページはページです。つまり、ここでは変換が必要になります。この変換はページビューコントローラー側が責務を持つのが自然です。インデックスとページ番号の両方を扱うのはページビューコントローラーなので、ここに変換関数を定義します。

- `static func index(from page: PageNumber) -> Int`  
- `static func page(from index: Int) -> PageNumber`

ここでは名前空間としてページビューコントローラーの中に定義しておきます。API デザインガイドラインに基づいて、`from index` のようにラベルを付けて曖昧さをなくします。返すのは `PageNumber` です。この変換はどういうものかというと、ページは1始まり、インデックスは0始まりなので、`page(from index)` は「インデックス + 1」を `PageNumber` に入れます。逆に、`index(from page)` は「ページ - 1」にします。これでページとインデックスの相互変換ができ、`offset(by:)` のようなインデックス操作も安全に行えます。うん、いいですね。 ここで設定関数を呼び出します。こうすることでコードの共通化も図れますよね。インデックスではなく、`Page.fromIndex` のように、インデックスからページへ変換する機能も用意できました。

次に、コントローラーを作るときの話です。ページ番号を `offsetBy` で扱おうとすると、`offsetBy` はインデックスそのものではありません。なので、このオフセットにも関数（あるいはプロパティ）が欲しくなります。作っておきましょう。オフセット自体はページが知っていそうなので、`static func` ではなく、ページ番号の側に持たせるのがよさそうです。今は0から始まるインデックス、つまりオフセットにしたいだけなので、ページ番号に `var offset: Int` を持たせて、戻り値を `value - 1` にします。こうすることで、ページ番号を0から始まる番号に変換できます。少し曖昧さはありますが、ここはドキュメントコメントで「ページ番号を0から始まるオフセット値で取得します」のようにきちんと書いておくとよいでしょう。普段は端折りがちですが、できれば書いていった方がよいと思います。

これをコンテキストに渡して、インデックスに変換するときには、普通に `let controller = ...` として、コンテキストのコーディネーターが持っているコントローラーを取り出します。コーディネーターはいろいろ持っていますが、ビューコントローラーが持っていれば十分でしょう。その上で、戻り値としてコントローラーの `controllers` を参照し、そこでインデックスに `offset` を与えて取り出す、という形でよいと思います。 インデックスから作るときには、これは厳密にやろうとすると意外と面倒かもしれません。ページ番号をインデックスから求める場合、インデックスが0から始まるとは限らないという考え方が必要です。`Collection` であれば、`distance(from: startIndex, to: index)` を使って、`startIndex` から与えたインデックスまでの距離を求めます。こうすると正しい距離が取れるので、その距離が取れたらページ番号の値（整数）にできます。距離が0とか1とか取れているので、このページ番号に反映すればよいわけです。

スタートページを持っておいたほうがいいのかなと思いましたが、スタートページを状態として持つと厄介です。そこでコメントで「ページ番号は1から始まる」という前提を明示しておくのがよさそうです。つまり、このページ番号は常にスタートが1という捉え方で進めます。

インデックス…というより、`self` の計算としては `self.value`（値は整数）でよく、1ページからという表現にします。静的プロパティにするかどうかは迷いますが、ジェネリック型だと静的プロパティの扱いが面倒なこともあるので、必要なら計算型プロパティで用意するのがよいかもしれません。`self` を返す形にしておく、という感じです。

ページに対して距離（オフセット）を足すという演算自体は、そんなにおかしいものではないと思います。本来は両方同じ型でないと演算を許さないのが基本ですが、ここは少し基本から外しても実用上は問題にならないでしょう。そこで、`PageNumber` の拡張の中で演算を用意します。たとえば、`static func +` と `static func -` を定義して、戻り値は `Self` を返すようにし、左辺（`lhs`）の `value` にオフセットを足したり引いたりして新しい `Self` を返す、という実装にします。イメージとしては `lhs.value + offset` のような形です。同様に引き算も `lhs.value - offset` にします。

さらに、整数リテラルから初期化できるようにしたいので、`ExpressibleByIntegerLiteral` に準拠させます。`typealias IntegerLiteralType = Int` とし、`init(integerLiteral value: Int)` を実装して `self.value = value` とします。これでリテラルからの変換ができるようになります。

加えて、`AdditiveArithmetic` に準拠させるなら、`static func + (lhs: Self, rhs: Self) -> Self`、`static func - (lhs: Self, rhs: Self) -> Self`、それから `static var zero: Self` を定義する必要があります。`+` と `-` はそれぞれ `lhs.value` と `rhs.value` を足し引きして `Self` を返します。`zero` は「ページ番号0」を返すことになりますが、ページ番号として0は実際には存在しないとはいえ、演算上は0になり得るので、ここは `zero` を0ページとして定義してしまって問題ないだろうという判断です。`static var zero: Self { Self(0) }` のような形にします。

ここまで実装すれば、たとえば `prev` は `value - 1`、`next` は `value + 1` で表したくなります。ただし、この書き方だと曖昧さが発生します。`value + 1` が `Int` の足し算になってしまい、結果が `Int` になりそうですし、`PageNumber + Int` の演算子が解決されないケースもあります。つまり、`Int` から `PageNumber` に暗黙変換できない、`value` は `Int` です、というエラーになります。

この問題に対処するには、次のどちらかにします。
- 明示的に `Self(value + 1)` や `Self(value - 1)` のように `PageNumber` に包み直す。
- `PageNumber + Int`／`PageNumber - Int` といった混在型の演算子を定義して、`lhs.value ± offset` から `Self` を返す。

いずれにしても、`AdditiveArithmetic` の同型演算（`Self` 同士の `+` と `-`）は実装し、必要に応じて整数オフセット版の演算子を追加してやると、`next`／`prev` の実装やページ移動の表現がすっきりします。 まず、次や前を表すときは `self + 1`（自分自身の次）と `self - 1`（自分自身の前）のどちらが見やすいかを検討します。`self - 1` のほうが見やすそうですね。これでいろいろと処理ができて、オフセットも取れます。オフセットは、値を 1 引けば 0 始まりの `Int` になります。

ここまでを踏まえて上の処理に戻ります。ページ番号を受け取り、コンテキストを受け取り、そこからコントローラーを取得します。そのうえでディスタンスを作り、ページ配列のスタートからそのディスタンス分だけ進めた位置を返すことで、内部では 1 から始まると考えなくてよい設計にできます。最終的な用途としては 1 始まりですが、内部実装としては考えなくてよい、という形になっています。ちゃんとできていますね。

次に `index(fromPageNumber:)` です。これは番号（`number`）を受け取る想定です。`controller(forPageNumber:in:)` も同様に、番号を取り、`in` でコンテキストを渡します。コンパイラから `incorrect argument label` が出ていましたが、引数ラベルを `fromPageNumber` に統一すれば解決します。これで `in context` でコンテキストを渡しつつ、インデックスを正しく取れるようになります。

このようにすると、インデックスがきちんと取得でき、コントローラーの範囲内にあるかどうかを気にして特別な分岐を書く必要がなくなります。コントローラーはインデックスから正しく取れていて、まずインデックスを作り、そのインデックスに対していろいろ処理をしていく、という流れに整理できます。さきほどのコードの間違いはそこでしたね。

命名については、`controllerIndex` のように、何のインデックスかが分かる名前にしておきます。ページ番号は「現在のページ」を示す `currentPageNumber` にします。`currentPage` だと View 側で使っている「ページ」と紛らわしいので、ここでは `pageNumber` を明確に使うのがよいです。

バインディングの `pageNumber` を使いつつ、`currentPageNumber - 1` が `pages.indices` に含まれるかどうかをチェックします。ページ番号に `pages` を対応づけ、`pages.indices` はページ配列に対して使います。さきほどのインデックス生成とも整合します。初期化を先に終わらせてから、イニシャライズの段階での条件として、`currentPageNumber` が `pages.indices` に含まれているかどうかを確認する、という形で書いていくのがよいでしょう。 ページインデックス、ページナンバー、ページに関するプロパティは持たせたほうが良さそうです。ページビューコントローラーの中にいろいろ変換機構を用意したついでに、コンテキストが必要で、コンテキストには `self` が渡っています。ページビューコントローラーの中でコーディネーターをセットしているのですが、`update` の中ではコンテキストは使わなくてよさそうですね。勘違いしていました。コーディネーターはコントローラーを持っているのか、ここではカレントページの範囲外の扱いなどもあり、`self` とコーディネーターの関係がなんとも厄介な位置付けです。むしろコーディネーターがいろいろやったほうがよい気がします。

この `pages` を元にいろいろやろうとしていたのですが、それでいいのかな、これでは `pages` を渡せるだけです。どちらでもよいとはいえ、コントローラーが対応するコントローラーを持っていて、ページの中でも持っています。両方で持つより、外側に寄せたほうがよさそうだと感じてきました。そうすると、ページビューコントローラーにいろいろ用意していたインデックス系は、全部コンテキストに移してしまうのがよいかもしれません。具体的には、インデックス参照、ページナンバー変換、レンジ、インデックスとページナンバーの対応、そしてコントローラーです。コントローラーこそコンテキストが管理しているので、この辺の話はコンテキストに持たせてしまいましょう。

ページビューコントローラーの中のコーディネーターに対してエクステンションを生やして、ページナンバーを用意します。コーディネーターの中でも普通にページナンバーを使うと思うので、`typealias PageNumber = PageViewController.PageNumber` のようにしておくのが良さそうです。こうすれば同じ名前で使っていけます。

これで大体固まり、型合わせのためにもらっていたコンテキストは要らなくなりますね。コーディネーターは自分自身なので、コントローラーへのアクセスでよいはずです。……あ、だめだ。コントローラーがない。コーディネーターはコントローラーを持っている想定でしたよね。ここで使っているのはコントローラーのインスタンスメソッドなので、なるほど、これは `static` では持てないという話になっていたのを思い出しました。コントローラーのインデックス計算（例えばインデックスの前後やオフセット）を扱う以上、`static` ではなくインスタンスが必要になります。

`static` を外して大丈夫か少し不安になってきましたが、進めましょう。どこで `static` を消したのか……消してしまうと実装が必要になります。ひとまず削除して、`index(from: pageNumber)` の実装を用意します。これで実装はOKで、かつコンテキストは不要です。ページナンバー周りも同様に実装を移していきます。つまり `static` はいらなくて、コントローラー側の前のほうに今の実装を貼り付け、コンテキストは受け取らない形にします。こんな感じでよさそうです。 コンテキストは不要で、コーディネーターは自分自身という前提にすると、コントローラーは要りません。こうしたものを省くことで、`return` も不要になります。その結果、表現がだいぶシンプルになってきますね。インスタンスは必要なので、そこは残します。これはこれで良しとします。

次に、このコンテキストが要らないという前提に立つと、「Controller for pageNumber」も不要になります。`index` から `pageNumber(fromIndex:)` を呼べばよいので、コンテキストは不要になります。インデックスが取れたら、そのページを返すだけで大丈夫です。

ここも `currentPageController` はコンテキストが不要になり、プロパティで良くなります。`currentPage` はそれで大丈夫です。それから `currentPageNumberManager` ですが、`currentPageNumber` はあります。検索すると、`PageController` の `currentPage` が取れますね。では、ここは上に選ばれれば出ています。

エンドページとかレンジも取得しようとしていたのですが、ここで立ち止まってしまいました。`return` は不要です。

では、`pageNumberRange` に進みましょう。コントローラーなので、`let startPageNumber = controller.startIndex` で、これに対して `pageNumber(fromIndex:)` を使います。スタートは `startIndex` からページを取れますね。`start` はこれで分かります。`end` は `pageNumber(fromIndex: controller.endIndex)` です。そんなふうにして、これをページナンバーの枠（レンジ）にします。`return` としては `start` から `end` まで、という形にすれば、ページナンバーのレンジが取れるようになりました。

ページナンバーのレンジが取れるようになると、この辺でいろいろできるようになってきます。ここはいろいろありますが、`currentPageNumber` かな。`pageNumber`、そしてここも `pages` のページナンバーですね。ここから `currentPageNumber`、`pageNumber` です。

ここでの条件判定ですが、`pages` に対してではないかもしれません。コーディネーターがまだいませんね。ここでページの範囲内にあるかどうかを言いたかったのですが、ここではできません。コーディネーターを作ったときにエラーを出す形にするのが良さそうです。

コーディネーターを作って、`pages` はもう関係なく、コーディネーターに任せます。コーディネーターの `pageNumberRange.contains(currentPageNumber)` を使って、含んでいなかったら「指定したページが想定するページ内にありません」とします。こうすると、デフォルトにフォールバックして辿るのが少し難しくはなりますが、それでもコーディネーターを作った段階で「現在ページが想定するページの範囲内にない」と分かるので、ここでおかしいと判断できます。

エラーはなるべく指定した場所に近いところで出すことで、原因を特定しやすくなります。エラーを後回しにすることはよくあります。例えば今回のようにページの範囲外にあったときに `nil` を返す、あるいはコーディネーターの中でとりあえず適当な対応を入れて返す、といったやり方です。しかし、渡すのが大変なので、なるべく早い段階で落とすのが望ましいです。落とさなくても良い場合は、誰か適切な人（責務のある箇所）にリカバリさせます。

今回一番早い段階はここなので、もう少し頑張ると `static function` を用意して、そこで検証する形でもいけるかもしれません。とはいえ、少し難しそうですね。 これくらいがいい気がします。`return coordinator` で、これでいいですね。これでコーディネーターができました。ページの範囲内にも入っていることが約束されました、という感じです。こうすると、`updateUIViewController` の中で「ページの中に絶対入っている」わけですよね、ページ番号が。でも、ここでもチェックしておいても別にいいんじゃないかなと思います。どんなに遅くなるものでもないですし。なので、やっておくと安心です。コンテキストのコーディネーターのページ番号（`currentPageNumber`）がコンテンツの範囲内かどうかを判定する条件は、コーディネーターを作ったときにも判断していますが、`updateUIViewController` 側でも軽く確認しておきましょう。これくらいやっておけば心配はないでしょう。

それで、コントローラーを取得する際は、これまでは `currentPageNumber` で取っていましたが、これはもはやコンテキストのコーディネーターの `currentPageController`（オプショナル）が取れないことがある、というお話でしたね。なので、ここで取ったら、もう早い話 `controller = currentPageController` にしようかなと。つまり、`controller = context.coordinator.currentPageController`。もしそれが `nil` なら、指定されたカレントページが範囲外だからそうなるのは確かなんですけど、「現在のページを表示するコントローラーが見つかりません」といった扱いにする、こんな感じでいいでしょう。なんだったらカレントページを表示しておいてもそんなに損はないんですが、`currentPageNumber` のバインディング（`Binding`）をラップして……あ、`currentPageNumber` って `Binding` じゃなかったっけ。`Binding` ですね。これでよいですね。そうするとカレントページのコントローラーがもう取れているので、ここでセットするのは `controller` ですよね。いい感じです。

それでちょっと思い出したんですけど、ページ番号が今、表示の考慮がされていなかったんですよね。ページ番号って明らかに表示形態があります。なので、そこは持っておきましょう。`extension` で `Page`（ページという型）が `CustomStringConvertible` に準拠するようにして、`description` としてどんな表現をするか定義します。`CustomStringConvertible` はこのインスタンスそのものがどういった値かを表現するためのものなので、ここでちゃんとページを表示しないといけません。一番簡単なのはページ番号（整数）をそのまま出す方法です。普通の整数と区別できるようにフォーマットをつけたい気もしましたが、まずはこれでいいでしょう。もう少しやるなら、出番はそんなに多くないですけど、`CustomDebugStringConvertible` にも準拠して `debugDescription` を用意します。例えば、`"Page(value: \(value))"` のようにしておくと、デバッグ時にページ番号が分かりやすく表示されます。こんな感じですかね。

ここまでできたら、全部書けているのかな……本当かな。上からちょっと見ていかないといけないですね。`pages` があって、これはもう——いや、使わない？ あれ、`pages` って使わなくないですか？ ちょっと `pages`。あ、`pages` はここで分かってるか。`parent` の `pages`……コーディネーターって、ああそうか、`parent`、`parent.pages` を見てるのか。なんとなくバラバラにしたくないんですよね。なので少し変えます。`private let pages` にして、ここでページの配列を持たせます。`parent` を読めても `pages` からいきなり `map` をかけて、こんな感じで——これくらいだったら1行でいいかな、`map` をかけてあげて。

ページはさすがに使いますよね。というか、多分使うんですよ。何だっけかな……ページのコントローラーでページを `UIHostingController(rootView: ...)` に持たせているから、もういらないか？ いや、でも入れておいていい気がしますね。ページビューコントローラー（`UIPageViewController`）を持っているときは、これは `pages` です。`pages` を受け取る形にして……ページ、ですね。 イニシャライザは親のものではなく、`ParentPageController` 側に置く想定ですね。`ParentPageNumber` が参照できなかったのは、`parent` 側に定義があるからで、親がない場合には一式を全部持ってこないといけなくなる、という状況です。この辺りは一昨日指摘された「管理がバラバラになっている」という問題が確かにありそうだと感じてきたので、少し直していきます。`parent` はここまで、という切り分けにしておきます。

まず上から見ていくと、ここで親ページを作っていて、ページ自体は自分で保持しています。コンテンツはここですね。`pageNumberRange` などはこのままで良く、コントローラ周りが少しややこしくなってきました。中身が増えてきたので、ページナンバー関連を移動しましょう。ページナンバーはここです。定義はこの辺です。`extension` でまとめていましたが、いったんカットして、この辺りに `PageNumber` を移します。続けて、この `PageNumber` 型の中に置いていたもののうち、まだ `PageViewController` の中に残っているページナンバー関連を持っていきます。`PageCoordinator` はここにあって良いです。`PageViewController` と `PageNumber` はこれで準備できました。

`Foundation` は使っていないので、`import Foundation` は外します。これで `PageViewController` の大枠は整ったと思います。

読み直していくと、ページを持っていて……あれ、ページは持っている。コンテキストはページを持っていなかったでしょうか。`Coordinator` は持っていないのかな。`extension` の順番が分かりにくいかもしれないので、`Coordinator` の定義の下に関連するものを持っていきたいですね。順番が分かりにくいのですが、昔の C 言語のように順序が厳密に大事というわけではなくなったのはありがたいところです。

`Coordinator` は `parent` と `controller` を持っていて大丈夫ですね。ただ、`controller` という名前はあまり良くないかもしれません。ページから作っているので、ページのコントローラですよね。今のうちに名前を変えておきます。`PageController` で良いと思います。こうすると、ページとページコントローラの対応が分かりやすいですし、インデックス周りもそのままで問題ありません。

- `pageNumberRange` は、`PageController` の `start` と `end` から変換していく形で OK です。
- `index(from pageNumber:)` は、`PageController` のインデックスの `start` からページのオフセットを動かして求めます。
- `pageNumber(from index:)` は、`PageController` の `distance` を取り、その分を `startPage` から足して求めます。

`controller.perform(pageNumber:)` も大丈夫そうです。`controller.index` を取って、そのインデックスが範囲に入っているかどうかを先にチェックします。ページでガードしても良いですが、インデックスのほうが早いと思うのでこれで良いでしょう。そのうえで、インデックスから直に取り出して返します。`currentPage` は `currentPage` から取得し、`currentPageNumber` も同様に扱います。この辺りの構成で問題なさそうです。

ビルドエラーになっているのは、`currentPageNumber` を渡すところですね。`PageView` でページ数や `PageViewController` のページ数をバインディングで扱っていますが、まだここに setter を作っていない、という話でした。`@State` の `pageNumber` と、`private` な `PageViewController` のページナンバーの扱いを整理します。

1 から始まるページナンバーとして表現している点は、`PageViewController` の中だけの話に閉じなくても良さそうです。`extension` に閉じず、アプリケーション全体のグローバルな定義として `PageNumber` を置いて、「このアプリケーションではこういうページの表現を使う」という位置づけにします。該当箇所をすべて差し替えます。これで `PageNumber` の拡張はグローバル側に移り、`PageViewController` 側に置く必要はなくなりました。

最後に、他の細かい部分も先に直しておきます。内部で使っている `PageNumber` は基本的に省略し、`Coordinator` 周りの整理を続けます。 ここでページ番号を選べるようにして、これでいいか、というところまでできました。次に、ページビューの `pageNumber` として `currentPageNumber` をバインディングしてあげます。あとは、プライベートな PageView のプレビューから…と思ったのですが、`PreviewProvider` ではイニシャライザを定義していないですよね。しかも、`currentPageNumber` を `private` にしているため、ここからは参照できません。@State からどう渡すんでしたっけ、という基本を少し忘れていました。

ページ番号はプレビューでバインドして渡す必要がありますが、イニシャライザがないのは明らかなので、`currentPageNumber` も含めてイニシャライザを定義してあげればよさそうです。こんな感じで用意すれば大丈夫だと思います。このとき、バインディングは `init` から渡すのか、あるいは通常どおり中で指定するのか、という話になりますが、基本は `private` で持つ形で問題ないはずです。

次に、ページ番号の前提として、基本は `pages` が渡され、`pages` が空であってはならない、というのがコントローラーを作るときの大前提になります。コントローラーを作るタイミングで、ページがなければ困るので、とりあえずページ自体は 1 の状態から始めればよいでしょう。それで `currentPageNumber` などは、ここからは外部から与えない、という方針にします。この辺りも、イニシャライザで早いうちに潰しておきたいところです。

`pages` を設定するときに、ここで `guard !pages.isEmpty else { fatalError("1つ以上のページを指定する必要があります") }` としておきます。`fatalError` にするか `precondition` にするかは悩ましいですが、これはロジックエラーでもあるので `precondition` でもよいかもしれません。スピード重視のときに省略するものでもない気がしますし、ひとまずこのままでいきます。

これでページですね。ここがページの配列なので、イニシャライザとして受け取り、`self.pages = pages` と代入します。ここでエラーになっていたのは、括弧や余計な記号が入っていたのが原因でした。不要なものを取り除けば問題ありません。さらに、個人の好みではありますが、すでにページ番号もここで出しておきたいので、`self.pageNumber = 1` のようにしておきます。

今やっていることは、ページ番号で見つけて追いかけていく、というコードの肝の部分です。とりあえずこの状態でページ自体は完全に動くはずです。分かりやすくするために、ページ番号をスクロール関連の表示に出してみるのもありかもしれません。ページの移動はコントローラーの中で行われるので、ページコントローラーの before と after の処理ですよね。リターンする前に、関数の中で `print` して、たとえば「moved to …」のように、`currentPage` を表示させれば、移動したページが分かるはずです。`defer` でメッセージを表示させるようにすれば、最終的にどのページに移動したのかが把握しやすいでしょう。フォワード、バックのそれぞれでログを出すイメージです。

これで実行してアプリを動かすと、コンソールにログが出ます。次に進むと 2 ページ目に行き、ログは「forward …」のように出ますが、「forward 2 → 1」といった表示になるなど、まだ連携できていない様子です。なぜかというと、ページコントローラーのインデックスしかいじっていないからです。`findIndex` でビュ—コントローラーからインデックスを探して「その次」を返しているだけなので、`currentPage` を更新していません。ここはこれから対応していく部分です。

ひとまず `currentPage` を用意するところまではできました。次はボタンです。PageView にボタンを追加して、セカンドビューへ飛ぶためのボタンを用意しましょう。PageView に用意して、それを試してみます。PageView に対してボタンを用意していく、という流れで進めます。 なので、Body の中の `PageViewController` が表示されています。これ、`PageViewController` の中にボタンを作るのかな。`PageViewController` はここか。ボタンとして、ボタンの中で親ページ…ページ番号。これをここで最小・最大を順守しないといけない作りになっていますね。それはそれでいいんですけど、`nextPageNumber` とか、そういうメソッドはあるのかな。ここでページ番号をコントロールできるのか。`PageViewController` が持っている…ページ番号ですね。ページ番号が `previous` と `next` を確か持っていたと思うんですよね。`next` と `previous`、ありました。あれですね。

これと同じ感覚で、mutating な関数、`mutating func moveNext()` と `movePrevious()` か。`moveNext()` を呼んで、この中で `self` を書き換えればいいのかな。`self = .next`。ちょっと効率悪そうですね、これね。`self = .next`。まあいいや、そうしたことじゃない。enum 型を直接書き換えちゃえばね、その話かなと思ったんですけど、まあいいや。`movePrevious()`、そして `self = .previous`。こんなふうにすると直接動かせるようになるので、これで `parentPageNumber.moveNext()`、これで次のページに移動しましょうね。

それでラベルとして `Text` かな。`Text("NEXT")`、`NEXT ページ` かな、というふうに用意してあげると…。For…? あれ、どれじゃダメなんだっけ。「T が見つからない」ね。何だこれ。もう一回動かしてみると、外れた、となるわけですね。これで `NEXT ページ` を押しても動かないし…。まあそうか、`NEXT ページ` を押したときに動かないのか。

`parentPage` があって、`parentPage` はここのスペースになっていますよね。ページビューになっていて、`parentPage` が変更されたときに…あれ、作業が掛からないのかな。Binding が掛かっていますよね、ここでね。`PageViewController` に対してね。それで、`PageViewController` の中で、Binding で `parentPage`（のページビュー）の中で…その中でこの `update`、呼ばれてないのかな。`makeUIViewController` と `updateUIViewController`。ここ、ちょっと `print` してみましょうか。

これで `update`。`update` 出ましたね。これでアプリを押して…これで `NEXT ページ` を押したときに `update` しますよね。`update` がされて、このときのカレントページも見ておけますか。カレントページはコンテキストが持っているのかな…。コーディネーターがカレントページ…コンテキストじゃない。もうダイレクトで持っていますね。`currentPageNumber`。これが Binding だ、だけど…。これはバインドじゃないのか？ いや、バインドだよね。だから `wrappedValue`。こんなふうにしてあげると…と思ったけど、`wrappedValue` がインスタンスから…そうか、Binding で持っているからこれだけでいいんだ。

そうすると、ページ番号が今 1 番ですよね。`NEXT ページ` を押すと 2 番ですよね。数字は変わっていくけど、ここは変わらないですね。番号が変わっているというところまでは OK ですね。

このコントローラーはでもカレントページコントローラーと言いますよね。制御するのが見つかっていますよね、ここね。そうですよね。じゃあ、コントローラーって何かあるんですかね。これで…コントローラーって何かな。こうでしょ、`currentPageNumber` でしょ。それで、この中でコントローラーをちょっと表示してみますね。コントローラーのインスタンスは、これが 407 とかね。400。もう 1 回押すと 400。これで…ない。`currentPageNumber` 必要があるんで、もう 1 回押すと 400。これでないですね、カレントページがね。

カレントページを取るところ、`currentPageController`。ここですね。`currentPageController`、`controller(for parent)` で、カレントページコントローラーで `controller(for:)`。これはここに呼ばれて、ここで一応インデックスと比較してみますか。`print` で、このままにしかなって…これでコントローラーインデックスと、あとページね。カレントページだから、カレントページはどこにいる？ ページ番号か。ページ番号って感じでやって、これで 0, 1。ここがいいですね。もう 1 回押したときに…もう 1 回押せたけど 0, 1。ページ番号 1 が来ていますね。ページ番号が 1 が来てる。ページ番号が 1 が来てる。もう 1 回やってみましょうか。これで `NEXT ページ` やると 0, 1。そうですね。 変わってないですね。変わってない。変わってないとすると、ムーブ…ムーブ…どこだ。ページがあって、ボタンを作ったところが…ボタンはここかな。アップデートが違う。ボタンがネクストページボタン…どこだったっけ。ネクストページ…ネクストページボタンがここで、このボタンを押したときの操作が `moveNext` ですよね。これで `currentPageNumber` は `moveNext` するわけですけど、このときも見てみましょうか。これにしようかな。

`currentPageNumber`、これで押すと…2。そうですね、1から2になりました。もう1回今押したんですけど、`currentPageNumber` はOKで、ボタンを押したら `currentPageNumber` はちゃんと変わりますよ、という状態です。

`currentPageNumber` は `@State` になっていて、このステートが `PageViewController` のほうにバインディングで渡されています。バインディングで、ここね。`currentPageNumber` にバインディングで入っている。この入っている `PageViewController` が、バインディングに対してアップデートが呼ばれたときですよね。そのときにコンテキストで渡ってきて、このコンテキストのページ番号、これがどうなっているかですね。

どうなった…これはメモか。これは良くて、ここにコンテキストの `Coordinator` の `currentPageNumber`。これが `currentPageNumber` ですね。こうなっているときに、これがアップデートでどう変わるかですね。押したときに…1とか。今も1回押したんですが、1。これですね。コンテキストに1のまま来るか…なるほど。なるほどなのか。

これ、`print(context, 1)`。`Coordinator`、`parent`。コンテキストが…コンテキストはコンテキストで、`Coordinator` でしょ。`Coordinator` って1回しか作られないですよね、ここね。`Coordinator`。`currentPage` 自体は `PageViewController` のスコープというか、今回はそれで良くて。そこの差がうかがえるのか、うかがえないのか。コンテキストに渡ってきたのが変わってないというわけですよね。つまり、ページナンバーが `Coordinator` で…コントローラーでしょ。

ここで「0 1 80」…ここら辺は、`update` 出したときには2になってるんですけど、アップデートのときは2になっている。アップデートのとき、そこのときには `currentPage` が2になってますよね。なので `updateViewController`。`updateViewController` のインデックスが、`currentPageNumber` が2になってますね。2になってる。ところが、ここの中で…アップデートの中でカレント…そうね。カレントが2になってるんですけど、バインドですよね。

これで、この中では…ここの中。要は、これが並べてもいいわけだからね。だから `ViewController` はここで用意させておくとして、用意をさせておくとして、アップデートで同じようにここで並べて用意しておきましょうか。これで、このままでね。これでアップデートというか、アップデートで良くて。

アップデートの中の、これは `self`。`self` の中の `currentPageNumber` ね、というのと、そこの中のアップデートの中のコンテキストの中の `currentPageNumber`。で、このときの自分自身…自分自身の `currentPageNumber` は `PageViewController` が `currentPageNumber` をバインディングしてるやつですね。で、もう1個、そっちのものは `Coordinator`。コンテキストとして渡ってきた `Coordinator` の中、その中の `parent` の中にある `currentPageNumber`。だから同じものを指してはいるんですけど、その `parent` ね。これが違ってますよね。バインディングでしょ、こっちもね。そこが気になるんですけど…。

とりあえず、これでもう1回ネクストページを押してみると、これでここですね。自分自身は2なのに、コンテキストは1。このせいか。

このセーパーってなんだこれ。コンテキストの `Coordinator` の `parent` がどうなってるかな。これが例えば、コンテキストの `Coordinator` の `parent` として…とりあえずこれを表示してみますけどね。ここに。そして、これ `in` にしましょうか。ここも `in` にして `self` にしましょうね。これで良く一緒でしょ。`Coordinator` の `parent` の中に自分が入ってますよね。これで見てみる。

そうすると、アドレスはいろいろ長らしくなっちゃって…アドレスが大変だな。なんだこれ、すごいな。たくさん入ってて。あ、そこ構造体とは…これ、`Coordinator` の `parent`。`parent` 自分自身で構造体ですね、これ。だから中身がいろいろ出てきたって…よく分からない、というわけになってるんで、これは `unsafeBitCast` でキャストで、これで `Int` にキャストでいいかな。これでエラーが出た。アドレスのサイズか。なるほどね。これでダメだ。 やりたいこととしては、`self` ではなく、今回は `$currentPageNumber` のバインディングを見たいのです。`$currentPageNumber` からたどれるだけたどって、`parent` の `$currentPageNumber` とアドレスが一致しているのか確認したいのですが、やはり一致していないように見えます。バインディングのページ番号まわりにはいろいろ書いてありますね。アドレスはこれかな……「Unknown Text」と出て、`$...` の表示とともに「4478」という値が見えます。`value` と `range` も出ていて、ページ番号は unknown、`value` は「Page 1」の中でバグっぽく出ているように見えます。「Page 1」「Page 2」になっていて、謎です。こういう差分が出るものなのか、使い方を間違っているのか、どうなんでしょう。

これが出たときのカレントページは、Coordinator から読んでいます。Coordinator 側のカレントページが更新されていないとすると、`UIPageViewController` 側で何とかしないといけない状況になっていて、そこが問題視されます。今どこでズレが出ているのでしょう。`moveNext` はどこだったか……`PageView` の中ですね。`PageView` の中で `currentPageNumber` に対して処理していて、その中で `currentPageNumber` を `next` している。`PageView` のバインディングの中でやっているので、タイミングの問題かもしれません。外と連携を取るには `currentPageNumber` をバインドしているのですが、謎のアップデートが来て、その後にバインドが反映されるのか、それとも自力で反映処理を書かないといけないのか……自力ということはないと思うのですが。

一旦このあたりはワークアラウンドでごまかしていきます。今ここがズレているので、とりあえず暫定のフィックスを入れておきます。`self.currentPageNumber` と Context の `Coordinator` の `parent.currentPageNumber` に反映がされていないようなので、方針を変えて、Context の Coordinator の `parent.currentPageNumber` に自分の `self.currentPageNumber` を代入してみます。本当はこのタイミングでやるのは良くない気がするのですが、これで動くはずだと思うんですよね。

今、SwiftUI でいろいろ書き換えていますが、ちょっと謎の動きが出ています。いろいろ書き換えてしまったので、自分の変更のせいかどうかも分からなくなっています。これで、コンテキストが 1 で `self` が 3 ですよね。`self` が 3 で、コンテキストが 1 のまま。書き換えてもダメですね。Coordinator の `parent`（コンテキスト側）のほうを書き換えてもダメか。今ここを書き換えるのはさすがにまずいよね。書き換えられないかな……やっぱりダメか。分からないですね、これは。

では、ここは ToDo にして、ここで更新をかけてみた、という形にします。これは悪手ですね。やっちゃいけないやつです。たとえ見かけ上うまくいっても整合が取れないので、調査項目にします。そんな感じです。

このあたりで区切ります。ページを自動で埋めてくれたらよかったのですが、残念ながら失敗に終わりました。どこで失敗しているのか、まだ分かりません。

ひとまずこの辺をいろいろ試し、このエクスペリメントまでは済ませました。ボタンを `PageView` に配置して、`PageViewController` のセカンドビューにジャンプする、みたいなこともやるようです。この辺をもう少し詰めていけば、もうちょっとマシな結果が得られるかもしれないので、続きは次回にします。だいぶトレーシングを見てしまったので、今日はここまで。

まとめとしては、まずはカレントページを 1 から始まるインデックスで表現するようにしました。さらに、配列のインデックスの `Int` の型を取り違えないようにしました。また、ページ数が 0 で渡ってきたときにはエラーとして扱うようにしました。そういったところまでの準備をしつつ、今日はこのあたりにします。お疲れさまでした。
