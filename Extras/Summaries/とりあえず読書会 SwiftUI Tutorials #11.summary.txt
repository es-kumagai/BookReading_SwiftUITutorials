Transcription & Summarize : とりあえず読書会 SwiftUI Tutorials #11

はい、では今日も「とりあえず読書会」。SwiftUI チュートリアルを読んでいきましょう。今日はアニメーション系の内容をやるみたいですね。アニメーションというと、SwiftUI って結構簡単にできるというイメージはありますが、自分はあまりアニメーションをいじっていなくて、何ができるのかイメージしにくいところがあります。こういったものは慣れや感覚もあって、得手不得手が分かれたりするのかなとも思います。ただ、ちょっとしたモディファイアを使っていろいろやっていくのが基本だと思うので、その範囲でやる限りでは、そこまでセンスが問われることはないのではないか、という期待もあります。そんな期待を持ちつつ、読んでいきましょう。

ビューとトランジションですね。「Animating Views and Transitions（アニメーションと遷移）」の章です。SwiftUI を使うときに、個別のビューにアニメーションを加えたり、ビューの状態を変えたりして、その変化に応じてアニメーションさせたりできます。エフェクトの有無に関わらず適用できる、という感じでしょうか。ちょっとこのあたりの理解が曖昧ですが、読み進めます。

SwiftUI は、複雑なオーバーラップや組み合わせ、重ね合わせ、中断などを含むアニメーションを柔軟に扱えるようです。アニメーションって中断や再開の扱いが結構大変なんですよね。UIKit のときは工夫が必要で苦労した記憶があります。そういった複雑さをいい感じに面倒見てくれる、ということなのでしょう。リアクティブな仕組みが効いているのだと思いますが、以前読んだ内容を少し忘れてしまっていて、しかも自分ではあまり触れていないので、記憶があやふやです。

このチュートリアルでは、アニメーションするビュー、グラフ、そしてユーザーが Landmarks アプリを使っている間にハイキング（ハイク）をトラッキングするデータを扱います。それを可視化するためのグラフを含むビューをアニメーションさせるようです。なかなか派手な内容で楽しみですね。アニメーションのモディファイアを使えば、簡単にアニメーションできるらしいので、まずはプロジェクトをダウンロードしておきましょう。必要になったときに展開して使います。

ではステップ1。ハイキングデータをアプリに追加します。アニメーションを追加する前に、いくつか準備が必要なようです。このセクションでは、データをインポートし、ハイキングデータをモデル化したものを使います。さらに、スタックやいくつかの事前に用意されたビューを使って、グラフにデータを表示するためのビューを組み立てていく、という流れのようです。まだ具体的に何を指すのかはよく分かっていませんが、読み進めながら理解していきます。 とりあえずプレビュー用のビューを追加するのですね。ステップ1として、まずは先ほどダウンロードしたファイルの Resources に入っている `HikeData.json` をプロジェクトに追加します。Resources グループに入れて、コピーして取り込むように指定すれば、プロジェクト側にコピーされます。OK ですね。できたら、あとは構造体を作っていきます。

ダウンロードしたファイルはたくさんありますが、必要になったらまた元の場所から持ってくればよいでしょう。構造体はモデルですから、`Model` の中に新しく `Hike.swift` を追加します。ここに対になる名前でいろいろ用意しているようですが、数が多いので今回はコピーさせてもらうことにします。`Foundation` を使っていて、フォーマッタ関連なども使っているようですね。自分はあまり使わない気もしますが、何でも知っているのはすごいです。

`struct Hike` は `Codable` にするのに加えて、`Hashable`、`Identifiable` にもしています。今回は Swift 6 対応も兼ねているので、`Sendable` にもしておくとよさそうです。この型なら `Sendable` で問題ないでしょう。これで値を表現していきます。

`Observation` は既に作ってあるとのことなので、`Hike` の構造体の中に定義されているようですね。外側に公開されているなら、`Observation` は外に出しておいてもよいかもしれません。`Hike` の中からコピーしたはずがコピーされていなかったので、改めてコピーしてきます。`Hike.Observation` は `extension` で分離して管理することにします。こうしておけば、ファイルを分けて見やすく保てます。

`Observation` は配列の `Double` で構成されていて、この中で `distanceFromStart` という計算プロパティが定義されています。`Observation` も `Codable`、`Hashable`、`Sendable` に準拠させます。

ここで一度ビルドしてみると、「`Codable` に準拠していない」というエラーが出ます。`Observation` は `Codable`、`Hashable`、`Sendable` に準拠しているように見えるのですが、何かがおかしいようです。`Landmarks` の `Model` の中に入っていますし、配置自体は問題なさそうです。

なお、`Hike.Observation` のファイルが Swift ファイルとして認識されていないようでした。拡張の閉じ方が悪いのかと思いましたが、ファイルタイプを見ても「Swift Source」になっているはずなのに色がつきません。一度ファイルを閉じて開き直しても同じです。いったん「Objective-C」に切り替えてからデフォルトの「Swift Source」に戻す、というのも試しましたが状況は変わりません。明示的に「Swift Source」にしてもダメなので、ひとまず中身をコピーして `extension` として書いておきます。

それでも `Hike.Observation` が見つからないのはなぜでしょうか。ファイルを入れ替えてみても変化はありません。引き続き原因を探ります。 とりあえず、このファイルが別の場所に入っていますね。これは Landmarks モデルの `Hike` の中ですよね。名前が違うかと思いましたが、変わらないので大丈夫そうです。

一度クリーンしてビルドをかけてみます。ビルドで nonzero exit が出ますね。`Hike` の中でここを一度直していきます。`Observation`…`Hike` が違うのかなと思いましたが、`Hike` は大丈夫そうです。コードを見ると `import Foundation` がないので、追加しておきます。シンタックスハイライトの色が付かないのが謎ですね。

こちらでは `Observation` の扱いが全然違う方向に行ってしまっている問題が一つあります。もう一つは、`LengthFormatter` を `static var` で定義しているため、対応していないというエラーになっています。`Hike` という構造体はいろいろなところで使うでしょうから、Actor の境界をまたいで扱うのは良くないですね。フォーマッタは `Hike` のフォーマッタに対して文字列を分けて、距離を `Length` で表現する形です。これは本来インスタンスごとで、`static` ではなく `private let` にするのが自然ですが、`LengthFormatter` が Non-Sendable なので面倒ですね。

`distanceText` は表示に使います。対応策としては、`@MainActor` で縛って、`distanceText` を取得するのもメインアクターにする方法があります。`@MainActor` での `private let`…という考え方もありますが、フォーマッタが全データで共通という価値観でいくなら、`@MainActor static let` でフォーマッタを持たせて共通化するのが良さそうです。`distanceText` がメインアクターなので、そこで呼ばれれば安全です。

ずっとハマっているのは `Observation` 周りですね。`import Foundation` が邪魔しているのかとも思いましたが、さすがにそれはないでしょう。どうしましょうか。ここまで来ましたが、ビルドしてもダメですね。何が起こっているんだろう。プロジェクトを開き直したことで何かがおかしくなったのかもしれません。Landmarks のどこかが壊れている感じでもないのですが…。

もう一回、まるっとコピーしてやり直してみます。そもそも色（シンタックスハイライト）が付いていないのが気になります。Swift ファイルを新規作成して、ファイル名を `Hike+Observation.swift` として作ります。色が付きましたね。コードを貼り付けます。これでエラーがなくなってくれると最高なのですが……どうでしょう。あ、またエラーが出てきました。そうだ、`LengthFormatter` は Foundation にある型なので、`import Foundation` が必要でした。`import Foundation` を入れます。

これでエラーがなくなりました。何だったのかはよく分かりませんが、ひとまず進めます。ここはまだ細かく読めていませんが、`Observation` も大丈夫そうです。とりあえず、ここまでいきました。 Hike 配列をモデルに読み込みましょう、という流れです。hike データの後に、ここで `hikes` は `load` でデータを読み出す想定です。これまでどう作ってきたかを思い出すと、`ModelData` 型の中に入れていましたね。モデルのデータ型としては、`hikes` を配列型にしたいので、`Hike` の配列になります。

ここで型エイリアスを用意しておくと扱いやすいです。`typealias Hikes = [Hike]` のようにしておけば、`Hikes` として定義できます。作っておいた読み込み用の API を使い、`hikes` はバンドル（main bundle）の Resources から読み込みます。たとえば `ModelData` の中で `let hikes: Hikes = load("hikeData.json", as: Hikes.self)` のように型を明示してロードすれば、これで問題ありません。

次に、ダウンロードしたファイルから Hikes フォルダをプロジェクトに取り込みます。Xcode の Project ナビゲータで、Views グループ内の Resources フォルダに、ダウンロードした Hikes フォルダをドラッグ＆ドロップします。その際は「Copy items if needed」をオンにし、「Add to targets」にチェックを入れ、「Create groups」を選択します。これでフォルダごとコピーされます。入ってくるファイルは、たとえば GraphCapsule、HikeDetail、HikeGraph、HikeView などです。場所は指示どおりまず Views の中に入れておけば大丈夫です。これで Hikes 系のファイルが入りました。

続いて、新しいビューに慣れておきましょう（Familiarize yourself with the new views）。読み込んだ Hike データを表示し、HikeView では表示・非表示の切り替えや、グラフの表示、パディングの調整などができるので、ライブプレビューで挙動を確認します。各ステップで実際にプレビューを動かし、出したり隠したりできるかを見ておくとよいです。

次のセクションは「アニメーションを個別のビューに追加する」です。アニメーションモディファイアを同じビューに付けると、SwiftUI はそのビューのアニメーション可能なプロパティ（カラー、透明度、回転、サイズなど）の変更をアニメーションします。さらに、`animation(_:value:)` の value パラメータで「どの値の変化をトリガーにするか」を指定すると、その値が変わったときにアニメーションが開始されます。

まずは HikeView の中でアニメーションを有効にします。ボタンの回転などにアニメーションを付けつつ、特定の状態値が変化したときに動くように、アニメーションモディファイアを追加します。たとえば、最後のボタンのラベル部分に対して、`animation(.easeInOut, value: showDetail)` のように書くと、`showDetail` が変化したときにイーズインアウトでアニメーションします。

これで、グラフのラベルまわり、特に丸いポイントの部分が滑らかにアニメーションするようになりました。動作も確認できたので、まずは OK です。 ついでに、他のアニメーションも追加します。たとえば、ボタンを大きくする（larger）アニメーションです。グラフを表示したときのOKボタンのように見せたいので、`scaleEffect` を状態に応じて切り替え、`1.5` や `1` を入れるようにします。これは `padding` の前に貼り付けます。これで、アニメーションでボタンが大きくなることが確認できました。実際に動きましたね。

次に、アニメーションの種類を `easeInOut` から `spring` に変えてみます。SwiftUI には基本的なアニメーションが事前に定義されていて、カスタムイージングやスプリング、流体的な動き（fluid）っぽいものも含まれているらしいです。アニメーションのスピードや遅延、繰り返し回数なども開始前に調整できます。とにかく今は `spring` に変えて試してみます。

`scaleEffect` モディファイアの上に、別のアニメーションモディファイアを追加します。そして、回転アニメーションは無効化したいので、回転には `animation(nil)` を指定します。SwiftUI のスピン（回転）を使って複雑なアニメーションや異なるエフェクトを見比べている感じですが、とにかく試してみましょう。`scaleEffect` の前に `animation` を入れて、`value` を指定します。これを入れてあげると、ボタンを押したときに回転が止まりました。回転を速くするのではなく、完全にこのスケールのアニメーションに寄せたいわけですね。`rotationEffect` 側は `animation(nil)` にして、`scaleEffect` に対しては `padding` をどうするか試しつつ、`animation(.spring())` はその後から発動する、という挙動になります。組み合わせ方が面白いですね。

次に、次のステップへ行く前に両方のアニメーションをいったん外します（remove）。とりあえず体験してみよう、という意図だったのかもしれません。ひとまずそのようにしておきました。

ここからセクション3です。アニメーションエフェクトを変更したときの効果についてで、どのようにアニメーションが個別のビューに適用されるかを学びます。値が変更されたタイミングでアニメーションを適用する、という考え方です。アプリは、ある値が変化したときに、その変更にアニメーションを適用していきます。

まずステップ1として、`showDetail.toggle()` を `withAnimation` で包みます。`showDetail` プロパティに影響する両方のビュー、つまりディスクロージャーボタンと `HikeDetail` ビューにアニメーション付きのトランジションを持たせる狙いです。まだ少し難しく感じますが、やることはシンプルで、`HikeView` の中のボタンで `withAnimation { showDetail.toggle() }` と書きます。ボディの中に、先ほどの `showDetail.toggle()` を `withAnimation` で包んで置いてあげる、ということですね。これで良さそうです。少しサイズ感が小さい気がしたので微調整しつつ、とにかく `withAnimation` で対応しました。 次に、アニメーションをスローダウンして、SwiftUI のアニメーションがインタラクティブで、どのように割り込まれるかを見ていきます。4秒に設定します。`withAnimation` 関数に 4 秒のイージングを追加する、つまり `.easeInOut(duration: 4)` を使います。先に試してみましょう。`withAnimation(.easeInOut(duration: 4)) { ... }` のように書きます。同じ種類のアニメーションを、ビューのアニメーション用モディファイアと同じような値として `withAnimation` に渡せる、ということですね。

これで、練習として操作してみます。グラフを閉じたり開いたりして、動きを確認します。とても遅いですが、4秒かけてちゃんと動いています。これは動きを観察するための設定です。途中で操作を割り込ませると、その途中から自然に戻っていくように見えます。これはすごいですね。

ステップ4です。続ける前に、`withAnimation` 関数のデフォルトアニメーションに戻すため、入力パラメータを削除して `withAnimation { ... }` だけにしておきます。さきほどの設定は練習用だったようです。パラメータを抜いて OK なので、次に進みます。

ここからは、ビューのトランジションをカスタマイズします。規定では、ビューは画面上／画面外への出入りをフェードイン／フェードアウトで行いますが、この挙動は `transition` モディファイアでカスタマイズできます。今回は、条件付きで表示される HikeView にトランジションを追加して、`transition(.slide)` にします。これで、グラフが表示されるとき、また非表示になるときに、どのように動くかを確認できます。 トランジションの`slide`を追加すると、`withAnimation`を付けたことによって、ボタンが押されたときに詳細がトグルし、その部分に関連する要素がアニメーションします。これがスライドという意味ですね。横から出てきて右へ行く動きで、面白い作りだと思います。とりあえず、`slide`はできました。

次に、トランジションを抽出して整理します。`static`プロパティを使って`AnyTransition`を`extension`で拡張し、新しいプロパティに`transition`モディファイアからアクセスできるようにします。構造的には「展開するアニメーション」のことを指していて、`transition`を`static`プロパティとしてまとめ、各ビューの`transition`にベタ書きしないで、新しいプロパティ（たとえば`AnyTransition.moveAndFade`）にアクセスする形にします。こうすることで、リユーザブルなコードをクリーンに保てます。抽出して`extension`にまとめ、`transition`モディファイアでその新しいプロパティを使う、という流れです。

この`moveAndFade`のようなトランジションは、Transitionsという新しいファイルに切り出しておくのがよさそうです。先ほどコピーしたコードを貼り付け、`moveAndFade`が返るようにしておけば、アニメーションを管理しやすくなります。

さらに、SwiftUIの`move(edge:)`トランジションを使って、ビューのスライドが常に同じ側から行われるようにそろえます。具体的には、`move(edge: .trailing)`のようにして、後端側からのスライドになるように設定を追加していきます。 とりあえず、現状のアニメーションを見ておきます。こうやって左から出て、右へ抜けていく、というムーブです。これをカスタマイズするには、上の Transitions の設定を調整すれば大丈夫、という話ですね。

「ムーブ、エッジとして、トレーディング」と言っていたのは、`move(edge: .trailing)` のことです。「アシンメトリック」は「非同期」ではなく「非対称」の意味ですね。まずはモディファイアを使って、ビューが表示されるときと非表示になるときで異なるトランジションを適用します。挿入（insertion）のときはムーブにフェード（不透明度）を組み合わせ、削除（removal）のときはスケールにフェードを組み合わせます。つまり、`transition(.asymmetric(...))` を指定して、挿入側は `move(edge: .trailing).combined(with: .opacity)`、削除側は `scale.combined(with: .opacity)` にする、ということです。

最初に「ムーブ&フェード」を別の場所に書こうとしましたが、そこではなく、入れるべきはトランジションの指定箇所でした。`AnyTransition.asymmetric` を使うイメージですが、明示的に `AnyTransition` と書かなくても良さそうです。最終的には、`transition(.asymmetric(insertion: .move(edge: .trailing).combined(with: .opacity), removal: .scale.combined(with: .opacity)))` のようになります。これで次のセクションに進みます。

では確かめます。こちらを見て、ボタンを押すと左から出てきて、もう一度押すと消える、という結果です。この非対称性はなかなか強烈ですね。少し驚きましたが、とにかくそういう動きになりました。

続いてセクション5に入っていくようです。「Compose Animations」、つまり複雑なエフェクトのアニメーションを「構成」して作るという話です。まずは読み進めていきます。今いじると知識不足で手に負えなくなる予感があるので、ひとまず読みます。

グラフを使って、3つの異なるデータセットを、バーのボタンをクリックしたときに切り替える、という内容のようです。このセクションではアニメーションを構成して、グラフを動的に見せる、いわゆるリップル（波紋）風のトランジションを付けていく感じらしいです。

ステップ1として、HikeView の中で、異なるデフォルト値を設定します。`showDetail` を `true` に変える、そしてプレビューをキャンバスにピンで固定する、という手順です。こういうところを書き換えるのは少し怖いですよね。今できあがっているところから、開発中だからといって `false` の `showDetail` を `true` にするのは、あまり良くない気もします。インターフェースで切り替えられるように用意した方がいいのではないか、と思いました。まあ、ひとまず今回はそういう方針で進めます。 ピン留めしたら、`HikeGraph` の方へ行って、新しいリップルアニメーションを用意し、それを各々の `GraphCapsule` に適用していきます。まずはアニメーションにリップルを追加していく、つまり「アニメーションに `ripple` を追加する」というのを最初にやるのがセオリーのようです。開発しやすくするための準備ですね。

そこで、`Animations` というまとまりを作って、UI 側で今コピーしてきたコードを貼り、これからこのリップルをいい感じに固めていく、という流れになります。リップルを作ったら、`GraphCapsule` の中でそのリップルを適用します。`HikeGraph` の中で貼るのではなく、`GraphCapsule` の責務として持たせる形です。`body` で `GeometryReader` を返しているところがあって、そこに `GraphCapsule` が組み込まれています。アニメーションを `ripple` にすると、これでリップルアニメーションが適用されます。いいですね。

次に、アニメーションを切り替えて、スプリングアニメーションに変えます。`spring` はバネのことですね。`dampingFraction`（減衰率）を下げて、バーが少し跳ねるような見た目にします。`dampingFraction` って何だろうと、一瞬英語の単語がたくさん出てきて混乱しますが、ここでは「どれくらい早く振動が収束するか」を決めるパラメータだと理解すれば大丈夫です。アニメーションをスプリングにして、`dampingFraction` を下げることで、エフェクトがわかりやすくなります。

この状態で効果を確認します。`Elevation`（標高）、`Heart Rate`（心拍数）、`Pace`（ペース）を切り替えることで、アニメーションの違いが見られるはずです。ライブプレビューの中で、標高・心拍数・ペースを切り替えつつ、アニメーションの効果を確認できます。

コード的には、アニメーションをスプリングにして `dampingFraction` を `0.5` にします。例えば、`animation(.spring(dampingFraction: 0.5))` のようにします。これを追加…というより、アニメーションに対して設定するイメージです。デフォルトアニメーション（`Animation.default`）ではなく、戻り値としてスプリングアニメーションを指定するので、デフォルトは不要です。最初は「何が起きた？」と思いましたが、実際にはデフォルトのアニメーションをもう一度指定していただけでした。デフォルトのままだとバーは跳ねません。スプリングに切り替えると、ちゃんと跳ねるようになります。

それから、`delay` も使います。`Animation` に `.delay(...)` を連結して、インデックスに応じて遅延をずらすと、リップルっぽい見え方になります。つまり、`index` を受け取って、`delay(Double(index) * 何ミリ秒相当)` のように指定します。`ripple` 用に `index` をどう渡すかについては、API デザインガイドライン的にどうするか少し悩みますが、例えば `ripple(index:)` のように引数名をはっきりさせるのがよさそうです。

あとは、必要に応じて `.speed(...)` を組み合わせて全体の再生速度を調整できます。`Animation.spring(dampingFraction: 0.5).speed(2).delay(...)` のように重ねると、より分かりやすいレスポンスになります。いずれにしても、デフォルトのアニメーションをやめて、`spring` に切り替え、`dampingFraction = 0.5` として、`delay` にインデックスを掛ける、というのがリップルアニメーション実装のコアになります。 とりあえず `Int` を受け取るようにして、アニメーションをまず見てみます。エラーは渡していないので、エラーはここ、インデックス…インデックスはインデックスで良いですね。これでアニメーションが、ちゃんといい感じにパラパラっと、アルペジオみたいになります。なるほど、少しだけディレイを入れるだけでかなり様になりますね。こういうのはセンスの部分でもあります。

次に、どのようにカスタムアニメーションが提供されるかを観察します。リップル効果やトランジション、`HikeGraph` のトランジションなどを見ていきます。そこは触れられていない気もしますが、理解度チェックに進みます。動いたことが分かったので OK ということで、プレビューのピンは外しましょう。

それから、`HikeView` のこのディテールをピン留めできるか確かめるために `true` にしていましたが、これはデフォルトで良いのかな、そこに触れていたかどうか…。余計なことをすると両方が表示される、という感じになっていたはずです。まずは理解度チェックの前に、動きも見ておきます。リプレイすると右から出てきて、押すとポンポン跳ねます。アクセスボタンを押すと…うん、合っていますね。連打したときの挙動の違いには、ここでは触れられていませんが、まあ良しとします。

理解度チェックです。どうやって、いわば抵抗するというか、アニメーションを抑止するか。`nil` をアニメーションに渡す、というのが一つ。もう一つは `rotationEffect` をアニメーションに入れて打ち消す、という話でしたよね。なぜここで消せるのかと考えていますが、`rotationEffect` モディファイアはアニメーションできないので、それは違うかな。では、ローテーションはアニメーションなしで、というやり方。アニメーションモディファイアでアニメーションさせない、つまり `nil` を渡す方法がいちばん上の選択肢ですよね。これで大丈夫だと思います。ここは自分の訳が甘かったです。「being animated」（アニメーションされること）をどのように防止するか、という話ですね。大丈夫そうです。

次は、プレビューをキャンバスにピンします。アニメーションを開発・チューニングするときに、プレビューをキャンバスにピンすると、現在のフレームで固定して観察したり、部分的に再生して動作をテストしたり、割り込みやステップごとの変化の間の動きを確認したりできます。アニメーションの `duration` を調整して、十分な長さを確保し、観察しやすくするのも大事です。ディレイがあると分かるだけで印象がかなり変わりますし、スローモーションで確認すると全然違いますね。OK です。

次回はコードを見るところからやってみましょう。触れられるところがあれば手を入れて、良い感じに Apple の Human Interface Guidelines に従っているかなども見ていく感じにします。では、今日はこれで終わりにします。お疲れさまでした。
