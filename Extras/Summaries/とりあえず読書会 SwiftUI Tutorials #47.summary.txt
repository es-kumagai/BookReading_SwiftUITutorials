Transcription & Summarize : とりあえず読書会 SwiftUI Tutorials #47

大詰めと言えば大詰めで、延々と続いている感じもしますが、チュートリアルの中で作っていたコードのリファクタリングを、補修も兼ねて進めているところです。残すところ、ビュー周りのコードはまだちゃんと見直していないので、今日はその辺りを改めて見ていくことにします。

早速チュートリアルのコードを Xcode で見ていきます。原型を崩しているわけではないのですが、だいぶ大幅に変わっていますよね。カテゴリのフォルダの中、iOS 用の部分から確認します。プレビューも出しておきましょう。今は iOS なので、プレビューを表示しつつ見ていきます。プレビューは少し小さめでよくて、下のウィンドウは不要ですね。そんな感じで進めます。

`ModelData` は良いとして、`Environment` や、`Binding` で `showingProfile` を持たせるところは、あの時にやりましたね。`landmarksByCategory` は `ModelData` から取っていますが、本来なら `ModelData` から直接取ればいいところです。ただ今回の `ModelData` にはいろいろ情報が入っているので、その中でも特定のカテゴリにフォーカスしたいものについては、計算型プロパティとして切り出しておいた方が分かりやすいと個人的には感じます。なので計算型プロパティを用意しているわけです。

`featuredLandmarks` も `Binding` で、`landmarks` を `ModelData` から引っ張ってくるときのものですね。`FeatureCard` はメインで、featured に指定されている landmark を使います。これはすでに `featuredLandmarks` で取得できるので、それを使って `map` をかけていきます。ここで `map` を2回かけるなら、`.lazy` を使った方が中間配列の生成を避けられて速いのかな、と思ってやってみました。2回配列を作るよりは、`.lazy` を挟んで1回でつないだ方が良いのかなという気がして、`.lazy` を付けて試しています。ただ、その後で `wrappedValue` を取り出してから `init`（イニシャライズ）しているので、別に `.lazy` にしなくても良いとも言えます。どちらでもいいのでしょうね。

要は `wrappedValue` が欲しいだけなので、`map { landmark in ... }` の中で `FeatureCard(landmark: landmark)` としてしまえばよく、`Binding` から `wrappedValue` を明示的に取り出す書き方にしなくても済みます。`featuredLandmarks.map { ... }` の形にすれば、この部分はもっとシンプルになります。一般的な書き方としてはこちらの方が多い気もします。

とはいえ、`map` をうまく活用する書き方は表現が簡潔で書きやすい反面、パフォーマンスはどうなんだろう、という気持ちになることもあります。そこで `.lazy` を学んだことで、「こういう書き方もありだな」という評価になりました。他の言語の Haskell は自分は詳しく分かっているわけではないのですが、原則遅延評価っぽいですよね。`map` などをどんどん連結していって、最終的に答えを導くように関数を重ねていくイメージです。

今回の `featuredLandmarks` の今見ている行でも、まず `Binding` から `wrappedValue` を取り出す関数を1回仕掛けて、その次の行（たとえば 27行目）でそれを `FeatureCard` をイニシャライズする関数に渡す、というように関数を重ねる書き方ができます。こうして見ると見やすい気がします。慣れにもよりますが、`wrappedValue` を取り出して、それに対して `FeatureCard` の `init` を適用していく、というスタイルですね。なので、今の自分の気分では `.lazy` を使う方がスッキリするかなという気がしているので、今回はこれにします。

ただ、だんだんブレなくなってきたとはいえ、リファクタリングのときに「こっちがいいよね」と思って直しても、翌日には別の方が良く見えたり、また別の日には前の方が良く見えたり、ということは案外あります。まあそれはそれで、禁じ手さえ踏まなければ大丈夫かなという気がします。思うままにどんどん書き換えていくのは、少なくとも練習のときには良いんじゃないかなと思います。実務ではまた判断が変わることもありますが。 とりあえず、こんな感じで`FeatureCard`は良さそうですね。`body`に入って、`NavigationSplitView`を使っていて、`List`で`landmarksByCategory`を1回取り出しているのは、計算型プロパティだからという理由ですね。何回も取り出すと、その都度計算しないといけません。最適化されるかどうかは分からないのですが、そこに期待するよりは、1回きちんとサクッと取ってしまって、それを使っていくほうが良いと思います。

また、カテゴリーを取った場面と、ここのインデックスアクセスをするときの場面、この2つに怖さがあります。もしタイミング的に並行処理などをやっていて、`landmarksByCategory`が並行で処理されて変化するようなときに、インデックスが壊れて、個数とかが変わると、インデックスアクセスがエラーになってランタイムで落ちたりするじゃないですか。こういったレースコンディションも怖いので、1回ちゃんと値をローカルに確保してしまえば、少なくとも公開プロパティとしての`landmarksByCategory`が変化したとしても、Swiftの値型の特色としてローカルのほうは変化しないので、古い情報のままではあるけれども突っ走ることができます。それが良いかどうかは分からないのですが、少なくともレースコンディションが起こるような場面よりはマシに動くかな、という感じがします。なのでローカルに取って、要はこの出所と同じところからちゃんとアクセスするように書くのが大事です。これは`String`に対する`Substring`でも同じですね。

`String`があって、その`Substring`を取ったとなったら、元の`String`が基準になります。言葉で話していると当たり前なのですが、一度見たことのあるコードで、取り間違えたというか、とにかくアクセスする拠りどころが全然別のものになっていて、`Substring`の元の`String`とは違うところを参照しに行って、なんかおかしくなっているのを見たことがあります。うっかりするとやりかねないのですが、とにかく「そこにあるもの」を基準にする、という意識が大事です。 カテゴリを例えば「Mountains」にして大きく表示します。これで合っているか、良い情報かどうかは、さっきのリプレースを見れば分かりますね。いまこういうふうに開いて、このデータを使ってプレビューをかければ、「Mountains」では項目がなくなるはずです。「Lakes」と「Mountains」では項目がなくなりましたよね。こうしてゼロ件になるものは、そのままではまずいので除外しておく必要があります。そこまで気を配らないといけません。

一度戻します。Ctrl+Z で戻して……カテゴリは残っていますね。ではもう一度実行します。これで「Rivers」と「Lakes」「Mountains」が出てくる状態に戻ったはず……あれ、戻っていない？ `landmarkData` で `Rivers` はカテゴリ……`River`？ 戻っていそうですが、プレビューは今戻っていましたね。これで「Lakes」「Mountains」がいなくなった。もう一回動かす。いなくなったか……何か間違えているのかな。`landmarkData`、`River`、カテゴリは大丈夫ですね。「Lakes」「Mountains」。保存しているんだけどな。保存はしてあって、カテゴリでこれが「Lakes」「Mountains」。フィルターはここ……ここは関係ない気がしますが、フィルターも試してみます。「Lakes」「Mountains」。そもそも「Rivers」が抜けましたね。今のカテゴリで、抜けていないのが出ていない。つまり最初から抜けていたということですね。

`landmarksByCategory` を適当にした後、その段階でリストアップし直していませんでした。だから、なくなっても表示だけは残っていて保存されていなかったわけですね。そうなると検証できていないです。検証できていないのもそうですが、戻ってくるのはどういうことだろう。クリーンすればいいですかね。クリーンしてビルドをかけて、存在が戻ることをまず確認してから考えます。プレビューを再開して……おっと。「Lakes」「Mountains」と「Rivers」ね。「Rivers」が出てくれないと困るのですが、ほら、あれ、いなくなっていると勘違いしていそうですね。

フィルターですよね。フィルターがあって……一度フィルターを外して、それでロックをかけておきましょう。これを見続けておきたい。「Lakes」「Mountains」。これはリスト、リストですよね。リストでバインドして、`ForEach` で `Category` を回して、この `Category` に入っていないということですよね。それで `landmarkData`。これが `Category` などを持っているわけですが、今どうなった？「Lakes」「Mountains」。あれ、もしかして下にいるか？ いましたね。見えていなかっただけか。そうか、そうですか、という感じです。チェックを間違えたかもしれません。まあいいや、そもそも勘違いがあったので、もう少し確実にチェックしていきましょう。

では、`Category` をフィルターします。やろうとした時に `Category` が……これですね。これにもう一つ `Category` があったとしましょう。ダミーを作ります。こんな感じであると、これはランタイムで落ちますよね。多分アサーションで。ゼロ件のもの……あれも落ちるのか。`River`……なんだっけ。ダミーがあって、これだけなら大丈夫ですね。ただ、ダミーのデータが入っていないから成り立っている、ということは `Category` が増え過ぎてダブるというのかな。カテゴリのリストは出した気がするので、まあいいか。こうしてデータを揃えた時ですね。

つまり `ModelData` のロード処理のところです。`ModelData` のイニシャライザで、バンドルの `landmarkData` を読み込んだ後、例えば `landmarks.append(...)`……いや、`append` でいいのかな。`landmarks` はディクショナリですよね。だから、これで `category` として `landmarks`……あ、違う。ここではない。`landmarksByCategory` ですね。`landmarksByCategory` をルーピングして他にも足したい、という意図でした。つまりデータを入れてあげないとダメか。ではここでいいか、`landmarks`……でもダメですね。こうすると必ず入ってくるから。たまたま消えた可能性もありますが、突き詰めていけば大丈夫です。

`landmarksByCategory` は `Binding<[Landmark]>`、要は `landmarks` から由来して作っているので、`landmarks` に存在するカテゴリでしか分類されません。そう考えると、現状は空になることはないですね。別の方法があっても、それが存在しなければ出てこないので、大丈夫といえば大丈夫です。今回はそれで問題ないことが分かりました。

ただ、このあたりは、そう思っていてもまだ把握しきれていない、不安だなというときには、さっきのアサーションを入れる、あるいはフィルターをかけておく、といったことが重要になる可能性があります。そうしておけば、カテゴリがないようなデータを持たない場合でも、デバッグを含めて正しく機能するようになります。このフィルターは結構重要だと思われます。

そうしておけば、「カテゴリを使っていないからランタイムですね」という状況でも守られます。これを7個やらないといけなかったっけ、クラッシュしたのか……いずれにしても、フィルターをかけておけば大丈夫です。

そのうえでもう一度 `Category` 用に戻りますが、この `Category` 用のイニシャライザではアサーションをかけています。同じカテゴリである必要があるかどうかのチェックですね。次に、コレクションのバインド（`Binding<[Landmark]>`）から初期化する実装では、空っぽだったときには `fatalError` で落とす必要があります。 前提条件に当たる話なので、そんなに意識して使い分けなくてもよいと思うのですが、フェイタルエラーは論理的におかしいときに使うものですよね。与えられた引数が妥当かどうかというのは前提条件に当たります。ここをこういう落とし方にするのであれば、`preconditionFailure`（プレコンディションフェイラー）ですね。こうしておくのが、まず後々の判断としても良さそうだという印象を持ちます。実際の動きはわかりませんが、今回は条件分岐で落としていて、その条件判断でクラッシュさせているので、チェックを外しているわけではありません。結果としては `fatalError` と同等な感じになりますが、こう書いておいた方がコードを見たときに「これは前提条件だ」とわかるのでおすすめです。

ただし、先ほどの`guard`文で `fatalError` を使って上のイニシャライザで落としたときはそれで良かったのですが、今回は「上はビルド時以外は動かしましょう」という方針のコードにしている中で、ビルドコンフィグレーションに関わらず必ず落とすのはアンバランスに感じました。もちろん、その方が適切な場合もありますが、今回の場合はそうではないですね。渡す形式が変わって、カテゴリーを明示するのか、それともカテゴリーを全て一致とするのか、といった違いが出る場面なので、この辺りはアサーションで良いかもしれません。この辺は好みかもしれませんが、今見ているイニシャライザの方は間違いに気づきにくい一方で、カテゴリーを明示する方は気づきやすいですね。多分、素直に `landmarks` を渡しているだけなので、「まさかカテゴリーが全て一致になっているのが拾われない」という条件を見落とす可能性があります。であれば、徹底的に落としてあげるのもありだと思いますが、今回はそこまでではない気がするので、ここもアサーションで良いですね。`assert` で「`landmarks` が空ではない」ことを条件に入れてあげて、デバッグでは厳しく落としつつ、リリースランタイムではそこまで厳しくない（無視される）状況を作って進めても問題ないですよね、という感じで、今回はこれで良い気がします。悪くないですね、このコード。アサーションも良い感じに入れていて、落ちる時はパッと落ちますし、リリースビルドなら無視されますからね。

ボディの方に来て、`List` の `Text`、カテゴリーで本当の方を指定しているカテゴリー、この辺ですかね。アプリ側に固定してしまうと分かりにくくなっています。プレビューだけで良いですね。テキストカテゴリーを `Text` で表示して、ここは良いです。`ScrollView` があって、この中で表示している。これも悪くないですし、場合によっては、ここをそっと取り出して別の名前を付けておくのもありかなと思うので、ちょっとやってみましょう。そうすると、カテゴリー用のエクステンションでこれはカットかな。この方はランドマークセル。この中身の、この辺ですね。表示している部分は同じノリです。`LandmarkCell` と同じように、`ScrollView` ではなく、例えば `Landmarks`、`LandmarkList` のような名前のビューを作るのも良いでしょう。

大詰めと言えば大詰めで、延々と続いている感じもしますが、チュートリアルの中で作っていたコードのリファクタリングを、補修も兼ねて高めている感じですかね。残すところ、ビュー周りのコードはまだしっかり見ていないので、途中で部分的には見ていますが、改めて見ていく感じで今日は行きましょう。早速チュートリアルの Xcode で見ていきます。原型を整えていないわけではないですが、大幅に変わっていますよね。カテゴリーのフォルダの中、iOS 用の `Category` フォルダから見ておきます。プレビューも出しておいた方がいいですね。今は iOS なので、これでプレビューを出しつつ見ていきます。プレビューは少し小さくていいかな。下のウィンドウもいらないですね。こんな感じでいきます。

`ModelData` は良いですね、`@Environment`。`@Binding` で `showingProfile` を持たせる。これはそのときにやりましたね。`landmarksByCategory` は `ModelData` から取りますが、普通は `ModelData` から直接取っても良いと思います。ただ、今回は `ModelData` にいろいろ情報が入っているので、その中でもカテゴリーにフォーカスしたいものを計算型プロパティとして用意しておいた方がわかりやすいかなと個人的に感じています。`featuredLandmarks` もバインディングで、`landmarks` を `ModelData` から引っ張ってくるときですね。`FeatureCard` はメインで使うものです。 ランドマークにフィーチャーカードが指定されているものは、すでにフィーチャード・ランドマークスで取得できるようになっています。それを使って `map` をかけていきます。今回は `map` を2回かけるので、レイジー（遅延評価）だと速いのかなと思って試しました。2回イテレータを作るよりは、1つに対して2回 `map` をかけたほうがいいのかなという気がして、`lazy` を付けて見ていますが、まあ多分大丈夫ですよね。

それで、`map` でラップドバリューが取れています。これはバインディングが取れているので、いったんそれをラップドバリューとして受けて、その後に `into` をやっています。だから、別にレイジーでやる必要はないですね。そっちでもいいし、どっちでもいいのでしょう。

要はラップドバリューが欲しいわけですよね。なので、ここでも `map` でランドマークを受け取って、この中でフィーチャーカードとランドマークを使い、ランドマークの `map` でラップドバリュー…あえて今は詳細は省きますが、それで十分ということです。どっちがスマートかは、もう完全に好みですかね。フィーチャード・ランドマークスに対する `map` なので、この部分はなくてよくて、問題はここ。こちらのほうが一般的な書き方かなという気はします。一般に書くときは、ですね。

ただ、`map` をうまく活用していく書き方は書きやすい反面、パフォーマンスはどうなんだろう、みたいな気持ちもありました。そこにレイジーを学んだことで、「まあまあ、こういう書き方もアリだな」という知見になりました。

他の言語の Haskell は自分はそこまで詳しく分からないのですが、少し見たことはあります。自力で書けるには全く至っておらず、雰囲気をつかんだ程度です。ただ、原則として遅延評価っぽいんですよね。なので、`map` などでどんどん連結していって、最終的に答えを導く、というふうに関数を重ねていくイメージです。

今回のフィーチャード・ランドマークスの、今選んでいる行についても、ランドマークのバインディングからラップドバリューを取り出す関数を1回かませて、その次の行でそれをフィーチャーカードをイニシャライズする関数に渡していく、という書き方ができます。こう見ると見やすい気がします。慣れにもよると思いますが、ラップドバリューを取って、それに対してフィーチャーカードに `into` していく、という感じです。なので、現時点の気分では、この `lazy` を使うほうがスッキリするかなという気がするので、今回はこれにしましょう。

まあでも、だんだんブレなくなってきたなという感じはします。バージョンやリファクタリングをするときに「こっちがいいよね」と思ってやるのですが、次の日には別のほうが良くなっていて、また別の日には前のほうが良くなっていて、というふうに案外ブレていたりするものです。まあまあ、それはそれで、この辺の基本さえ押さえていれば大丈夫なんじゃないかなという気がします。思うままにどんどん書き換えていくのは、少なくとも練習のときにはいいんじゃないかなという気がします。日常ではね。 とりあえず、こんな感じで `FeatureCard` は良さそうですね。そして `body` に入って `NavigationSplitView` を使っていて、`List` で `landmarksByCategory` を1回だけ取り出しているのは、これが計算型プロパティだからという理由ですね。何回も取り出すと、その都度計算が走ります。コンパイラやランタイムが最適化してくれるかどうかは分かりませんが、そこに期待するよりは、1回きちんとサクッと取り出して、それを使い回すほうが良いと思います。

あとは、カテゴリを取得した場面と、ここでインデックスアクセスをするときの場面。この2つがズレていると、タイミングによっては並行処理で `landmarksByCategory` が変化して、個数が変わるとインデックスが壊れ、インデックスアクセスがエラーになってランタイムで落ちたりしますよね。こういったレースコンディションも怖いので、一度ちゃんと値をローカルに確保してしまえば、少なくとも公開プロパティとしての `landmarksByCategory` が変化したとしても、Swift の値型の特性によりローカルに確保した値は変化しません。古い情報のままではありますが、そのまま処理を進めることができます。それが常に良いかどうかは分かりませんが、少なくともレースコンディションが起こるような場面よりはマシに動くかなという感覚です。ローカルに取って、要は同じ出どころからきちんとアクセスする、と書いておくのが大事です。

これは `String` に対する `Substring` でも同じですね。`String` があって、その `Substring` を取ったのであれば、元の `String` が基準になります。言葉で言うと当たり前なのですが、実際に、基準とすべき元の `String` とは別のよりどころにアクセスしてしまい、おかしくなっているコードを見たことがあります。うっかりするとやりかねないところです。

この録音には、YouTube Live で配信している「とりあえず読書会」で話した内容が記録されています。元のデータは動画で、その音声部分を抽出したものです。

この読書会は、プログラミング言語 Rust の公式解説書である [The Rust Programming Language 日本語版](https://doc.rust-jp.rs/book-ja/)（以下、The Book）を読み進めるのが目的です。録音は The Book を読み進める内容が中心で、基本的には Rust 言語に着目しますが、他のプログラミング言語や、それに縛られない一般的なソフトウェア理論やソフトウェア工学についても話すことがあります。話し手は「熊谷（くまがい）」という名前で、進行と解説のすべてを務めています。聞き手は YouTube Live チャンネルを見ている人で、チャットを使って話に参加することがあり、話し手はそれを拾いながら話を進めていきます。話し手は、まさに読み進めている The Book のページや、取り上げているプログラミングの話に関係するスライドや資料を画面に映しながら話し、必要に応じてライブコーディングしながら進めていきます。

なお、今回の文字起こし対象の動画は、勉強会の録画動画の一部分です。 今回分の生の文字起こしテキストがまだ届いていないようです。続きの部分のテキストをそのまま貼り付けてください。途中から始まっていても大丈夫です。冒頭が中途半端な文なら無視して整えます。

整形時の方針
- ですます調で自然な文章に整えます（要約はしません）
- 明らかな誤変換は適切な表記に直します（例：Xcode、Haskell、C言語 など）
- コードに該当する部分はバックティックで装飾します。短いものはインラインで表記します
- 複数人の会話でも、発話者ごとのセリフ書きはせず、一続きの文章にまとめます

テキストをお送りいただければ、前回までの内容（Xcode/iOS/SwiftUI の話題など）の流れを踏まえて整形します。
