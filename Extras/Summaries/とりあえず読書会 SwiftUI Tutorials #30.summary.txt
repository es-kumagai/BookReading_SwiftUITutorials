Transcription & Summarize : とりあえず読書会 SwiftUI Tutorials #30

はい、ではとりあえず読書会を始めていきましょう。今日はチュートリアルでApple Watchのターゲットを作成するところが、リファクタリングもだいぶ詰めて大体OKかなというところです。ただ、個人的にはSwiftUIのチュートリアルに沿ってやっていけば問題はなかったんですけど、チュートリアルに沿わないでやっていた部分が若干影響しているので、まずはその流れを直すところから始めていきます。それが終われば、もう一度おさらいして、いい感じにできているか、他に手を入れるところはないかを見て終わりにしたいと思います。

今問題になっているのは、これをエミュレーター上で動かしたとき、Apple Watchのユーザーインターフェースはシンプルに収めておかないと使い勝手の面でよろしくない、という点です。そこは方針として尊重します。ところが、iPhone用に手を加えた部分が残っていて、具体的にはユーザープロファイルを表示する機能です。これはリストにはなかったんですが、iPhoneの場合に追加してしまったんですよね。これを消していく必要があります。今は押しても動かないですが、これは動かせるようにするというより、むしろ動かさないようにしたいです。あるいは、画面を長押ししたときにユーザープロファイルが出るようにする、という形でもよいかもしれません。どうするかは少し迷っています。

やり方をいろいろ忘れてしまっているところがあって、Apple WatchアプリってwatchOS 1の時にしか作ったことがないんですよね。当時は画面を強く押す（長押し）とボタンが出てきて、そのボタンを押すとメニューを選べる、みたいなことができたと思います。そういう作り方も試してみたい気はします。ただ、いずれにせよ、このリストの先頭にユーザープロファイルのボタンがあること自体はあまりよろしくないので、まずは表示しないようにしたいと思います。ここはそんなに難しくないはずです。watchOSであれば、NotificationSceneと同じような感覚で制御できます。ただ、個人的な好みでやや読みにくいと感じるだけで、watchOS自体が悪いわけではないです。

まずは`LandmarkList`ですね。このあたりで、watchOSのときにはボタンを表示しない、という条件を入れていきます。今プレビューを出します。プレビューを出せばすぐ確認できます。プロフィールのツールバーですね。ここで出しているんですが、これはモディファイアですよね。このモディファイアを条件付きで適用できるのかな、というところ。SwiftUIでそういう書き方はできたはずなので、ちょっと書いてみます。とはいえ、プレビューがちゃんと出てからにします。その前に、watchOSでボタンの出し方、特に長押しに紐づくメニューの出し方を調べておきます。

「watchOS 長押し ボタン」みたいな検索だと半端かもしれません。長押しの実装で出てくるのは、UIKitの場合は`UILongPressGestureRecognizer`で、インスタンスを作ってターゲットを設定し、長押しされたときの操作を作る、というやつですね。これは`UI`、つまりUIKitの話です。SwiftUIに限定しましょう。SwiftUIなら、例えば`ContentView`の`body`で`onLongPressGesture`を使って`print("Button long press")`といった実装ができます。長押し自体はそれでわかったのですが、やりたいのは長押しでボタンを出すことです。つまりメニューを出すやつですね。

長押しを認識するだけではなく、メニューを出す実装。`UIButton`ではなく、SwiftUIなら`contextMenu`でしょうか。そう、コンテキストメニューです。ただ、watchOSでどうだったかが問題です。iPhoneなら`contextMenu`でよく見ますが、watchOSのSwiftUIアプリではどうだったか。これは`List`の話ではないんですよね。強く押す（長押し）で出すUIについて調べたい。昔どうやってApple Watchのプログラミングを勉強したのか、ちょっと忘れてしまいました。とりあえず「watchOS プログラミング」くらいで探すと、デベロッパーのドキュメントやUIガイドラインに当たるはずです。ジェスチャーを使ったアクションボタン、という記述がありますが、これはハードウェアのアクションボタン（Apple Watch Ultraの左側のボタン）の話ですね。つまり今回の話ではありません。コンプリケーションでも通知でもなく、デジタルクラウンの話でもないので、この辺は違います。

ではSDKのドキュメント、WatchKitのところを見ます。アプリケーションデリゲート、エクステンション、アプリのライフサイクル、ユーザーインターフェース、Storyboardサポート、コントローラー、アラートアクション、インターフェースボタン……。うーん、どうやってメニューを出すんでしたっけね。ひとまず調べは続けるとして、先に目の前の問題を解決してから考えましょう。プレビューはいったん閉じて、もう一回プレビューを出し直します。その上で、Apple Watchのボタン（長押しで出すメニュー）の表示をどうするか考えます。

シミュレーターで長押しや強押しの入力はどうするのかという話ですが、Xcodeのシミュレーターに「Device > Input」みたいな項目で用意があった気がします。Side Button、Lock、Siriといった項目は見えますが、「長押し/強く押す」みたいなのはなさそうです。昔はこんなに辿り着くのに苦労した記憶がないんですが、メニューの出し方をどうしていたかすっかり忘れてしまいました。watchOS 1の頃にはそれなりにきちんとアプリケーションを作った記憶があるんですけどね。あの頃、何かしらのUIで出ていたんでしたっけ。 Apple Watchのことですね。とりあえず、エミュレーター（シミュレーター）がどこにあるのかを確認したいです。シミュレーターを落とせばいいのかな。この辺は、Xcodeを落とせばいいのかもしれません。いずれにしてもエミュレーターを動かしたいので、いったんクリーンしてみます。Apple WatchのターゲットがAutomaticになっているのですが、別の機種に切り替えて試してみます。この間に、さっき邪魔になっていたボタン、プロファイルツールでしょうか。これを表示にしておけば、何か良いことが起こりそうな気がします。

あとは、watchOSですね。Xcodeをとりあえず落として、シミュレーターも一応落としておきます。こうした上でもう一回動かせば動くでしょうという、楽観的な希望ですが、まあ動くことはありますよね。Xcodeを起動してビルドをかけて、念のため確認します。その後、今度こそプレビューが出るでしょう。そこで、ボタンを消すという作業を進めていきます。その後に、メニューが出せるようなら、それも実装していきたいところです。

プレビューが思うように動かないのかな。Apple Watch Series 11 の48mm、watchOSの今のバージョンで試しています。プレビューが動かないのは少し困りますね。ここにかなり頼っているところがありますから。Apple Watch Series 11 をクリーンしてビルドをかけます。こういうことをやっている間に、もう一回…まあ、まっすぐ終わってくれるのが今回の希望かなと。ビルドをかけて、これでXcodeのプレビューが出てくるでしょう、今度こそ。

ボタンの扱いをどうするか考えながらプレビューを待っています。ボタン、インターフェースの名前というんでしょうか。このメニューがどういう名前なのかによって、探索のしやすさが違ってくると思います。ここから調べられればいいのですが、これも動かないので、モードを変えてみますか。とりあえずビルドしている感じです。今回も、もう一回調べてみます。Xcodeのチュートリアルっぽいものですね。ビルドで終わってしまうやつだと、これを見れば分かるかな。Overview、それからこういうやつで…今ちょうど作っているのと同じ感じですが、まあ良いでしょう。

Apple Watchのプロジェクトを作って、今回はNavigationではないですね。Navigationシーン。チュートリアルで見たようなコードが出てきていますが、やっぱり良い感じに書けている気がします。チュートリアルでは標準のAppオプションは使っていなかったのですが、それで良いですよね。良かった、良い感じに書けていることが分かりました。"It’s interactive" って何だろう。"It’s interactive" か。あとは、Event、Content、Handling、Common State。Continue User Activity、User Activity、Handling User Activity。これを少し見てみます。User Activityはどういうやつなんだろう。"View … from Completion" って何だろう。ActivityでuserInfo…アクティビティか。チェックしていたら終わってしまいました。まあいいか、これはこれで良いです。

そして、アプリケーションデリゲート。デリゲートかな。ドキュメントに戻れば良かったのかな。違いますね。さっきはこっちを見ていたはずが、チュートリアルに飛んでしまったようです。チュートリアルではなく、Lifecycleでもなく、UI…Updateでもないですね。Lifecycleのキーワードを見てみます。Planning、Inactive、Active、Background、Suspending、Handling user actions。

このボタンを消したいんです。これを消すには、この辺でできるかな。watchOSで、ここで `if` を使えばいけるか。`toolbar`。条件が違うか。`!`（not）かな。こうすると…できました。これで基本的にはボタンを消すのはおしまいです。

それから、お気に入りのオン・オフもできるようにしたいです。これもやっぱりボタンを押せるようにしたい。どうするのが良いでしょうね。ここでドットを打てば何か出てくるかな。`popover` とか `toolbar` は出てくるのですが、求めているのが出てきません。とにかく「ボタンを押させたい」。調べるしかないのですが、最近はChatGPTに頼ることが多くなっていて、自力での探索が弱くなっている気もします。分からないので、ChatGPTに聞いてみましょう。watchOSアプリを作っています。 自分のアプリでは、画面を強く押すとメニュー画面を表示できていたと思いますが、UIのアイデアとしてはどうすればよいでしょうか。以前はフォースタッチでメニューを開くUIが存在していましたが、この機能は廃止されました。つまり、いまは中押し（長押し）でメニューを出すことはできません。以前はフォースタッチのUIでメニューオプションを用意していました。フォースタッチといえば、iPhoneでも3D Touchとして提供されていましたよね。今は必要に応じて、明示的に自分でメニューを表示するUIを用意するだけ、という形になったのだと思います。

自分で配置する形としては、コンテンツビューの中で`Menu`があります。これでボタンのアクションを指定して選べます。「このラベルは何だろう」と思うかもしれませんが、`Menu`はラベルをタップ（点々のアイコンなど）するとメニュー項目が表示されます。「どこに点々が出るんだろう」という点は、配置した場所やラベル指定によります。

中押しでメニューを表示するなら、いまはロングプレスジェスチャーを使います。ロングプレスジェスチャーでメニュー表示を有効化し、メニュー表示がオンのときには確認ダイアログ（`confirmationDialog`）を出す、という流れになります。これを少し試してみましょう。

まずはApple Watchでやっていきたいのですが、たとえばリストの中でメニューを作りたいので、`@State`ですね。まずは`@State private var showingMenu`です。`showingMenu`を最初は`false`にして、ロングプレスジェスチャーを`body`に追加してあげる感じです。`body`の`NavigationStack`、あるいは`List`に対して、`onLongPressGesture`を付けます。そこで`showingMenu = true`ですね。

あとは`onChange`…いや、ここは`onChange`ではないですね。確認ダイアログ（`confirmationDialog`）を使います。タイトルは「メニュー」にして、`isPresented: $showingMenu`です。アクションとして、ここでボタンをいろいろ出す、ということだったはずです。`Button`で、またプロフィールのボタンですね。`Button`は名前とアクションです。プロフィールとして、ここでプロフィールボタンを押した場合には、`showingProfile = true`にしてあげる。これでいいのかな。

これで長押しが効いて、メニューに「プロフィール」が出てきました。プロフィール自体はまだ表示していないのですが、ボタンの長押しはできましたね。こんな状態で、まずは「お気に入りのみ（Favorites only）」もやりたいな、というところです。 なので、プロファイルも重要ですけど、この前にプロファイルのボタンってどうなってましたっけね。シミュレーターが動かせないか。あ、そうか、ここでいいんだ。さっきの、これ。動かしたやつ。この中でボタンの名前を出してましたね。`Showing profile`。ユーザープロファイルって名前だったか。でも、長すぎると大丈夫かどうか。これはウォッチの画面としてね。一応、まずは「ユーザープロファイル」にしておいてみましょう。

プロファイルとは別に、あとはトグルか。ここでボタンじゃなくて、スライドするスイッチ。スイッチ、スイッチ。スイッチでいいのかな。トグルか。トグルはどうしたらいいのかな。トグルで用意。`favorite only`。これダメか。トグルはどう作るんでしたっけね。トグルは`body`にあったはず。トグルは`isOn`か。`isOn`と`text`。これ配置してるのかな。これが今のところにできるかどうかですね。なんかできそうな雰囲気は感じるんですけど。でも、これできてもあんまり面白くないかな。まあ、やってみましょう。

長押し。メニュー。あれだけ？ 更新されなかったんじゃないって気がしたんですけど。えーと、なんか動いてる気がしないというか、何というか。これを一応切り替えてみて。`favorite`。長押し。あれ？ 長押し。メニュー。これでメニューの下にある？ 何か。あー、そっか。上だもんね。

トグルはダメか。ボタンにしてみましょうか。ボタンにする場合はボタンの出し分けが重要かな。ボタンの出し分けというか表示での。えーと、面白いですかね。まあまあ。でもまあ。うーん。あ、まあいいか。何個でもいいですかね。

ボタンとしてラベルを表示するときに、ここで`show favorite only`がどうかで、`show favorite only`だった場合には`show all`ですね。そうじゃなかった場合は`favorite only`ですかね。これで、ボタンを押したときに`show favorite only`をトグルしてあげるというね。多分、いい感じにできるんじゃないかなと思うんですが。これで、なんか押してみると出てきた。`favorite only`。もう`favorite only`できましたね。これも一回長押し。ここ、長押しできなかったっぽい。ここがちょっと気になってくるんですが、ここでもできないとね。こんな微妙なところ狙ってらんないですからね。まあ`show all`、これでいい感じに出ますね。

この`favorite only`のスイッチ、これはちょっとOSではいらないですね。なので、これは`body`から、やっぱり`show if`。これはよく使うんですかね。どうなんだろうね、マルチプラットフォームのときね。ここで、`show if OS`。あ、間違えた。あ、えーと、違うか。違うだった。OSを、あのときに送る。うん。こうしてあげると、あれ、`end if`。あ、そっか、`end`か。この辺全部ですね。これで、OKと。

うん、うん、うん。これすごいね。知らなかった。これで小さくなるんだ。このカーブに合わせて。カーブというか、曲面。斜めに出てくる感じにしてたんだ。なんか気にしなかったけど。

こういうとこまで来たとね、長押しが効かないじゃないですか。これはどうしましょうかね。これはどう効かせるんだろう。この辺、僕が押せば、ね、いいでしょうけど。これで`favorite only`にすればね。とにかくできた。

じゃあ同様で、長押しをして、あれ、長押し。長押しをして、あ、できた。ユーザープロファイル。これの表示を作らないといけないですね。これ、プロファイル、バインディング。あ、そうか、コンスタントバインディングしちゃったんだ。表示しちゃったんだから。 アプリケーションを共通化する前提で、`LandmarksApp` の構成を見直します。`ContentView` の中で、watchOS の場合に `.constant(false)` を使ってしまっている箇所があるので、ここを修正していきます。iOS 側もあわせて確認しておかないと忘れてしまうので見直します。iOS 用と watchOS 用でファイルが分かれていると探すのは面倒ですが、仕方ないですね。

まずは `ContentView` です。プレビューは iOS 側にあります。iOS の `ContentView` では、`showingProfile` の `@State` が必要です。大きいデータ（`ModelData`）も持ってきておきます。`ContentView` でプロフィールを表示するには `Environment` が必要なので、`@Environment` の `ModelData` も渡すようにします。

`showingProfile` に紐づく `sheet` は、`body` の中、今回は `LandmarkList` に付けるのがよさそうです。ここに `sheet` を貼って、表示内容を制御します。これまでのように定数を使うのではなく、`if` で分岐して実際の状態に基づいて表示を切り替えます。

watchOS では、`ProfileHost` と `ProfileEditor` までは要らない気がします。Apple Watch だと編集 UI は持たず、表示専用で十分なので、共通で使うのは `ProfileSummary` のみにします。つまり、`ContentView`（OS ごとのアプリ側）で `ProfileHost` を表示するのではなく、`ProfileSummary` を表示します。

`ProfileSummary` を表示する際に、`Environment` から `ModelData` を取得して使っているかどうかを確認します。使っているのであれば `@Environment` の `ModelData` を渡せば大丈夫です。あとは `Profile` を渡せば OK です。`Profile` は `ModelData` が保持していますが、オプショナルになる可能性があるなら、`profile ?? ModelData` 側のデフォルト `Profile` といった形でフォールバックさせます。以前にデフォルトを用意していなかったでしたっけ？もし `ModelData` にデフォルトの `Profile` を用意しているなら、それを使えばよいです。

気になるのは、iOS と watchOS の両方で「プロフィールがなかったらデフォルトのプロフィールを使う」というコードがそれぞれ別に存在してしまっている点です。ルールを変えたときに片方だけ古いまま残る、といったことが起きやすいので、ここは共通化して一箇所で扱えるように改善したいところですね。

要点
- `ContentView` の watchOS 側で使っている `.constant(false)` をやめ、`@State` の `showingProfile` と `sheet` を正しく持たせます。
- `sheet` は `body` の `LandmarkList` あたりに付与します。
- 共通で使う表示は `ProfileSummary` に絞り、`ProfileHost`/`ProfileEditor` は watchOS では使いません（表示専用にする）。
- `@Environment` の `ModelData` を渡し、`Profile` は存在しなければ `ModelData` のデフォルトにフォールバックします。
- iOS と watchOS のフォールバック処理が二重化しないように、デフォルト適用のロジックを共通化する方針にします。 プレビューを表示して様子を見てみましょう。そうすると、Apple Watch 向けのエラーが起きましたね。ビルド設定の問題かと思いましたが、どうやらバッジ周りが関係していそうです。Apple Watch にバッジを表示できるのか、まずは試してみます。

この定義を追加して、このファイルを Apple Watch でも使えるようにしてみます。もし合わないようなら、そのときに考えましょう。ビルドをかけると、どこでエラーになるのか確認します。バッジが見当たりません。これがバッジですね。バッジ関連のファイルも Apple Watch（watchOS）ターゲットに含めるとして、ビルドを進めると、いろいろエラーが出てきます。シンボルや要素の型変換に関するエラーも出ました。

ひとまず気になるところとして、バッジのエラーはありますが、まずは過去に作ったユーザープロファイル関連のコンテンツが watchOS でも大丈夫かを見ます。エラーを落ち着いて確認していけば何とかなりそうです。本当は iOS でビルドできるかも見ようと思ったのですが、結局 watchOS 側のビルドを先に進めます。ビルドログを眺めると、スタイル周りの対応が必要と言われています。次に `BadgeSymbol`。これは `Shape` ですね。`BadgeSymbol` も watchOS に含めるとして、次は何でしょう。`HikeView` が見つからないというエラーが `ProfileSummary` に出ています。`ProfileSummary` の `HikeView` も watchOS に含めて、ビルドを進めます。まだエラーですね。

`AnyTransition` にメンバーがない（no member）というエラーが出ています。`moveAndFade` も別ファイルで定義していましたね。これも Apple Watch で使えるようにしておきます。次はアニメーションの `ripple`。定義はしてありますが、Apple Watch でもこういった表現が使えるのかは少し心配です。まずはやってみて、もし使えないと言われたらそのときに考えましょう。

これでビルドが通るでしょうか。通りそうな気がします。では `ContentView` を見ていく流れにします。プレビューはいったん閉じて画面を整理しておきます。ビルドは通りましたね。実行してみると、どう表示されるか楽しみです。

長押ししてメニューを出し、ユーザープロファイルを押すと…出てきました。バッジも表示されていますし、横スクロールもちゃんと動いています。これを押すと、グラフが下にアニメーション表示されました。少し見にくいですが、動作はしています。この見にくさは改善したいですね。これを押すとこうなって、もう一度押すとこう、と動いています。下に出ている分には良いのですが、`HikeView` の横に長々と出てしまっています。もしかすると、テキストは最初から表示して、グラフも最初から出しておく、という構成のほうが良さそうです。これをやってみましょう。

この変更をするには、OS ごとに条件分岐するよりも、実装を分けてしまったほうが良さそうですね。 このビューは、とりあえずプレビューを確保しておきます。今の箇所は、ここが `View` なので `body` の中ですね。その中でビューとして、プロフィール、あ、プロフィールサマリーがあり、これを iOS と watchOS で分けてあげるのが良さそうです。どうしましょうか。では、`MicView` でテキストコンプリーションバッジをもう一度取りに行っておきますかね。

あれ、出てこない。なんか欲しい…あ、またプレビューが消えた。テキストバッジは、`ScrollView` のどこかで、バッジがいろいろ並んでいたというのがまずありましたよね。それと、コンプリーションバッジのビューと、プロフィールのプロフィールビューとして、`Group` でテキスト…この辺ですね。プロフィールはこれはOKなので、この中でプロフィールとコンプリーションバッジのリセットをします。

`MicView` は、この中で `MicView` を表示する中で…グラフ、これだ。`MicView` を OS ごとに分けてあげればいいんだ。つまり、iOS 専用の `MicView` にして、それを複製して watchOS 用を作る、という形です。これだけだと大変かなと思ったのですが、`MicView` を OS ごとにこういうふうに並べたほうが、分かりやすそうじゃないですか。ふと、そんな気がしました。

それで、watchOS 側の `MicView` は watchOS ターゲットに登録して、iOS からは消してあげます。そして、こちらの `MicView` は iOS 用ですよ、という形にすれば分かりやすそうです。

さらに、watchOS の `MicView` を出すにあたっては、`showDetail` を必ず ON にして、`showDetail` といった条件は何もいらなくて大丈夫です。`DetailView` についてですが、sprinkle.com の `MicView` の中に `DetailView` が利用されているのか。`MicView` として `DetailView` を利用しているけれど、これについては `DetailView` で、まずは…。 とりあえず、親ビュー側で `DetailView` を条件付きで表示するようにすれば、いきなり `DetailView` にいけるので、`transition` なんてのもいらないですよね。そうすると、Move & Fade みたいなアニメーションも、Apple Watch では別にいらなくなるので、これでOKでしょう。

次は `HikeGraph` ですね。`HikeGraph` は表示いらないんじゃないかなと思っています。使わない可能性が高いのですが、無くすと困るかもしれないので、ひとまずコメントアウトしておきます。ランドマークのマークは省いてもいいですかね。名前と距離のテキストは、`VStack` にまとめます。うん、大丈夫そうですね。

それで、show-detail ボタンは、これで `showDetail` をトグルしていますけど、今回はボタンでトグルするようなことはしないので、この `showDetail` ボタンはなしですね。これは確実にいらないでしょう。ということで、`Toggle` を消します。

`HikeView` の `DetailView` の中では、データパスというのと、ボタンアイテムがあります。ボタンは `Elevation`、`Heart Rate`、`Pace` に切り替えられるようになっています。とりあえずそこは良くて、`VStack` でボタン群を置いておけば、いい感じですかね。`VStack` とボタン群、まあいいか。

`HikeGraph` は、ここで `HikeGraph` を表示するようにしていて、`DetailView` 内のボタンでいろいろ切り替えられますが、まずは動くようにしたいですね。`HikeView` の…ここだ。`HikeView` のグラフのところで、上の方でビルドが通っていますね。ここで `HikeGraph` を無くして、上のディテールボタンも無くした。ディテールボタンが無くなって、そこで `DetailView` が…なるほど。`Spacer` が無くなっていますね、そうすると。

これでビルドが通るのかな。ビルドが通るので、まずは `HikeView` のプレビューを見ておきましょう。あれ、間違えた。`HikeView`…`HikeGraph`、`HikeGraph` をやるんだったのかな。`HikeGraph` はこれですね。`HikeGraph` 型は残っているかな。ちょっと復活させます。`HikeGraph` をここで復活させて、`HikeGraph` の `HikeGraph` も復活させて、それでプレビューを。`HikeGraph` のデータを見て、エレベーションだったら…とかがあって、`body` で `HikeObservations`、うん、ですね。それを `GraphView` に表示していると。`GraphView` は普通にいろいろ入っていく感じですかね。

まずはこれだけで。プレビューが…これか。`body` で `HikeView` を見て、テキストが何かあると思うんですが、どこ行ったかな。`HikeView`…あ、そっか、`HikeView` はこれだけってことか。

Xcode でやっているけど、これはスクロールかな。`ScrollView` に入れてあげると、多分、画面を越えて動いているんじゃないのかな。あ、動いてる。あ、出てきた、出てきた。まあ、スクロールしないで、タップ、タップ、タップとかね。ボタンで切り替わる。おお、いいですね。いいけど、全然見えてないですが。スクロールが思うように動かないな。なんだろうこれ。どうしたの。ミスかな。そんな感じで…あ、動いた。シミュレーター。あ、動いた、動いた。ここのグラフはいらないなと思っていて、出てるじゃないですか。 なので、`HikeGraph` の中でそれをやっているはずなんですね。これですよね、`HikeGraph` のフレーム。だから、`HikeGraph` を中から確認すると、何が見えてくるんだろう、という感じです。ここを覗くというよりは、`HikeGraph` のこちら側を見れば良かったのかなと思います。すると、`Text` も覗かれていたような気がしたのですが、そんなことはありませんでした。やっぱり要らないですね。単純に画面から追いやられていただけでした。なるほど。だからこれは要らなくて、`VStack`、`HStack`……なんか表記が変ですね。`VStack` と `HStack` ですが、`VStack` だけで良くなっていますね。`Spacer` とかも要らないので、これで良いですね。で、あとは…。

そして、スクロールがなんとなく気になります。上の方に余白があまりないなという感じがして、ここに `Spacer` を入れると何か変わるんだろうかと思って入れてみたのですが、あまり変わりません。上の方のスクロール領域が余っているのが気になっていて、これは `LandmarkSummary` の中ですかね。`LandmarkSummary` で `Text` でハイク名とハイクの距離を出していますね。`Text` と、そのスタイルで何か調整できるかな。`Font` で `subheadline`。`subheadline` とは、という感じですが、あと `body` でしたっけ。`body` と同じか…。他には…この `body` でいいか。距離はどうしようかな。大丈夫かな。まあいいか。なのでですね…。

それで、距離はできて、グラフがあって、グラフのスクロールが微妙です。これかな、`HikeGraph`。`HikeGraph` はもうカットしましたよね。これは要らない、と。これでサマリーだけ表示するようにして。で、ディテールの方で `Path` があって、大丈夫かな。これでスクロールがうまくいかない。スクロールがうまくいかないのは何のせいだろう。とりあえず、こっちは `Large` にしておいて。まあ、どうでもいいですけどね、それは。で、スクロールは一旦いいか。これで、データパス。

データパスはボタンで使っていますかね。このボタンアイテムたちが横並びですね。`ButtonBar`。`ButtonBar` が、ボタンアイテムを配置して `HStack`。これ、`VStack` にしますかね。`VStack`。縦に分けると、ボタンが押しやすくなるのかなという感じになるね。ここね、ボタン。このボタンも、長押ししてボタンを表示させるっていう手は中途半端ではありますけどね。それでもいいのかなという気はします。ただ、Apple Watch で長押ししてボタンが出てくるとはユーザーは思わない、というところが不安でもあるので、なるべく乱用は避けたい、ない方がいいのかなという感じがします。なので、今回は単にボタンを配置するという形でやってみましょうかね。

これで、ボタンのビューが…まだ表示されないですね。プレビューが表示されないので、いろいろ見ておきますか。また `HikeGraph`。この `HikeGraph` はまだ使っているんでしたっけね。この中で、`HikeView`。プレビューはあるけど。まず `HikeView` は良いとして、`ButtonBar` も良いとして、プレビューが終わらない。スクロールでしょ。`VStack` で、これで OK。`LandmarkSummary` も OK。これで、出ているビューとして表示するのは、グラフの `path` と、あとは `range`。このデータの `range` でしたっけ。で、ハイク情報とデータパスが `@State` であって、ボタンがこれだけあります、という形になっています。`body` で `HikeGraph` と `ButtonBar` が表示されていて、`ButtonView` は、このアイテム、選択されているかどうか、押されたときのアクションを受け取る。ここはそのままで良さそうですね。あとは、`ButtonBar` は `VStack` で表示する。プレビューはまあいいのかな、これでね。 できた気はするのですが、プレビューが更新されていません。コンテンツの方を押してみます。コンテンツは押しましたが、これで動けばひとまず良いですかね。さっきはクリーンしたらプレビューが直ったと思うので、プレビューが表示されないようなら一回クリーンビルドしてみます。クリーンビルドもそうですが、まずは一回実行してみます。これでおおよそできた気がします。

ただ、これだと iOS のビルドがどうなるんでしたっけね。大丈夫かな。エミュレーターの方はいま起動中です。これによって、リスト上の操作をして、長押しでプロフィールを出すことができ、プロフィールを出すとシンプルなプロフィールが見られる、という動きになります。基本は OK ですね。長押しをして動作を確認し、できました。これでユーザープロフィールが表示されます。こうやって見えて、ここで ID の情報があって、ボタンのスペースがちょっと邪魔ですね。あと、エレベーションとか、押されているボタンの見た目が若干違いますね。とはいえ大丈夫そうです。これで動かせました。とにかくボタンの見た目が少し変なので、ここを直せば何とかなりますね。

ボタンとしては、ビューのバー・ボタンで、`DetailView` の中でボタンアイテムをボタンバーで表示しています。ボタンバーの中でスペースが効かない、という感じでしょうか。これで OK かな。あとは `ButtonView` もちょっと気になりました。`ButtonView` のタイトルとタイトルアニメーションに行って、ボタンアイテム、ボタンバーで表示していますが、ここで流し出したいんですよね。これが許されているのは良かったです。

これでユーザープロファイルを見ると、こんな感じでできていて、良さそうですね。若干このボタンは使いにくいですが、まあしょうがないです。とりあえずは良いのかなと思います。それから、この配布データは見えないようにするか、またはボタンで切り替えるのではなく、3 つ全部出しておくという案もあります。その辺は、とりあえずできたので良しとして、リストはできたので、アプリはひとまず完成しましたね。よし、これで OK。

ただし、今のところだと、iOS だけでなく、そうではないプラットフォームでも動きや制約がそのまま変わってしまうはずなので、そこは何とかしないといけません。この上でちょっと気になるのが、グラフの軸です。このグラフの軸は、iOS に限定して書いているわけではありません。いえ、違う、iOS だけとかは書いていないんですよね。なので、ここは共通化したいですね。ただし、共通化にあたってスコープが微妙で、今のところ `private` にしていますが、`private` では効かなくなる場面があるので気になっています。`HikeGraph` 自体も同様です。だから、`HikeGraph` を外に出したらまあまあ良いのかなと思います。

なので、まず `HikeGraph` を選択して外に出せましたっけね。`HikeGraph` まで全部を……どこだ、ここまでかな。選択……あ、ダメか。いやいや、モデルじゃなくて、`View` の中の `Hike`、`Hikes` ってフォルダでしたっけね。`HikeView` はコントロールですか。 コントロールは同じ場所に集約するという発想で進めていました。まず、`HikeGraph`として用意し、`HikeGraph`に関するコードをまるっとコピーして該当ファイルに入れていきます。不要なプレビューは削除します。

次に、SwiftUI の `HikeView` の拡張は、`private extension` ではなく `extension` にして、共通化を図ります。プレビューも、上が `HikeGraph`、下がカプセル（`GraphCapsule`）でしたので、この2つのプレビューをこちらに移しました。これでグラフ部分の分離ができました。プレビューも問題なく動作しています。

iOS 側でも、持ってきた `HikeGraph` の挙動を確認します。`Path` と `body` の扱いは `EmptyView` 相当で大丈夫そうですし、`GraphCapsule` としても問題なさそうです。不要な部分はカットしました。プレビューからは、グラフとカプセルの2つを除外します。これで `HikeGraph` は iOS と watchOS とで分けて対応する形になりました。プレビューも一応確認しましたが、特に問題はなさそうです。

`HikeGraph` が片付いたので、次は `Profile` 側です。iOS かどうかの分岐を入れていない箇所があったはずなので見直します。`ContentView` のプレビューでビルドが通らず、いったんクリーンしてからビルドし直しました。ビルド自体は成功しましたが、プレビューはうまくいっていないようです。ひとまず先に進めます。

プロフィール表示は `List` のビューにあり、`LandmarkList` は共通で書いてあります。watchOS の場合は分岐が必要なので、この中で watchOS のときの分岐を入れます。`List` のほか、長押し、`confirmationDialog`、`Menu` あたりを、`#if os(watchOS)` と `#endif` で囲う形にします。これで watchOS 専用のコードができました。長押しでユーザープロファイルを表示し、閲覧や編集、そして閉じることまでできました。問題なく動作しています。

もう少し整理します。プレビューはいったん置いておいて、ファイル（グループ）構成の共通化を進めます。`Common` ではなく `Landmarks` にまとめて、`Model` として `Hike` は両OSで共通にします。`HikeData` も共通ですし、`CircleImage` も共通で大丈夫です。`LandmarkList`、`ProfileSummary`、`LandmarksApp` も両方でOKです。次に `Badge` も両方で使えるので共通化します。`Controls` 配下も共通にして問題ありません。最後に、`FeatureCard` は iOS 専用という扱いにします。 フェーチャーカードもコントロール扱いですが、この`FeatureCard`はiOSです。こんなふうにファイル名ベースで仕分けしていきましょう。`HikeBadge`と`HikeGraph`は両方（iOSとwatchOS）で使います。`HikeView`はiOSとwatchOSで分かれています。

それから、`ProfileSummary`は…どこだったかと思いましたが、これはiOSですね。watchOSではないです。ビルドをかければ判明すると思いますが、問題なさそうです。`FeatureCard`はiOS、と。`TestImage`は確認済み。`LandmarkDetail`はiOSですね。これは`Landmarks`に入れておきます。

次に`ProfileEditor`はiOS（括弧iOS）。`ProfileHost`もiOSです。この2つはプロフィール関連なので、`Profile`の中に入れておきます。

続いて`Categories`が残っています。`CategoryHome`と`CategoryRow`はどちらもiOS（括弧iOS）。`CategoryHome`はまだ`Views`配下に入れていなかったので、まとめて移動しておきます。これでOKです。

次はアニメーションの`AnimationRipple`。これはiOSだけでよい気もしますが、コードの参照が残っている可能性があります。あ、ありました。「`AnimationRipple`がない」と言われているのは`HikeView`。これは共通。`HikeGraph`も共通ですね。ということで、`AnimationRipple`自体はiOSに限定せず、共通にしておくのが良さそうです。影響も大きくないので問題ないでしょう。ということで`Animation`は共通に。

`ContentView`はiOSです。これは`Views`の中に。アニメーションの置き場所はそこまで重要ではないですが、`ContentView`は`Views`配下に入れます。

それから`RippleStyle`。これも両方で使います。こちらも`Views`の中でOKです。`Transition`はiOSだけなので、iOS側に置きます。

次に`ViewBuilder`。あ、これは`@ViewBuilder`を両方（iOSとwatchOS）で使えるようにするやつですね。なくても困らない類ですが、共通で置いておきます。

こうしていくことで、このあたりの`Views`は一通り移行できました。あ、`PageView`がまだでした。`PageView`と`PageViewController`はiOSですね。なのでiOS側に。ひとまずコピーで対応します。これでOKです。

`PageView`をファイル以下で分けてみましたが、どうでしょう。バラバラのほうがやりやすかったかもしれません。これで`Views`配下が散らからなくなって、個別のものは今のとプレセットぐらいになる、というイメージですね。

ここからはwatchOSです。こんな感じで、`LandmarkDetail`もwatchOSに入れます。`NotificationContent`、`NotificationController`、`NotificationView`、`NotificationPayload`もwatchOS側ですね。これらは`UserNotifications`…ではなく、フォルダ名は`Notifications`として用意しましょう。`Notifications`は`Views`の外にして、このあたりに置いておきます。うん、いいですね。

あとは、`ContentView`と`LandmarkDetail`を`Views`の中に入れてあげて、`LandmarkDetail`はコントローラ……ではなく`Landmarks`だったかな。`LandmarkDetail`は`Landmarks`ですね。ここに入れておきます。これで揃って、いい感じになってきました。

ということで、ファイルの位置は`Views`として整理できました。残りはコードの最適化くらいです。上から見ていきます。共通側、iOS側の共通部分という感じで、ファイル分割もできたので、上からタイプを確認していきます。 文字起こしのテキストを貼り付けてください。  
ですます調で読みやすく整え、誤記は適切に修正します。要約はせず、コードはバックティックで装飾し、短いコードはインラインで表記します。途中から始まる文は無視して次の文から整えます。 文字起こしのテキストをご提示ください。ですます調に整え、句読点を補い、明らかな誤変換（例:「G言語」→「C言語」など）を適切に修正します。コードに該当する部分はバックティックで装飾し、短いコードはインラインで表記します。

もし以下の希望があれば併せてお知らせください。
- 特定の用語・固有名詞の表記ゆれを統一したい（例: 英語表記を維持する、かな表記にする など）
- タイムスタンプやノイズ語（えー、あのー等）を残す／削除する希望
- セクション見出しの付与や最小限の段落分けの方針（詰めて一段落にする／細かく分ける など）

テキストをそのまま貼り付けていただければ、指示に従って整えます。 これは両方で使っていましたよね。問題はなさそうです。次に、`Hike.Observation`。これも情報を持っているだけなので問題ありません。`Image` も問題ないはずですし、さっと書けて良いですね。

`Landmark` は、バインディング周りなど少し面倒な感じがあります。ここはまだ Binding を使う `Landmark` ですね。`extension` がいきなり出てくるのが少し戸惑うところですが、`Landmark` の定義が終わったあとに `extension` をまとめるなど、配置を工夫すれば良いと思います。バインディングで値を入れて変換する部分や、`Sequence` 周りも問題ありません。`LandmarkCategory` も共通で使うものとしてシンプルにまとまっています。

`Coordinates` も問題ないはずです。`ModelData` もおおむね問題ないのですが、デフォルトのプロファイルについては整理したいです。すでにデータに `Profile` があればそれを返し、なければデフォルトを返す、といったメソッドが iOS と watchOS に分散してしまっています。仕様変更の際に watchOS 側だけ反映漏れ、といった厄介な状況を避けるために、このあたりは `ModelData` に集約したいところです。

`ModelData` に `Profile` はありますね。関数を1つ作って、プロファイルがなければデフォルトを取得するようにするのが良さそうです。英語名は少し悩みますが、`useDefault` や `fallback` は意味は通るものの、やや抽象的で自分には馴染みが薄い感じもあります。`profileOrDefault` のように具体的にしても良いのですが、より「有効な値」を返すニュアンスで `effectiveProfile` とするのがソリッドかなという気がします。`PresentProfile` でもよかったかもしれませんが、最終的には「有効なプロファイル」という意味で `effectiveProfile` にしておきましょう。

一時はブール引数で「デフォルトを使うかどうか」を切り替える案も考えましたが、`Bool` の分岐が増えるだけで分かりにくくなるのでやめて、単純に `Profile` を返す関数にします。これで、プロジェクト内でプロファイルを参照している箇所（`ModelData` 内や `PendingProfile` のあたりなど）は、この `effectiveProfile` を使うように差し替えます。watchOS 側でも同じメソッドを使えば、どちらの OS でも同じロジックでプロファイルを取得でき、仕様変更があっても安全です。ここは重要だと思います。

ということで、`ModelData` を修正しました。`ModelData` に関わるところは他も大丈夫そうです。少しコードが長い箇所はありますが、長さ自体は問題ではありません。`Profile` 周りも差し当たって問題ないでしょう。watchOS 用の部分も、前回このあたりを整理・廃止しているので大丈夫だと思います。

次に、リソースはデータなのであれば OK。`Category` のフォームは iOS 側を見ても特にいじっていませんし、watchOS 固有の機能も入っていないので問題なし。カテゴリの色も OK です。`Badge` は watchOS と iOS の両方で使っていますが、同じコードで表示できていたはずなので問題ありません。`CircleImage` も同様で、早い段階から両 OS で使っていました。お気に入りボタンも両方で使っています。`Form` も特に細かいことはしていないので OK ですね。`FeatureCard` は iOS 限定で問題ありません。`HikeBadge` も OK、バッジの表示は問題なしです。

`HikeGraph` は若干変わっているはずで、`Capsule` とグラフがあって……という構成ですが、`HikeGraph` 自体は共通モジュールとして切り出して、同じコードで動くようにしています。これで iOS と watchOS の両方で共通化できています。 ここも大丈夫ですね。コードとしてもややこしいことにはなっていません。`HikeView` の iOS 用は、ひとまず触らなくて大丈夫そうです。まずは iOS 用に細かく作り込んだので、そのおかげで `HikeView` の macOS 版は簡単になりそうという感じです。

実際ここで `LandmarkSummary` と `DetailView` の2つを表示していますが、`DetailView` が少し重いのではないかという気がしています。`DetailView` はいろいろ切り替える想定にしてあり、`BarButtonItem` があって、ボタンの配置はボタンバーですよね。データは `Hike` のデータで問題ありません。`ButtonView` と `BarButtonItem`、このあたりは取り出せます。`ButtonView`、`HikeGraph`、そしてバー・ボタン……`HikeGraph` はどこでしたっけ。ここか。`HikeGraph` は共通でしたね。グラフは共通です。一方で、`BarButtonItem` はインスタンスで使っているので、`DetailView` 自体は良いとしても、`BarButtonItem` と `ButtonView` を `HikeView` 配下に置くべきかどうかは少し悩ましいところです。`HikeView` のボタンなのか、ボタンバーのボタンなのか。`ButtonView` 自体は共通で使えていますが、分離するならアクセスコントロールの観点くらいが論点になりそうです。

`ButtonView` は `HikeView` 専用に限らなくても良いかもしれません。`title` と `isSelected` を持たせるようにしました。つまり、いま `HikeDetail` に実装している `ButtonView` と、その周辺の `BarButtonItem` までをまとめて持ってきて、`ButtonView` を新たに追加します。`ButtonView` は「`HikeView` に限らない」という前提で実装し、UI を変えればボタンは差し替えられますよね。

問題はデータのパスです。ここは `KeyPath` のことです。`DetailView` の `KeyPath` は、ストラクトの中で「`KeyPath` はこういうものです」と定義してあげればOKです。同じようにコピーしてきて、ストラクト内に `KeyPath` を用意すればビルドは通ります。大丈夫ですね。

この共通化によって、`HikeView` の iOS 側ではバー・ボタンやそのほかのアイテム、`ButtonView` を個別に持つ必要がなくなります。これで良さそうです。こうするとだいぶ整理されて、いい感じですね。`HikeView` の iOS 版はやや複雑ですが、macOS 版はそこまで難しくありません、という状態になりそうです。

ただし `DetailView` は少し気になります。同じような作りではあるものの、最後のボタンバーだけが異なるのが気になるので、ここは共通化してしまいましょう。`HikeView` の `DetailView` で、並び替えとボタンの動き、つまり並び順（`HStack` と `VStack`）のあたりだけが違うので、このスタックのコンテナをどう扱うかがポイントです。微妙なアイデアを思いついたので、とりあえず試してみます。

まず `HikeView` の `DetailView` を切り出します。ここから先は製品領域に踏み込みかねないので、正解かどうかは断言できませんが、ひとまず共通化します。`HikeView` の `DetailView` を iOS と macOS の両方に追加し、その中で共通化を図ります。SwiftUI ではなく、トップレベルの Swift ファイルとして用意して、Xcode に読み込ませます。

`HikeDetailView` 用のプロトコル（コンテナ用のプロトコル）を作り、拡張で適用します。これでもうプライベートではなくなりました。続いて `VStack` を `HikeView` の `DetailView` コンテナとして扱う拡張にし、同様に `HStack` も拡張します。コンテンツは関数で `VStack` のコンテナを返す形にし、`alignment` と `spacing` を引数に取るようにします。定義は `HikeDetailView` 向けに持っていきます。

Xcode を起動し直して確認すると、`alignment` が `HorizontalAlignment`、`spacing` が `CGFloat` です。`VStack` はイニシャライザで `alignment: HorizontalAlignment` と `spacing: CGFloat` を受け取ります。最後に「マージン」ではなく「スペーシング」です。こういった形で抽象化できれば、`DetailView` の差分はボタンバー周辺だけになり、残りは共通化できるはずです。 まず、`CGFloat` でコンテンツを扱えるようにして、スコーピングするコンテンツ…という話ではなく、ここは「`Content` は typealias ではなく、`associatedtype` で持つ」という形にします。`Content` は `View`（インターフェース）ですね。

一度ビルドをかけて、`VStack` が要件を満たしてくれるか、あるいは `DetailView` が見つからないと言われるかを確認します。結果として「`DetailView` がない」と言われています。プレビューの中には `DetailView` はありませんが、これは `MyView` の `DetailView` のプレビューなので、ここに置く必要があります。ビルドするとやはり「`DetailView` がない」と言われます。`MyView` の中に `DetailView` がない、というエラーです。iOS 側の `MyView` の `DetailView` が見つからないということですね。見つけられていないようです。

いったん名前などは後で整えるとして、まずはこのエラーだけを見ます。クリーンビルドも試しますが、やはり見つからない。iOS と watchOS の両方が入っている状況でビルドしており、watchOS のほうでも `DetailView` が見つからないと言われています。iOS 側も確認して、`MyView`（iOS）の `DetailView` をいったん外して、`DetailView` を共通化したい意図です。関連するファイル（`HikeDetailView` など）も削除して、ビルドをかけると、watchOS でも iOS でも `DetailView` が見つからない、という状態になります。

ここで一度コピペで検討します。`HikeView` をイニシャライザで受け取っており、`HikeView` の `DetailView` は、`extension HikeView` の中で `DetailViewContainer` プロトコルに準拠した `DetailView` を定義している、という形でした。これで良いはずですが、`extension HikeView` 側が見つからないようです。`HikeDetailView` も見つからないと言われます。

いったん、`HikeView` のネスト型（`HikeView.DetailView`）にするのはやめて、トップレベルの `HikeDetailView` として定義し直します。`extension` が `private` になっていたので、これも通常の `extension` に戻します。ビルドすると「`DetailView` がスコープにない」と言われ、関連箇所がグレーアウトしました。`HikeView` の中の `DetailView` がやはり見つかりません。不思議ですが、ひとまず `HikeView` の `extension` をやめてビルドしても、結局 `DetailView` が見つからないエラーになります。

以前、ファイルを追加したのにターゲットメンバーシップに入っておらず、延々と認識されない…ということがあったので、今回も一度ファイルを作り直します。該当コードをコピーして、`HikeDetailView` をいったん削除し、新しく Swift ファイルとして `HikeDetailView` を作り直します。

ビルドすると、今度は両方のエラーが出ます。1つは「イニシャライザの引数が合っていない」、もう1つは「プロトコルへの準拠が満たせていない」というものです。`HStack`/`VStack` 風のコンテナを実装していて、`verticalAlignment` や `spacing`、`@ViewBuilder` 付きの `content` など、イニシャライザのシグネチャをきちんと揃える必要があります。

`HStack` の場合は `verticalAlignment`、`VStack` の場合は `alignment` です。`verticalAlignment` 自体は `Equatable` かどうかは関係なく、ここでは型を合わせることが大切です。`associatedtype Content` と合わせて、`associatedtype Alignment` のようにして `Alignment` も持たせ、`alignment` を受け取るようにします。さらに、`@ViewBuilder` を付け忘れると「`ViewBuilder` が見つからない」となるので、`@ViewBuilder` をしっかり付けます。

`VStack` のイニシャライザ定義を参考にして、`@ViewBuilder content: () -> Content` の形を拝借し、必要な部分を実装します。`HikeView` の `DetailView` をコンテナとして使いたいので、`DetailViewContainer` に準拠させ、`Content` と `Alignment` を満たすようにします。これで `VStack` コンテナに隠蔽して使えるようにする狙いです。

デフォルト引数が取れない問題は、`extension` でイニシャライザのオーバーロードを追加して対応します。つまり、要求としては `alignment` や `spacing` を受け取らないシグネチャを用意し、内部で既定値を与えて指定イニシャライザにフォワードします。`fileprivate` で十分な可視性にしておき、`extension` に以下のようなイメージで実装します。

- 省略可能版のイニシャライザ（`alignment` と `spacing` を受け取らない）
- 本体で `self.init(alignment: .center, spacing: nil, content: { ... })` のように指定イニシャライザを呼び出す
- `HStack` の場合は `verticalAlignment: .center`、`VStack` の場合は `alignment: .center` を既定にする

この方針であれば、呼び出し側は `alignment` や `spacing` を省略でき、エラーも解消できるはずです。 マージンではなく、`spacing` が `nil` で、`content` が `Content` という形でしたね。こう書けば準拠はできました。同様に `VStack` の方もこれでよさそうです。同じ名前になってしまう件は少し気になりますが、まあそういうものだと考えればよいでしょう。

ここで、まだ `Container` ができていません。`Container` を `View` に準拠させて、ボタンバーや `some View` を返すようにしておきます。`Container` の `content` は `Container` 側で受け取り、`Container` 自身は `View`。その中で `content` を使ってビューを構築し、`content` が `View` であればよい、という設計だったはずです。型は何でもよい想定なので、`ContainerContent` みたいなプロトコルは本来いらないはずなのですが、ビューが `ContainerContent` を返さないといけないと言われてしまい、こちらとしてはこのビュー自体が `ContainerContent` だと思っているのに、うまくいっていません。

`ForEach` の型（`data` と `id` と `content`）のあたりも噛み合っていないようで、無理やり合体させて複雑にしてしまっている感じがあります。`HikeView` の中に置いているのがよくない可能性もあるので、プロトコルは一度 `HikeView` の外に出してみます。これで劇的に変わるわけではない気もしますが、日本語化やジェネリクス絡みで取れない情報も出てくるので、まずは様子見です。

`DetailView` で `Container` に `DetailViewContainer` を指定してみても、やはり同じエラーです。もう一度イニシャライズを試してみますが、`ForEach as` の書き方自体がそもそもおかしいですね。`ForEach` に `Button` と `Item` を渡して、全部を `AnyView` で包むような悲しいやり方を試すとどうなるか。これで `Container` が `AnyView` になるはずですが、やはり推論できないと言われます。`DetailView` の `Container` のところでエラーになっていて、ジェネリックな `struct` は `fileprivate` ではダメだ、と。どうもこちらを `fileprivate` にしてしまったのが原因なので、これはオープンにするしかないですね。

それでも `Container` の問題は残り、ビューが開くだけです。`DetailView` をオープンにすると、`DetailView` の `Container` を作らなければいけなくなります。`HStack` のように定義しなければいけないということですね。そうしてみたのですが、やはり「ジェネリックパラメーターが推論できない」と言われます。後ろに `AnyView` を付けないといけないのかもしれませんが、それはそれでオープンにするしかなく、状況は変わりません。

`HStack` がコンテナーだったかどうか、そこでも「推論できない」と言われました。なるほど、分かりました。推論の問題はここでも同じですね。ここで `Container = AnyView` としているのなら、最初から `Container` を `AnyView` に限定してしまう手もあります。そうすると「non-generic なコンテナーを要求している」と言われます。`DetailViewContainer` はジェネリックのはずなのに、non-generic とは何でしょう。ここに置けばよいのかと試しても、結局は「推論できない」と言われ、ダメでした。

当初は `Container` で頑張りたかったのですが、これはもう、縦に並べるか横に並べるかは使う側で決めればよい、という話に落とし込むのがよさそうです。そうすれば `Container` も `AnyView` も要りません。なぜできなかったのかは、無理やりやっているとよくある話ではありますが、できたと思ったんですけどね。ともあれ、これで `Container` は不要になります。

`HikeView` の `DetailView` でも、`Container` を要求する必要はなくなり、これ自体が `View` であれば十分です。その上でボタンを置いて、プリストップして、`HikeGraph` があって、ボタンバーという構成です。最終的には、横に並べるか縦に並べるかという問題がまた出てきますが、そのときは OS によって切り替える必要があります。`HikeGraph` があるとなると、結局その問題は出てきますね。 では、どう進めましょうか。例えば、コンテナ……あ、そうか。`body` に `@ViewBuilder` を付けて、ここでイニシャライザ相当の関数、例えば片隅に `let f = ...` みたいに書いて、クロージャに `@ViewBuilder` が付いてくるのかな、という発想です。`@ViewBuilder` でラベル名が付いた `content` を受け取り、`some View` を返す、そんなジェネリック山盛りな関数は書けるでしょうか。これで例えば `some View` を返して、イニシャライザにクロージャを渡す、という形にしたい、ということですね。

とりあえずコンパイルして様子を見ましょう。`@ViewBuilder` の取り扱いが認識されていないなどのエラーが出ます。`@ViewBuilder` を付けるなら、`content` は `() -> some View` を返すクロージャになります。`content` という名前が他と衝突して混乱しがちなので、`F` とかにしてみたりしましたが、やはり `Void` を取って `some View` を返すクロージャ、つまり `() -> some View` を受け取るのが正しいです。`HStack(content)` のように返したいのですが、クロージャ名や戻り値の扱いでややこしくなってきました。`some View` を取って `some View` を返す、のような書き方はできないので、この方向はやり過ぎでした。ここはいったんやめます。

同じ目的は、もっと素直に `body` で `VStack` にするか `HStack` にするかを切り替えるだけで達成できます。iOS か watchOS かで、`HStack` にするか `VStack` にするかを悩んでいたわけですが、やることはそれだけです。そこで、`Stack { ... }` の形にして、`Stack` 自体を条件付きコンパイルで差し替える方法にします。

例えば次のようにします。`#if os(watchOS)` のときは `typealias Stack = VStack`、`#elseif os(iOS)` のときは `typealias Stack = HStack`、それ以外はビルドエラーでも構いません。つまり、`#if os(watchOS) private typealias Stack = VStack #elseif os(iOS) private typealias Stack = HStack #endif` のようにしておけば、`body` では単に `Stack { ... }` と書けます。これで OS ごとに `Stack` が切り替わってくれるので、ビルドできます。

ここで使っている View はジェネリックではないので、このままで問題ありません。これでボタンバーの中の見た目は保てました。美しいかどうかはさておき、目的は果たせています。

さらに、この `typealias` は `private` を付けておきたいです。外側に影響しない、このファイルの中だけの話だからです。`VStack` にするか `HStack` にするかという実装詳細は外に漏らさないほうがよいですし、`private` にしておけば「このファイルの中だけで工夫しているんだな」とわかります。ファイルの上のほうに置いておけば最初に目に入りますし、もし気づかなくても「この `Stack` とは何だろう」と定義をたどれば、すぐに辿り着けます。やや不思議な感じがするなら、名前をもう少し具体的にして、`ButtonStack` のようにしておくと、何の Stack か想像しやすくなります。 ボタンのスタックは `VStack` でいきます。これで問題ないと思います。`HikeGraph` の方もこれで大丈夫そうです。`HikeView` を見ていましたが、そこもおおむね問題なさそうです。

iOS 用もこんな感じなので、そのあたりをいじっていました。マップビューは共通で、特に難しいことはしていません。プロフィールツールバーは iOS だけで使うモディファイアなので、これはこれで OK です。スタックイメージについても、特に難しいことはしていません。

`LandmarkDetail` のあたりは、チュートリアルに沿って作った部分なので大丈夫です（多少アレンジはしましたが）。`LandmarkList` には OS 分岐があるはずで、そこが少し気になっていました。ただ、`FavoritesOnly` と `List`、プロフィールツールバー、アニメーション、最後のメニュー表示の部分あたりは、部品に切り出してしまう手はありそうです。

例えば、フェイバリットのトグルは「フェイバリットオンリートグル」のように中身をコンポーネント化して、バインディングを受け取るようにしても良さそうです。iOS に切り替えたときにそれが反映されるようにしておけば、今後 watchOS 版を作るときにも悩みが減ると思います。名前は `FavoriteOnlyToggle` のようにして、`Binding` を受け取る形にすればよいでしょう。

watchOS に切り替えた場合、このあたりのモディファイアは仕方ないので、切り替わったら別のモディファイアを作って対処します。たとえば「watchOS メニューモディファイア」とか「watchOS ランドマークリストモディファイア」のようなものに分けるのが良さそうですが、それを作る価値があるかは微妙なところでもあります。ひとまずモディファイアを作ってみます。

モディファイアを作るには、既存のものを参考にしつつ、`struct ListMenuModifier: ViewModifier` を定義して、`body(content:)` を実装する形にします。これは watchOS 専用なので、ファイルは watchOS 用として分けておきます。プロフィールツールバー側では `body` を組み立て、最終的にモディファイアで返す形にします。つまり、`content` に対してこのモディファイアを適用するイメージです。`showingMenu` のような状態は `Binding` にします。ボタン類はそのまま使えます。これでコードはいったん OK です。

次に `extension View` を用意して、`listMenu(showMenu: Binding<Bool>) -> some View` のような関数を生やします。引数の型は `Binding<Bool>` にしておけばよいでしょう。`Binding` を受け取るので、場合によっては `@State` の値を渡してもよいです。これで OS の分岐をまるっと吸収できるので、必要であれば `LandmarkList` のファイルを watchOS 用と iOS 用に分けて、`#if os(watchOS)` のようなコンパイラディレクティブで切り替えることもできます。watchOS ならこれが要る／要らない、といった切り替えをファイル単位で明確にできます。

`List` も、別のところに分けておけば共通コードとしてよりシンプルになります。`List` の中で `ForEach(landmarks)` のようにしている部分を抽出して共通化すれば、ファイル分割のメリットがさらに出ます。実際に分けてみてもよいのですが、今回は少し面倒なのでいったん保留にしておきます。 とりあえず、そうしますかね。これをリストという形で、`LandmarkList`…ここに名前がかぶってしまっているので、いったんやめたのですが、ここを何らかの型名にすると、ズバッと「この型。iOSだったらこの型、このモディファイアで終わり」という感じになります。watchOS用のファイルを分けてしまえば、その条件分岐はもういらないですよね。つまり、この型とこのモディファイア、さらにこのモディファイア…というふうに、3つか4つくらいの部品感覚で組み立てられるので、ファイルを分けても問題ないと思います。見やすさや保守の面でも問題なくなってくる気がするので、分けるのは良さそうだなと思いました。まあ、ひとまずここまで。

全部は見ていないのですが、大体は確認した気がします。ここは良いでしょう。`PageView`は何もいじっていないですし、iOSの機能です。アニメーションは共有しただけです。あとは、`ContentView`はiOSとwatchOSとデバッグ用の対応をやりました。

このコードは微妙ですね。何か直した気がします。アンダースコアの値、この辺は評価にしていて、まあ仕方ないのかなという感じです。iOSの事情もありますし。スタイルも普通に共有しただけです。トランジションはiOSでしか使いません。`ViewBuilder`はおまけ的な、`print`によるプリントデバッグをやるためだけのコンテンツです。それから、`ViewBuilder`は`#if DEBUG`にしたいですね。デバッグのときに使えれば十分なので、残しておいたほうが良いです。これでビルドは通るはずです。大丈夫ですね。これで良いでしょう。

あとは、`LandmarkApp`は共通なのでOKです。ここももちろんOSで分けていますが、あれくらいなら大丈夫かなと思います。エントリーポイントを分けても良いと思いますけどね。まあ、`#if`をそんなに嫌わなくてもいいかなという気分にもなってきました。`Range`は普通に用意しただけですし、その感じでOKですね。できました。

あとは、アプリがちゃんと動いているかどうかが超重要なところです。例えば、ランドマークの星を外すのか、これ。右クリックで動かない？ どういう動作にしていましたっけ。あ、忘れました。本来動くはずのものが動かない、みたいな状態になっているのかな。長押しにするのかな。

「お気に入りのみ」にすると、とりあえずこれは動いていますね。「お気に入りのみ」というフィルタもちゃんと表示されますね。大丈夫そうです。で、結局どうでしたっけ…全然分からないのですが、どうでしたか。 ディテールはまだやっていなかったかもしれませんが、とりあえずこれでいいことにします。それで、リストですよね。少しだけ見ておきます。リストは、ランドマークディテールではなく…あ、でもランドマークディテールは少し作りましたよね。そうすると、ランドマークリストのほうを見ます。もしかするとメニューが邪魔している可能性があるので、これをオフにして実行してみます。シングルタップをしたときに…あ、押せました。押せたのですが落ちましたね。やはりメニューが邪魔してタップを奪われている感じでしょうか。もう一度だけ試します。これはちょっと問題ですね。どうしましょう。長押し作戦は失敗でしたかね。長押しと短押しで、押せなくなっています。やはり長押しするとメニューが出る都合でタップに干渉します。これは問題なので、次回直すか、メニューを諦めるかですね。メニューを諦めれば早いでしょう。とりあえずはそうしておきます。

納期の都合があるような状況では、ひとまずそれでOKということにしておきます。上にスクロールしていて、Apple Watch の動作はやはり難しいですね。画面が狭いからでしょうか。ここでバリデーションはできるのか…すごいですね。はい、こんな感じで、とりあえずできました、ということにします。iOS も動かして終わりにしましょう。iOS は一回ビルドをかけて、その感じで。ここら辺のところで、長押しは一旦フィックスにします。長押しを有効化すると、リストの各項目を個別にタップできなくなるので、対応が必要です。とはいえ、とりあえずはこれで大丈夫でしょう。

どこでやるのがいいのでしょうね。多分、長押しのジェスチャーと、そうではないジェスチャーを追加するなど、何かしら工夫が必要なのだと思います。シングルタップだったときには、リストで選択しているものを `print` することにするか、またはリストの中にタップジェスチャーを持たせるか、といった対応かもしれません。

今はナビゲーションに置いていますが、これをナビゲーションではなく、丸ごとリストに置いてしまうのもありかもしれません。例えば、このリストに対してツールバーでプロフィールを置く、というのが良さそうです。ここだと `#elseif` でもいいですよね。まあ `#elseif` でもいいのですが、こんな感じでやって、とにかく iOS を先にやります。これは動きそうです。

それで、雪山…リストの雪山をお気に入りにしつつ、プロフィールもとりあえずありました。大丈夫ですね。キャンセルして、watchOS に切り替えて、こうして、リストに貼ると気を使ってくれそうだという勝手な推測です。うまくいけばいいのですが。ビルドをかけて、ビルド成功でメーターが動いて、こちらに移って、このリストでプロフィールを押す…あ、押せないか。やっぱりダメですね。長押しだけが反応する感じです。つまり、watchOS 側の実装や知識が足りていない、そんな感じですね。

このままだとアニメーションが選べなくなってしまうのかな。`#if os(watchOS)`、`#elseif`、`#endif` にしてみましょう。では、OK にします。一通り見たので、クリーンにやっていってもアリですし、次は watchOS 版を作って、UI を作り込んでいこうと思います。

では、これで終わりにします。お疲れ様でした。
