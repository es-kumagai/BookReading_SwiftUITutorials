Transcription & Summarize : とりあえず読書会 SwiftUI Tutorials #43

はい、では今日も「とりあえず読書会」を始めていきましょう。Swift をマクロで扱う話で、既に出来上がっているチュートリアルの方を踏まえつつ、リファクタリングも進めています。最初に聞くと「マクロが絶対に使われそう」という雰囲気に思えるかもしれませんが、そうではなく、いろいろリファクタリングしていく中で「ここはマクロを使うと面白いのではないか」という好奇心から試している、という感じです。なので、このタイミングで必ずしもマクロを持ち出すとは限らない、というところですね。

ただ、汎用化や、もう少しフレームワーク的な観点での汎用性を考えると、マクロで表現する余地は十分にありそうです。こういった学習のタイミングでは、好奇心に任せていろいろ試してみるのは有意義な学習方法だと思います。自分でも手を動かしながら臨んでいくと良いのではないでしょうか。

では、さっそく続きに入っていきます。前回、マクロを作る中でここまでできました。どんなものを作ったかというと、`Notification` のコンテンツ、つまり `userInfo` に対する型安全なアクセスをマクロで展開する、というものです。`userInfo` は `String: Any` のディクショナリで、キーを文字列で指定して取り出した値をキャストする、というのが一般的なアクセス方法だと思います。これを、宣言的に、かつ安全に扱えるように「列挙型で構成して、それをマクロで展開する」という手法を取っています。

`userInfo` は `aps` と、あとは `landmarkID` のようなアプリ独自のキーで構成されています。`aps` の中はさらに `alert` があり、`alert` は `title` と `body` を持ちます。先ほどの取り違えがあった部分は、正しくは「`userInfo` の中に `aps` があり、その中に `alert` がある」という関係です。

このテストコードは試しに作っただけのものなので、いったん置いておきます。完全にテスト用の構造なので、このままでも問題ありません。

さて、こういったアクセスを手でいちいち書いていくのは悪くはないのですが、あまり直感的ではなく、昔の手続き的なコードになってしまうところがあります。Swift の側では、プロトコル志向もあって宣言的に書くスタイルが好まれます。そこで、列挙型で構造を宣言し、それをマクロで展開するというアプローチを取っています。たとえば `enum Alert` を定義して、`title` と `body` を持つ、といった形です。

現状、`enum` に対するコード展開まではできています。具体的に展開すると、下に出てくるように、`aps` は `userInfo` の中の `aps`（型は `[String: Any]`）、`alert` は `aps` の中の `alert`（やはり `[String: Any]`）という形でアクセスするコードが生成されています。テスト側も同様に、ここまでの生成が確認できています。

あとは、各ケースに対して実際のプロパティから適切な型の値を取り出し、必要な戻り値を返す処理を用意してあげれば、今回のマクロは完成です。プロパティラッパー程度でも通常は十分なところですが、汎用化や宣言的な書き味を重視するなら、マクロで表現するのも良い選択肢だと思います。 まずはそれを進めていけば良いと思います。このとき毎回気になるのが、インデントのずれです。エクステンション・マクロで `extension` を追加したときに、自動でインデントが入ってもおかしくなさそうですが、どうも思ったようには揃わないようです。昔、自分でマクロを作ったときはそのあたりであまり苦労しなかった記憶があるのですが、今回はとにかく進めていくしかないですね。

ターゲットは LandmarksMacroClient にしておけば、マクロだけに注目して実装していけます。実装は LandmarksMacros の中の `UserInfoAccessor` です。これは用意されていますが、今回は使いません。なくても大丈夫だと思うので、とにかく実装していきましょう。

実装箇所は、宣言部の中で `@UserInfoAccessor` が付いている対象です。そこにあるメンバーブロック（`MemberBlock`）の中身を見ていきます。今回の場合、メンバーブロックの `members` の中身は列挙型（enum）が1つだけです。これを見つけたら処理を進め、見つかった情報の `name` が `UserInfo` だったときにさらに続行します。`UserInfo` でなければ次の候補を見ていく、という流れです。

`UserInfo` の列挙型のメンバーブロックに対しては、中に定義されている列挙型を拾っていきます。そのために、`ContainingEnumVisitor` 型（自作）を使います。これはビジターパターンを用いて中身の列挙型を見つけていくもので、見つかるたびに、その情報に基づいてマクロ展開すべきコードを `expansions`（たとえば `ExprSyntax` の配列）に蓄積していきます。最後にそれを返せば完成、という動きです。

`ContainingEnumVisitor` は `SyntaxVisitor` に準拠していて、`override func visit` を実装します。ノードが `EnumDeclSyntax` のときに呼び出される `visit` メソッドの中で必要な処理を行います。まず、マクロ展開時に使うキーを作ります。キーは `node.name.text` を lowerCamelCase に変換したものです。たとえば列挙型名が `API` なら、キーは小文字で始まる `api` になります。

次にプロパティ名です。ここで言うプロパティは、`UserInfo` の中にあるこちら側の名前のことです。今見つけた列挙型を囲っている親の列挙型を取得する処理（先ほどのビジターを用いるなど）を呼び、その親の `name.text` を lowerCamelCase にしたものをプロパティ名にします。たとえば `API` を囲っているのが `UserInfo` という列挙型であれば、プロパティ名は `userInfo` になります。 それにしても、出力はこのとおりですね。`private var`、ここに書いたままですが、`private var`のキー名、つまりキー名というよりは変数名ですね。変数名というのも少し違って、プロパティ名とも取れます。キー名という名前付けはややよくないので、これを「キー名」ではなく`nodeName`にして、`parentNode`や`enumName`にしようと思います。`nodeName`も`enumName`も、意味が分かっていれば後悔はないはずです。

`private var`で、`redButton`の名前……いや、`redButton`の名前というのも違いますね。`lowerCamelCase`にしてしまっていますが、若干違和感があります。なので、`propertyName`と`enumName`という整理にしておきます。少し語弊はあるものの、そこまで厳密に語らなくてもよさそうなので、ひとまずこうしておきましょう。とにかく、変数名として`redButton`の名前を採用して、それでエンコード処理の中で、親の`enumName`に対してサブスクリプトを取り、`enumName`をキーにする、という形で同じですね。やっぱり出てきたものがあります。

では次です。`enum`の`case`（値を持つ`case`を含む）に対して、プロパティを生やしていくことをします。また、このASTについては、実際に構文木を見ながら確認していきましょう。Swift AST Explorerというツールを、ネットで公開してくれている方がいます。これを使うと、プロパティの把握が相当楽になるので、なかなかの「救世主」的ツールです。これを開くと、ここにASTが出てきます。

今回作りたい対象は、例えば「Alert」を見ると分かりやすいでしょうか。Alertのところを見ると、`memberBlock`があり、その`members`の中に`EnumCaseDecl`が並んでいるのが分かります。つまり、ここから拾っていけばよい、ということがまず分かります。`EnumCaseDecl`をさらに見ると、`EnumCaseElement`の`identifier`と、`EnumCaseParameterClause`があります（“clause”です）。この`clause`の中にパラメータがいろいろあることが分かるので、これをSwift側の処理で使いたい、という感じですね。

何にしても、まずは名前を取ってプロパティを作る、というところから始めたいです。そうすると、`enum`があって、プロパティがあって、あとは上の`case`ですね。`case`を探していく必要があります。`case`を探すなら、`members`に対して回せばよさそうです。基本的には、この`visit`の中だけでやるより、別の処理に切り出したほうがよい気もしますが、まずは良しとしましょう。ノードの`enum`が取れているということは、この中から`case`を取れるはずです。`enum`と`enumName`の情報は揃いました。

取りたいものは「型」と「プロパティ名」です。ですので、欲しい構造は、`name: String`と`type: String`を持つような配列、という気分です。これに対して、ノードの`memberBlock`の中の`members`に`map`をかけて、この中で各メンバーから取り出していく、という流れを考えています。ただし、`memberBlock.members`に`map`をかけたとき、各メンバーが必ずしも`case`とは限りません。ここはその点を考慮して抽出していくことになります。 なので、どこでフィルターをかけるか、という話になりますね。かけ方としては、メンバーに対してマップの中でかけると、メンバーが空っぽだったりする恐れがあります。そうするとどうしますかね。`map` ではなくて `reduce` がよい可能性も出てくるなと思います。

機構が多いとコードがややこしくなってしまいますので、ここでタイプエイリアスを作っておきましょう。ちょっとタイプエイリアスを作って、名前は `PropertyInfo` にしようかなと考えています。これは型ですよ、という形にして、これを返すようにします。`PropertyInfo` はノードのメンバーブロックの中のメンバーに対して、`map` ではなく `compactMap` を使い、さらに `reduce` で `PropertyInfo` の配列にまとめるのがよさそうです。`reduce` の初期値は `PropertyInfo` の配列で、クロージャの引数は `partialResult` と `member` にします。

それで、いきなり一つ目は `guard` ですよね。`guard` で、まずは対象をケース宣言に絞り込みます。メンバーは `MemberBlockItemListSyntax.Element` で、その中の `decl` を `as? EnumCaseDeclSyntax` にキャストします。もしケース宣言でなければ `return partialResult` で次の要素へ進みます。ここは少しクセがあるところですね。

分かりやすいように、キャスト後の変数名は `caseDecl`（ケース宣言、`EnumCaseDeclSyntax`）にしましょう。ここから名前を取りたいのですが、`caseDecl` 自体に直接「名前」っぽいプロパティがあるわけではありません。`id`（「このノードのユニークな識別子」）、`kind`、`parent`、`position`、`range`、`root`、`trimmed` などはノード共通の情報で、求めているケース名そのものではありません。`leading trivia` などの余計な情報もここには含まれますが、それは置いておきます。

欲しいのは `EnumCaseDeclSyntax` が持っている `elements`（`EnumCaseElementList`）です。構文的にはケース要素が複数あり得ます。たとえば `case A(Int), B(Int)` のように書けますよね。この場合、`EnumCaseDeclSyntax` の中に `EnumCaseElementList` があり、その `elements` に `A` と `B` という複数の `EnumCaseElement` が入っている、という構造になります。ですので、`elements` に対して1つずつ取り出して処理すればよい、ということになります。逆に言えば、こちらの都合にも合っていて扱いやすいですね。 `members` の中で `reduce(into:)` を使って `enumCaseElements` を集約する方針にします。対象は `enumCaseElements` ですね。処理自体は `for` で回しても良いのですが、今回は `reduce(into:)` にします。

それと、名前付けについてです。`caseDeclaration` はやっぱりちょっと長いので、`enumCase` にしようかとも思ったのですが、結局 `caseDeclaration` のままにしておきます。`memberDecl` や `enumCaseDecl` みたいな候補も出ましたが、ここは `caseDeclaration` を採用します。

次に、`elements` とか `members` といった命名も迷いましたが、最終的に単数形の `member` に寄せることにしました。プロパティ名の付け方に合わせる形にした、という感じです。今の気分的にはこれでまあまあ大丈夫でしょう。

`element` が取れたら、その `name` や `parameterClause` にアクセスできます。ほぼ完成で、例えば `let name = element.name.text`、`let type = element.parameterClause` といった具合です。型に関しては、この `parameterClause` の中の `parameters` を見て決めます。パラメータが1個なら単純な方を、複数ならタプルにしようかとも考えましたが、都合よくタプルで `extract` するケースはあまりなさそうです。ないことはないでしょうけれど、そこまで考えずにまずは進めます。

ということで、`element` の中でまずはガードを書いてしまいましょう。`guard` の条件は `parameterClause` の `parameters` に対してかけます。`guard let parameter = ...` みたいに最初の1件だけを取る書き方だと、複数ある場合の検査ができないので、`parameters.count == 1` をちゃんと見る必要があります。例えば、`guard let parameters = element.parameterClause?.parameters, parameters.count == 1 else { fatalError("...") }` のようにします。

`fatalError` に入れるメッセージは英語で、「UserInfo 用のアクセサのための enum の case は、1つのパラメータだけを持つべき」という内容にします。英語にすると、"The enum case for UserInfo accessor must have only one parameter." くらいでしょうか。細かい冠詞や言い回しが自信ないときは、GPT に「この英語は正しいですか？」と聞けば教えてくれます。DeepL だとよしなに訳してしまう可能性があるので、こういうピンポイントの文法確認は GPT に聞けるのが革命的だなと思います。実際、「enum case」に冠詞の the を付けるのが自然か、なども確認できますし、英語が得意でないと判断しづらい部分をすぐ検証できるのは本当に便利ですよね。 文字起こしのテキストを貼り付けてください。いただいた内容を、です・ます調で読みやすく整え、句読点や表記を適切に修正します。誤変換（例:「G言語」→「C言語」など）も文脈に合わせて直します。要約はせず、内容はそのまま活かします。

コードに該当する部分はバックティックで装飾します。短いコードはインラインで、長めのコードはコードブロックで示します。会話形式が含まれていても、発話者名は残さず、内容を踏まえて自然な文章に整えます。途中から始まる不完全な文は無視して、次の文から整えます。

タイムスタンプやノイズ（えー、あー等）、機械的な繰り返しが含まれている場合は、読みやすさを優先して適宜整えます。特別な希望があれば先に教えてください。 文字起こしのテキストが見当たりませんでした。整形したいテキストを貼り付けてください。いただいた内容を「ですます調」に整え、誤変換を修正し、コードは適宜バックティックでインライン表記します。長い場合は分割して送っていただいても大丈夫です。 enum case、enum case…そうですね。the がないと英語的には「あれ？」ってなりますよね。中学英語では a とか、ドイツ語だったら der とか ein とか、そういうのを習った気がします。ここに must が入ると、ネイティブだとまた感じが違うのでしょうけど、とにかく少しバカっぽく聞こえるのでしょうね。`enum case for`、`must`、`pub`、この辺は合っていたみたいです。なるほど、まあまあ自分にしてはずいぶんよく書けている気がします。the enum、the enum case、こんな感じにして…。

これでエレメントが唯一になったので、ここで case の `ParameterClause` の `parameters` の `first` を取ります。そうすると最初の要素が取れるので、その上でその最初の要素の `description` を使います。こうしてあげると、タイプ名が取れました、という感じになります。これで準備はおそらくできたと思われます。

この中でやるべきこととしては、やるべきことも何もないのかな。`propertyNodeName` と `properties` がそろったので、これで良いですね。2つができたので、あとは `return` で `name` と `type` を返します。

あれ、これではダメでしたね。`String` と `print` の後ろのところで `description` が絡んでいる感じです。`ParameterClause` のカウントが 1 であるということは、`ParameterClause` はありますね。2 になっていたら条件に合わないので、ここも強制アンラップで良いですね。これで `description` を強制アンラップして、`convert` が `String -> String` から、`Result` の型が `Void` になっている。`PartialResult` のメンバーは `PartialResult` に足していくのか。`PartialResult.append`。ここで `name` と `type`、`propertyType` ですね。

これでタイプを取って、この中のコードとしては raw の `enumName`。いや、`enumName` ですね。だから `enumName` で、私が作った `property`。このディクショナリから値を取っていくので、`row` として、この中身が `property` の `name` ですね。`property.name` をサブスクリプトで取って、あと、ここで `row` で `enumName`…違う違う、`property.type` ですね。で、書き出して、区切ったら終わり。スペースを 1 個空けておきますかね。上に 1 個空けるのがいい気がします。では、そうしましょう。ということで、上に 1 個スペースを空ける形を取って、これでたぶんできました。

ビルドをかけるでしょ。ビルドをかけて…あ、止まりました。`dest` かな。`Environment` を入れてくるアレですよね。展開すると…`dest`、`dest`、`dest`。あ、この `dest` か。こういう破り方ね。なるほど。抜かしましょう、`dest`。で、次に `dest` を作ろうとした。これはどうしましょうか。これは回避しにくい問題ですね。アラートが含まれると衝突するので、回避しないといけますね。

これは、どこだ…ネットワークで作るときの名前がかぶらないようにしたいのか。名前をかぶらないようにするとなると…タイトル。まあ、必ずかぶる可能性は存在してしまう気がするので、ここは何とかしないといけないんですよね。かぶる可能性が…アラートの `userInfo` の `title`。あれ、これ作りがまずいんですよね。配列や連想配列になっていないと、プロパティがあって、インスタンスがあって…不可能というか、要はアラートの `title` があって、`dest` に `title` があっても、これだと上書きしちゃうでしょ。

なので、これをやるには `alertTitle` か。そんな感じで、名前を連結していかないといけないのかな。そうですね、そうしないとダメになっちゃうのかな。それか、`userInfo`、`content`、`aps`。`aps` に対してプロパティを載せていて、あとはプロパティ…`aps`。`aps` をインスタンスにして、`userInfo` の `aps` の階層構造を作らないといけないんですね。

そうすると、やるべきこととしては、`userInfo` を持って、`userInfo` を持って、`aps` 用のプロパティを作っていくのか。なので、構造体にするのが良さそうだと判明しました。やり方としては、まずはここで作るときにプロパティを作っていますけど、このプロパティは構造体に作りますね。構造体、そうですね、構造体。なので、これはメインのエントリーポイントの方に行きます。 このあたりは `struct` についてです。`struct` はプライベートでも問題ありません。`struct` に対してプロパティ名を用意します。ここで「プロパティネーム」と言っていましたが、実際には列挙型（`enum`）の名前も扱いたいので、「`enum` 名（`enum` の名前）」も考慮します。`enum` の名前は必ずしも `lowerCamelCase` である必要はなく、`lowercase`（小文字）や `lowerCamelCase` を使い分ければよいと考えています。

ただし、すでに `enum` で定義してしまっているため、このままだと都合が悪い箇所があります。`enum` にするとケースがあって、名前空間を作る目的には合っているのですが、この構造だと意図通りにいきません。名前空間がうまく作れない場合、列挙型での定義（`UserInfo` などの中に持たせる案）でもやりようはあります。展開されるので問題はなさそうです。できそうなので、その方向で進めます。

この中では `struct` と型名を定義します。型名は `lowercase` にそろえます。`enum` 名（ここでは本来 `enum` 名にしたいところ）が何カ所かで使われているので、列挙型の名前として扱うのがよさそうです。まだ足りていない要素がありますが、そこは後で補います。本来はこちらが `enum` 名ですね。どうするかというと、`lowerCamelCase` 化した親の名前（`parentName` のようなイメージ）を毎回計算するのは少しもったいないのですが、わかりやすさを優先して今回は毎回処理することにします。

`enum` なので「エレメント名」ではなく、`enum` のケース名として `lowercase` にそろえます。親についても同様です。この段階で `lowercase` 版の名前を作っておき、プロパティ名（`propertyName`）もテキストとして扱います。

次に、プロパティのマッパーでエレメントに対して `parameterFirst`、`description` を設定し、`name` はこのように作っていきます。これでプロパティに対して `name` がそろってきました。

続いて、この型に対してイニシャライザが欲しいです。どんなイニシャライザかというと、`init` を用意します。`private init` にして、`UserInfo` と `Any` を受け取るイニシャライザを作り、後からプロパティとして `UserInfo` を渡していく形を考えています。ただ、`lazy var` はあまり使いたくありません。`lazy var` が必要になると、プロパティにアクセスして追加していく場面で複雑になってしまいます。いま作ろうとしているのは構造体で名前空間を整える発想なのですが、少しややこしくなりそうなのでやり方を変えます。

一度このあたりまで戻して、テストへの影響と命名の問題を整理します。ここでやりたいのは、`UserInfo` のコンテンツの回数（構造）に応じて名前を作っていくことです。

`enclosingEnum`（親の `enum`）についても同様の方針です。プレフィックスや親の `enum` 名（`parentEnumName`）は、`UserInfo` の `enclosingEnum` をたどりながら繰り返し処理で名前を集めます。`while` ループでいけそうです。ここではループの中でインデックス（番手）が必要になりそうなので、その番号も一緒に管理しながら名前を作っていくのが良さそうです。 なので、ここで `private static func` にして、関数名は `makeParentEnumName` かなと思います。戻り値は `String` にします。呼び出しは `makeParentEnumName(of: node)` という形にして、`makeParentEnumName` に渡す `node` は `Visitor` の中のノードです。`enum` で来る `Syntax` なので、そこから名前を取っていくときに順々にたどっていきます。

いろいろやり方は考えられますが、ふと思いついたのは `let parentTarget` みたいに持っておいて処理することです。`enum` 系で一気に取ってしまえたら面白いかなとも思いましたが、意外と面倒になりうるので、ここは素直にループで書くのがよさそうです。最初は `repeat { ... } while` でやろうかとも思いましたが、`repeat-while` の `continue` がどう振る舞うかや、条件判定をどこに置くかが気になって、やりにくいですね。結局、`while` 文のほうが扱いやすそうです。

ということで、`node` を起点に親をたどるループを作ります。最初は `Optional` として始めますが、いきなり `nil` になることはないので条件は `true` ですね。`while` の中で親に進めていきます。`enclosingParent` を使えば、あるノードの親はすぐに取得できますよね。`while let` の条件束縛で書く方法も一瞬考えましたが、ここでは使わず、素直に回す形にします。`if let` の条件判定をどこで使うかも少し迷いましたが、なくても進められます。

次に、親の名前を連結していくための変数を用意します。`result` でいいでしょう。まずは文字列で作っておいて、そこに対して `result += node.name.text` のように、`node` の `name.text` を順番に足していきます。名前が付いたときに連結されていけばよいので、これで大丈夫です。区切り文字がいらない前提なら、そのまま連結で問題ありません。

このようにして `result` を作って返すわけですが、そうすると `userInfo` が出てきてしまう側ですね。ここはその前提を踏まえて処理を考える必要があります。 では、`enclosingEnum` なんですが、`nodeNameText` が `!= "UserInfo"` のときに、`UserInfo` を除いてループを回し、`UserInfo` までループを回していって名前を出していく、ということがこれでできました。そしたら `return` で `result` に対して `lowerCamelCase` で整えてあげます。そうすると、名前の累積ができ上がるので、これをどこで使うかという話ですね。

プロパティに対して、さっきのプロパティの上にある `parentEnumName` をここで呼びます。ここで `self` のノードから `enclosingEnum` をたどるかたちですね。これで名前ができたので、そうすると、`parentEnumName` がここでスコープ外になってしまうのでは、という懸念があります。`innerName` は `parentEnumName` のほうから使う想定です。`innerName` もここ、ダメですね。それも `innerName` の中で `lowerCamelCase` にしますが、`innerName` の扱いも違います。`innerName` はペアレントを取ってからの `innerName` で、これから変更の可能性があります。

`parentNodeName`、まあ、ということはいいのか。`parentEnumName` を出すことと `nodeName`、これを `lowerCamelCase` にします。`lowerCamelCase` ではない…いや、`lowerCamelCase` です。そうすると、`innerName` は小文字から始まっていなければいけないんでしたっけ？ここが2つあって、`lower` でここが変わっていますね。`innerName`、`innerName` か。あとは大丈夫ですね。むしろ `innerName` でよくなりましたね。なので、`lowerCamelCase` はここではいらなくなり、ペアレントもいらないですね。もうやってありますもんね。

`lowerCamelCase` を `result` のときにかけましたよね。それで、`innerName` も `lower` でやって、ここに `parentName` が空の場合があるんですよね。そのときに呼んじゃっているけど、結構もったいないけど流しますね。そうすると「上も忘れているのではないか」みたいな、そんな心配が出てきちゃうような気がして、`parentName` が空だったときは…みたいにやってもいいのかなという気がします。

えっと、だから `parentName` のテキストを…そうですね、ちょっとそれやってみますか。`switch parentEnumName.isEmpty`、これがブールです。`true` だったときには空っぽだということなので、`nodeNameText` の `lowerCamelCase` ですね。`false` だったときには、`node` の `parentEnumName` に `nodeNameText` をそのまま足して出せば完成ということですね。やっていることは一緒で、取り捨てもそんなに変わらないと思うんですけど、こっちのほうが「`lowerCamelCase` を読んでいるよ」というのが分かってくるので、多分いいんじゃないかなという気がします。

これでできたのかな。ちょっとビルドかけてみますね。ビルドをかけると、エラーは出るのか出ないのか、ループが延々なのかどうなのか…ループが延々になる可能性もあって不安になってきた。これは `while` ループの中でやらないとダメですね。今、無限に頑張っているでしょ、きっと。だから、これで `var node`、`node` で `enclosingEnum` にして、`while` で…そうそう、出しちゃってるでしょ。なので、これを出すわけですけど、それからこれは `node` で、`node` は `EnumDeclSyntax`、`EnumDeclSyntax` のオプショナルですね。

それで、ここの中でループで、`node = enclosingEnum` で…これはエラーになってるのか、なんだ？オプショナルか、オプショナルのオプショナルか…これか。`node.enclosingEnum` で、`var`、`repeat`…いや、`EnumDeclSyntax`。`EnumDeclSyntax` の上がダメですね。`enclosingEnum` がオプショナルなのはいいですね。`node` は上で入ってますね。 これは `repeat-while` ですね。`repeat` の中で `guard let`（いわゆるガード）を書いて、条件を満たさなければ `continue` していく、という形にしたいのですが、その場合、上に登れなくなってしまうノードに代入していって良いのか、という点が気になります。まずは `node = ...` と進めていく形にしたいのですが、あれ、ダメなのか。

`EnclosingEnum`、そして `EnumDeclSyntax` がメンバー…というより、`EnumDeclSyntax` には `enclosingEnum` を持っていないノードがあり得ますね。`EnumDeclSyntax` 自体がトップの列挙であれば `enclosingEnum` は `nil` です。これは想定どおりなので問題ありません。

ということで、`repeat-while` で、`node.name` が `userInfo` ではない間はたどっていく、というイメージです。`let node = ...` と `repeat` に頼りすぎるのは良くないかもしれません。`node` が `EnumDeclSyntax` なら `enclosingEnum` を代入して、それで代入したところで `node = ...`、ここも同じように進めます。`parentNode = node`。これで `node` は `enclosingEnum`。そして `enclosingEnum` なんですけど、`guard let` で、`node.name.text != "userInfo"` なら続行、`else { break }` ですかね。`break` が終わったら、この中で出力していく。`result` として `node.name.text` を使う想定です。

ただ、`node.name.text` を2回触っているのと、`break` が効いていない。`repeat` の“後”が `repeat-while` だからですね。ここで条件を満たすかどうかは、すでに評価のタイミングがズレています。つまり、`repeat-while` ではないのか。

「`nil` でなくなるまで繰り返す」というやり方のほうが素直です。最もシンプルに見えるのは `Sequence` ですね。`Sequence` を使って、`nil` になるまで、かつ `userInfo` でなくなるまで、という形にすれば、そのまま `reduce` が回せます。`reduce` が回せると良い感じになります。`reduce` を回すための準備をして、`reduce` を回す、という選択肢は一つあります。どうしようかな。

`while` ループは思ったよりきれいに書けないなという感触があって悩ましいです。`parent` をたどっていくだけなので、ループ自体はループでいいとして、`while` でずっと回し、`break` は…`repeat` は `break` できないのか？（できるはずですが）`while` でもいいのですが、代入して `nil` だったら…C言語だと一行で書けるんですけどね。これができないとなると、しょうがない。では `do` ブロックですか。`do` ブロックでどうしよう。ラベル付きの `loop` にしましょうか。まずは `loop` で良いかな。`break loop`。こうする感じですね。これで条件を満たせばループを抜けて、それ以外は回していき、今度は `enclosing` になるものをたどっていくことになります。

ビルドはどうなるか。終わるかな。終わったら、長いエラーが出ていますね。エラーは、ここの中のプロパティを展開すれば出てくるんでしょうか。エクスパンド…あれ、これはどうかな。展開すると、この辺ですね。`asString`。あ、そうか。`Optional` ではなくなっているからですね。今まで作っていたのはどうでしたっけ。`content`。今までは `Optional` で、与えられたならば…という作りにしていました。今回は「与えられる前提」で良いのかどうかで、びっくりマーク（`!`）での強制アンラップにするかが決まります。仕様上「ないことがある」とは言われていないので、与えられる前提にしましょう。そうすると、ここでは強制アンラップしてあげれば良い。どちらを強制アンラップするか少し迷いますが、プロパティ名にしましょうか。一旦 `var` でカットして `propertyName` を作る。この形で OK です。

もう1つ気になるところがあります。`APS` や `APSAlert` のようなところは名前が期待どおりに作られていますが、`title` がうまく取れていません。`title` がそのまま `Title` になっていて、これはプレフィックスの付け忘れです。単なるミスですね。どこだ…`propertyName`。この辺か。`propertyName`。ここですね。`propertyName` ではなくて、この中で展開する前に `name = ...` を決めます。ここも `switch` 文か。同じ雰囲気にしすぎると使い回している感じが出てしまうのが悩ましいのですが、要はこれです。`switch` 文でプレフィックスを `parentEnumName` にする。`enumName` はもう取れている。`enumName` が取れているので、新たに別の名前を作る必要はなく、既存の `enumName` に対して `propertyName` をつけます。その際、文字のケースは `lowerCamelCase` ではなく `UpperCamelCase` にする必要があります。これを追加しましょう。

下のほうに、`lowerCamelCase` と `UpperCamelCase`。コードはほぼ同じで、`Upper` を用意します。ここは共通化しきらなくても良いかなという気がします。先頭文字の処理だけ変えればよく、先頭のフラグを 0 ではなく 1 にして、文字の ASCII 値に対して AND 演算で大文字化する、という実装にします。こうするとビルドが通るはずです。

ビルドが終わって、展開も終わった。もう一度閉じてから展開し直すと、エクスパンドしたものが `APS` と `APSAlert`。いいですね。そして `APSAlertTitle`。これも良い。できました。こんな感じで展開して、期待どおりに出力できました。これで良しということです。 あとは、インデントがまだ気になっているのですが、これをどうしますかね。そうですね、これを `append` で要素を継ぎ足していきたいのですが、そのときにマクロの expansion を使います。expansion を使うときに使っているのはここですね。`.map` でいいのかな。`map` で `$0`、えーと、`Syntax`。で、`Syntax` の…あ、なんだ、`leadingTrivia` が…これはダメなのかな。あー、戻り値になっちゃう。これだと `DeclSyntax` でしょ。これを `DeclSyntax` の…イニシャライザはいくつかあるかな。今打っているのは完全に `DeclSyntax` か。なので `DeclSyntax` の、ユニットの中には `Syntax` からのイニシャライザがありますよね。それがあるのと、えーと…これだけか。`SyntaxProtocol` から `Syntax` への変換。これはできるはずですよね。なので、こうした後に `Syntax = Syntax` の `leadingTrivia` に対して `node` を入れてみようと思ったけど、これはダメか。なるほど。じゃあダメですね。うん、なるほど。ここはちょっと怖い感じがしたので、一旦やめておきます。

そして、ここにアサートが邪魔ですね。これ、何していたんだっけ。メンバーがあって、`userInfo` が…あ、違う、`userInfo` が見つからなかったときですね。なので、テストではなく、純粋に何も活用しない、というだけの話でしたね。はい、これで完成しました。

これによって `NotificationContent` の作りが変わってきます。ここはこれでいいですね。で、マクロを用意してあるので、ここのプロパティたちを全部消してしまいます。いったんビルドをかけて、押したときにプロパティがないというエラーが出てくるはずです。タイトルがないよ、というときに、`content.userInfo`。`UNNotificationContent` の `userInfo`。プライベートでも、`userInfo` をコンテンツの…`NotificationContent` の `userInfo`。これを作って…あ、プロパティを消しすぎましたね。`NotificationContent` の中に保持しているだけだからいいですね。なので、`userInfo` は明示的にアクセスしなくてもいいですが、マクロを展開すると、マクロが不完全なのかもしれないですね。expansion で中身しかやっていないですよね。

だから、プロパティを visitor の中で、`enum` の中で、`visit(_ node: EnumDeclSyntax)` でしょ。なので、visitor で処理すべきノードを…これですよね。ノードがこれじゃなかった。`EnumDeclaration` の `MemberBlock` を渡しちゃっていたので、`EnumDeclaration` の中の、要は 1 個目、`userInfo` かどうかで、`userInfo` に対してやっていかないとオーバーがいけないんだ。こうすると余計なプロパティを取っているんじゃないかな。`enum` のエントリ宣言が `userInfo` ですよね。でも、こう感じで除外すればいいのか。`enum` の visitor でプロパティを生成するときに、名前を append するところで、`userInfo` を除外してあげればいい。`userInfo` を除外する。それか、それを除外しないという手もありますね。

宣言の定義を見てみると、`userInfo` ってこうなっちゃうのか。なるほど、`self` 自体ね。`self.userInfo` ってわけにもいかないですしね。`userInfo` だったら `userInfo` を使う。それで妥当でしょうか。なので、`userInfo` だったら無視する、というコードにします。ちょっと無理は感じるのですが、また再度リファクタリングすれば何とかなる気がします。

とりあえず、そうすると、このプロパティを作るときに、`if m != .userInfo { ... }` という形を取れば、ビルド通るでしょ、きっと。あ、どうなった。メンバー `landmarkID` をまだ持っていない。これでもまだ持たないか。どうなっているんだ。つまり `userInfo`。`userInfo.landmarkID` か。どうなっちゃうのか。`userInfo.landmarkID`。あ、なるほど。`userInfo`。ちょっとルートが厄介ですね。ルートが厄介だから、もう少し共通化したほうが良さそうですね、コードは。なので、これはまた今度にします。やりたいこともいろいろありそうな気がします。

ここでコードを戻していって、メンバーブロック。この中で…現状では、`UserInfo` 型に直接持たせたものがプロパティとして出力されないので、そこがずれちゃう。ないので、visitor の「プロパティを出力するコード」を共通化して、`EnumDeclaration` 自体にも直接適用する必要がありそうな気がします。なので、これを次回やっていってマクロを完成させ、完成したマクロに置き換えていって、あとリファクタリング。コードが雑になっているところがあるので、直していく、ということをやっていくことにしましょう。

今日は時間になったので、これで終わりにします。お疲れ様でした。
