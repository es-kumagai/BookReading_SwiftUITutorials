Transcription & Summarize : とりあえず読書会 SwiftUI Tutorials #12

はい、では「とりあえず読書会」。今日も SwiftUI チュートリアルを読んでいきます。今日は、前回見ていたアニメーションとトランジションのあたりを引き続き見ていきます。前回は、プロジェクトをまるっとコピーして使うソースコードが珍しく多かった印象があり、少し落ち着かない感じもありました。そこで今日は、そのコードにリファクタリングの余地がないかを見ていきたいと思います。

リファクタリングにはいろいろな観点がありますし、技術的にも難しいですよね。基本は動作をそのまま維持したまま変更していくことですが、「この方が効率がいいだろう」といった好みや習慣に寄りがちです。自分でも、今日はこれが良いと思ったけれど、次の日には別の方が良いと感じることがあります。ですので、何かしらの根拠に基づいて「こうすると良いでしょう」と言えるのは望ましいのですが、その根拠自体も「誰かが言っていたから」という話に流れがちです。この読書会でも「Swift API Design Guidelines ではこうなっている」といったことを言いますが、結局のところ、何に従うかは習慣の問題であって、有名人が言ったからといって必ずしも正しいとは限りません。そういうことを考えると、なかなか答えのないところがあります。ただ、この勉強会は好きなように進めていますので、好きなようにリファクタリングしていけば良いとも思います。とはいえ難しいことだなと時折感じます。

「Animating Views & Transitions」の章で実際にコピーしたプロジェクトのコードは、配布物の中に全部入っています。このあたりをじっくり見ていけば、良い感じに理解が深まると思います。今、何気なくコードのインテリセンスを使いましたが、今日から新しい環境で、AI が搭載されているので、設定を少し整えておきます。アカウント設定は裏方でやります。手元の API キーを設定して、サインインの途中で何か聞かれましたが、プライバシーに関する話だと思います。開発を一般公開するときは重要ですよね。この PC は勉強会専用なので、その点は心配していません。プライバシーポリシーとしては、データの取り扱いに関するオプションもあるようです。ウェブサイトに飛びましたが、この辺は後でやれば良いでしょう。とにかくやってみます。

では、上からファイルを順番に見ていきますが、もう少しあたりをつけておきます。`HikeData`、`HikeView`、`HikeView` が一番の根本ですね。動かして、一応プレビューを出しておきます。フレームを直指定して、スタックで名前と距離を表示して、その後にスペースを挟んでボタンがある構造です。ボタンがいろいろあって、インデントが深くなっているので、ここは直したい気がします。

`var` で `Hike` を持っています。`Hike` はそこから参照されるのでしょう。プレビューでは `Hike` を渡していますね。`HikeGraph` もあります。これらを踏まえると、`Hike` はこの中で書き換えるわけではなさそうです。チュートリアルではその点はあまり触れていないようにも見えますが、まあまあ、そのあたりも含めて見ていきましょう。 先へ進みます。ここで `HikeGraph` があって、`VStack`、まずは `HStack` ですね。ここからグラフ化してみると分かりますよね。`HikeGraph` はグラフのマークのような見た目で、場所と距離という情報があるので、`LandmarkSummary` のような感じにまとめるのが良さそうです。少しこれを分けます。

ビューを独立した型に分けてもいいのですが、プロパティは `private` にしておきたいので、ここはやめて計算型プロパティにしましょう。名前は `landmarkSummary` で良いですね。`HikeView` の中に、実装の前にインターフェースとして `var landmarkSummary: some View` を用意し、`VStack` を返すだけにします。そうすると良い感じに表示されて、「ランドマークのサマリーですよ」という意図も名前から把握できるようになります。

いったん戻って確認します。該当部分をコメントアウトすると、期待どおりの名前が出ますね。`HikeGraph` についても、同じあたりで「`HikeGraph` として `some View` を返す」という実装にしておくと、選択しやすいです。`HikeGraph` の位置をコメントアウトするとグラフがなくなることが確認でき、想定どおりに動いています。`Spacer` も問題ないですね。

次はボタンです。画面上ではまだ見えていませんが、これは「Show」ボタン、あるいは `Toggle` にするかを少し迷います。ここでは「Show Detail」ボタンとして扱いましょう。この書き方だと状態を直接セットできない部類に入ると思うので、あまり多用しないほうがいいなと思いながら見ています。とりあえずボタンを出しておき、これによって、`HikeView` は `HikeGraph` と `LandmarkSummary` と `Spacer` と「Show Detail」ボタンが水平に並んだアイテムだ、という構成になります。さらに、`showDetail` が `true` のときには `HikeDetailView` を表示します。`transition` をここに入れているのも良いですね。

`LandmarkSummary` も水平レイアウトの中で、リーディング揃えで、名前と距離のテキストが表示される、ということで良いと思います。「Show Detail」ボタンは、アニメーション付きで押されると `showDetail` がトグルされます。ラベルは `Label` を使い、`systemImage` を指定します。このあたりのシステムイメージはもう少し調整できそうな気もしますが、`Label` の引数なのでこれで良いでしょう。`systemImage` が受け取る型は `String` です。

`HikeView` はこれで良さそうですね。では、2番目に使っている `HikeGraph` を見ていきます。この辺は `let` で良いものが2つあります。どちらが良いかは一概には言えません。とにかく、`Hike` と `KeyPath` で、`Hike` の `Observation` に対する、戻り値が `Range<Double>` になるような `KeyPath` を指定する形になっています。`HikeGraph` は、`HikeView` の中だけで使うかどうかはまだ分かりませんね。ひとまずこれで良いでしょう。 計算型プロパティとしてカラーがあって、これはパスによって決まるようにしておけば良いでしょう。たとえばエレベーションならグレー、ハートレートなら赤、ペースなら紫、というようにデータとして持たせます。さらにオーバーオールレンジ（`overallRange`）として、全体のレンジを関数的に求める処理にしています。これはデータの `lazy` なマップ（`lazy.map { ... }`）で、キーとなるキーパスに対して値を取り出す形ですね。`$0` はマップの各要素を指しますから、各データに対して、その型に設定されているキーパスで値を読む、という流れです。

最大設定値（`maxMagnitude`）は、マップした値に対してメソッドでマグニチュードを計算し、キーパスを指定して、自分自身の値を全体のレンジのマグニチュード（`magnitude(of: overallRange)`）で割る形になっています。`magnitude` の戻り値は `Double` なので、`CGFloat` に無理に変換する必要はありません。外側でも `magnitude(of:)` は `Double` を返しますから、割り算で問題なく処理できます。ここは余計な変換は要りませんね。

`GeometryReader` を介してプロキシ（`proxy`）を使い、`HStack` の `spacing` を指定して並べます。`ForEach` のところでは、`Array(data.enumerated())` のように列挙してインデックスと要素を一緒に扱いたくなりますが、`ForEach` はコレクション（特に `RandomAccessCollection`）を要求する初期化子があり、そのまま `enumerated()` のシーケンスでは合わないことがあります。そういう場合は、`Array` に変換したり、`id:` に適切な識別子を渡す必要があります。たとえば `ForEach(Array(data.enumerated()), id: \.element.id) { index, element in ... }` のように、`id:` で一意にできれば使えます。

一方で、`ForEach(data)` のようなイニシャライザでは、`data` 側に `Identifiable` が実装されているか、あるいは `id:` でキーを指定することが前提です。ここで扱っている `data` のエレメントは配列の要素で、キーパスはそのエレメントのプロパティに向いている必要があります。`HikeObservation`（観測値）の配列であれば、`path` が `\.elevation` や `\.heartRate`、`\.pace` を指す形になります。`enumerated()` を使うと戻り値はシーケンス（`(offset, element)`）になるため、`id` をどう解決するかが鍵で、そこが引っかかっていたようです。

次に `GraphCapsule` ですが、これは `index`、`color`、`height`、`range` で表現していて、アニメーションでリップルのように動く実装になっています。`offset` などで見た目を調整しています。`HikeGraph` ではいろいろやっていますが、結局のところ `GeometryReader` を使ってレイアウトしている点がポイントです。このままでも問題ない構成に見えます。

たしかに、これまでの構造の書き方と合わせるなら、`HikeGraph` にグローバルの `bounds` を持たせていましたので、それに寄せるのも一案かもしれません。ただ、それが最適かどうかはもう少し検討が必要だと思います。 ひとまず、`Hike` と `Path` があって、`bounds` を先に扱うか、`Hike` を先にするかを考えています。`Hike` と `Path`、それから `bounds` を用意して、`CGSize` で受け取る形にします。そうしておくと、内部でいろいろ出てくる `GeometryReader` からの `return` が、結局 `Group` を返す形になってしまいそうでしたが、ここは大丈夫で、`HStack` でいきます。

`return` のところで `GeometryReader` を少し省いて、`proxy` ではなく、ここでは `bounds`、特に幅を使います。ここも同様に、`proxy.size` ではなく大きく `bounds` に置き換えます。`proxy.size` をすべて `bounds` に置き換えてあげればよく、余計な箇所は削除します。これでインデントも少し整って解消できるので、まあまあ良いかなと思います。

ただし、これをするには `Group` は関係なく、`GeometryReader` で得た値をどう扱うかを見直します。フレームとして渡しているつもりでしたが、実際にはジオメトリではなく `bounds` を渡したいのです。いま作っているのは `Graph`（`HikeGraph`）でよく、`Geometry` ではなく `bounds` を使います。「`HikeGraph` に `bounds` ありますよね？」と考えていて、`frame` にあるものとして扱っていたのが間違いでした。こちらを正して `bounds` を使います。

こういうふうに渡してあげると、「`bounds` がそこか…いや `bounds` ではなくジオメトリのサイズ」つまり `CGSize` を使うのが正しい、という整理になります。同じ置き換えを残り2カ所（ここと、ここ）にも適用します。これでこのコードは OK です。

一方で、これを `HikeView` から呼ぶ、つまり `HikeGraph` を呼び出すところが問題になります。`GeometryReader` をその中で呼んでもよいのですが、なんとなく冗長に感じます。なので、関数（あるいはビュー）の引数として、たとえば `HikeGraph(bounds: CGSize)` のように渡す方がよさそうです。引数ラベルをどうするかは少し悩ましいところで、SwiftUI ではどういう名前付けがしっくり来るのか、まだよく分かっていないところがあります。 とりあえずこの名前でいいのでしょうか。`bounds` でもいいのかなと思うのですが、`SwiftUI` ではそういう感じなのか、ちょっと分からないので、まずはこれでいきましょう。

これで `HikeGraph` に対して `bounds` を渡すには、`GeometryReader` を使えばよさそうです。`GeometryReader` の `GeometryProxy`（クロージャの `geometry`）を使って、`HikeGraph` の `bounds` にジオメトリのサイズを渡します。これでプレビューがちゃんと動くはずですよね。あれ、動かないかな。まだエラーがある感じでしょうか。`bounds` が渡されていない……ここですね。

`HikeDetail` の中でも `bounds` が渡されていません。これをどうするかは、`HikeDetail` がどこで使われるかにもよります。先に見てみましょう。`HikeDetail` があって、ここでジオメトリが必要になってきます。`GeometryReader` は `HStack` の中のこの部分ですね。なので、この中に `HikeDetail` を入れて、ここで `bounds`（というか `geometry.size`）を渡す必要があります。

ただ、`HikeDetail` 自体の中でも `bounds` を使おうという話になってしまっているようです。それでいいのかどうか……まあ、`bounds` と `CGSize` を一緒に持たせる形でやってみましょう。そうすると、この中のどこだったか、`HikeGraph` にちゃんと `bounds` を渡せるようになります。ここで `bounds` を渡せるなら、さっきの `HikeDetail` 側の `bounds` も渡せます。つまり、`geometry.size` を使うということです。これでプレビューが動くはずです。

まだエラーが出ます。プレビューが、さっきの `HikeDetail` の中で、プレビューを作っていなかったせいかもしれません。`GeometryReader { geometry in ... }` と書いて、その中で `bounds` として、`HikeDetail` に `geometry.size` を渡します。これで今度こそエラーが解消されて、`HikeDetail` がちゃんと表示されるはずです。

……全然表示されません。なぜ壊れたのでしょう。`bounds` がうまくなっていない可能性があります。`GeometryReader` でサイズを取って、`HikeDetail` の中で `HikeGraph` に `bounds` を渡して、`HStack` の中で `HikeGraph` を使っていて……この中での渡し方がダメだったのかもしれません。試してみます。

`HikeGraph` を `GeometryReader` で包んで、`geometry` を受け取り、そのグラフに対して `geometry.size` を渡してみます。これで少しだけ表示が変わりました。少しだけ変わったということは、まだどこかに誤差があるということですね。

`HikeDetail`、いえ、`HikeGraph` の中をいろいろ見ていきます。さっきまでやっていたのは、ここで `GeometryReader` を返して、その中の `HStack` に対して、`bounds` でサイズを決定させていた、という実装でした。これが狂っているのか、プレビューの中でも表示がめちゃくちゃですね。勝手に伸びすぎてしまっています。

`HikeGraph` から、ここは `HStack` で、`GraphCapsule` のプレビューがどうなっているかも気になります。横長のバーになっているかどうか。`GraphCapsule` はそんなにいじっていないので、ここは大丈夫そうです。 `magnitudeOf` が `CGFloat` に変換されているのは不要だと思いましたが、実際に外してみても問題なく動きます。こちらも不要ですね。これで、フィットしてオフセットしている部分はOKです。角が丸くない件は少し気になりますが、このままでも良さそうです。ほかは特にいじっていないので、一応色は赤にしておきます。

高さ関連の値は、ここは `Double` で良いでしょう。そこは変換の箇所なので、わざわざ `CGFloat` にこだわる必要はないと判断しました。プレビューがこれで合っているかは少し自信がありませんが、パラメータは何もいじっていないので大丈夫なはずです。グラフビューで `Equatable` の警告らしきものが出ているのも気になりますが、とりあえずグラフはさっきの状態でOKとします。

全体がかなり巨大になっていて、これが `GeometryReader` の中に入っている、ということなのかを試してみます。`GeometryReader` の中で、ジオメトリを `in` で受け取り、その中で `bounds = geometry.size` としてあげます。この状態で `GeometryReader` を閉じたとき、壊れていたレイアウトがどうなるかを確認します。

`HStack` を返すつもりが、`GeometryReader` の順番を間違えていました。`HStack` の後…いや、先ですね。`GeometryReader` を先に返して、その後に `HStack` を組み立てるようにしたところ、見た目がかなり変わりました。それでも、なぜか要素同士がぶつかってしまうのが気になります。ここは一度コードを戻します。どこまで戻すか検討して、この辺りまで戻しました。確かきれいに並んでいたはずです。ここはこのままでも良さそうですが、とりあえず元に戻しておきます。

描画できていなかったのは、`bounds` を渡す必要がなくなったからです。必要がなくなったというか、無駄なので、ひとまずパラメータで `bounds` を渡すのをやめます。まずは描画の結果を確認します。プレビューは本当に助かります。全然動かない状態になっていたので、プレビューで助かりました。ビルドをかけて、プレビューの表示を待ちます。プレビューはこのくらいの情報で十分でしょう。

まずはエディタ側の確認です。いろいろ見ていきます。`GraphAxes` が横長になってしまっていますが、これはこれで問題なさそうです。コード自体はいじっていないので、この挙動で正しいらしいです。赤に変えたのと、やはり `CGFloat` への変換を直した程度ですが、これで良いようです。

次は `HikeDetail` のプレビューです。この形だときちんと出ていますね。`HikeGraph` だと3つ出る想定ですが、まったく出ていません。完全に壊れています。ひとまず一番外側、`GraphAxes` から手を入れていきます。ここは直せたので良しとします。`Double` に変えたことと、最大値については `magnitudeOf`（あるいは `magnitudeOfRange` のような）関数を呼んでいく予定です。これらはグラフ側のコードの中にあります。そうなると、この `Graph` と `GraphAxes` は、どこかでまとめて扱いたい気がしてきますね。 なので、ちょっと`GraphCapsule`を持っていきましょう。えーと、ここからコピーして、プレビューも持っていきますかね。ざくっと持ってきて、`GraphCapsule`は`HikeGraph`に持たせればいいかな、と。`HikeGraph`の中の`GraphCapsule`にすれば大丈夫かなという気がするので、`extension`で`HikeGraph`の中に貼ります。 このとき、`GraphCapsule`はきっと外からは使えないでしょうと考えられるので、これは`private extension`にして、`GraphCapsule`を`private`に取りましょう。で、この辺は全然問題なしです。

プレビューがこの位置にあるのがなんとなく気になるので、このプレビューは…あれ、コピーできてない？今何をコピーしてきたんだろう。えーと、プレビューと言っちゃったけど、これですよね。ぱっとしましたよね。で、ぱっとして、このプレビューを一番下に持ってきて終われた。これで「アクセル」じゃなくて、ちゃんと`GraphCapsule`って感じで名前つけて。こっちの一番上はなんだっけ。今見ているのは`HikeGraph`か。だから「Graph」でいいのかな。こんなふうにプレビューを分けます。

それで、この`GraphCapsule`は、`HikeGraph`…だからこうかな。`HikeGraph`の`GraphCapsule`だが……あ、`Capsule`がない。`Capsule`がない。`extension`、`private extension HikeGraph`…あ、名前書いてない。これを`GraphCapsule`にして。これで、この辺はおおむね良いのかな。これは`range`と`overallRange`をもらおうとしている。グラフじゃないや、カプセルを載せていくわ。まあ、この辺は全体的に直さないとダメですね。`GraphCapsule`にして。全体的に、何も…一箇所かな。えーと、一箇所でいいのかな。この赤いのは…あ、ここか。

`GraphCapsule`が「missing argument」というのは、`HikeGraph`の`GraphCapsule`の中で使っているからかな。これは`range`…えーと、なんだっけ。間違えたかな。`GraphCapsule`の中で`GraphCapsule`を使っている…えーと、引数の指定。`GraphCapsule`を戻していくと…あー、ここは戻さなくていいや。こっちは良くて、こっちの`GraphCapsule`を一回戻せば、ずっと出てくるんで。これで、`body`の中で`Capsule`使ってます。`Capsule`って名前あるのか、どういうことですか。SwiftUIに`Capsule`ってあるのね。なるほど。ということは、私の問題ではないですね。

だから、`GraphCapsule`はとにかく、この`GraphCapsule`ファイルの方はもうざくっと、ざくっと消した状態で良くて、`HikeGraph`の方の`Capsule`、これがSwiftUIの`Capsule`ですね。これで…あれ、パラメータまだ聞かれるか。えーと、1、2、3、4個がパスされたってスタイル。これを渡す必要があるよ、という話になっていますけど、まだ`GraphCapsule`間違えたかな。ここ、この`body`…こっちだ。えーと、これがSwiftUIの`Capsule`ですね。これはこれで良くて、もう1個、ここ。ここは`GraphCapsule`…こっちの`GraphCapsule`ですね。ちょっと名前がわかりづらかったかな。`GraphCapsule`。`HikeGraph`の…うーん、待て待て、しょうがないか。あー。

とりあえず、ローカルチェック…じゃないや。プレビューはできましたね。じゃあこれで、持ってきたから、`GraphCapsule`のファイルは要らないですよね。これね、ざくっと消して。それで、`HikeGraph`の方なんですけど、まだちょっと気になるところがあるような気がしていて、どうしようかな。このファイルだけ見ればいいかな。横のナビゲーションは消しておいて、えーとね、これで、この辺のカラーはまあいいのかな。パレット。このカラーも、なんかまとめたい気がしますよね。すでに、ほら、これ、カラー…カラーは定義してなかったっけ。スタイルにしてたのか。`ShapeStyle`か。`ShapeStyle`でもまあいいか。だから、`ShapeStyle`と`Color`とか、ちょっと試しに…なんだっけ。バッジ…あ、バッジシンボルありますね。じゃあ大丈夫だ。プレビューはいったんどかしておいて、この2つのカラー、これをスタイルに定義しちゃいました。 シェイプスタイルについてです。Xcode がバージョンアップされた状況で、ナビゲーション周りの挙動が少し変わりました。以前は Option キーを押しながらの操作で、いわゆる Option-Click によって別ペインで開く、という設定にしていました。Xcode の Navigation 設定の「With Option-Click」で「Next Editor」や「Separate Editor Pane」を選べるあの項目です。新しいバージョンになったときに昔の設定に戻さないほうが基本的には良いと思うのですが、タブでどんどん開かれてしまうのは少し困るので、今は「Separate Editor Pane」寄りの挙動にしています。「Unpin Tab」など、いろいろ変わったところもありますね。

左側のナビゲーション周りを見ていて、`accentColor` のような色を「カラー」ではなく「`ShapeStyle`」としてまとめて持っておきたい気がしてきました。`static var` で用意する計算型プロパティにするのが良さそうです。これはプロトコル拡張に載せるので、単なる値でも構いはしますが、ここでは計算型プロパティでいきます。

たとえば、`HikeGraph` で使うエレベーションの色を `static var` で用意します。名前は `elevationHikeGraphColor` のようにして、戻り値は `Color` にします。さらにもう一つ、`pace` 用に `static var paceHikeGraphColor` のようなカラーも用意します。いずれもその `Color` を返すだけです。こうして名前を付けておくと、後から使うときに分かりやすくなりますし、スタイルとして統一できます。デフォルトのグラフ用の色は特に固有名を付けなくてもよいかもしれませんが、必要なら `static var unknownHikeGraphColor` のような色を決めておくのもありです。

分岐には `switch` 式を使いました。せっかく `switch` 式があるので試してみた、という感じです。`return` を書いたほうが都合が良いこともありますから、無理に消す必要はありませんが、ここでは `switch` 式でスッキリさせています。これでカラーのプロパティはいい感じに作れたと思います。

一度プレビューも確認しておきます。壊れてはいなさそうで、ちゃんと出てきていますね。今はとりあえず赤 (`.red`) にしていますが、`@State` を付けているわけではないので、「それは `@State` じゃないよ」という主張は特に必要ありません。

`body` プロパティの中では、`Hike.Observation` と、`rangeOfRanges` という関数を呼び出しています。現状は同じファイル内で定義している関数を使っていますが、その他の要素は、型や拡張の中に適切に所属させるというガイドラインに沿って整理していきます。今はその所属先が少し気になっているので、改めて見直していこうと思います。 まずは、ちゃんとRangeに属しそうなマグニチュードから見てみます。いまは「magnitude(of: range)」のような関数で、レンジに対して`Double`が返ってきています。`upperBound`と`lowerBound`の差の絶対値は距離ですから、これはレンジに属する性質と言えますよね。つまり、`Range`自体が持っていてよいはずです。`Range`に`distance`のようなものはありませんでしたっけ。距離を扱うには、境界の型が`Strideable`である必要があります。昔は`Indexable`だった気もしますが、いまは`Strideable`ですね。

ただ、`Strideable`の定義はストライドできることなので、仮にそれで距離が取れたとしても、そのままだと嬉しくないかもしれません。とはいえ、やはり`Range<Bound>`に対する`extension`で用意するのが本筋でしょう。モジュール内部だけに閉じるほど特殊な状況ではなさそうなので、通常の`extension`にします。

`extension Range where Bound: Strideable`のようにして、`var magnitude`というプロパティを生やすのがよさそうです。レンジのマグニチュードなので、`var magnitude`で問題ありません。これで呼び出し側も自然になります。わざわざ「magnitudeOfRange」みたいな冗長な名前を使わずに済みます。

次に、既存の呼び出しを直します。KeyPathで参照したレンジに対して、その`magnitude`を取るようにします。たとえば、データが`Observation`の配列なら、`data.map(\.observation.range.magnitude).max()`のようにして、マグニチュードの最大値を求めます。このデータは`Observation`ですから、`map`の引数は`Observation`のKeyPathですね。少し長くなりますが、自分の記憶力に頼りすぎると混乱するので、ここは明示的に書いておきます。これで「マグニチュードの最大値（たとえば0.15）をハイライトしている」ことが視覚的にも分かりやすくなります。ほかの箇所でも、全体のレンジのマグニチュードは同様に`range.magnitude`で取ればよいでしょう。

この変更でエラーが出るはずなので、ショートカットで次のエラーにジャンプします。ナビゲーションの「Jump to Next Issue」です。たしか「Command+シングルクオート」ですね。あ、飛びました。プレビューも表示しておきます。先ほどのように壊してしまうと困るので、プレビューを出した状態で進めます。

これで、`magnitude(of:)`を消して、`range.magnitude`に置き換えていきます。見やすさのために、`data.map(...).max()`の形に統一します。終わったら、データの解消が済んで、グラフが変わっていなければ成功、という判断にします。

…と思ったのですが、大失敗ですね。何が悪いか、コードを見ないといけません。全然ダメになっています。どこまで戻せばよいのか…厄介ですね。まずは、通っていた状態まで戻します。この段階ならプレビューも戻っているはず。戻りました。よかったです。壊してしまったらしょうがないので、慎重に進めます。

さきほどマグニチュードを実装しましたが、高階関数を使っている箇所、つまり`magnitude(of:)`を置き換えたところで`.max()`を呼んでいます。ここでマグニチュードの計算がおかしい、という指摘になっているので中身を確認します。あ、これ、`lowerBound`を2回引いていますね。完全に大誤算です。正しくは`upperBound - lowerBound`（あるいは`lowerBound.distance(to: upperBound)`）にしないといけません。修正します。

これで再度プレビューを確認します。今度は大丈夫そうです。一応、いったん元に戻せるところまでは戻して、改めて動作確認を済ませました。 反転していると怖いので、その点を確認します。大丈夫そうです。これでマグニチュードにして、次は`OverallBendy`のマグニチュードを設定します。これでもグラフが壊れなければOKです。問題なさそうです。

次にもう1つ、`TPath`もマグニチュードにします。`magnitudeOf`のところを`TPath`のどこに適用するかを確認し、該当箇所にマグニチュードを設定します。これでプレビューが壊れていなければOKです。`magnitudeOf`はすべて使い切ったので、元のコードは削除します。プレビューも正常に動きました。良さそうです。このままもう少し進めます。

いろいろありますが、まずはタイプグラフの部分が、先ほど述べたとおり分かりにくいところです。`Observations`については、`Observations`の`map`で、`{ observation in observation.tPath.magnitude }`の形にします。`TPath`とマグニチュードがあり、`TFloat`は`double`型と暗黙的に型変換できるという基本的な特徴があるので、これを利用して`map`内で型変換するのがよいでしょう。

ただし、`TPath`に対して`I2Observation`が適用できないというエラーが出ます。これは変換の方向の問題です。加えて、よく出るエラーがあり、ネット版だとおかしくなることがありました。その点は気になっていますが、しばらくはリファクタリングを進められそうです。 とりあえずここで解決したいです。Range of Ranges がフリーで、ふわっと浮かんでいる状態になっていて、これは何をしているのかなと思いました。`G` がコレクションで、コレクションを受け取ってレンジを返す。そのとき、`G` の要素は `Range<Double>` ですよ、ということですね。つまり、レンジのコレクションからレンジを返すものみたいです。レンジのコレクションから、`Double` 型のレンジを取り出す、という感じでしょうか。

そのときに、レンジが空でないことが条件で、空だったときには `0..<0` という無効なレンジを返すと言っています。そうでなければ、`low` と `high` を `Int.max` などで初期化して…という話になります。これ、レイジー（`lazy`）にしても、結局全部チェックしますよね？ いや、どうなんだろう。`lazy.map` が必要なのかが最初は腑に落ちませんでした。`lazy` でレンジの中から要素を一個ずつ取り出して `map` し、`min()` が見つかった時点で終わる…と言いたいのかもしれませんが、`min()` が確定するのは結局最後まで見た時点では、という気もします。とはいえ、`map` の結果をまるごとメモリに展開せず、逐次的に `min` チェックしてくれる、つまり中間コレクションを作らないという意味では、メモリは節約できますね。なるほど、こういう使い方があるのか、と。

`Ranges` があって、`Ranges` はコレクションでもありシーケンスでもあります。シーケンスから `min` と `map` は先頭から順に処理しますよね。この時、`lowerBound` とか `upperBound` を見たいわけで、やっぱり `lazy` があるほうが良いのかもしれません。速いというより、中間配列を作らなくて済む分だけ効率的、という理解です。

これってシーケンスではダメなのかな、とも思いました。シーケンスだと `isEmpty` が使えないからでしょうか。`next()` を取るわけにもいかない…いや、取れなくはないのですが、最初の要素を消費してしまいますし、きれいではない。`isEmpty` のためにコレクションを要求している、というのは少しオーバースペックにも見えますが、まあ妥当ではあります。

ということで、レンジのコレクションを受け取り、空だったら不正な値を返す。そうでなければ、レンジに対して `lazy.map` を使い、それぞれの `lowerBound` の `min()` と、`upperBound` の `max()` を返す、という実装になっているわけですね。ここ、`lazy` を使って頑張っている割には、`min()` と `max()` を別々に2回走らせているのが少し気になります。同時に取ろうとすると、自分でイテレーションを書くことになりそうです。`min()` と `max()` をコレクションに対して個別に取る方がシンプルではありますが、まとめて一発でやるなら自前で回す形になる、という理解です。

`max()` で `lower` と `upper` が手に入る…というわけではないので、そこは勘違いしないように、ですね。ちょっと自分でも組んでみます。 間違えるとどうなるのかを確認したかったので、あえて間違えたやり方で試してみます。「min」と「max」でやっていきましょう。最近こういうコードを書くのをあまりやっていなかったので難しいですね。単なるコードですが、自分の中では見にくいので体裁を整えます。インデントも直して、ガードも入れます。これはフリー関数ですよね。これでよさそうです。

レンジの各要素を見終わったら、`if` だったら早期リターンで抜ける、みたいにしていましたが、シーケンス的にもできるのではないでしょうか。レンジに対して `reduce`（あるいは `fold`）できますよね。イニシャルバリュー、つまり初期のリザルトは `0, 0` という形にして、とりあえず `lo` としましょう。これで `partial_result` と `range` を受け取る感じにして、レンジの中で `lo` と `upper` の `max` をやればよいですね。`if` 文でやる手もありますし、関数でやる手もあります。

`partial_result` の `lo` は、`range` の `lower_bound` との小さい方、つまり `min` を取るイメージです。`min` 関数はそんなに重たくないですよね。`partial_result` の `hi` は `max` で比較して、`hi` と…そうですね、`max` で `partial_result` の `hi` を更新する。リテラルでこの型を浮動小数に合わせる必要があれば合わせます。これによって、`partial_result` の `lo` は全体を通して最小値に抑えられますし、`hi` は全体を通して最大値に更新されていきます。これでよいでしょう。

ここで `lo` と `hi` を返していますが、変数名は `bounds` にして、`bounds.lo` と `bounds.hi` のようにアクセスする形にしましょう。レンジがあって、その各レンジに対して `lower_bound` を取っていき、その中のいちばん小さいやつを選ぶ。一方で `hi` の方は…`min`/`max` でいいですね。`min` と `max` に変えます。ここは `max` で、こちらも `max`。これでよいはずです。

`bounds` はダブル、つまり `f64` ですよね。型は `Bounds`（のような構造体）で持っているはずです。名前が「レンジ」だと紛らわしいので「bounds」のほうがよいですね。`min/max` について、`min` が被っちゃうなら…`min` 関数は誰が持っているんだ？ そうですね、`Iterator` の `min` と `Iterator` の `max` を使えばよいです。これで `0` も取れて、`min` と `max` が取れます。`lo` と `hi` があって、`return` で `lo` と `hi`…いや、`0` じゃない、`min` と `max` ですね。

ところが、`reduce` で `min` と `max` の初期値を `0, 0` にしてしまっているせいで、これが邪魔をしています。初期値の `0` に引っ張られて、結果が `0` に落ちてしまいますね。ここが原因でした。初期値が `0` だとダメでした。 ここですね。なるほど、これはオプショナルにしないとダメですね。オプショナルにするとなると……。うーん、どうしましょうか。`Sequence` にしたいのですが、`Sequence` にすると `first` がダメでしたっけ？ `Sequence` と `Range`、それから `reduce` とその結果型、ラムダ……という感じでいくつか選択肢があります。

もう一つの方法はイテレーターを使うやり方です。`makeIterator()` で返ってくるイテレーターは `Sequence` のイテレーターですよね。このイテレーターは `next()` しかなくて、`reduce` が使えないだけなので大した問題ではありません。悩みどころはそこではなく、実装の流れのほうですね。

たとえば、`var rangeIterator = range.makeIterator()` のようにして、最初の要素を取り、取れなければ `guard` で抜ける、というのが素直そうです。そのうえで、`var min` と `var max` を用意して進める形です。`guard` の前に `var` は置けるかな……いや、`var` で問題ないですね。`var min: Double`、`var max: Double` のようにする想定だったのですが、よく考えると `Range` のイテレーターの `next()` は `Element` が返ってくるので、`Double` 固定ではダメですね。まずは `range` から最初の要素を取って、その型に合わせて `min` と `max` を決めるべきです。

最初はタプル束縛のように `min, max = rangeIterator.next()` と書ければ楽なのですが、さすがにそれはできません。`let` にすれば大丈夫かなと思ったのですが、イテレーターの `next()` はミューテーティングなので、イテレーター自体は `var` でないとダメですね。ここは素直に `guard let first = rangeIterator.next() else { … }` で最初の要素を確定させ、`var min = first`、`var max = first` としてから、残りを `while let x = rangeIterator.next() { … }` で更新していくのがよいでしょう。

制御は多少ややこしいですが、ローカル変数で使う分には、この関数の外に状態を出さないので、可変状態は完全にカプセル化できます。これで良いと思います。変数を3つほど使いますが、その代わりに見通しは良くなりますし、変数に関する懸念はこの `rangeOfRanges` という関数の中に完全に閉じ込められているので安全です。

では、これで進めましょう。この関数を作って、ここまででやったこととしては、`min` と `max` を使う例だけですね。その例だとここで整数リテラルを使っています。`Range` の型パラメータを `W` ではなく、たとえば `Value` として、`Range<Value>` という書き方にしておきます。

リテラルについては、`ExpressibleByIntegerLiteral` でごまかすか、あるいは `AdditiveArithmetic` を使う方法もありますが、今回は加算を使っていないので `AdditiveArithmetic` 準拠までは不要かもしれません。リテラル変換（`ExpressibleByIntegerLiteral`）で十分でしょう。別案としては、この関数自体がオプショナル（または無効な状態を表す何か）を返す仕様にすることです。今回は無効な範囲を返していますが、無効な範囲は `Range` 自体としては直接は持てないので、たとえば `0..<0` のような「空の範囲」を返すには、`Value` が `ExpressibleByIntegerLiteral` を満たしている必要があります。

ここでエラーが出ているのは、上下の取り違えがあったからですね。`lowerBound` と `upperBound` を正しく参照すれば大丈夫です。`Range` はすでに `Bound: Comparable` を要求しているので、境界同士は比較できます。あとは「0」をどう表現するかだけですが、それは `ExpressibleByIntegerLiteral` を使う方針にした、ということです。

「0」は数値リテラルの 0 でも良いのですが、`AdditiveArithmetic` に準拠していれば `Value.zero`（`Self.zero`）も使えます。ただ、今回は加算などは使っていないので、`AdditiveArithmetic` まで広げる必要はなさそうです。リテラルの 0 を使うなら `ExpressibleByIntegerLiteral` 準拠で十分です。どちらにするかは API の意図次第ですが、今回はリテラル 0 でいきましょう。 悩ましいところですが、`Range` で無効な `Range` を作りたいわけです。ただ、そのためにも 0 が欲しいのですよね。0 を用意する方法として今考えられるのは、`ExpressibleByIntegerLiteral` にするか、もう諦めて `AdditiveArithmetic` にするか、または `Numeric` にするか、といったところです。今回の目的だと、`Numeric` にするのが確実でしょうか。これでも実現できますよね。こうしておけばリテラルに変換できて、かつ中途半端な指定よりは「値は数値ですよ」という意味がはっきりするので、まずはこの方が妥当な気がします。あまりジェネリックプログラミングで大きい方に寄せることはしてきませんでしたが、妥当だと思います。

あとは、`T` が `Sequence` になっていますが、ここは `Ranges` で良いですね。`Ranges`。そしてここも `Ranges`。これで、`Ranges` の要素が `Range` の値で、その要素の値が `Numeric`、という形になります。例えば割れていないし、ということで OK。

ここまでやりましたが、これはフリーな関数で、`Ranges` の中から `Range` を取るという話ですよね。なので、具体は `Ranges` な気がします。そうすると、フリーな関数にするのではなく、`Ranges` に持たせた方が良いのでは、という API デザインガイドライン的な考えになります。さきほど作った `Ranges` のファイルに移動してみましょう。移動するときのコードはこれです。これを付けると何が良いのかというと、今回はとにかく `Sequence` で良いので、`extension` で、`Sequence` かつ `Element` が `Range` の値、という形にできないかを考えます。

つまり、`Sequence` で `Element` が `Range` の値にできないか。`Sequence` はどうするんでしたっけ。`Ranges` で、`Element` が `Range` プロトコル……いや、`Range` のプロトコルなんてありませんよね。`Range` プロトコルにしてしまうとダブってしまいますし、それは困ります。どうやるんだっけ。`Sequence` の `Element` が `Range` で、しかも `Range` の `Bound` が……。とりあえずプロトコル拡張ではなくて、`Range` のほうで、もう少し試してみますか。

`Sequence` の `Element == Range` にするとなると、`Value` とか言わないといけないはずですが、その `Value` がないわけですよね。ここで `Value` を追加してもどうにもなりません。ここに `Value` と書いたらプライマリ要素になるだけで、意味がありません。`Range` のここを省略できるわけでもないですし、`Value` をここで `Numeric` にしたいのですが、そんな書き方はできません。ここで `Value` とやると第一要素になってしまいますし、`Range Value` なんて書けません。

そうすると、`Bound` として考えるしかないですね。`Range<Bound>` だったら別に良いのですが、他にあるのは `Range` のプロトコルでしょうか。`Range` のプロトコルなんてありましたっけ。`Expressible...` かな、`ExpressibleRange` とか？ 違いますね。`Range` 型を見ればいいのか。`Range` が準拠しているのは `RangeExpression` か、なるほど。`RangeExpression` はあります。`RangeExpression` でも良いのか、試してみましょう。これでいけるかもしれません。

つまり、ここで `Sequence` です。`Element` が `Range`、ではなく `Element` が `RangeExpression`。`RangeExpression` なら `Bound` が使えるので、`Element` の `Bound` が `Numeric`、という条件にできます。こういうふうに解決できましたね。これで条件は整いました。整いましたが、ここだとまだダメなはずです。`upperBound` と `lowerBound` が多分通らないのでしょうね。 まずは関数を全部持ってきますが、名前の問題がありますね。`Range` の `Range` というのは意味がわかりにくいです。すべてを含む、つまり全体を覆う範囲を表したいので、名前を工夫したいところです。たとえば「1から3」と「5から10」のように離れた区間があるとき、それら全体を「1から10」で覆う一つの範囲のことを指したいわけです。

この場合、離れた複数の区間の全体を覆う一つの区間という発想になります。英語だと「Union of Intervals」や「Smallest Enclosing Interval」などが候補に挙がります。日本語だと「最小包含区間」や「バウンディングレンジ」「境界レンジ」など、いろいろ呼び方があるようです。となると、`Union` はキーワードかな？という迷いも出ますし、`Merge` も少し違うかもしれません。やはり「Smallest Enclosing Interval（最小包含区間）」が一番しっくりくる気がします。

今回は `Range` を扱うので、関数ではなくメソッドにします。メソッド名は `smallestEnclosingRange` のような形がよさそうです。その際にジェネリクスの制約をきちんとかけます。`Self.Element` が `RangeExpression` で、かつその `Bound` がコレクションの `Index` と一致する、という制約、つまり `where Element: RangeExpression, Element.Bound == Index` のような形です。

実装の中では、`Range` が相手なので `makeIterator()` で走査します。ところが、`RangeExpression` のままでは `lowerBound` と `upperBound` に直接アクセスできません。`Unbounded`（下限/上限がない部分区間）の可能性があるためです。したがって、ここでは要素をいったんコレクションに対して具体化する必要があります。つまり、`RangeExpression` を `relative(to:)` でそのコレクションに相対化して、実体の `Range<Index>` に変換します。これで `lowerBound` と `upperBound` が取れるようになります。

一時は、`Element` 側にさらにバウンド（境界）を課して解決しようとして、`Self::Element` が `RangeExpression` で…といった具合に再帰的な制約を書き始めてしまい、表現がややこしくなりました。しかし、`RangeExpression` である以上、`relative(to:)` を通して具体的な `Range` に落とすのが正攻法です。`Sequence` として `makeIterator()` で要素を取り出し、それぞれを `relative(to:)` で `Range<Index>` に変換しながら、`lowerBound` と `upperBound` を見て全体の最小包含区間を更新していく、という流れになります。

要するに、`RangeExpression` のままでは境界情報（`lowerBound`/`upperBound`）が不十分で、`Range` に具体化して初めて扱える、という点がポイントです。`Collection` に対する `relative(to:)` という変換を挟むことで、うまく実装できるはずです。 こういうパーシャルレンジを渡したときに、50、60みたいなのは取れるのかな、という話になりますね。`relative(to:)` で、与えられたコレクション表現の範囲でレンジを取る、そういったものになっているはずです。パーシャルレンジを渡したとして、コレクションに対して相対的に解決される、ということですね。レンジが返るとして、具体的に何を渡すのか、この使い方がまだよくわかっていません。調べてみます。

LowerBound、UpperBound、閉じた範囲かどうか、みたいな話ですね。多分、`RangeExpression` を使うときは今のを使うんですよ。そうしないと写ってなくなっちゃってね。`RangeExpression` がどういうものか、`relative(to:)` をどう使うのか、この辺で確認しておきたいです。

`relative(to:)` に渡すコレクションに対して相対化されるのに適した範囲が返ってきますが、返される範囲はコレクションの境界内にあることが保証されていない、という記述になっています。それでいいんですけどね。

例えば、`numbers` として 10 から 70 までがある中で、`..<4` が「4 まで」のパーシャルレンジです。`..<4` を `relative(to: numbers)` にすると、`0..<4` になるのかな、という理解です。`r1` が `0..<4`、つまり 0、1、2、3 が範囲になるわけですね。別の開始インデックスを持つ場合は、下端がその開始インデックスから測られます。例えば、インデックス 2 から始まるスライスだと、`2..<4` になる、という感じです。なるほど、というところです。パーシャルレンジ、難しいなぁ。どうしようかな。`RangeExpression` の挙動がまだ腹落ちしていないので、プレイグラウンドで試します。

とにかくパーシャルレンジを具体的なレンジ型に変えたいんですよね。レンジに変えるにあたって、どういう手法を取ればいいのかが、まだ分かっていません。これをするには、プレイグラウンドでちょっとやってみます。ファイルで New Playground、Playground Blank を作って、コードを書きます。

例えば、`let range = /* some RangeExpression */` として、この中で `1..<10` でいいか。このときに `print` はしなくてもいいかな。`range.relative(to: /* コレクション */)` があるとして、これは何が返るんだろう。`relative(to:)` で `1..<10` が返るのか、それとも 1 だけになるのか。`relative(to:)` に 0 を渡す、みたいなのはだめで、コレクションを渡す必要があります。`some RangeExpression` でいいのか、押してあげるとこれでいいですね。プレイグラウンドを動かしたときに、これが `1..<10` になるのか、それとも 1 だけになるのか、どうなんだろうね。今、実行中です。

これで取れたとしたら、とにかくレンジ型に振り替えられる、そういった効果が得られるという理解でいいのかな。範囲内にあることは保証しないといけないから、それで良いはずです。`relative(to:)` で 0 から、つまりインデックスが 0 からの前提で、レンジ型が取れる。そうすると `upperBound` とかが取れると思うんですが、プレイグラウンドは今どうなっているんだろう。結果は？ 準備中かな。

この間に、`let` で Result 的な書き方かな、などと思いつつ……。なんだかプレイグラウンド、少し変わりましたかね。まあいいか。iPad 系に似てきているような気がします。あまり使っていないので、使い方が変わりすぎるとちょっと嫌ですね。まあいいか。 ディスタンス系の処理については、さっき自分で `distance` を作りました。エディタが「ディスタンスフロム（`distance(from:)`）がある」と予測して提示してきますが、これはプレディクティブコードコンプリ―ション（予測補完）なので、必ずしも正しいとは限りません。一応、補完に従って書いてみましたが、`distance2` のように数字から範囲を出しているだけのものもあって、期待したものではなさそうです。

いまはプレイグラウンドで試しています。実行するとエラーになっていて、この辺一帯をコメントアウトすると動きます。つまり、自分のコードに致命的な間違いがあるということですね。たとえば、`1` から `0` をレンジとして書いてしまうと、Swift の「レンジ式（`RangeExpression`）」としては不正ですし、「レンジ式はプライマリ式でなければならない」といったエラーになります。これはもうダメですね。

しょうがないので関数を作ることにしました。名前は正直あまり良くないのですが、仮に `execute` とします。引数には「`some RangeExpression` で `Int` を取りうるもの」を受け取り、中で `Range<Int>` を作って結果を返す、という方針です。返り値は `Range<Int>` にして、最後に `return result` とすれば、外側で `let result = execute(...)` のように呼べます。これで、`result.lowerBound` と `result.upperBound` を見れば、レンジが期待どおりか確認できます。実際に動かすと、`lowerBound` が `1`、`upperBound` が `10` になりました。プレイグラウンドの表示が少し見にくくなってきましたが、動作自体は問題なさそうです。

部分レンジの扱いも試しました。`0, 1, 2, 3 ...` の並びで、たとえば部分レンジを `3..<4`（あるいは `3..<5`）のつもりで指定して、`relative(to:)` で全体レンジに対して相対化したかったのですが、`3..<10` になるだろうと思ったところが、なぜか `1..<10` のままになってしまいました。ここは自分の理解が怪しいところで、この挙動に頼り切るのは危険な気がします。

先ほど書いていた `rangeOfRanges` をどうするかですが、`RangeExpression` を汎用的に受け取るより、受け取ったレンジ（あるいは自分自身のレンジ、要素がレンジであるケース）ごとに `relative(to:)` で処理するのが筋ではあるものの、あまりきれいに書けません。ジェネリクスに頼りすぎるのも微妙です。正直、`Range<Double>` と決め打ちしてしまえば一発で片が付きます。つまり、`[Range<Double>]`（レンジの配列）として扱う形です。やっていることはシーケンスからレンジを求めるだけなので、`let elements: [Range<Double>] = ...` としてしまえば良いという話です。

`some` を使って `Int` に束縛するような書き方は、場所によっては使えず、結果として `next` が取れない（イテレータとして進めない）といった問題にも突き当たります。ここは `Range` そのものを要素として扱う（すなわち「要素がレンジ」）設計のほうが素直かもしれません。

関数の配置（どの型やモジュールに所属させるか）もまだ決め切れていません。呼び出し元を見直すと、`rangeOfRanges` を使っていた箇所は、おそらく `path`（`KeyPath`）を介して `observations` をマップしてから、`enclosingRange` に流す、という形になっているはずです。たとえば、`observations.map { $0[keyPath: path] }` の結果に対して `enclosingRange` を適用する、といった流れです。

パフォーマンスを少しでも良くするなら、中間配列を作らないように `.lazy` を挟みます。つまり、`observations.lazy.map { $0[keyPath: path] }.map(enclosingRange)` のようにして、最後に `overallRange` を求める、という形です。これでビルドも通ります。

なお、`observations.map { $0.range.magnitude }.map(enclosingRange)` のように、別の箇所でも同じようなマップ連鎖をしているので、ここも API をまとめたくなってきます。いずれにせよ、`observations` を `keyPath` でマップして `enclosingRange` に流し、最終的に全体のレンジ（`overallRange`）を出す、という統一した書き方にしていくのが良さそうです。

補足として、エディタの予測補完（プレディクティブコードコンプリ―ション）や IntelliSense の設定場所を少し探しましたが、どこにあるのかまだ分かっていません。ひとまず今は保留にします。 とりあえず `lazy` を入れておきますが、これで壊れないはずです。まあいいや、とりあえずこれでいきます。さっきのレンズの所属先が決まったので、前回の方針に基づいて移動ができた、という感じですね。いい感じでしょうか。ここが引っかかっていますよね。

イテレータで `map` してキーパスを取るまでは一緒じゃないですか。だから、ここは一回メモリに持っておくか、またここでプロジェクションにして、同じようにやるかです。エンクロージングの範囲の `map` と、つまりその `map` と `max` の両方を `reduce` で計算していくとしても、まあ取れなくはなさそうかなという状況になっています。

一つは `max` を取っていくわけですよね。もう一つのエンクロージングレンジは、もうまとめたはずです。まとめちゃった場合だと、これと同じで一緒に……というか、`max` 取れていない？ これ。`max`、`max`……あれ？ `max` か。ここでやっているのはマグニチュードの `max` ですね。この違いです。だから、キーパスに対して `max` を取っていっているのだから、同じノリですよね。ここの中でマグニチュードに対しても `max` を取って、一緒に計算……さすがにちょっとまずいですけど、効率面で考えるならそういう感じになってきますかね。マグニチュードを取って、ということです。

なので、`Observations` の中で `overall_range` と `max_magnitude`、`enclosing_range`……という整理です。ここで `overall_range` と `observation_ranges` みたいな感じで一回やって、エンクロージング……。`observation_ranges = observations`。いや、`range` はいらないな。`range` いらないし、もしかして `observations` はここでしか使っていない？ まあいいか、使っていないならどうでもいいや。とにかく `map` にして、これで `self.key_path`。これはダメですよね。これはこうして、こうして、修正ですね。

それで、`observation_ranges` に一回メモリにも取ってしまいます。そんなにメモリは食わないと思います。`overall_range` はこうですよね。そう、そして `.smallest`。これで……あれ、これ、馬鹿みたいに大変なだけですね。

ここは `max`。これもそうですね。`.max`、それから `observation_ranges` で `.max` というふうにして、これで……ここがダメ。えっと、`observation_ranges` の——あ、そっか、マグニチュードの `max` か。だから、`lazy`……あんまり綺麗になりませんでしたね。`lazy` の `map` の、オブザベーションじゃなくて、マグニチュードのそれの `max` か。微妙でしたね。はいはい、なるほど。

まあでも、ここがアイテムを `push` してあげて、それで——あ、使っているのか、どうか。なるほど、じゃあこれでいいか。ああ、微妙でした。これは微妙でした。まあいいか。`enumerate` で回して、その中でいろいろ、という感じでやっている中で、いろいろとネックになっているところがあるので、もうちょっと——要はだいぶ時間がかかってしまったので、これはまたにしましょう。引き続きリファクタリングを進めていくのは次回に回すことにします。

はい、では今日はこれで終わりにします。お疲れさまでした。
