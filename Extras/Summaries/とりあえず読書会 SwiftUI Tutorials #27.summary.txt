Transcription & Summarize : とりあえず読書会 SwiftUI Tutorials #27

では、とりあえずどっちから始めていきましょうか。`SwiftUI` のチュートリアルは読んできていますが、Apple Watch のアプリもだいぶ進んできています。とはいえ、そんなに大きなアプリではないですけどね。リファクタリングをしながら進めていて、前回かその前あたりで、なかなかリファクタリングに手こずってしまいました。元のチュートリアルとは、データの渡し方がだいぶ変わってきてしまったのですが、`SwiftUI` の `Environment` をどこまで活用するのが良いのか、悩ましいところだと感じています。便利なのは確かだと思うのですが、特に今回のサンプルのように、インデックスにアクセスするような場面で、一度インデックスで取ったアイテムを、また `Environment` から探す、ということをやっていて、機能としては動くのですが、渡ってきたものを別の場所からまた探すのは、なんとなく違和感があります。こんな不確かさを持ったままにして良いのかな、という観点です。

そこでリファクタリングをして、今のところは、バインディングしたものを渡す形にすることで、最終的には `Environment` からインデックスを探すようなことはしないで済むようにしています。こういった `SwiftUI` のコードをあまり見たことがないので、これが正しいのかどうかは分からないのですが、方針としては論理的に間違っていなさそうな感じはします。この調子で、引き続き `SwiftUI` のチュートリアルをこの方法で進めていこうと思います。

リファクタリングした後のコードをどうしましょうかね。アップデートが終わってからアップロードする、というのもどうなのかもしれないですね。まあ、いいか。とりあえずそのあたりを気にしながらやってみました。

今日はセクション4を見ていく感じになりますね。さっそく読んでいきます。ランドマークリストを表示する、という内容です。iOS 版で作った `LandmarkList` が watchOS アプリでも流用できる、と言っていますね。そして自動的にナビゲートする仕組みも同じ、ということです。これは同じ仕組みだからですよね。次に、watchOS 用にコンパイルする話。これはすでに別に作ってあります。次に、リストを watch の `ContentView` に接続する、ということですね。これがないと表示されないので、ここが重要です。それによって、プレビューのビューが動くようになる、という感じです。

では進めます。ステップ1として、`ContentView` を選択して、さっそく接続していきます。`WatchLandmarkApp` のフォルダからですね。それで、`LandmarkDetail` と同様に、watchOS ターゲットでも `ContentView` は同じ名前で持たせる、という話です。watchOS 用の `ContentView` ファイルは、watch アプリを作ったときに自動的に生成されていますね。それを使っていきます。同じ名前を維持して、インターフェースも同じにしておくと、ターゲット間でファイルを簡単に共有できます。これは自分で作るというより、すでにある `ContentView` を活用する形ですね。`ContentView` 自体では特に何もしていません。あるだけの状態です。

そして、watchOS アプリのルートビューは、`ContentView` がリストビューを表示するように変更しましょう、とあります。`ModelData` を `@Environment` で提供する、という流れですね。プレビューにも `ModelData` を `Environment` として必ず提供しないと、`LandmarkList` 側でそれを使うため、プレビューが落ちてしまいます。`Environment` を渡し忘れるとアプリが落ちることがあるので、そこが少し気になります。どこかに `Environment` を追加したために、どこか別のプレビューに伝播していなくて、たどっていくとプレビューがエラーで落ちて、プレビューできない、というコードをよく見かけるんですよね。コンパイラで判定できない部分があるので、意外と難しいと思います。`UIKit` を使っている感覚と、`Environment` を使って UI を組む感覚が、そんなに変わらない気もしていて、宣言的かどうかという点はあるものの、そのあたりに違和感を覚えるコードをよく見ている、という感じです。

とにかく、ランタイムのアプリケーションレベルではすでに提供しているとしても、プレビューでは各プレビューごとに必要に応じて `ModelData` を提供する必要があります。`LandmarkList` のプレビューにも `ModelData` を渡す、ということですね。ひとまずそこまでで良いでしょう。ライブプレビューでアプリの動作を確かめる、という話のようです。ここまでやれば良い感じです。

Apple Watch の `ContentView` の中で、`LandmarkDetail` と `LandmarkList` を表示できるようにします。プロファイルのバインディングは要らないのかな。`showingProfile` のバインディングは自分で作ったのでしたね。`@Environment` として `ModelData` を用意していて、さらにプロパティとして渡さなきゃいけない箇所がある。`LandmarkList`（iOS のほう）も見ておきました。`Environment` を渡した感じですね。`ContentView` の中で `showingProfile` を扱って、`LandmarkList` に `showingProfile` を渡しておく。`showingProfile` を iOS と watchOS の両方でできるようにしよう、という話を以前にしたのでした。それをやるためにこうなっていて、`showingProfile` を渡す必要があるけれど、これは watchOS では使わない想定だったから入れていなかったのかもしれません。

対応としては2つあります。ひとつは watchOS にも `showingProfile` 機能を入れる方法。もうひとつは、watchOS では `showingProfile` 機能を持たせない方法です。`LandmarkList` 側で `showingProfile` を参照して、プロフィールを表示するかどうかのボタンを追加する、ということもできますね。それに応じて `showingProfile` のバインディングが変われば、自動的に表示の挙動も変わります。iOS 版の `ContentView` には親に `showingProfile` があるので、これを使ってプロフィール表示を制御できます。Apple Watch ではどうするか、という判断になります。

どうしましょうか。Apple Watch からは削ってしまう形を取るのが一番良いと思いますが、まずはチュートリアルに沿って進めてみます。なので、ひとまずバインディングを `false` のまま渡して、絶対に機能しない状況として作っておきます。ここでは `showingProfile` は `Binding.constant(false)` のようにして、まずはごまかします。これで試せるようになった、という話だと思います。そしたら `ContentView` のプレビューを見れば良いですね。こんな感じで進めます。ちゃんとリストが出ますかね。出ると思いますが、あとはお楽しみ、という感じです。これで表示されて動いたら次のステップに進み、その後、ゆっくりと `showingProfile`（Apple Watch では使わないプロフィールのカスタマイズ）をどうするか、どう折り合いをつけるかを考えていけば良い気がします。難しいですね。プロフィールを watch で見られたほうが良い、という発想も十分あり得ます。その場合は `showingProfile` のアプローチは悪くないと思います。ただ、そのボタンが Apple Watch でどう表示されるのかに依存します。うまく連携が取れるなら、プロフィールを見せる方向に従うのも良いでしょう。ですので、まずは Apple Watch 全体をひとまず作ってみて、その状況においてプロフィール表示がいるのかいらないのかを判断する、というのが良いかもしれません。

そんな感じで進めるとして、プレビューがまだ進まないのですが、ビルドを一回してみましょう。ビルドが通ることは確認できたので、プレビューを表示して、ちゃんと出てくるか見ておきます。もしプレビューが出てこないなら、読み進めてしまっても良いかもしれません。Apple Watch の出力設定もこれで良いはずですし、問題なくビルドできています。問題なければ表示されるはずですが、されないのかな。まあ、いいか。まずは確かめたつもりで、次に行きましょう。確かめられれば、たとえば「Favorites Only」など、いろいろリストの表示が出るようになる、ということですね。では、セクション5に進みましょう。 まずは Notification Interface を作ります。watchOS 版の Landmarks アプリです。これはほとんど完成しているようですね。最後のセクションとして「Notification Interface とは何か」を確認します。内容としては、「お気に入りの場所の近くにいることを示す通知を受信したときに、ランドマークの情報を表示するインターフェースを作成する」というものです。英語の「Receive notification indicating you’re close to one of your favorite locations」のような記述で、"close to" は「近く」という意味ですね。最初はよく分からず戸惑いましたが、要するに「近づいたときの通知に応じて、それを表示する」ということだと分かりました。

このセクションでは、通知を受信したあとの表示、つまり「どうディスプレイするか」だけにフォーカスします。通知を送信する側の話には触れない方針のようです。

では、Landmarks のデータがあって、インデックスなどを使って表示していく形に進みます。その前にプレビューを動かしてみます。今は動いていないので、どうしましょうか。プレビューを増やしまくるわけにもいきませんし、とりあえず保存し直して、ビルドしてみました。ビルドは成功です。ここで実行ターゲットを Apple Watch にしてみます。もう一度プレビューを出して動くか確認したいところです。セクションの移動が大きく、やることも多いので、動くところまで確かめたいですね。

これが動かないのはどういうことでしょう。Xcode を一回落とせば直る、というよくある話かもしれません。あるいはクリーンビルドも手ですね。では Xcode を一度落としてみます。もう一度プレビューを動かします。今度は watchOS のビルドが走りました。いつもと挙動が違うので、いける気がします。準備中…iPhone シミュレーターの起動中と出ています。iPhone になっているのはダメですね。Landmarks を watchOS に切り替えて、シミュレーターも watchOS を選びます。実行ターゲットを Apple Watch に変えましょう。それからビルドを一度止めて、ビルドがちゃんと走ってからキャンバスを開き直します。こんな感じで進めます。

ビルドが走って「iPhone シミュレーターを準備中」と出ています。少し待てばいけるかもしれません。うまくいかないときは、クリーンビルドやシミュレーターの再起動という手もありますね。シミュレーター自体はまだ起動していないようです。ビルドは成功しましたが、試せていないので、実行してしまいましょう。実行します。これでシミュレーターが起動して、Apple Watch が出てくるはずです。どうでしょうか…出てきました。

少し懐かしいことを思い出しました。Apple Watch のアプリを初めて作ったとき、このシミュレーターを見て感動したんですよね。そのときはまだ Apple Watch 発売前で、使う機会のあるイベントがあって作ってみたのでした。初代の発売前の話です。懐かしいですね。ともあれ、これは動きそうです。シミュレーターなら大丈夫な気がします。

リストが表示されました。遊び終わったら次へ進みたいところです。画面の片隅に「プロフィール」のボタンがあります。これは表示しないようにしたいですね。あるいは押したらプロフィールを出す方法もありますが、画面が狭いので少し邪魔に感じます。「St. Mary Lake」を押すと、ちゃんと詳細が開きます。アプリ自体は良い感じです。

先ほどのボタンが微妙なので消したい気がします。まずはもう少し実用的な作りに寄せましょう。表示が違う点も気になっていますが、結局のところボタンが邪魔なだけです。ではセクション5に進みます。通知によって表示されるランドマークを表示する、という話ですね。そのためには、Landmarks のインデックスをデータから取得して表示する形になりそうです。通知からインデックスが渡ってくる想定でしょうか。ひとまず、その方針で進めていきます。 文字起こしのテキストをお送りください。いただいた内容を、ですます調に整え、適切に句読点を入れ、誤変換を修正します。コードは必要に応じてバックティックで装飾します（短いものはインライン）。途中から始まる不完全な文は無視して次の文から整えます。複数人の会話でも発話者名は付けず、内容を踏まえた自然な文章にします。 とりあえず、新しいカスタムビューとして、watchOS 用のアプリの中に `NotificationView` を作って、Landmarks に関する情報をそこに表示させていくことにします。タイトルとメッセージも表示します。コードはこれですね。`NotificationView` は、これはコピーしちゃったほうがいい感じがします。どこまでコピーしようかな。ビューの中身…あれですね。これでまず `NotificationView` を作ってあげると。

なので、watchOS のところで SwiftUI ビューを作って、`NotificationView` をこんな感じで用意します。プレビューはどうしようかな。プレビューは動かしたほうがいいか。それで、中身に、今コピーしてきたやつを貼り付けてあげると。今のところは良いですね。これによって `NotificationView` が表示される…けど、まだそれじゃないか。この辺の引数がまだ設定されていないですよね。タイトルとメッセージと Landmark がちょっと気になります。何を表示したいんだろう。

まずはここまでコードができたので、次にプレビューを追加します。タイトルとメッセージと Landmark を `NotificationView` にセットして、プレビューできるようにします。これで `NotificationView` が、データが提供されたときに表示できるようになったかな。任意の Notification の値を `nil` にできるので便利、という説明があります。デフォルトプレビューとして、データがないときにも `NotificationView` を確認できるのに役立つ、と。`NotificationView` を作るこのコードをデフォルトプレビューにしてみましょうか。データがないときにこれを `nil` にできるのはいいんですけど、本当に役に立つのかな？自分の感覚とは違う気がしますが、やってみないとわからないですね。

とりあえず、Turtle Rock を仮のデータとして入れて、Landmark の 0 番を使う、という感じで試してみます。これのプレビューはまだダメですね。データの持たせ方が違うはずです。それと、ここは自分のコードのリファクタリングの都合でダメになっている部分ですね。原因は `resizable` がダメなだけで、`resizable` は確か `AsyncImage` の中にも持たせましたよね。そんな気がします。`AsyncImage` の中で `resizable` を指定してうまくいったので、これでいいですね。これでプレビューが出てくる、というお話です。

ただ、全部が `nil` だったときに、Turtle Rock まで「5分でたどり着くよ」とか言われても、さすがにいい加減なことを言っている感じになります。`nil` のときに本当に 5 分とは限らない可能性がある。その状況で `nil` を許す意味というのが、自分にはまだよくわかっていません。この辺は後で調整していきましょう。プレビューは「できた」と言っているだけなので、ひとまずはこんなもんでしょう。

これでステップ3として、新しい Swift ファイル `NotificationController` を作ります。ホスティングコントローラー、Landmark、タイトル、メッセージのプロパティを持つ構造体（ここで情報が渡ってくるので、それを表示したい、という意味ですね）を用意します。コントローラーなのか…まあいいか。これらのプロパティは値を保持します。`NotificationController` は `WKUserNotificationHostingController` を継承する形で作っていくのかな。`WKUserNotificationHostingController` は使ったことがないですね。しばらくアプリを作っていなかったからかもしれません。`NotificationView` が渡ってくる…いや、渡ってくるわけではないか。あ、これは表示するやつですね。なるほど、わかりました。だから「データがなくても大丈夫」を考えていたのかな、という理解です。 とりあえず作っていきましょう。新しい Swift ファイルで `NotificationController` というのを作り、この中に今コピーしてきたものを貼ります。ですが、インポートが抜けてますね。`UserNotifications` を `import` して、`UNUserNotificationCenter` を使います。

`NotificationController` ってなんでしょう。OS のフレームワークのやつでしょうか。これも初めて見た気がしますが、OS 側のものかなという印象です。

これで、とりあえず今は入らないはずです。これはなくなったところで大丈夫でしょう。念のため切り替えて確認しますが、大丈夫そうですね。これは要るかどうかはもう少し様子を見ます。

こんな感じでユーザー通知に対して、`landmark` と `title` と `message`。これらをオプショナルな形で持っています。それで `NotificationView`。`NotificationView` はオプショナルのプロパティを持っていますが、今は渡せないんですね。これはこのあと対応することになりそうです。まずは先に進めておきます。

これで `updateBody()` メソッドとプロパティ。これらのプロパティを使って、そうですね、`title`、`message`、`landmark`。これらを今からセットするという形になります。

ここで思うのは、`NotificationView` に何も渡さないというのは普通考えにくいですよね。「とりあえず作っているから」といって、試作用だと言いたいわけではない気がするので、これはイニシャライザーを用意しておいたうえで、デフォルト値は持たせないほうがいいんじゃないかなという気がします。人のコードを見ているとデフォルト値を持たせたがることがありますが、デフォルト値はあくまで常識的に「その値であることが多い」場面でなければ付けないほうがいいです。何を渡しているかが分からなくなりますからね。

これだと `NotificationView` がそのまま使えるかと思ったじゃないですか。でも、基本的には情報が欲しいわけです。見た目だろうと何だろうと。イニシャライザーでデフォルトの値を渡さなければ、ここで指定してあげざるを得ない。つまり、指定し忘れを防げるというメリットがあります。そういった設計にしたほうがよさそうです。これでできました。

ついでに、ここは `final class` ですね。継承するつもりはないので。あとは、これは表示するだけで中身を書き換えないので、`let` でいいんじゃないかなという気がします。あ、でも分からないか。`NotificationController` がどう使われるのか自分が分かっていないので、まずは `var` でいっておきましょう。

それで `landmarkIndexKey` を定義します。このキーを通知から `landmarkIndexKey` を展開するのに使う、ということらしいです。`NotificationController` に対して `let` に指定するのは、まずはこれだけ、`landmarkIndexKey` ですね。後でたぶん直すことになる気がします。 とりあえずここに持たせる、という話ですね。そうした上で次は、`didReceive` です。このメソッドは、通知からデータをパースするために用意する想定でしょうか。このメソッドはコントローラーのプロパティを更新します。`didReceive` が呼ばれた後、システムはそのプロパティを使って通知の内容を更新し、Apple Watch 上に表示します。つまり、`didReceive` を付けてあげればよい、ということですね。オーバーライドなので、やっぱり親クラスにちゃんとあるメソッドということです。

これを載せてあげますが、細部の違いがたくさんありそうなコードを貼っている気がします。とにかくまずはオーバーライドして貼っておきましょう。ただ、コードは理解しないといけないですね。いくら貼るといっても、与えられたものをそのままではよくありません。モデルデータを取って…これも少し変ですかね。見直したいところです。

通知を受信すると、通知のカテゴリーに関連付けられたアプリ内のシーンを検索します。ではやってみましょう。Landmarks アプリに戻って、通知用のシーンを追加します。カテゴリーを使って `WKNotificationScene` を登録し、コントローラーとして `NotificationController`、カテゴリーとして Landmarks 用のもの（例: `Landmark`）を持たせる、という形です。こんな感じでカテゴリーに基づいて通知シーンを追加してあげるわけです。

シーンは watchOS 用だけなので、条件付きコンパイル（`#if os(watchOS)`）で、watchOS のときだけこれを使うようにしていきます。OS で分けるのは全然アリだと思います。通知シーンの登録をする、ということですね。いったん書いてみましょう。`#if` で表現すべきか、別の工夫をすべきかというのは難しいさじ加減ですが、どっちでもよいと言える程度の話です。Landmarks アプリを今日通過したがために、こういった条件が必要ですよ、という話ですね。

`WKNotificationScene` は、コントローラーとしてこの `NotificationController` を持ち、カテゴリーとして Landmarks 用のカテゴリー（例: `Landmark`）を持たせます。そういった情報を登録しておきます。

そして、アラートを表示する前にパーミッションを取ります。`ContentView` に行き、`UNUserNotificationCenter` の `requestAuthorization` を使って通知を有効にしないといけません。これは `ContentView` の `.task` モディファイア、つまり `ContentView` が最初に現れたときに呼び出されるタスクの中で実行する、ということですね。 まず、`ContentView` に `UserNotifications` をインポートし、タスクの中で通知の許可リクエスト（`requestAuthorization`）を実行します。`WK...` の何かではなく、ここは `UserNotifications` を使うのが正しいです。`LandmarkList` の中でタスクを呼び出しておけば大丈夫です。これで通知を扱える状態になりましたので、次に進みます。

`ContentView` はテスト用のペイロードを用意して、通知用の情報（ペイロード。タイトルやボディといった内容）を `NotificationController` に渡してあげます。そのために、watchOS アプリの中に通知シミュレーション用のファイルを作成します。テンプレートは「Push Notification Payload」を選び、ファイル名は「Push Notification Payload」とします。これはアプリの一部ではないので、どのターゲットにも追加しないでください。

作成したペイロードファイルには、タイトル、ボディ、カテゴリ（今回は `landmarkNear`）、ランドマークのインデックスなど、必要な情報を入れます。Xcode のファイルインスペクタにあるシミュレーション用の設定（ターゲットのバンドル識別子など）があれば、対象の Watch アプリに届くように更新します。不要なキー（`thread-id` やアクション、カスタムキーなど）は削除して構いません。形式は JSON なので、余計なカンマや不正な構造が入らないよう注意します。

このペイロードファイルは、リモート通知から送られてくるデータをシミュレートするためのものです。ひとまずファイルを追加して内容を整え、必要なキーを残しておけばよさそうです。

ビルド手順としては、まず `Landmarks` アプリをシミュレーターで実行します。初回起動時にシステムから通知のパーミッションを求められるので「許可」にします。許可後は、Xcode あるいはシミュレーターに先ほどのペイロードファイルをドラッグ＆ドロップして、リモート通知をシミュレートします。シミュレーターは、先ほど指定した情報を含む通知を表示してくれます。アプリのアイコン、通知ビュー、ボタン、アクションなどが確認できれば準備完了です。

それでは、まずシミュレーターを動かして確かめていきます。 まずは権限の許可を取ります。初回実行時に許可が求められるので、これを許可します。ここまでは問題ないですね。許可が終わったらアプリを閉じろと言っていました。ここで一度ストップします。これでいいのかな。

次に、このファイルを投げ込めと言っていたので、並べておきます。これでいいのかな。Xcodeの横に並べておけば投げられるかなと思いましたが、投げられませんでした。いったん戻して、ペイロードのある場所をFinderで表示して、これでいけるかな。ファイルの場所を確認してからシミュレーターを終了します。何も変わらない。これはなぜだろう。やり方を間違えているのかな。

Xcodeでやってもいいのですが、まずチュートリアルをもう一回見直します。パーミッションを与えてから、Xcodeでアプリを止めて、後ろの通知ペイロードファイルをウォッチのフェイスに投げ込めば動いているように見えましたが、自分の環境の問題でしょうか。「対象のアプリを停止し、通知ファイルをウォッチフェイスにドラッグしてください」とあり、その通りにしたつもりです。ということは、ハンドリングができていないのでしょうか。どこを見ればいいのだろう。

ウォッチと共通で用意したLandmarkApp、ここでしょうか。ウォッチフェイスだったら、シーンを`LandmarkNear`で登録して、`NotificationController`。これが`didReceive`を呼んでくれそうですけどね。ここが違うのかな。`LandmarkApp`と場所が違ったかな。

`ContentView`ですね。`ContentView`の中に`LandmarkList`があって、通知まわりはこれでよくて、問題はここだ。`LandmarkApp`ですよね。ひとまず`print`で`didReceive`が呼ばれたかどうかを確認してみます。これで今は閉じられたので、アプリを実行してOKですよね。では一回実行し直します。実行し直すのをやっていなかった気がします。今それをやっているので、これで動いたら…でも落とさないといけないですよね。まずはちょっと投げてみましょう。投げてみましたが、何も変化がありません。アプリを落としてみます。ストップ。こうしたときに投げ込んでみても、何も動く気がしません。ログが出るはずなのに出ないですね。ログが出るはずなのに出ないので、どうしようかな。

とにかくダメだったということだけは今のところ分かっています。`Landmark`の方の動きは問題ないですよね。ちょっと困りました。もう一回このセクションに戻って、順々に見ていきましょう。大体のところはそんなに触っていないので大丈夫で、そのまま追いかけられると思います。

まずは、`NotificationView`というものを作りますよ、という話です。`NotificationView`はほぼコピペで作ったはずです。`NotificationView`については、自分のサンプルだけはリファクタリングに合わせて作り直しましたが、ケースは一応確認しておきます。

`NotificationView`でイニシャライザを少し変えましたが、それが問題なのかな。一度元に戻してみますね。それでも成り立つはずです。これで実行して投げ込んでみて、これは大丈夫かなと思います。ここまでやったら、アプリを落とさないとダメかな。Homeを押せばいいのかな。まあ、とにかく何も変化はないですね。 とりあえず、Xcodeでビルドすれば今みたいに動くはずだと思うのですが、反応しないのは良くないですね。これはおそらくイニシャライザーのせいではないと思います。`VStack` は単にコピーしただけですし、プレビューもちゃんと表示されています。ここは良しとして、念のためプレビューを確認しましたが問題ありません。では、何にはまっているのでしょうか。

SwiftUI のプレビューはできています。`NotificationController.swift` を作って、`final class` にもしました。`WKUserNotificationHostingController` を使っています。このファイルで `import WatchKit` も追加しましたが、ここは特に気になるほどではありません。プロパティは書いたかどうか確認して、`NotificationView` と `NotificationController` は揃っています。`import WatchKit` を書いたかどうかで挙動が左右されるとも思いませんし、コンパイル自体は通っています。

それなら、ファイルを整理して Xcode でビルドして、`User Notification` のフィールドを渡してあげれば、ここに反映されるはずです。さらに次の確認です。`NotificationView` はここまでで問題なし。次に `body` に対してプロパティ（`title`、`message`、`landmark`）を渡していきます。`override` も大丈夫です。ただ、なぜか不意に戻ってしまう挙動があり、そこが気になります。

この後は、`landmarkIndex`（キーは `landmarkIndexKey`）というものを定義します。`NotificationController` に `landmarkIndex` を持たせて、ペイロード側にも `landmarkIndex` を入れる形です。ここはあまり本質的ではないかもしれませんが、確認しておきます。

続いて、`didReceive` メソッドを使って Notification からデータを取り出します。このメソッドでプロパティを更新します。ここは提示されているコードをそのままコピペしています。`NotificationController` の中に `override func didReceive(...)` を載せて、その先は全部コピペで問題ないはずです。

受信時には、割り当てられた Notification のカテゴリを確認します。`NotificationScene` でカテゴリを `landmarkNear` にして追加します。アラートを表示する前にパーミッションを許可する処理も必要です。コードの追加漏れがないかを見直しましたが、なさそうです。`ContentView` 側で許可を取る処理を入れて、`LandmarkList` に `task` を付ける形で呼ぶのも大丈夫そうです。

ここからは、スクロールで該当箇所をたどって最後まで確認してから戻りました。受信処理がまだ残っているかを見て、ペイロードを作り直します。最終的にペイロードはこういう形にするので、この中身を一度丸ごと消して差し替えます。ソースコードの方に戻って、Push Notification のペイロードを一旦クリアして貼り付け直し、シミュレーターに投げてみます。

リリースビルドに投げればこれで良いと思ったのですが、アクセス許可のダイアログの後に「開けなかった」と言われました。やり方自体は全然アリだと思ったのですが、投げ方を間違えた、という感じですね。 もう一度、通知（`APNs`）を送ってみます。何も考えずにコピーしたままのものを投げてもダメでした、という状況になっています。そこで、チュートリアルの続きに戻ります。コード自体は問題ないはずです。

まずは `Landmarks Watch App` を `watchOS` のシミュレーターでビルド＆ランします。スキームは `Landmarks Watch App`、ターゲットはシミュレーターです。最初に通知の許可が求められるので「許可」を押します。その後、権限を与えたらいったんアプリを終了し、プッシュ通知のペイロードファイルをウォッチのシミュレーターにドラッグ＆ドロップします。そうすれば続きが出るはずなのですが、出てきません。ここで終わってしまいます。何かを忘れているのでしょうか。

ログやシミュレーターのメニュー（File、Edit、I/O、Debug など）を一通り確認して、通知を直接確認できないか探しましたが、該当しそうな項目は見当たりません。手順としては「これを投げ込めばいい」と書いてあるように見えるのに、動かないので困っています。

アプリケーション自体は共通の `LandmarksApp` があり、`watchOS` のときには通知のペイロードで `category` を `Landmark` にして送っています。ここで違いがあるとすれば、ターゲットの `Bundle Identifier` かもしれません。`Landmarks` の `WatchKit App` 側の `Bundle Identifier` を確認し、いったんアプリを再実行してから、まずは通知を投げてみます。

動きました。通知を投げてみても最初は変わらなかったのですが、何度か送ってみると届きました。表示されました。よかったです。これで一応完成ということになります。つまり、これだけですね。

では次の問題を見てみます。「どのオプションが、`watchOS` ターゲットを既存の `iOS` プロジェクトに追加するものですか」。答えは、既存の `iOS` アプリ用の `Watch App` を追加するオプションです。これで正解です。

次の問題は「なぜ `LandmarkDetailView` を `watchOS` で再利用しないのか」です。`CircleImage` が大きすぎるから、というのは理由ではありません。`CircleImage` は共有して使っています。`watchOS` のユーザーインターフェースは、重要な情報に簡単にアクセスできるよう要点だけを提供する設計思想なので、iOS の詳細画面をそのまま持ち込まず、一覧や必要最小限の情報に絞ります。なお、`MapView` は `watchOS` でも使えますし、実際に共有していました。これで大丈夫です。 大事になってくるのは、要は Apple Watch は iOS と違って小さい画面で、情報表示的なものだという点です。主要なものだけ、必要な情報だけを提供することで、ユーザーの体験を良くしようという話だと思います。

ビューはほとんどのプラットフォームで使用できます。これは重要です。ビューが表示する情報のコンテンツ量や表示方向（レイアウト）、そしてプラットフォームで実現できることをきちんと確認することが大切だと言っています。ちょっと適当に進めてしまったので言い忘れていましたが、ビューを表示することは可能でも、微妙に違った仕様があります。表示する情報の量と表示方向、そしてプラットフォームでできることを確認することが重要です。表示はできるのですが、ディテールはそれぞれに合わせて分けました、という話ですね。

さて、次…あ、これはこれで終わりですね。次は iOS アプリの開発に移っていくということみたいですが、まずこの段階で Apple Watch アプリをリファクタリングできたりします。とはいえ、基本的には、だいたいこの読書会は目安を勝手に1時間に置いているので、今回は1時間はかかっていますかね。では、それはまたにしますかね。ちょうどいい感じです。

今回は、ちょっとリアルに沿って、かなりざくざくと進めていったので、雑なところ…ざっくりというのは、まあ、とにかく微妙なところがいっぱいありそうですね。なので、そのリファクタリングはまた次回にしましょう。明日ぐらいですかね。また同じくらいの時間、8時から9時の間くらいから始める感じでいくか、ちょっとわからないですけどね。ちょうどいい時間に始めていこうと思います。

はい、では今日はこれで終わりにします。お疲れ様でした。
