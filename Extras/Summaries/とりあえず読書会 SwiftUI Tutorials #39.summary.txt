Transcription & Summarize : とりあえず読書会 SwiftUI Tutorials #39

では、とりあえず紹介を始めていきましょう。SwiftUIチュートリアルの最後のところまで進めて、前回はデバッグでしたね。デバッグがうまく動かない箇所が一つあって、それを直すということをやっていました。それが終わったらリファクタリングもしよう、という感じで進めていたのですが、結局バグが取れないまま終わってしまったんですよね。原因はだいぶ掴めてきたかなという感触はありますが、そのあたりをもう少しだけ試してみて、バグが取れればよいのですが……。取れないのはまずいものの、今のところはちょっと難しいなというところで終わった、という状況です。まあ、まずはやっていきましょう。

バグの内容としては、macOS用アプリで、リストを選ぶときに1回目のクリックが無視されてしまう、というものです。今クリックして一瞬選択されるのですが、すぐに選択が消えてしまう。もう1回押すと大丈夫、という挙動です。これは一度できればその後は大丈夫なのですが、`command` を押しながらクリックして一度選択をリセットしてしまうと、また同じことが起きます。例えば2番目を押してあげると、一度選ばれてから無視される。こうなったときに、同じものを選ばなくてもどこでもいいので、もう1回目は大丈夫、という挙動になります。これはリスト側の動きの問題のように見えます、とりあえずは。

具体的には、リストが実際に表示している項目の選択状態（`selection`）が `nil` のとき、次に何かを選んだときに不具合が発生してしまう、という状況っぽいです。一度選ぶと、この `nil` からバインドされているところに値が与えられ、次からは「`nil` から変わった」という変化にはならないので、つじつまは合うのですが、問題の根本はまだわかっていません。

一つ言えるのは、`selection` をバインドしないとちゃんと動く、ということです。これをどう直していくか、という話になります。問題になっているのは、ランドマークリスト（`LandmarkList`）のコードの中、`body` にある `List` です。`List` を `ForEach` と入れ替えても挙動は変わらず、とにかく `selectedLandmarkID` のように `selection` をバインドしている限り、初期値が `nil` だとダメ、`nil` がバインドされるとダメ、という状況になっています。このあたり、なぜなのかが謎です。

類似する最小の例を作ってみれば、ちゃんと動くかどうかがわかるはずなので試してみます。新しいプロジェクトを作成し、macOSでやっているのでテンプレートは「macOS App」で良いでしょう。名前は「リストのデバッグ」みたいな感じにします。SwiftUIでOKです。

とりあえず生成されたものに、`Author Information`（例えば author name やメールなど）を入れる欄がありましたが、そこはキャンセルしました。コンテンツ内で試していけば良いでしょう。やることとしては、この中でまず `List` を作ります。`List` の `selection` にバインディングを渡したいので、`@State` で `id` を `Optional` にして持ちます。例えば、`@State private var id: Int?` のようにして、これを `List` の `selection` にバインドします。中身はさっきのコードだと `ForEach` でしたね。`ForEach` の中で表示するデータは、前は `@Environment` から取っていましたが、ここでも `@Environment` を使いましょう。

そのために、`ObservableObject` に準拠した `class` を作り、その中に `Item` の配列を持たせます。`Item` は `struct` にして、`id`（`Int`）と `name`（`String`）を持たせます。`Container`（仮名）に `items` を持たせ、イニシャライザで例えば `id: 2, name: "A"`、`id: 5, name: "B"`、`id: 7, name: "C"`、`id: 10, name: "E"` といったデータを入れておきます。`Item` のイニシャライザの引数（`id` と `name`）を書き忘れてエラーになりましたが、そこは修正します。

プレビューでは、`.environment` で `Container` のインスタンスを渡します。アプリ側にも `@State private var container: Container` を持たせて、`.environment` に渡しておきます。`ForEach` の中では `items` を回して、`Text(item.name)` を表示するだけのリストにします。これで、名前が表示されたリストが出てくるはずです。

さて、最初の選択がうまくいくかどうか。この最短距離で書いたリストだったら、うまくいかないはずがないように見えるのですが……。プレビューがうまく表示されないと言われたので、とりあえずビルドして実行します。リストは出てきます。やっぱり、どこかが悪さをしているということでしょう。`command` を押しながらクリックして一度空の状態にしてから、他を押すと選べますよね。

こちらがチュートリアルで作った方ですが、選べるときは良いのに、一度「何も選択していない状態」を作ったあとに何かを選ぶと、これが無視されてしまいます。選ばれた瞬間に無視される、という現象です。さきほど作った最小構成の方でも、`command` クリックで空にしてから `B` を一度クリックすると、同じ現象が再現しました。早い段階で再現できたので、切り分けが進みます。

ということは、`NavigationSplitView` の中のまず `NavigationLink` が怪しいのかもしれません。試しに `NavigationLink` をやめて、`Text` だけにしてみます。`NavigationLink` の中身を何も入れないのも気持ち悪いので、`EmptyView()` を入れておきます。要は `Item` に依存しないものを入れたときにどうなるか、という検証です。これでもダメですね。つまり、`NavigationLink` の段階ではなく、`NavigationSplitView` の段階でダメ、ということになりそうです。ここでちょっと手詰まり感があります。

`NavigationSplitView` で `List` を入れて、`ForEach` で……あ、まだ `NavigationLink` を使っていましたね。`ForEach` の話でした。そういえば、`NavigationStack` というのがありましたよね。iOSかmacOSか、どちらだったかまだよく分かっていませんが、SwiftUI の `NavigationStack` を調べてみます。Apple のドキュメントを見てみると、`NavigationStack` はルートビューを表示して、その上に遷移先のビューを積んでいくもののようです。macOS は 13 から対応ですね。

`NavigationStack` でデータとルートという形を取り、`NavigationLink` をタップ（やクリック）して遷移する、というのができるらしいです。組み込みのビューを使うことで、プラットフォームに適したコントロール（戻るボタンやスワイプジェスチャなど）でビューを削除できる、という説明もあります。

`NavigationLink` を作るときには、ビューとデータ型を結び付けて、`navigationDestination(for:)` モディファイアで、そのデータ型に対する遷移先のビューを割り当てる、という流れのようです。`NavigationLink` が表示するものやタイトルなどは同じ型のデータに基づき、戻るボタンで戻れる、といった具合ですね。

次のサンプルとして、`NavigationStack` で始まり、`List` で `parks` のデータを表示する例が示されています。`NavigationLink` に `name` などを表示し、`navigationDestination(for: Park.self)` で `Park` を受け取って詳細を表示する、という構成です。なんだか以前のやり方から使い勝手が変わっているように感じます。 ディスティネーションと、あ、リンクですね。なるほど、これを使ってみます。これで合うかな。これは今作っているデバッグ用のビューです。

ナビゲーションは、`NavigationSplitView` は `NavigationStack` とちょっと違いそうですね。とりあえず書いてみます。`NavigationPath` をこうやって用意して、それを `NavigationStack` の中で……おっと。

`NavigationDestination(for:)`、`Path.self`……これ、何でしたっけ。そう、`NavigationDestination(for:)` ですね。`Hashable` を取るもう一個の実装やイニシャライザーがあったはず……あ、違いますね。

ディスティネーションとしてアイテムを受け取って、ここでコードを書く、という感じなのでしょうか。ここがですね、`Binding<Item?>` とか、オプショナルのパス……えっと、`NavigationDestination` のどこだっけ。サンプルはないんだ。Apple のドキュメントで、ナビゲーションを作るときに型を指定していましたよね。`for: SomeType.self` です。

あ、でもここだったらいいのか。`item` がエラーになってしまいました。`Binding<[Item]>` から別の期待される型（例えば `Binding<NavigationPath>` や `Binding<Item?>`）にコンバートできない、みたいな内容です。ここで求められているのはディスティネーションのクロージャではなくて、下の方のイニシャライザーのほうでした。 ここだ。この中で `destination` でアイテム、バインディングで `Optional<D>`。`destination` は `D` を受け取る。だから配列を受け取っていて、`D` を返す。うん、`D` を受け取って `C` を返す。で、`C` は完全に任意ということなんですかね。あ、違う。この `C` は、型が持っている `C` ですか。持っているんですかね。`NavigationStack`…うん、持っていそうな感じか分からないですが、辿ってみればいいのかな。まあ、そういうことかな。

では、どうすると…これじゃないですね。えーと、`navigationDestination(for:)` で `Hashable` のタイプ。これを受け取るときに、`Hashable` のタイプだから `Item.self` ですかね。で、これで `destination`、`destination` はこうしてアイテムを受け取って、で、それで何かをするよと。で、「何かする」っていうところでは、ビューを返してあげて、このビューはさっきで言うと `NavigationLink` の本体ですね、おそらく。なので、これを拝借して合わせてもらって。

で、`NavigationStack` の中では、これを `items` ですね。で、それで `items` in…で、それでこの中で、`items` じゃないや、`item` in。あ、で、それでテキストじゃないや、`NavigationLink` ですね。なので、`NavigationLink`。で、`titleKey` と `value`。これを表示しようとしていますね。いや、これでいいか。で、`titleKey` は `item.name` ですね。`value`、`value` は `item` ですか。分からない。で、これで `value` パスが合っていそうですね。`NavigationLink` でパスネーム…あ、文字列の補間とかじゃなくて、普通に `item.name` とかにして。

で、それであとは `List` がエラーになっていますね。`List` は `Identifiable` に準拠していないといけない。あ、これは `id` を `\.self` じゃなくて `\.id` というふうにすれば大丈夫ですよね。これでちょっと `NavigationStack` も用意したので…と思ったけど、ワーニングで、ビルドをかけて。

で、そうすると、あと同じバインディングになっちゃってちょっとやりにくいんで、`NavigationSplitView`、これを一旦止めてみますけど、でも `NavigationSplitView` を止めてしまうとちょっと問題ですね。あれはこれで、うん、こうなって、で、それで選ぶことはできるんですけど、`NavigationStack` としてよしなに表示させるっていうことが、ちょっとね、これだと難しくなっちゃいますよね。うん。だから、これを `NavigationSplitView` を生かした状態で、無理なくちゃんとやっていかないといけない。`NavigationStack` はやらないで。

これで実行かけたとき、この時ですね。こんな感じで困りましたね、これ。`NavigationLink` を置いてしまって、それを選択して画面が表示されると、`List` が一回リセットされちゃう。うん。これは、なんか簡単そうなんですけどね。簡単そうなわりに難しいですね。これどうにもならないって言ったらいいのか、自分が単にね、リスト周り、`NavigationSplitView` 周りがちゃんと使えていないっていう可能性も考えると、`NavigationSplitView` を調べていけば、まあいいことあるのかもしれないですね。これやってみますかね。うん。

まあでも、この最短距離でね、再現できた気がするところはとても良かったですけどね。簡単に再現できたほうが楽でいいんですよね。リストが配慮がされてしまう…コンテナの `items`。`items` を、例えば `Hashable` にしていない、`Identifiable` にしてみましょうか。こうしたときには `Identifiable` なので、`id` を明記しなくて良くなりますよね、ここでね。こうしたときに、これだけでうまくいくとは思えないですけど、うまくいったら嬉しいんでね、やっておきますが、これで C を選ぶと、エラーって出ますね。うん。

あとは、言っている…これが例えば最初何もないとか、そういった状況でやるとどうなるでしょうね。この状態で何もない。選択。エラーって出ますね。そうすると、ビューのどこかで `@Environment` を使っているというのも1個ありますね。例えばこの `items` を `@Environment` ではなくて `@State` にしますか。`@State private var items`、そして `@State` で持たせて、で、このアイテム…コンテナじゃなくてね、この持ち物の `@State` の `items`。このときにどうなるかというのも結構重要になりそう。例えば B を選ぶ。ダメですね。これもダメか。

じゃあ、ありに、これが…一応こうなったら、`@Environment` を一回なかったことにしてみましょうか。こうして純粋に `items` だけで動く、そういった最短ルートで。これ、ダメですね。うん、なるほど。

あと考えられるのは `Optional` ですね。この `Optional` をやめて、例えば 0 みたいな存在しないアイテムを入れてあげる。まあまあ、これは大丈夫なんですよ。`nil` じゃなければこれ選べる。一回選べれば動く。これはいいんですけど、一回また Command-Click…なんだっけ、リセットできないですね。Command-Click が効かない。そうなんだ。それならいいんですけど、これが `nil`…あ、そっか、`Optional` を今やめました。 オプショナルをやめたので、選択できないという状況が存在しない形になっています。この中でゼロなどを設定すると、それはもはや「選択されていない」という状況になるので、最初はそれでいいのですが、これでは選択という動作自体が起こらなくなります。これなら安定的に `nil` を出せますが、それでいいんですかね。`nil` のときに何がおかしいのかがよくわかっていません。とにかく原因はわかったので、あとは GPT にいろいろ聞いてみますか。

例えば Swift 系の話をしたいのですが、SwiftUI の `NavigationSplitView` を使った macOS アプリを作っています。その中で、この `NavigationSplitView` のイニシャライザは最初がサイドバーですね。このサイドバーで `List` を使い、それにオプショナルな型を関連付けています。サイドバーにセクションが2つあるとすると、最初にリストの先頭行が一瞬選択された後で、すぐに非選択の状態（`nil`）に戻ってしまいます。これの回避方法を教えてください、と。私もちょっと調べました。これで通じるのかな。よくある問題なら AI が解決してくれると思うんですけど。

何を許容すると直るのかがわからないのですが、`NavigationLink` では、ディテールのタイプを決めるにしても、非選択時に `nil` に戻る現象が発生します。`ContentView` があって、`selection` が `Item?` の発生で、アイテムが A、B とあって、それを `NavigationSplitView` と `List` で表示し、ディテールとしては「`selection` があればその選択肢の名前を `Text` で表示し、なければ別の `Text` を表示する」という形です。これは `NavigationLink` を使わず、ディテール側で条件分岐して実装したバージョンですね。ディテールで条件分岐して中身を書き換えるのはアリなんじゃないですかね。

これを実行すると、最初にリストが一瞬選択されて、すぐに `nil` に戻るらしいです。`NavigationSplitView` は（プラットフォーム側で）ナビゲーションスプリットビューコントローラをラップしていて、ディテールの制御のために `selection` を監視しています。ディテールが「設定された状態」から「`nil` に変わる」タイミングで再構築が発生し、その結果 `selection` が初期化されてしまう、という挙動になっているようです。`selection` をいったんでも、一瞬でも設定すると、何か違いが出ますね。

iOS 16 以降なら、`NavigationSplitViewStyle` を使います。それ以降では、`.balanced` スタイルを使うことで、再構築時の状態が安定します。これは一番手軽なので、やってみますか。やるところとしては最短距離の修正ですね。`navigationSplitViewStyle(.balanced)` にして実行してみると……オプショナルにしていました。 押していない。これは絶対に大丈夫です。これでは面白くないので、`Binding` のオプショナルにして、`nil` の状態で突き進んでいきます。やはり、選択されていない状況は `nil` で表現したいところです。自分の中では絶対的にそういう状況な気がするので、押して開いて、さっそく選択してみます。ああ、やっぱりダメですね。2回目は OK と。だからこの方法はダメです。

そうすると、他に考えられる方法としては、`NavigationLink` を使わないことです。ラベルのテキストだけをここで表示して、まずはそれで良しとします。そして、ディテールのところで ID が変わっているはずなので、その ID を元にアイテムを探します。

どうするのかというと、まずは `if` でやってみます。ID に対して、たとえば `if let item = items.first(where: { $0.id == id }) { ... }` のように、`first(where:)` を使って条件に一致するものを取ります。この条件を満たしたときには `Text(item.id)` を表示して、それ以外のときには `DetailView` を表示します。押したときに `NavigationLink` を使わないので、問題は起きないはずです。実際に `DetailView` が出てきて、そこで C を選ぶと、「7C」と表示されました。7C はとても良いです。こんな感じで上げて、もう一回コマンドで押すと何もない。これでいいですね。よかった。こうすると、バグは直せます。

では、学習用の元のコードを開いておきます。やることとしては、モデルデータに `selectedLandmarkID` があって、これを `NavigationLink` で管理するのではなく、`NavigationView` のディテール側で表示を制御します。`Detail` で表示するランドマークを取るときに、`selectedLandmarkID` がある場合には、その ID を使ってモデルデータから取得します。ここで、実際に画面に表示しているランドマークはモデルデータから取れているので、これは `LandmarkList` が知っていることです。つまり、この `LandmarkList` が「ID によってランドマークを取る手法」を提供すれば良いわけです。

そこで、`func landmark(by id: Int) -> Binding<Landmark>` のように、`id` を `Int` で受け取って `Binding<Landmark>` を返すメソッドを用意します。返し方としては、モデルデータに対して `bindingLandmark(by id:)`（以前作った `elementByID` に相当するもの）を呼べば良いです。これで、`Binding<Landmark>` を ID で取得することを `LandmarkList` ができるようになりました。

これを使って、`selectedLandmarkID` が取れたら `let landmark = landmark(by: id)` のようにして表示します。書き方はいくつかありますが、たとえば `if let landmark = selectedLandmarkID.flatMap({ landmark(by: $0) }) { ... }` のように書けます。`guard` で書いても良いのですが、ここは `switch` が好きなので `switch` にしても良いでしょう。`switch selectedLandmarkID { case let .some(id): ...; case .none: ... }` のように、`nil` の場合とそうでない場合を分けます。

ビルドもできるし、実行してもちゃんと表示されます。これでもうバグは直りました。よかったです。こういうバグは、たとえ練習のときでも、ちゃんと解決できるところまでやっておくべきだと思います。

なお、最初はオプショナルな `Binding<Landmark>` を強制アンラップ（びっくりマークの `!`）で取り出していましたが、`map` ではなく `flatMap` を使う形に変えました。`selectedLandmarkID.flatMap { landmark(by: $0) }` のように、オプショナルだったときに `landmark(by:)` の結果をフラットに丸め込むのは、少し慣れが必要かもしれません。何をしようとしているのか一瞬わからなくなりそうなので、名前を付けてわかりやすくすると良いです。

たとえば、「選択されているランドマークを取る」というメソッド（あるいは計算プロパティ）を作ります。`var selectedLandmark: Binding<Landmark>?` のようにしておき、内部で `selectedLandmarkID.flatMap { landmark(by: $0) }` を使います。こうしておけば、すぐそこに「選択されているランドマークを取る」と書いてあるので、意図が明確になって読みやすくなります。 文字起こしテキストを貼り付けてください。  
以下の方針で整えてお返しします。

- 「ですます調」で自然な文章に整形し、適切に句読点を入れます。
- 誤変換（例: G言語→C言語、万全オキス→万全を期す など）を文脈に沿って修正します。
- コードはバックティックで装飾します。短いコードはインラインで、長いものはコードブロックで表記します。
- 複数人の会話は発話者名を出さず、内容を踏まえた通常の文章にまとめます。
- テキストが途中の文から始まっている場合は、その断片は無視して次の文から整えます。
- 要約はせず、与えられた内容以外を追加しません。 ただ、これも分かりにくいなと思ったら、これくらいの関数になると、`guard let selectedLandmarkID else { return nil }` と書いて、`landmarkID` をそのまま使う、という書き方でも良いと思います。`selectLandmarkID`…いや、`selectedLandmarkID` でいいかな。こうしてあげると行数は増えるんですけど、行数が増えたところで、`selectedLandmark` というプロパティがやっていることは明白ですよね。この「明白さ」は、コード量が多少増えても明白ですし、さっきのように `flatMap` みたいな、なじみの薄いものを使っても理解できます。なので、どっちでもいいと思います。1行の方がきれいに見えるならそれを採用すればいいですし、今回は長く書いておきます。これでいいかな。

あとは、自前で書く方法もここは十分ありますしね。`flatMap`、どっちがいいかな…どれも迷うって感じですね。どうしようかな、今回。あ、これでいいか。

はい、できたので実行してみましょう。今度こそうまくいっているはず。こういう状況で `selectLandmark` が出ていて、ここでダブルクリックするだけで…おお、できましたね。これで、サイドバーをクリックすればまたそっちに行きますし、`Command+クリック` で選択解除もできます。ほかの操作もすぐできます。おお、バグ直りましたね。完璧ですね。こんな感じで良い気がします。

こうなったら、他のプラットフォームも結構大きく変えたので、動くかどうかは確かめておかないといけません。iOS をちょっと見てみましょう。iOS のシミュレーターですよね。シミュレーターは…どこだ？ シミュレーターが見当たらない？ Mac のやつと、これは…あ、DK のやつですね。あとは、Mac じゃない方。シミュレーターがどこにいるかが分からない。どこだ？ あ、ウィンドウの後ろか。GPT も分かって、助かりましたね。GPT のおかげでね。レイアウトが外れていたところもいっぱいありましたけど、直していったところもあったので、そうやって活用していかないといけないって感じですね。

Mac の動作は良かった。これを…あ、そう、iOS。一番上だったから実行を押してみて、これでシミュレーターが起動するはずなので、それで動作確認をして、問題になったらランドマークリストだから…あとはそうですね。これも試してみて問題なければ OK と。

あ、見えた。これですね。シミュレーターが動いていない。1回落としてみますか、シミュレーター。うん、落ちましたね。そしたらもう1回…あ、ビルドが失敗か。ビルド失敗を見落としていました。動くものだと思ってたけど、そんなことはなかった。えっと、ビルド失敗は…どこで見るんだ？ ビルド失敗…表示されていないですね。ビルドのログを見る…ここですかね、iOS 用のビルド。これですね。この中で…ここだ。`FocusedValue`、`selectedLandmark`。この辺が見つかっていないらしい。`FocusedValue` か…。 とりあえず、`FocusedValue` はメニュー用でしたよね。iOS もやるって、確かチュートリアル出ていませんでしたっけ。`FocusedValue` がないのかな。えっと、iOS でしょ。これでどうしますかね。エラーが出てほしいんですけどね、このログに出てほしいんですよね。

`FocusedValue` の定義を辿ってみますか。定義を辿ると、`FocusedValue` は iOS 16 でありますよね。じゃあ、この `selectedLandmark`、これがない。えっと、extension で。この extension は iOS がありましたね。iOS はあるから、大丈夫に見えますね。

で、それ以外だと、`selectedLandmarkID` はありますよね。あとは `landmarks`。これは当たり前になりましたね。`elementByID`、これもありますね。

えっと、ビルドが失敗したことをはっきりと知りたいので、一度クリーンして Xcode を落としますかね。それで、Xcode を落とした後にもう一回プロジェクトを開いて、ここだ。そう、Landmarks だ。これを開いてみて、もう出来上がっていると思うんですけど、出てきましたね。その上で、もう一回ビルドをかけてみて、ちゃんとエラーのところに出てほしいですよね。

ビルドはエラーなんですが、エラーの内容が予想どおりに出ている。出ている予想というのは、この中の2カ所ですね。2カ所の中でも、watchOS だ。watchOS に切り替えてビルドをかけていけば、エラーの場所が出た。クロスプラットフォーム、ここ難しいですね。ターゲットを切り替えるだけではエラーが表に出てこないけど、該当ターゲットでビルドすれば出てくるという。

`FocusedValue`、ここなら確かに watchOS だと無いですよね。`FocusedValue` が無いのではなくて、`selectedLandmark` が無いですよね。`selectedLandmark` 自体は定義はされているんですけど、これは watchOS に入れていないんで、これだ。なので、`FocusedValue` は watchOS 以外でやらないといけない。

もうちょっと言うと、iPadOS、macOS と、あとは、または OS が iOS ですね。こういうふうにやるのは、将来 visionOS を作ろうと考えたときに、このときに visionOS がターゲットに追加されたときに、どっちがいいかは分からないですけど、思いがけないものを通過させるよりは最初から無い方がいいかなということで、`#if !os(watchOS)` ではなくて、`macOS` と `iOS` では有効にする、という形がいいですよね。つまり、`#if os(macOS) || os(iOS)` で入れるんだ。だから、これがいいですね。今、macOS とかではなく watchOS なので、これでいいですね。ビルドをかけると、これでビルドが通る。

…またダメだ。`Landmark` がカテゴリーを持っていない。`Landmark` がカテゴリーを持っていない。この `Landmark` は iOS 用ですね。iOS のビルドでエラーになった。 なぜかエラーは正しく出ていますが、iOS に切り替えます。一応 iOS に切り替えてビルドをかけると、「カテゴリーが無い」と言われます。カテゴリーを入れる場所を間違えたんですかね。これはだめですね。入れ忘れていそうです。カテゴリーを通して…これですかね。

iOS、watchOS、macOS、カテゴリー。以前はランドマークの中の `name` フィールドに入れていたものを外に出したからですね。なので、その対応が抜けていました。つまり、`name` フィールドを消せば OK です。iOS のターゲットですね。その中で iOS 専用だから、macOS をいじっている間に `name` を変えたせいで、ここが抜けてしまったということですね。

カテゴリーは `name` を持っていません。ややこしいのですが、`name` はやめて `description` で提供することにしました。そうすると、これはまずいですね。`sortingByName` ではなくなっています。`description` でやっているので、`sortingByName` ではないな。その前にも何もないか…。いずれにせよ、さっきのエラーは「`name` がないよ」という話ですね。

`Text` を拡張したので、`name` を渡さなくてもテキスト表現できるようになりました。カテゴリーですね。`Text` のカテゴリー…カテゴリー。カテゴリーを使う場面で `Text` を使っている箇所が、他の OS でもあったと思うんですけど、この辺ではないですね。`Text` は `CategoryRow` か。これは良いですね。`CategoryRow` の iOS 版ではなく、他のバージョンのほう。`CategoryRow` を見ますか。なるほど、どこに置きますかね。カテゴリー自体に拡張してあげる…これでもいいですかね。`CategoryRow` ではなくカテゴリー側です。

カテゴリーの中でテキスト表現をするのは `CategoryRow` なので、ここで作ってありますね。ですので、`CategoryRow` の extension ではなく、アクセスレベルを private にするのではなくて、extension で `Text` に対して拡張を追加し、この中でイニシャライザを例えばカテゴリー用に用意します。`Initializer` でカテゴリーを受け取る形にして、`self` のイニシャライザにパスするのは `String(describing: category)` にします。こうしておけば `Text` での表現が可能になります。これでランドマークの側も良くて、カテゴリーのテキスト表現が可能になりました。ここは良いですね。

それができたので、次にやることはカテゴリーの並びです。さっき `name` を廃止したことで、明らかに `sortingByName` ではありません。名前ではない。ではどうするかというと、定義を拡張するというよりも、「カテゴリーには並び順がある」という表現のほうが妥当な気がしてきます。本当にやりたいことは、「カテゴリーは比較可能ですよ」という表現です。つまり、`Comparable` に準拠させて、`static func < (lhs: Self, rhs: Self) -> Bool` を作り、さきほど `sortingByName` で使っていた大小比較、要は `description` で大小比較をする実装にします。こうしておけば、`sortingByName` なんて特別なものは要らなくなって、カテゴリーをソートするという表現だけで書けるようになります。

そうすると、今消した `sortingByName` が使われているのは `CategoryHome` かな。ここが一箇所やり直しになるので、ここで `sortingByName` だったのを `sorted()` にしてあげれば OK ですね。すると、LandmarksByCategory の categories をソートしたものを表示する、という形で出てきます。

カテゴリーが並べ替え可能で、並び順が表示テキスト（`description`）ですよ、というのは、これは基準次第です。並べ方が本当にそれでいいのか、それとも登場順という可能性もあります。カテゴリーって列挙型になっているのだと思ったんで、そうそう。 これが上からの順番を登場順と捉える手もありますし、アルファベット順で捉えることもできます。どちらが良い、どちらであるべきといった状況では全くないので、ここは仕様として決めてしまってもいいかもしれません。もし他にもいろいろな並べ替え方法が存在するのであれば、さっきのように `sortedByName` や `sortedByID` のように、`sortedBy〜` と名前を付けたほうが良いと思います。ただ、今回はそういうケースでもなさそうです。持っている値から取れる情報といえば `rawValue` くらいですからね。それが将来、不公平を招きそうだという感じであれば、`sortedByRawValue` のような名前になるのでしょうか。あまり言わない気もしますが。

とにかく、これでビルドは今度こそ通るようになったはずなので、ビルドして動かしてみて、macOSでの変更がiOSのほうに悪影響を与えていないかを調べられれば、とりあえずOKですね。バグは直せないときは辛いですが、そこもまた楽しいところだと思います。

iOSのシミュレーターも今度は動いてくれそうです。ここでやったことは、お気に入りのフィルタリングのリストに関してです。1回目のクリックでちゃんと動くかどうかという点で、1回目のクリックではもう直っているはずなので、クリックしたときに意図したとおりに表示されるかを確認します。ここを見れば、コードが悪影響を及ぼしていないかが判明します。問題なく動いていれば、macOSとiOSは完成です。そしたら watchOS も確認して、watchOS もちゃんと動けば全部完了で、チュートリアルは完了という感じです。ただ、やろうと思っていたのはデバッグとリファクタリングなので、リファクタリングはまだ手を付けられていません。そこが直ったら、今日は一度終わりにして、また次回リファクタリングしながら進めていきましょう。まあ、そんな感じでやっていけば良いのでしょう。

お、動きました。これでエミュレーターが立ち上がり、ここでアプリが動きます。アプリは早く動くのかな。画面、止まるかな。ウィンドウをちょうど良い大きさにするのはどうするんでしょうね。Zoom、`Command+1/2/3/4` のショートカットですね。ウィンドウの横にある要素を消せると、だいぶ画面が広くなって嬉しいのですが、これは消せるのでしょうか。少し余計なことを始めましたが、Device Bezel、これはバックですよね。これは無理かもしれないですね。ベゼルは出しておきますか。ウィンドウには他にリサイズやフルスクリーン、さっきの `Command+1/2/3/4` はこれですね。あとはメニュー……まあ、こういうのはこのくらいで。 YouTube Live のコメントの確認をすっかり忘れていましたが、今はまだコメントは来ていないようです。「いいね」の方ですね。これでリストが出ていそうです。クリックしたときに、選択保持もちゃんと入ることを確認して、戻ったときにも選択が保持されましたね。

「お気に入りのみ」にするとこうなります。ここで星を押しても、お気に入りからはすぐには消えません。仮にこれが送信ボタンだったとして、押した瞬間にリストからいなくなるアプリがありますよね。誤ってプチッと押してしまったときに、リストから消えると困るので、フィルターを次に変更するまではリストに残るように調整しました。これは好みの問題で、アプリを作る側と使う側で必ずしも一致しないと思いますが、今回はそうしています。

macOS だと取り消し（やり直し）が効くので、星を入れ直して戻れば大丈夫です。iOS でも確認しました。アプリを戻ったときも問題なく、こんな感じで iOS は OK ですね。

では watchOS も見ておきましょう。ビルドをかけます。たまに通らないこともありますが、今回はとりあえずビルドが通りました。シミュレーターも動いています。watchOS 側のリストもちゃんと動けば大丈夫でしょう。iOS が動いたので大丈夫だとは思いますが、watchOS への影響も念のため確認しておきます。メニューからリストへ戻る遷移も問題ありません。最後にもう一度だけ watchOS を確認しておきます。これでクロスプラットフォーム3つが完成です。

コードも少し見ます。リストまわりは、カテゴリーの何だっけ……`CategoryRow` ですね。いや、`CategoryRow` ではなく、ランダムなリストの方でした。これは3 OS 共通で使っています。

先ほど話した挙動、たとえばお気に入りを「オンリー」にして3件だけになったときに、項目を消す操作をすると、以前はその瞬間にリストから消えてしまっていました。取り消しで復活できればよいのですが、バインディングが切れて古い方のバインディングが残ってしまい、項目が消えたことでリストが再構築されてしまう、という問題がありました。今回のアプリ側の不具合を直した影響で、今は大丈夫かもしれません。

ひとまずデバッグが終わったので、次回は念のため、リファクタリングすべきところが残っていないかという観点で、Rust コードを全部見ていきたいと思います。チュートリアルをやっているうちに、結構書きましたからね。だいぶ綺麗なはずですが、`FIXME` もいくつか残っています。Apple Watch 向けの操作を便利にするための小ネタ的なものを、思いつきで付けていただけの部分もあります。練習には良いですが、チュートリアルでやるほどではない気もします。とりあえず、いらなそうなコードを見つけて整理していきます。
