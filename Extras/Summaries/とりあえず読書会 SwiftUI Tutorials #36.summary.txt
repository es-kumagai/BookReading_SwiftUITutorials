Transcription & Summarize : とりあえず読書会 SwiftUI Tutorials #36

はい、では、とりあえず読書会を始めていきましょう。`SwiftUI Tutorials`を読んでいって、最後のほう、いよいよ……いよいよではないですね、すでにだいぶ進んでいますが、`Creating a macOS App`ですね。これをセッション5から進めていきます。では、早速やっていきましょう。

こちらですね。この中の、えっと、macOS、`Creating a macOS App`です。とりあえず次へ進んでいきますが、ちょっと心配になってきたのでマイクが入っているか確認します。あ、入っていますね。大丈夫です。

続けていきます。リファクタリングをしながら進めている都合で、だいぶチュートリアルからコードがかけ離れてきていますが、その代わり、自分の感覚では良い感じにコードが書けている気がします。この調子でいきたいですね。リファクタリングしながらやると勉強になります。やっぱり頭でよく考えるからでしょうか。

チュートリアルに沿ってやっていて思うのは、コードのことを考えているつもりで、意外と細部を見ていないという実感があることです。そこで今回はリファクタリングをしながら進めてみました。そうすると、チュートリアルと動きが違うなと思ったときに、どちらが間違っているのか確認することになります。時々チュートリアル側が間違っていたりもするので、そのあたりは難しいですが、問題を解決するという観点では良い練習になります。今のところは、問題を解決しながら、セクション5まで来たという感じですね。

では続いて、ビルトインのメニューコマンドを作っていきます。今はmacOSなので、macOSの醍醐味と言ったらいいですかね。UIデザインガイドラインは自分は全然把握できていないのですが、macOSは備えられている機能のすべてをメニューから実行できるようにするのが推奨されていたような気がします（確信はないです）。UIのデザインガイドラインも読んだほうがいいのかもしれませんが、それはこれを終えてから考えます。とりあえず先へ進みましょう。

UIライフサイクルを使ってアプリケーションを作成すると、システムが自動的に共通で必要となる項目を作ってくれます。UIKitやStoryboardで作ったときにも、テンプレートがそういうことをしてくれていましたよね。そういえば、`SwiftUI`はどんなメニューが揃っているのでしょう。まずは読み進めてからにします。

「閉じる」や「最前面のウィンドウ」など、いわゆる基本的な操作が思い浮かびます。`Close` はウィンドウを閉じることかな、といったところですね。以前にもそういう文脈で出てきた気がしますが、大丈夫でしょう。トップとか最上位という表現は、アプリの最前面やその自動化のあたりの話ですね。

`SwiftUI`は、共通のコマンドをビルトインのビヘイビアとして提供していて、カスタムコマンドと同様に追加できる感じです。完全にカスタムのコマンドも追加できます。英語訳が怪しくなってきたので、ちょっと文章の力に頼りましょう。読み込みなどの他の一般的なコマンドや、完全にカスタムなコマンドを追加できるようですね。珍しい気がします。

このセクションでは、システムが提供するコマンドを追加していきます。ユーザーがサイドバーをトグルできるようにする、ドラッグで閉じてしまった場合でも対応できる、といったコマンドです。ここでは `LandmarkCommands` という型を作り、その `body` で `SidebarCommands` を呼べばよい、つまり標準のコマンドが用意されているということですね。なるほど。

プロジェクトをビルドし直してmacOSアプリを実行し、セパレーターをドラッグして左側にすべて動かしてから、マウスボタンを離す、という操作ができます。 ボタンを押すとリストが消え、ツールバーのボタンをクリックすると戻ってきます。導入するメニューコマンドでこのコントロールを操作できるようにし、このコントロールをメニューにも導入していく、という話みたいですね。この動きを見ればよさそうです。動いているのがこれですね。これで、ボタンを押すと出てくる、と。こういった感じの話をメニューでやっていこうという話ですね。

ちなみに、標準は何があるのでしょう。「About Landmarks for macOS」を選ぶと、こんなのが出てくるんですね。あとは「Services」かな。これは macOS が基本的にどんなアプリにも提供しているやつですよね。「Landmarks for Mac を非表示」や「ほかを非表示」といった一般的な項目もあります。

あと、「ファイル」には「新規ウインドウ」があります。新規ウインドウで複数開けるようになっているんですね。すごいです。出るのがすごい、という感じですが、これは iOS 版から作っている状況で、macOS へも簡単に対応できたので対応させた、という状態です。なぜか、うっかりどこかでこのウインドウに対する共通コンポーネントをグローバルに持っていた、ということが起きがちです。今もそうですね。今は `ContentView` にあります。これがグローバルに持たれていたりすると、本来はウインドウが違ったら分離されないといけないデータソースが一緒になってしまう、ということがあります。なので、片方を何とかするともう片方に影響してしまう、といった可能性もあったりするので、意外とこの新規ウインドウは怖いですね。まあ、普通に書いていれば大丈夫だと思いますけど。

あとは「クローズ」、また「編集」として、コピーみたいなのは標準のテキストフィールドで使えますよね。ライティングツールとか、こういった一般的な…まあ、ライティングツールはアプリに依存しちゃうんですけどね。こういったものが普通に用意されていて、テキストエディタがあれば使えると。テキストエディタとフォーマット、こんな感じでしょうね。

あとは「ウインドウ」＞「タブバーを表示」「すべてのタブを表示」。タブバーを持てるんだ。ああ、そこに出ているんだ。なるほど。この辺も、タブバーはこのアプリでは想定していないので、タブバーなんて出ないでほしい、という要望もありそうですよね。あとは、フルスクリーンは大丈夫ですかね。大丈夫ですよね。

そう、こういったのもクロスプラットフォームだとちゃんと確認しないといけないから大変ですよね。Mac のこういう機能ね。 とりあえずこんな感じで、メニューは標準でいくつか用意されていますし、あとはサイドバーがちゃんと動きを見せるように、といったことがありますね。

ステップ2として、新しい Swift ファイルでランドマーク用のコマンドを作ります。対象は macOS と iOS です。iOSにもメニューがあるのかという疑問はありますが、どこかで使う想定なのでしょう。これで Target の iOS も有効にしました。iOS をターゲットに含める理由としては、共有の Landmark リストが、最終的には別のファイルで定義されるいくつかの型に依存するため、ということでしょうか。そのあたりをコンパイラが意味を汲んでうまくコードを書かせてくれるならよいのですが、そうでないと逆にいろいろ溜め込んで、手間が増えそうだなという不安はあります。

ところで “eventually” は「結局」「ついに」という意味なんですね。このあたりの差は分かりにくいです。さっきの説明にも、“eventually” と “finally”、それから “at last” の違いが書いてありました。“eventually” は一連の出来事の末に「結局」「やがて」という意味で使い、否定文では使わないそうです。“finally” はいろいろなことが起こった末に、結果として最後に、というニュートラルな感じ。“at last” は主観的な苛立ちや安堵など、感情を伝えるときに用いる、という理解でよさそうです。時系列の流れというよりも、結果のニュアンスが強いのが “finally”、感情が乗るのが “at last”、と。まあ、今回はこのくらいにしておきます。とにかく “eventually” は「結局」「やがて」という意味だと覚えておきます。

では、Landmark のコマンドを作ります。`import SwiftUI` を書いて、`struct LandmarkCommands` を `Commands` プロトコルに準拠させます。`Commands` なので、コンピューテッドプロパティ `body` を実装し、型は `some Commands` になります。別に `some View` ではない点に注意ですね。ビルダー（いわゆる Result Builder／DSL）のセマンティクスで、ユーザーインターフェースを簡潔に書けるようになっています。DSL は端的に書ける利点がある一方で、その書き方を学習しないといけないという学習コストもあります。今回はそこを深掘りはしませんが、SwiftUI には SwiftUI の書き方があり、今はそれを学んでいる最中という感じです。もちろんライフサイクルなど別の概念もあります。ただ、もし SwiftUI が登場していなければ、覚えることはもう少し少なく済んでいたかもしれませんね。まあ、これは余談です。

`Commands` は `View` の代わりにコマンドを期待します。まずは `LandmarkCommands` を作って、`body` はとりあえず空の状態で用意するところから始めましょう。

このコマンドをどこに置くといいでしょうか。コントローラっぽい場所ではない気がするので、新しく「メニュー」フォルダーでも作ってみます。とりあえず、特に指示はないので、どこに置いてもいいとは思いますが、メニュー用にまとめておくのが分かりやすそうです。ファイルは Swift ファイルで作り、名前は `LandmarkCommands` にします。アプリ名は Landmarks ですが、型名は `LandmarkCommands` としておきます。 今回は複数形に合わせて、`LandmarksCommands` にしておきます。`SwiftUI` をインポートして、`struct LandmarksCommands: Commands` を定義します。コマンドの `body` プロパティは `some Commands` です。つまり、`var body: some Commands` という形になります。

次に、`SidebarCommands` を `body` に追加します。これはビルトインの `SidebarCommands` で、サイドバーをトグルするコマンドを提供します。これでサイドバー用のコマンドの実装はできました。

このコマンドをアプリで使うには、`Scene` に追加します。`LandmarksApp` ファイルを開き、利用する `LandmarksCommands` を `commands` モディファイアで指定します。`commands` モディファイアは `ViewModifier` のように動作し、ビルド時には `Scene` で活用されることが期待されます。ですので、`commands { LandmarksCommands() }` を追加すればOKです。ここでの変更はこれだけですね。

では実際にやってみます。Macアプリを再度動かし、メニューの「View > Show Sidebar」コマンドから、リストが復活できることを確認してください。

ただし、残念ながら iOS アプリはビルドに失敗します。`Commands` が iOS では有効ではないためです。これは次で直していきます。

ここまでの段階でもう一度整理しておきます。`View` 内からサイドバーの話は今のところ載っていないので、`View` に何かを追加するというよりは、アプリ全体のメニューとして定義する形になります。

`SidebarCommands` を組み込み、`LandmarksCommands` はOKです。ファイルの所属先（ターゲットメンバーシップ）は iOS と macOS の両方にしておきます。プロジェクト内では慣例として、iOS と macOS のグループに分けて配置しておくとよいでしょう。

メニューは `Scene` にぶら下がるので、アプリケーション本体、つまり `LandmarksApp` の中にシーンモディファイアとして付けます。実際には `WindowGroup` のところで `commands { LandmarksCommands() }` を指定します。その上でビルドを試します。 うん、大丈夫ですね。これを押すとメニューが選べるようになります。では、その話に進みます。こちらでビルドします。出ましたね。サイドバーでも同じように表示されました。できましたね。では、次へ行きます。

次はチュートリアルの `watchOS` を直します。条件付きで `.commands` モディファイアを使い、`watchOS` では除外する設定を追加します。そのうえで `watchOS` をビルドします。そして、`LandmarkCommands` は `watchOS` ではない場合に適用するようにします。

こんな感じで進めると言いましたが、そのままでは届かないので、間に合わせの対応をします。モディファイアはここですね。もし OS が `iOS` または `macOS` のときに `LandmarkCommands` を追加します。

こうしている理由は、`watchOS` 以外、たとえば `tvOS` や `visionOS` なども今後考慮に入ってくる可能性があるからです。対象を広げた場合でも、今のところ想定している一番狭い範囲を取ることが、条件分岐では大事だと思います。ですので、ここでは `iOS` または `macOS` に限定して用意しています。 iOS が本当に必要なのかどうかは、まだ半信半疑ですけど、まあいいや。必要なければ、SwiftUI for macOS で済んでいたはずなんでね。うん。

ランドマークコマンズ、悪くないかな？`ViewModifier` でランドマークコマンズというのを作ってもいいのかなと思ったんですが、コマンドは…あとはモディファイア、いや、`CommandBuilder` か。メニュー関連をやったとき、これがすごく良さそうですね。まだ使い方は知らないですけど。

これで良さそうな気がするので、次。セクション6、「カスタムコマンドを追加していきましょう」。前のセクションで、ビルトインのメニューコマンドセットを追加しました。ここではカスタムコマンドを作る。お気に入りステータス、現在選択中のランドマーク…現在選択中のランドマークのお気に入りステータス。ああ、それを後で作るんだ。なるほど。じゃあ、`selectedIndex` が前回とかに付いてありますけど、それが使えそうな感じですね。

で、Bool の値を用意して、ランドマークが選択されているかを見るために、フォーカスのバインディングを作っていく。フォーカス…フォーカスか。自分でこの前やったのは selection でしたよね。フォーカスじゃないですね。その違いも、ちょっと楽しみにしつつ進めていきます。

そのためにランドマークコマンズの中で、`FocusedValues` を出したい。`selectedLandmark` の値を使って作成する。FocusedValues Structure…なんだろ？`FocusedValues` 構造体ですね。それをカスタムキー、`SelectedLandmarkKey` を使って拡張していく。このパターンは、新しい Environment 値を追加するのと類似するパターンです。プライベートキーを使って、システムが定義している `FocusedValues` 構造体に対して、`SelectedLandmarkKey` というフォーカス値キーの構造体を作り、typealias で `Value` は `Binding<Landmark?>` といったものを用意するらしい。

そして `FocusedValues` には `selectedLandmark` というプロパティを持たせて、ランドマークのバインディングを使って、`SelectedLandmarkKey.self` に対して get と set を載せていく、ということをするらしい。

ランドマークコマンズにもコピペで貼ってみますか、とりあえずね。こうして、ランドマークコマンズ…これですね。これに対して貼り付けてあげる感じ。なんか変ですね。変じゃないのかな？いや、変じゃないな。

`SelectedLandmarkKey` がこんなグローバルにあることがすごく気になったんですけど、構造体ですね、`SelectedLandmarkKey`。まあいいのか。フォーカス値に対して使うけど、`FocusedValues` の `SelectedLandmarkKey` と一緒に捉えていいですかね。そうだとすると、これ、extension の中に持たせてやったほうがいいんじゃないかなという気がしたので、ちょっとそれやってみましょうか。extension…はい、extension。何だっけ。こう、`FocusedValues` の中で、こうやって extension で `SelectedLandmarkKey`。あと、ここがその定義の外になっちゃうんだ。ならば、この2つに対してフォーカス値…これの書き方…ここですね。`FocusedValues` の中に出てますね。`FocusedValues`。

あとはチェックアウトなのかな？どうだろう。Value…。あらためて `Value` が見つからない。`FocusedValues` で…あれ、ここ違うか。`SelectedLandmarkKey` ここにありますもんね。これは省略で大丈夫ですかね。こんな感じ。

で、あとエラーになっているのは、「宣言はファイルスコープ内でのみ有効」です。ああ、そうなのか。ああ、これね。`FocusedValues` がプライベートだったんですね。 なので、こうしてプライベートにしておいてよかったのだと思います。宣言はファイルスコープでのみ有効なので、`private`で問題ないですよね。いいと思います。

さて、`SelectedLandmarkKey`はこれで正しいですよね。定義としては「パラメーターの型が推論できない」と言われていますが、`SelectedLandmarkKey`がスコープ内にないことが原因でしょうか。`FocusedValues`の中に`SelectedLandmarkKey`がありそうですけどね。今の箇所をクリックすると、ちゃんとそこに飛べていますよね。

`FocusedValueKey`の`Value`は`Binding<Landmark>`（あるいはオプショナルの`Binding<Landmark?>`）ですよね。確かに`SelectedLandmarkKey`に`typealias`がないですね。あれ、コピーしてくるのを忘れていました。`Binding<Landmark>`にしておけば`SelectedLandmarkKey`が推論できそうです。

`self`にぶら下げる形で使っているつもりですが、もしかして`extension`だと通らなくて、`extension`をやめると通る、という可能性はありますかね。`Binding<LandmarkKey>`が`FocusedValues`の中にあって、その中から使っている気がするのですが、今のやり方だと大丈夫です。やっぱり`FocusedValues`の中がスコープに入っていない、ということなのかもしれません。

`SelectedLandmarkKey`をどこに置くのが理想か、という話になります。これを知るには、`FocusedValues`の構造をちゃんと把握しておくのが良さそうですね。この中で`extension`して、`FocusedValues`に何たらキー（今回は`SelectedLandmarkKey`）を生やしているはずです。`FocusedValues`にファクト（＝紐付け）しているのは自分側の話なので、ここにないということは、ここで`FocusedValues`への拡張をしていない、ということですね。そうなると、`SelectedLandmarkKey`のようなものは外に定義しておくのが理想なのかなと思いました。そうかもしれません。では`extension`はやめて、`private struct`にしておきましょう。これで`SelectedLandmarkKey`ができたようです。

以前に自力で実装した選択のロジックとは全然違いますね。`FocusedValues`のような仕組みがあるとは知らなかったので、そもそも発想が違っていました。こんな感じで、とりあえずコピーできたので次に進みます。

`@FocusedBinding`プロパティを追加します。プロパティラッパーを、現在選択しているランドマークに追加してあげるイメージです。Reading the value（値の読み出し）のところでその値を読めて、`ListView`で後ほどこれをセットできるようにします。ユーザーは選択を行える、という感じですね。

`@FocusedBinding`で`selectedLandmark`というものを用意して、`FocusedBinding`を`LandmarkCommands`に持たせるのかどうか、というところです。何だっけ、`FocusedBinding`…。そうそう、これで`selectedLandmark`。これが`Landmark`だったでしたっけ。オプショナルかな。いや、`selectedLandmark`を使うタイプですね、まずは。だから`selectedLandmark`で、ここに型などは明示しなくていい、という感じです。これでバインディングの`selectedLandmark`ができました。

あとは、また画面を戻ってしまった感じですね。セクション5はここから辿れますかね。ここじゃないですね。セクション5までタップしていったほうが早そうです。この辺かな。セクション5で、今はセクション6。これでここまでできました。

次に、コマンドメニューにランドマークと呼ばれるコマンドを追加します。これはユーザーが定義するメニューのコンテンツですね。コマンドメニューでランドマークを…これだけでいいのかな。そうですね。あ、戻ってしまいました。間違えました。どこまで行けばよかったんだっけ。一番下まで行くと、セクションは8の中だった気がします。ここはまだですね。セクション7、セクション8、セクション5でした。 文字起こしのテキストがまだ届いていません。整文して読みやすくしますので、元の文字起こしテキストを貼り付けてください。

対応内容の要点:
- 要約はせず、内容はそのまま「です・ます調」で整えます。
- 誤変換（例: 「G言語」→「C言語」、「万全オキス」→「万全を期す」など）は適切に修正します。
- コードはバックティックで装飾し、短いコードはインライン、必要に応じてコードブロックにします。
- 複数人の会話でも話者名は出さず、通常の文章にまとめます。
- 文頭が途中から始まっている場合は無視し、次の文から整えます。

長文の場合は分割して送っていただいて大丈夫です。表記の希望（専門用語の原文表記・カタカナ表記の統一など）があれば一緒にお知らせください。 整形する元の文字起こしテキストが見当たりません。処理したいテキストを貼り付けてください。

- 「です・ます調」に整え、適切に句読点を入れます。
- 誤変換（例: 「G言語」→「C言語」、「万全オキス」→「万全を期す」など）は文脈に沿って修正します。
- コードはバックティックで装飾し、短いコードはインラインで表記します。
- 複数人の会話が含まれていても、セリフ形式にはせず、内容を踏まえた自然な文章にまとめます。
- テキストが途中から始まっていて不自然な冒頭は無視して、続きから整えます。

特に気をつけてほしい用語や表記ゆれの方針があれば、あわせて教えてください。 文字起こしテキストを貼り付けてください。いただいた内容を「ですます調」に整え、句読点を補い、誤変換を修正し、コードは必要に応じてバックティックでインライン表記にし、要約せず自然な文章に直します。会話形式の部分も話者を分けずに文章化します。文頭が途中からでも、次の文から整えて対応します。 ここですね。セクション5はここも終わっていて、試すのも終わっています。あっ、違う。ランドマークコマンドを追加して、セクション6に入っていました。この中でコマンドを作るところのステップ3、ここまで行きました。ステップ2もここまで行っています。ここら辺もステップ2みたいですけどね。

これで、フォーカスとバインディングといった仕組みができて、プロパティラッパ（例えば`@FocusedBinding`）で`selectedLandmark`をトラックするラッパだと言っていて、これで値を読み込める。リストビューで、ユーザーがセレクションを変更したときに後で追加できるようにする、という話ですね。自分でセットするのかな、これ。フォーカスとバインディングという形で搭載して、どれだけか…。

次に、新しいコマンドメニューを「ランドマーク」という名前で追加します。コマンドの中に追加するみたいですね。コマンドメニュー「ランドマーク」。ボタンの追加。ここを見ておきますか。

`selectedLandmark`、`isFavorite`、ステータスを反転する（トグルする）。メソッドを用意して見た目を整えます。Appearanceってなんでしたっけ、どっちが出てくるか分からないのですが、要するに現在選択しているランドマークに依存して変更が現れる、そんな感じなのかな。ボタンとして、`selectedLandmark.isFavorite`が`true`かどうかによって、「お気に入りに追加」か「お気に入りを解除」かの表示を切り替えると。`selectedLandmark.isFavorite`によって、ボタンに対して「追加」するのか「解除」するのかを表示するんだ、ということですね。お気に入り。そこで`isFavorite`のトグル。ここで`toggle()`を使うのか。この辺は`toggle()`を使えばいいのかな、`isFavorite`に使えばいいのかな。これはまた後で考えますか。

`selectedLandmark`が`nil`のときはディスエーブルにする。これは好印象というか、当たり前ではあるのですが、こういう条件をきちんと抜けている。こういったコードを見る機会がたくさんあって、`selectedLandmark`が選択されていなかったら無効化ですよね。どきどきなんですけどね。`selectedLandmark`を`nil`にする用意をしない、みたいな実装に出会うことがあって、選択していない状態があるにも関わらずオプショナルじゃないというのは、実装の手間が増えます。無理やり組み立てる手間が増えるので、オプショナルを使った方がいいですね。選択肢がないならオプショナル、という当たり前の発想にできると楽になるコードだとかね。オプショナルになっているのは、純粋に自分が知らなかったフォーカスとバインディングを使っているから、勝手にそういった仕組みになっていて、なおさらいいですよね。UIで作っているんだから、その機能をちゃんと使っていけば、いい感じのコードになるよ、といったお話ですね。

それでプログラムを作って、これで終わりなのかな。あとショートカットも作るかな。もう一回戻ってくればいいもんね。キーボードショートカットも、このメニューのアイテムにね。キーボードショートカットのモディファイア。直感的にいいですね。覚えていないと、モディファイアで付けるって忘れますけど、何にしてもモディファイアを追加する。これによって自動的にキーボードショートカットがメニューに表示されてくれるよ。ここが重要なんですよね。メニューの中を見るとショートカットキーがちゃんと表示されているので、よく使う機能、例えばサファリでブックマークをよく使うなっていう時に、ブックマークの「追加」を見ると「`⌘D`」って書いてあるから、次からはメニューからじゃなくて`⌘D`でブックマークを追加する、というのをここで見込んでおいて、実際やれるようになると効率が良くなりますね。まあそれはおまけで、とにかく今みたいなコマンドとかのショートカットキーが、自動で表示されてくれるという、そんな感じになるらしい。

キーボードショートカットが`F`で、モディファイアがShift+Option。これで「お気に入り」の`F`ですかね。Shift+Option、Shift+Option+`F`。全然関係ないことを思い出しましたけど、これが`OptionSet`ですね。`OptionSet`って、先日ちょっと聞かれてきた勉強会で話題に上がった`OptionSet`。`OptionSet`を使うと、列挙だといい感じにフラグとして使うことができます。列挙値って「1または2または3または4」みたいな排他的な選択を表現する方法ですけど、`OptionSet`は、個別の選択肢があるよって列挙値で表現した上で、その要素のうち0個でもいいし1個でもいいし2個セットでもいいし3個でもいいし全部でもいいし、みたいな、自分の好みで選べるようになる、そういった便利な機能ですね。まあまあそれはいいかな。

これでメニューは新しいコマンドを含むようになったら、`selectedLandmark`、フォーカス、`selectedLandmark`、`FocusedBinding`。これを動かすための実装が要る、まだやってないってことか。なかなか多いですね。やってないの？`selectedLandmark`はコマンド？コマンドに対して`FocusedBinding`を付けていたのか。そういうことか。これで実際の動きと、メニューを選んだときの接続先が関連付けられるってことか。そうかもしれないですね。

なのでやることは、ランドマークリストに対して`selectedLandmark`を`Landmark?`で持たせる（オプショナルにする）というのをやって、それだけじゃないよねって感じですが、インデックスとして`Index?`のオプショナル。インデックスがオプショナルになっているのは、選択していない状況があり得るってことでオプショナル。良い選択ですね。それで、ランドマークの`firstIndex`で、`selectedLandmark.id`から抽出して、持っているデータからそのランドマークを再び取り出す。その再び取り出す必要がある理由は、このチュートリアルをやりながらハマったところですよね。要は、バインディングを持ち回ってしまうと、ビューの再評価が起こったときに、そのバインディングが画面にうまく影響を及ぼせなくなってくる、みたいなのがあるので、値を取り直しているよっていう感じですね。

自分のコード、どうなってましたっけ。 似たような感じになっていたと思うのですが、インデックスはあまり明確には出していなかったと思います。とりあえずこのようなものを作って、インデックスと `selectedLandmark` を用意して、どこで使っているのか、まだ使っていないのかを確認していく、という流れですね。

リストをイニシャライズして、`selection` にバインディングしたリストを用意し、`NavigationLink` に `tag` を追加します。説明を読んでいても分かりにくいところがありますが、UI の知識が甘いと余計に難しく感じます。`tag` は特定のランドマークに関連付けられて、選択されたアイテム（`ForEach` の中の個別の要素）を他のものと区別するために使われます。`tag` と `selection`（例えば `NavigationLink(tag:selection:destination:label:)` の組み合わせ）を使うことで、選択状態をドライブできます。以前はタグを付けずに ID でやっていましたが、タグを付ければランドマークそのもので扱えるので便利そうです。まあ、これで良いのでしょう。

次に、`FocusedValue` モディファイアを `NavigationSplitView` に付けます。`FocusedValue` を提供し、ランドマーク配列から値のバインディングを追加する、という説明なのですが、最初は意味が掴みにくかったです。`FocusedValue` を追加して、ランドマーク配列から値をバインディングする、つまり Environment の中にあるランドマークのバインディングを渡す、という話ですね。実行して確認する、という感じでしょうか。

`LandmarkStore`（モデル）に保存されているランドマークをモディファイして、動くことを確認します。これに合わせて、ランドマーク用のコマンドメニューも用意します。`CommandMenu` で、名前は `"Landmark"` とします。`CommandMenu("Landmark")` のようにローカライズされた名前で新しいメニューを作成し、アプリ固有のコマンド群をまとめます。このメニューは、アプリケーションの標準的なメニューの後に、明示的な位置指定なしで宣言された他のメニューと順序を揃えて挿入されます。そういう英語だったのですね。まあ良いでしょう。次に進みます。

アプリケーションメニューの標準的な位置に置かれる想定で、`SidebarCommands` と並べて `CommandMenu` を配置します。ランドマークメニューの中では、ボタンでトグルします。`isFavorite` によって、ラベルは `"Remove Favorite"` または `"Mark as Favorite"` を切り替えます。つまり、`selectedLandmark` に対してメニューコマンドを定義し、`isFavorite` が `true` なら「Remove」、そうでなければ「Mark」というラベルにします。やることとしては、このボタンのアクション内で `selectedLandmark.isFavorite` をトグルします。しかも `Binding` をパスしておけば良いのですね。

ただし、`selectedLandmark` が定義されていない場合の取り扱いが必要です。`selectedLandmark` が `nil` のときに、条件で「`Mark as Favorite`」と出るのはおかしいので、メニュー自体を無効化した方が良さそうです。`if let selected = selectedLandmark { ... }` のように選択があるときに限ってボタンを描画し、その中で `isFavorite` に応じて `"Remove Favorite"` または `"Mark as Favorite"` のラベルにする、という方法が自然です。あるいは、ボタンは常に置いておきつつ、`Button` に対して `.disabled(selectedLandmark == nil)` を付けて、選択がないときはグレーアウトさせる方法でも良いです。ここではグレーアウトで良さそうなので、`.disabled(selectedLandmark == nil)` を付けておきます。これで、選択がないときにメニュー項目が選べない状態（グレー表示）になります。

一方で、`selectedLandmark.isFavorite.toggle()` のように書くと「immutable value」と怒られる場合があります。これは `selectedLandmark` が値型で不変のまま参照されているからです。ここは `FocusedValue` で `Binding` を提供しておき、`selectedLandmark?.isFavorite.toggle()` のようにバインディング経由で変更できるようにする必要があります。`nil` の可能性があるので、オプショナルは適切にアンラップしてください。

文字列ラベルの組み立てで、`"Mark"` と `"Remove"` の切り替えを足し算でつなぐ場合は、オプショナルを無理に加算したりしないように注意します。`selectedLandmark?.isFavorite == true ? "Remove Favorite" : "Mark as Favorite"` のように三項演算子で安全に分岐させるのが簡潔です。

スペルミスにも注意が必要です。`selectedrandmark` ではなく、正しくは `selectedLandmark` に統一します。同様に、`disabled` はメニュー全体に付けるのかボタンに付けるのかで意味が変わるので、どこに適用するかをはっきりさせます。ここではボタンに `.disabled(selectedLandmark == nil)` を付ければ十分です。

また、丸括弧の対応が崩れてエラーが増えていたので、`if let` のスコープ、`CommandMenu` と `Button` の閉じ位置を丁寧に見直します。`if` の括弧、`CommandMenu { ... }`、`Button { ... } label: { ... }` それぞれの閉じ位置がずれているとビルドエラーになるので、順番に整えます。

最終的には、`SidebarCommands` と並べて `CommandMenu("Landmark")` を配置し、その中に `Button` を置いて、`selectedLandmark?.isFavorite.toggle()` を実行します。ラベルは `selectedLandmark?.isFavorite == true ? "Remove Favorite" : "Mark as Favorite"` とし、`Button` には `.disabled(selectedLandmark == nil)` を指定します。これで、選択がないときはメニューがグレーアウトし、選択があるときだけトグルできるようになります。 なので、うん、言った気がします。ミュータブルなメンバーをイミュータブルな値に対しては使えないので、たしか mutating なボディにしていましたっけ。どうだったかな。コマンドメニュー……あ、そっか、`selectedFocusedBinding` だから大丈夫なのか。うん、これですね、`selectedLandmarks` ね。

それで、その `selectedLandmarks` をここで使っています。ボディのコマンドは条件付きで、コマンドメニュー（ランドマーク）で `selectedLandmarks` を参照しています。あ、ここラベルは間違っていると思ったけど、`isFavorite` は……いや、ラベルはこのままでいいですね。で、`isFavorite` は `selectedLandmarks.isFavorite`。ここが「トグルがいらないな」というのがひとつ気になります。

「使っていない mutating メンバー」「イミュータブルな値」といったエラーで、`selectedLandmarks` を `let` で定義しているせいだと言われています。`selectedLandmarks` はここでしか使っていなくて、定義はここ。うん、ですよね。なのに、これはなぜだろう。`if` 文周りでいろいろ苦労しているのは、何か括弧が足りていないからかな。`selectedLandmarks` で `if let` でしょう、ここは。で、この括弧の位置がここになっている……やれてないね。いや、やれていないわけではないか。コマンド……あ、コマンドの括弧がないです。あ、なるほど、丸括弧がないですね。これは単純なエラーです。これで丸括弧がここに来る。あ、1個目はそれでいい。

でも `.disable` はだめですね。ボタンに対しては `disable` ではなく `.disabled` で、`Bool` を渡します。`disable` は何か違いますね。`Button` に `disable` は存在しない（no member 'disable'）ので、`.disabled(Bool)` に直すべきです。もう一回……ボディのコマンドの `.disabled`。ボディ？ ボディか。ボディはもう1個は……どこだ？ これはランドマークコマンズですよね。ランドマークコマンズで、ボディのコマンズ。ランドマークコマンズの中でボディのコマンズが出ますね。それで、`CommandMenu`。`CommandMenu` で……あれ？ ラベルあたりが怪しいのかな。`disabled` が2つある？ いや、そんなことはないですね。これは無くしてもかまわない。で、もう一回。あ、先のほうのこれか。`disabled` に `Bool` を渡すやつ。

なんだっけか。おかしいな。あり得ない部分はなくて、ここの条件が `= "true"` で……それで、ここが……`apply`？ あー、オプショナルバインディングね。それで、`disabled` がやっぱり効いていないと。エラーは「`Button` に `disable` はない」みたいな感じですね。ボタンのラベル……この波括弧はボタンですよね。で、ボタンで `disabled`。ちょっと混乱していますね。いったんコピペしましょうか。これなんだったっけ。前と同じようなやり方で。

とりあえず、どこまでコピーしたっけ？ ボタンだけか。なので、ボタンから全部。こうしたところで、波括弧がまず1個足りていないのでは。こうして、`selectedLandmark` に上がってしまっていますね。えーと、`selectedLandmark`、`landmarks`、`selected` ってのは……まあ変数は `landmarks` だから `landmarks` にして、うん、あ、これは通ったって感じですね。そうすると、これでラベルが、うん。ラベルの前にこの `if let` ショートハンドを復活させると、ここがオプショナルじゃなくなります。OK。

`selectedLandmark` の `if let` はここか。ここがローカルの名前になっているから、`if let landmark = selectedLandmark`。あれ、`selectedLandmark` だから複数形じゃなさそうですね。これで `selectedLandmark` でいいですね。それで `selectedLandmark` という形で引き込んでいくんですが、これでいいのかな。`landmark`……うんうん。ここも `landmark`。ここ、ここは `landmark` ですね。`landmark`。ここが `landmark`。で、ここも `landmark`。`selected`……ここか。あれ、違うか。`selectedLandmark.isFavorite`。ここか。なるほど。じゃあこれを `landmark` に変えて、そうするとここが `landmark.isFavorite`、`isFavorite` のトグル。

トグルのエラーは、えーと、mutating か。`isFavorite` は変更が必要だし、あとはコピーなんだ、これが。ちょっと厄介ですね、これ。ランドマークコマンド……なるほど。つまり、これが今の状況だと `selectedLandmark` はバインディングか？ フォーカスとバインディングってやっているのかな。値としての情報は `value`。`value` か。まあ、値は取れているってことですかね。それはそれとして、`selectedLandmark.isFavorite` を変更するときに、これはバインディング？ あー、関係ないか。今のはすごい適当にやった気がします。`Landmark` は `Landmark` 型。`Landmark` 型っていうことは構造体で、`selectedLandmark` がオプショナル。と。 `selectedLandmark` はランドマークのオプショナルですよね。`if let` とかで扱っていて、プロパティの表示がちょっと変だなと思いました。いったんビルドしてみます。ターゲットは macOS 用ですよね。macOS 用でビルドして、どこか選びます。2カ所、ここですね。ここで「mutating メンバーを使えない」みたいな話が出ています。それから、LandmarkList だとか `Landmarks` のシンボルがない、というエラーもあります。これは、`Landmark` 自体はあるけれど、`nil` なんてない、という話ですよね。なので、`if` も使っているので `.disabled` にする必要はない、ということですね。とりあえずこの方針で進めます。

残りとしてはトグルです。`isFavorite` のトグルをやらないといけません。ですが、`toggle()` は書き込みができない状態になっていますよね。`let` で束縛されたままだったり、バインディングになっていないとダメです。`Landmark` の `isFavorite` はそういう性質ですよね。つまり、いまは何にもバインディングになっていないので、ダメということなのかな。そうすると `selectedLandmark` ……あ、型が出ていないのか。`Binding` にする必要があります。`Landmark` のバインディングです。`selectedLandmark` をバインディングにしてトグル、というのをやりたいのですが、ダメですね。`Binding<Landmark>` として扱いたいのに、`Landmark` が value だと言われます。`if let` は値に展開するので、これは独立してしまいますよね。

次に、ここの「足し算」かな、これが気になります。いや、「代入」のほうですね。ラベルのときには "asFavorite" という文字列の中でやっていました。その "asFavorite" のラベルはどこで使っていたかというと、`isFavorite` によってボタンのラベルを変えるやつです。つまり、ボタンのラベルですね。コマンドメニューのラベルです。`selectedLandmark` はアクションのほうで使います。コマンドメニューの中でボタンを作るのを忘れていましたね。なので、ここで表示名（ラベル）を追加して、トグルする。タイトルを決めたらボタンを作らないといけなかったのを完全に忘れていました。`Button` とラベルを書いて、波括弧の中にアクション、という形ですね。とはいえ、まだトグルはできません。`selectedLandmark` をオプショナルで持っている都合で、`LandmarkRow`（ランドマークの行）から来る `selectedLandmark` はバインディングであるべきです。`selectedLandmark` の `isFavorite` なら参照はできますが、`if let` のショートハンドを使うと、どこかでバインディングが外れて値になってしまい、ここで問題が起きています。

手元のメモだと、`selectedLandmark` は `Landmark` のバインディングを読み書きする、と書いてあります。つまりバインディングでやり取りするのですが、そこにオプショナルかどうかは関係ない、ということです。バインディングが通らなければいけないので、このまま `selectedLandmark` をそのまま使うのが良いのかなという気がします。上のほうも `selectedLandmark` をそのまま使う方針に合わせたほうがアンバランス感がなくなります。

それから、ビックリマーク（`!`）を使う利点としては、逐一アンラップが必要ないのでコードの見通しが良くなることがありますし、「ここでは絶対に値があるでしょ」というときには使えます。ただ、アラートをいじったときに、ボディが先に呼ばれていたんですよね。アラートの表示の有無にかかわらず。だから、ここが大丈夫なのかな、という心配があります。まずはやってみましょう。

コマンドメニューでの話に戻ると、コマンドメニュー「Landmarks」の中に `Button` があって、これが `nil` のときは `.disabled` にするだけ、という形です。`nil` のときもビューの構築自体は普通に行きます（今回のコードだとそうなります）。オプショナルじゃないとダメですね。オプショナルにするとこれでビルドは通りますが、選択されていないときには「お気に入りではない」などと言われるだけです。大きな間違いではないんですが、そういったことが起こるのは注意が必要で、リファクタリングの課題ですね。

とにかく、こうやってクロージャにして、キーボードショートカットは `F` に `Shift + Option` を付けます。ここでキーボードショートカットを `F`（`Shift + Option`）に設定します。

メニューは追加できましたが、`selectedLandmark` へのフォーカスができていません。LandmarkList 側で `selectedLandmark` を `@State` に追加して、リストの `selection` を使っていく、という形ですね。これに対して、`selectedLandmark` のセレクションが……あ、ここにありました。`selectedLandmarkID` で取得していました。ID で取った後は、どうするんでしたっけ。 定義はここにあったプライベート変数ですね。このプライベート変数の使い道は、ナビゲーションのリストにバインドすることと、変数として保持することです。

今回、`selectedLandmark` の扱いについては、`filteredLandmarks` に対してフィルタする流れを見ていました。IDに対してランドマークを引く処理、つまり `filteredLandmarks` に対しての `selectedLandmarkID` の使い所は特に用意していなかったようです。選択すればデータは選べるのですが、そのIDを使って何をするかという具体的な利用箇所が見当たらず、使っていない可能性があります。

この後の流れとしては、バインディングを取得して、`selectedLandmark` でランドマークを取り、`selection` で選べるようにし、`focusedValue` モディファイアを使って、`NavigationSplitView` がバインディングを提供していく、という話でした。とりあえず `selection` のところまで進める、あるいはここまでにしておく、という区切りです。

現在は `selectedLandmarkID` を使って `ForEach` で回し、該当するランドマークを取る形にしています。これでもよいのですが、今回のチュートリアルのように `filteredLandmarks` を回すのであれば、`tag` を設定しておき、それを `selection` で受け取る形でもよいのではないか、という考えです。

`filteredLandmarks` はボディ内で使っています。これはバインディングのランドマーク配列ではないため、`selection` でやるならバインディング可能なランドマーク配列に対して設定する必要があります。ただし、ここではそれがバインディングになっていないため、IDを直接取ってセレクションを管理する、というやり方にしています。本当はバインディングで取れれば理想なのですが、現状の構成だと難しいのかもしれません。まずはチュートリアル通りに実装して動かし、その後で本当にバインディングではできないのかを改めて調べる、という方針でよいでしょう。

やることとしては、今回はIDで取っているところをランドマーク自体で取る形にもできるはずです。さっきはインデックスを拾おうとしていたので、IDからインデックスを取る方針でも構いません。`tag` は今回は使いません、という整理です。

次に、`focusedValue` モディファイアを使って、`NavigationSplitView` にバインディング（ランドマーク配列）を渡し、モデルに書いたことがちゃんと反映されるようにします。モデル側ではモデルデータをバインダブル（`@Bindable`）にします。今はモデルデータを `Environment` に置いているので、これをバインダブルにして直接扱えるようにします。

リストのボディに入る前に、`@Bindable var modelData` を用意して、`modelData.landmarks` を取得します。そして、`NavigationSplitView` のところにモディファイアを設定し、バインディングのランドマーク配列が手に入るようにしておきます。リンクに関しては、そのままで問題ありません。バインドした値は `modelData.landmarks` からIDで取る想定です。どちらの層（モデル側かビュー側）で取得するかは、以前どこに載せたかを見直す必要があります。`first` で取るのではなく、IDで要素を引く実装です。

モデルデータのほか、ランドマークの定義や拡張も見直します。`Sequence` への拡張として用意した `elementByID` があり、これが名前的に分かりにくい問題がありました。もし `Landmark` に特化した拡張であれば `landmarkByID` のような名前のほうが分かりやすいかもしれません。あるいは、サブスクリプトで提供する手もあります。例えば次のようにしておくと、呼び出し側のインターフェースが自然になります。

- `subscript(id: ID) -> Element?`
- 内部で `elementByID(id)` を呼ぶ

このようにしておくと、上と下が同じインターフェースになります。どちらかというと、既存の関数を廃止してサブスクリプトのほうに寄せるのがよさそうなので、後で整理しておきましょう。 ここですね。リストの中…もう一個戻ればよかったかな。ここの中のランドマークのIDとして、`selectedLandmarkID` を使います。これが 0 だったときは 0 にする、という話になっていましたよね（チュートリアルでは）。ただ、ランドマークリストが 0 個の場合もあり得ます。動きはするのかもしれませんが、やっぱりおかしいです。

`selectedLandmarkID` は `Int?`（オプショナル）です。ということは、モデルデータのランドマーク数の…あ、これですね。インデックスを 0 にしているのか、そういう意味ですね。なるほど。やりたいのはこっちでした。セレクションがなければランドマークIDを 0 とみなしてやって、ということですね。ただ、ランドマーク数が 1 個もなかったら落ちますよね。あまり良くないと思うんですけど、とりあえず先に進みます。

それで、`selectedLandmark` が…どこだ。エラーメッセージをちゃんと見ましょう。`selectedLandmark` は「`private` のアクセス制御レベルのためアクセスできません」と言われています。つまり `selectedLandmarkID` が `private` なのが問題でした。特にここですね。`selectedLandmark` は外からアクセスできるようにして、`SelectedLandmarkKey` はこの中でしか使わないので `private` が妥当ですよね。そして、`LandmarkCommands` は外で使うので公開が妥当です。これでビルドを通して、動かしてみましょう…という話でしたっけ。チュートリアルでは、確かそうでした。

チュートリアルを動かして、新しいメニューアイテムを確認します。あ、追加したからですね。これを選んで…なるほど。これを選んで、ランドマークから `Remove Favorite`。`Remove`。あ、そうか。この横がチカチカ動いているのが気になりましたが、やってみましょう。お気に入りを外すかどうかだけの話です。ディテールビューであんなに大きく動く必要はないはずなので、どうなっているのかは気になります。

アプリ（これはチュートリアルだからOK）から、メニューを見ます。今のところ、ランドマークの…あ、メニューの表現が間違っていますね。スペースが足りない。優先度も変です。ラベルがあって、ボタンのラベルを作るときに用意しましょう。このままだと多分「Mark」にしかならないでしょう。なので、こうして、ストリング補間を使って選べるようにして…`Add Favorite`。これでいいですね。課題はいろいろありそうですが、とりあえず実行して動作を確認します。

何も選んでいない状況では、ランドマークの `Mark as Favorite` メニューが表示されてグレーアウトしています。これは、選べないことが分かるので良いのかもしれません。エディット系でもコピーなどがグレーで出ますしね。とはいえ、選んでいないのに出ているのは少し気になります。

`Silver Salmon Creek` を選ぶと出てきます。ランドマークから `Mark as Favorite` を選ぶと、お気に入りになります。もう一回やろうとすると `Remove Favorite` になります。ショートカットキー（Option+Shift+F）でも効きます。このときランドマークのメニューのところがチカチカっと光って、どのメニューに紐づいている操作かが分かるのは大事ですよね。ショートカットキーだけ押す状況もあるので、対応するメニューの場所が分かるのは便利です。たとえば G キーを押したらリストがヒットしたりしますし、類似するメニューがあそこにありそうだな、という当たりをつける助けになります。

肝心なのは、「Favorites only」にすると、表示されるアイテムが減ります。ここでお気に入りを外すと、それは良いとしても、お気に入りを外した途端にフィルターでいなくなって、もう一回「間違えた」を直すのが大変になります。そこで、次にフィルターをいじるときまでは残しておこう、という実装にしました。ともかく、今はお気に入りが全部なくなった状態です。

ここで「Favorites only」ではなくてもいいので、たとえば X を選びましょう。押したときに…こっちはどうだ、動くのか。メニューは？ メニューには `Mark as Favorite` がいます。これはバグですね。自分のコードが想定していません。フィルターを更新したときにリストからいなくなったのに、メニューに表示されていると誤解を招きます。リストにいるものだと思ってしまいます。これは大問題で、直さないといけません。

`Mark as Favorite` はできるけれど、これをやるとどうなるのか。見た目は何も起きませんが、裏では状態が変わっています。ちゃんとお気に入りが付いていました。これはバインディングの都合で、ビューには反映されません。ビューとモデルをつないでいるバインディングが古くなって評価できなくなっているのですが、モデルデータとはつながっているので、そちらは更新される、という状況ですね。やっと説明できるようになった感じです。 落ちるかと思ったのですが、落ちませんでした。インデックスは……まあ、`0`はほとんど使っていないので、このままでよさそうです。`selectedLandmarkID` またはゼロという扱いになっていて、何も選択していない状態から、さらに `focusedValue` が絡むと、ああ、そういうことか、という感じです。

Turtle Rock で偶然うまくいっているのかもしれません。フィルタを「Favorites Only」ではなく「All」にして、Turtle Rock が一番上に来るのはあまりよくないですね。カテゴリーを St. Mary Lake（Lakes）にしてから「Favorites Only」にすると、リストが空になり、その状態でランドマークから「Mark as Favorite」を実行できるという状況です。それで、これを押すとどうなるのか試しましたが、特に何も起きませんでした。

St. Mary Lake を開いて、カテゴリーを Rivers にしてみます。`selectedLandmarkID` がゼロで、「Favorites Only」を外しても問題は起きません。今は Rivers には該当が何もない状態です。いったん Rivers をやめて、カテゴリーを Mountains に変えます。そこには該当がいない状況で、St. Mary Lake のお気に入りを「Remove as Favorite」して、もう一度「Mark as Favorite」します。今操作しているのは多分 Turtle Rock でしょう。お気に入りにしたあと、「Favorites Only」を外します。ここは「Favorites Only」のままでもよかったかもしれません。「Favorites Only」で List にすると、St. Mary Lake の `selectedLandmarkID` が、`selectedLandmarkID` またはゼロ、つまり ID がゼロという扱いになっているように見えます。

そもそも ID がゼロなんて言いましたっけ？リソースの `landmarkData` を見ると、ID は 1001 などの値になっています。なので、`selectedLandmarkID` が `nil` のときにどう扱うかが本質でした。`selectedLandmarkID` が `nil` のとき、フィルタを更新しても選択状態を解消していないので、選択が残ったままになります。そして、ID が見つからなかったときにゼロを返す設計だと、もしデータに ID 0 のランドマークが混ざってきた場合にそれが選ばれてしまう、という問題が起こります。仕様で「ID は 0 より大きい値」と決めていたとしても、コード側ではゼロが混ざってきたときに区別できません。

昔の Cocoa の `NSNotFound` のように「見つからなければ -1、見つかれば 0 以上」という番兵値の設計は、モダンな言語の世界では時代遅れです。要は「見つからなければ `nil` を返す」という設計にすべきで、ゼロを番兵にするのはやめたほうがよい、という話です。なので、ゼロをどうにかしないといけない状況です。

モデルデータ側のランドマークも同様で、`selectedLandmarkID` がある場合には、`modelData.landmarks` に対してサブスクリプトではなく `element(byID:)` で検索するのがよさそうです。`modelData.landmarks.element(byID:)` であれば、見つからなかったときに `nil` が返るのでちょうどよいはずです。

ただ、実際に `focusedValue` と `Binding` に組み合わせたところで、型が合わないと怒られました。`focusedValue` は Optional を取れるので、インターフェース的には問題ないはずなのですが、`selectedLandmarkID`（`Optional<Int>`）に対して `map` で `modelData.landmarks.element(byID: id)` を適用し、結果が `Optional<Landmark>` になる設計で進めると、`Binding` 周りでアンラップが必要だというエラーになります。`Binding` の要素にアクセスするにはアンラップが必要、という旨で、`!` で強制アンラップすれば良いという話ではなく、そもそも `Binding<Landmark?>` の形に自然に落とし込めていないのが問題です。

`compactMap` にすればよいのでは、と思ったのですが、`compactMap` はシーケンス用なのでここでは関係ありません。`Int?` を `map` して `Landmark?` にする流れ自体は筋が良さそうですが、`Binding` に噛ませたときに「オプショナルを解除してからでないと要素にアクセスできない」というエラーに突き当たります。サブスクリプトにせず `element(byID:)` を使う方針は正しく、`ID` を `IT` と誤記していたのも修正しましたが、型合わせのところでまだうまくいっていません。

丸括弧や角括弧の修正を戻してビルドしてみても同様で、`optional` のままではダメだというエラーになります。`Landmarks` のコレクションのサブスクリプトと `element(byID:)` の実装は Town と同じようにしているつもりなのですが、`Binding` の層でアンラップをどう扱うかを再検討する必要がありそうです。 とりあえずこれでやってみますか。これでやってみて、これだとダメと言っているわけですよね。`element(id:)` が `Optional` になるのが問題だと言っているわけです。これで返るのが `Element` のはずなんですね。サブスクリプトの場合、一般には存在しないとランタイムエラーで落ちそうな気がしますね。今そのことはどうでもよくて、`Optional` が返るので、`selectedLandmarkID` の `map` で、なかったらなかったで `landmarks` …。

`Binding` の `element(id:)` で、なかった場合は `nil` を返せばいいのかな。これも `nil`、`Binding<Landmark>`…あれ？ これ落ち着いて手直ししたほうがいいのかな、という感じがしてきましたね。こういう表情・擬音の悪さは何なんだろうか。

これでクロージャで `map` したものを返すのか、`Binding<Landmark>` を返してほしいわけですよね。ここで `landmarks`。モデルデータで `landmarks`。そしたら `Binding<Landmark>`…。ここを置いて、`Binding<Landmark>` を返したとき、型は `ID` ですね？ それで `id` で出して、`Optional` ですね。それで `Binding<Landmark>` は `Optional` ではなく、`Binding<Landmark>` をアンラップしないといけない。

`landmarks.element(id:)` が `Optional` を返した場合、`Binding<Landmark>` で `id`…では `Optional` ですね？ `Binding<Landmark>` か `Optional` かですね？ この話としては、モデルデータの中で `landmarks` のモデルデータ…これを `Array` に変換するのかな？ これで `Binding<Landmark>` に変換できたのか？ 自分で分からなかったという感じなんですけど、作りはしましたよね。

それで `Element` で、何か勘違いしていると思うんですけど、アンラップしないといけない？ `map` で `Optional` を返す。これは `Optional` を返しているんじゃないのかな？ このことはやらなくても、ここで `result =` でいいと思うんですけど、これで `result` の型は、`Landmark?` か `Landmark` か？ `element(id:)` が外れなくなっていた。だから、`landmarks = ...`。モデルデータの中で細かく分けていくと見えるようになるので、よくこういうふうにして、謎のときに調べますけど、`Binding` これはダメなのか？ これがダメになった。ここで `landmarks` の型が見えないのか？ なるほど、ここからやるのかな？ ちょっと長くなってきちゃいましたね。解決したくなるんですよね、ハマっちゃうとね。

`Binding` の配列が取れていると思うんですけどね。それで、`Binding` の配列が取れている中で、`Binding<Landmark>` になっているので、あそこから選んであげればいいのか。`landmarks.first(where: { $0.id == id })` ですね。`first(where:)` で、`$0.id == id` こういうふうにして、これを返す分には…`==` がダメか？ これで `return`…`return` はいらないんですけど、押してあげると、`first` がダメか？ `Optional` 型、また同じですね。だから自分の勘違いか。`FocusedValue`…`FocusedValue` 間違っているのかな？ `Binding<Landmarks>` ですね。

それで `FocusedValue` の定義は何かというと、`Value` があって、`Value` というのは `KeyPath` で、戻り値が `Value?` でこうなってしまうんですよね。なので、`Binding<Landmarks>` も `Optional` ですよね。欲しいのはね、これのキーがそうなのでね。なので、これが今 `Optional` が2つになっちゃっているんだ。戻り値で、これが `Int` がなかったとすると、`Optional` の `map` というのは、戻り値として `Int` を返した場合は `Int?` になるわけですね。`Optional` を返したときには `Int??` になる。`Binding<Landmark>?` を返した場合には、`Optional` の `Optional` にならないといけない。なので、そうすると `Optional` の場合って、`flatMap` でいいんだ。こうすると二重をフラットにしてくれるので、これで OK でしょう。ここが `=` で止めるよって言われていますけど、これは OK。

だから、`landmarks` の `id` で、ここで `id` の `element` にしようかな。`landmarks.element(id: id)` で `id` を渡す。これで通りました。勘違いしていました。これを簡単にしようかなということで、クロージャをやめて直接渡してあげる。`landmark` に押してあげれば OK。こういう感じ。これで丸括弧がない。こんな感じですね。いや、なんか簡単とか言って、相当時間かかっちゃいましたね。

でもこれで、`id` が見つからなかったときは `nil` になるので、ちゃんと `FocusedValue` に、余計なものがリンクされなくなる。あるいは `id` が 0 のものがリンクされなくなるというのは、今時の安全性を保有する上で非常に大事になってくるやつですね。

ここサブスクリプトできるのかな？ サブスクリプト渡したいんですよね、どっちかというとね。こんなことできるのかな？ そんなこと無理ですよね。じゃあこれで、消化の意見がこれくらいの規模だったら、サブスクリプトでやっちゃってもいいですね。`flatMap` と `map` であれやっても…そうか。リスト構造だけじゃないんだ。ああ、そうか。そうね。そうすると、やっぱり `id` がいいですからね。もっと簡単にできそうですけどね。できそうもそうだし、別に分ければいいんだ。関数で。`selectedBindingLandmark` みたいなのを…。

じゃあこれで、とりあえず YouTube のセクション6が終わったので、次回セクション7をやってみますかね。リファクタリングももうちょっとまとまってから、いろいろやっていく感じにしましょう。はい、じゃあ今日はこれで終わりにしますね。お疲れ様でした。
