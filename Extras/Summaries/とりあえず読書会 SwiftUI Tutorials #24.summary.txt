Transcription & Summarize : とりあえず読書会 SwiftUI Tutorials #24

では、実装を始めていきましょう。前回は UIKit との連携周りで Binding がうまく動かないという問題があり、その原因を調査するために前回の実装の詳細を眺めてみる、ということをやりました。結論としては、後でもう少し詳しく触れますが、「バインディングをコンテキストに持たせるべきではない」と言いつつも、整理してみると結局コンテキストに持たせざるを得ない状況になっていて、「仕方ないけれどこういうやり方にしないとダメだね」という話で終わっていました。

その過程で、「コンテキストに self を持たせるのはよくない」という話をしていましたが、改めてゆっくり考えると、むしろ self を持たせるべきなのでは、と思うに至ったので、まずはそれを紹介しておきたいと思います。

これが前回まで見ていたコードです。チュートリアルを元に、自分なりに美しいコードを目指して書いていったのですが、ここが美しくない状態になっていました。大事なところは、`UIViewControllerRepresentable` を使うことで UIKit と SwiftUI を連結できる、という点です。この `PageViewController` は UIKit のビューではなく、SwiftUI の View として定義されています。この View を SwiftUI の上に置き、その内部で UIKit のビューを表示します。つまり、受け渡しの役割を持ったものになっている、ということです。

具体的には、`makeUIViewController` によって受け渡し先の UIKit のコントローラを用意します。SwiftUI の View が更新されたときには `updateUIViewController` が呼ばれるので、そこで更新を働きかけます。SwiftUI は View のインスタンスを作り直す性質がありますが、UIKit はそうではありません。このライフサイクルの違いにより、状態をどこかに残しておく必要があり、それを `Context` 経由で参照できる `Coordinator` が担います。

`makeCoordinator` で最初に `Coordinator` がインスタンス化された後は、UIKit 側はそれをずっと使い続けます。SwiftUI の View がいくら作り直されても、`Coordinator` は同じインスタンスを使い続けられる、という作りになっています。

実際に進めていったとき、`Coordinator` が View の `self` を持つのはよろしくない、という話をしていましたが、むしろ `self` を持たせるべきでは、という考えに変わりました。というのも、`Binding` を持たせるべきかという観点で考えると、元になる `PageViewController` が別の SwiftUI の View から `currentPageNumber` を `Binding` でもらっており、その共有がうまくいくのかが問題になるからです。

原因としては、この `Binding` が値型で作られていることと、SwiftUI のライフサイクルの都合があります。SwiftUI 側で View のインスタンスが作り直されるたびに、以前の `Binding` を `Coordinator` が握り続けていると情報の更新が伝わらない、という事実が前回の調査の中で分かりました。つまり、どこに何を保持させるか、`Coordinator` が何を参照し続けるかを適切に設計しないと、更新が反映されない状態に陥る、ということです。 このバインディングは、ビューが書き直されるたびに更新していかないと、役目を終えた古いもののままになってしまいます。最初にコーディネーターに持たせてしまうと、その後にSwiftUIのビューが更新されても、コーディネーターは最初にしか作られないので、役目を終えたバインディングを持ち続けるという問題が起こります。

そこで、`updateUIViewController`のタイミングで新しいバインディングをコーディネーターに渡し、更新するような「`updateBinding`」のようなメソッドを用意する、という対処を考えました。更新のたびに必要なバインディングを受け取って差し替える、というやり方です。ただ、これはうっかり更新を忘れたときに破綻します。たとえば必要なバインディングが増えたのにコードを直し忘れたり、あるいは`currentPageNumber`のバインディングの更新を漏らしたりすると、新しい`currentPageNumber`を取得できず、最初の値のまま固定されてしまいます。今回の例だと、延々と1ページ目のままになってしまう、という問題が起きます。

こうしたミスを避けてより確実にするには、改めてコーディネーターに`self`を渡すのが良いという結論に落ち着きました。SwiftUIのあるビューからインスタンス化され、そこでバインディングしてもらい、そのバインディングをSwiftUI側の`self`がUIKitに橋渡しします。そのために、コーディネーターには`self`、もう少し正確に言うと、`self`が持っているバインディングを渡します。

`self`は複数のバインディングを持っている可能性があります。元のビューから何も受け取っていなければバインディングはありませんが、`currentPageNumber`以外のものを持つことも十分にあり得ます。その中で、これらすべてのバインディングをコーディネーターが正しく扱えるようにするには、`UIViewController`自体のインスタンスが作り直されたときに、バインディングを更新できる設計にしておく必要があります。だからこそ、「`updateBinding`のようなメソッドで差し替える」というやり方を検討したのですが、前述のとおり更新漏れのリスクが残ります。

そこで、最終的にはコーディネーターに`self`を保持させて、常に最新のバインディングにアクセスできるようにするのが良いと思います。具体的には、`private var`でプロパティを用意し、コーディネーター側には`parent`というプロパティ名で`self`を保持させます。チュートリアルでも、コーディネーターの`parent`という名前を使っていました。こうしておけば、ビューの更新や`UIViewController`の再生成があっても、コーディネーターは常に最新の`self`を経由して、正しいバインディングにアクセスできます。 ペアレント（親）という表現よりも、オーナーの方が良いのではないかという話をしました。これは感覚的な問題ではありますが、ここではオーナーという呼び方で進めます。

まず、すべてのバインディングはオーナーが持っています。つまり、オーナーが持っているすべてのバインディングがそこに集約されているわけです。ですので、`updateBinding` のような仕組みは不要にします。その上で、たとえばカレントページはオーナーが持っています。ここで言うオーナーとは、自分が受け取ったオーナーの参照を内部に保持しているもの、という位置づけです。

ページが `didFinishAnimating`（スライドが終わったとき）にページ番号を更新します。このとき、今回はオーナーにバインドされています。`currentPageNumber` は、そのバインディングさえ生きていれば最新の情報が手に入るので、コーディネーターは現時点のページのコントローラーを返すことができます。ここは本来通りの書き方ですよね。

一方で、古い `currentPageNumber` をオーナーから取ってきてしまうケースがありました。つまり、バインディングがすでに終わっていて、オーナーが解放されていたため、そこから古い情報を取ってきてしまい、現在のページ番号とは異なるコントローラーを返してしまった、というのが大元のバグです。これを避けるには、常に最新の情報を使うようにする必要があります。たとえば、最新の `currentPageNumber` を引数で渡すタイプ、つまり `pageControllerFor(pageNumber)` のようにして、都度最新の値を渡す方式にするのが自然です。カレントページ用のコントローラーを取得したいわけですから、こちらの方が安全です。

別のアイデアとして、コーディネーターにバインディングを渡すのではなく、オーナーとして `self` を渡す方法もあります。これはまさにその通りで、`pages` も `self` が持っているので、個別に渡す必要はなくなります。渡すページはオーナーが握っているので、オーナーの `pages` から `pageController` を作ればよい、という形でイニシャライズできます。

ただし、このままだと、コーディネーターが最初に作られたときの `self` が持っているバインディングを使ってしまいます。UI の都合上、ビューは書き換えられるたびに新たにインスタンス化されます。その結果、あらかじめセットしておいたコーディネーターのオーナーは、すでにアクティブなビューのインスタンスではなくなってしまいます。つまり、コーディネーター側に保持された `self` の参照が古くなり、そこで持っているバインディングも古いものになってしまう、という問題が残ります。 ページの情報がバインディングされなくなってしまい、プレビューの動きがおかしくなっています。1回スライドすると動くのに、もう一度スライドすると動かない、といった不安定な挙動です。ページコントローラーのインデックスを見ると、上の方がアクティブな値で、下の方がコンテキストに設定されているオーナーが持つバインディング経由の値です。つまり、下の値は古いオーナーから取れてしまっているようです。もう一度スライドすると直ることもあるのですが、とにかく挙動が不正なのは確かです。

どこだったかな……まあ、イメージと少し違いますね。最後の方で何かの情報を消してしまったのかもしれません。できたと思って消したのですが、一部は残っている、という状態です。これはページコントローラーのページ周りの話で、この辺をどうするか、開始と最後を消した方がいいのか、少し悩ましいところです。まあ、今は一旦このままでよいでしょう。

とりあえず「バインディングが情報を送るだけではうまくいかない」という話でしたが、もう少し突き詰めて考えると、UIKit のライフサイクルと SwiftUI のライフサイクルの違いがポイントになります。UIViewController を present したとき、UIKit 側はインスタンスが継続し、その中身だけが変わっていきます。`makeCoordinator` は一度きりですし、同様に `makeUIViewController` も一度きりの呼び出しになります。

一方で、SwiftUI 側のページビューコントローラーは、更新のたびにインスタンス化されます。すると何が起こるかというと、アップデートのタイミングで最新の `self` を UIKit のライフサイクル側に運んであげればよい、という結論になります。つまり、コンテキスト経由でコーディネーターが持っているオーナーに対して、最新の `self` を渡せばいいのではないか、ということです。`owner` が `var` である限り、書き換えは可能ですよね。UIKit 側の更新が必要になったタイミングでは、古くなっているオーナーを差し替えてしまえば、`self` が持っているバインディングは常に最新のものになります。たとえば `context.coordinator.owner = self` のようにしておけばよさそうです。多分これで動くはずです（まだ試してはいませんが）。

今はプレビュー中なので一旦置いておきますが、少し処理が長いですね。一回ビルドを止めますか……大丈夫そうです。これで更新をかけて、処理が走りました。ではスクロールしてみると、ちゃんと動きますね。逆方向も問題ありません。こうしておけば、論理的にもとてもきれいです。UIKit が更新されたのだから、オーナーを最新に差し替えておこう、ということを最初にやっておけば、特に問題なく実装を進められます。 これで万々歳ということで、いいのではないでしょうか。ほかに何かありますかね。アップデートのあの辺は、できれば自動化したいですよね。更新がかかったときに、それを有効化できる手段があるとすれば、先日見つけた…なんでしたっけ。アップデート、バインディングが持っていたやつ、バインディングが持っていたプロトコル、何でしたっけ。 文字起こしテキストを貼り付けてください。長文の場合は分割して送っても大丈夫です（例: [1/3], [2/3], [3/3]）。すべて送信し終えたら「以上です」とお知らせください。

整える際のルールは次のとおりです。
- ですます調で自然な文章に整えます。要約はしません。
- 誤変換や聞き間違い（例: 「G言語」→「C言語」、「万全オキス」→「万全を期す」）は適切に修正します。
- コードはバックティックで装飾します。短いコードはインライン、長い場合はコードブロックを使います。
- 複数人の会話でも、話者名は付けず、内容を踏まえた通常の文章にまとめます。
- 途中から始まる不完全な文は無視し、次の文から整えます。

表記の希望（例: 英数字の全半角、固有名詞の表記ゆれ、URLやタイムスタンプの扱いなど）があれば、最初にお知らせください。 見つけたやつなんですけど、どれだったかな…。下のほう、アップデートみたいなやつだったと思います。この辺、もうすぐかな。あ、ダイナミックプロパティだ。`DynamicProperty` を使えば何とかなるのかな。例えば「更新が必要になった」というタイミングを検知するとして、`DynamicProperty` を持たせるべきなのはどこでしょう。`self`、HBコントローラーが `DynamicProperty` を持つとどうなるでしょうね。

`DynamicProperty` を使うなら、`update()` の実装が必要ですよね。`update()` の中で `print` で、例えば絵文字でも出して確認してみます。これで `update()` が呼ばれるのかなと思って試したのですが、あれ、`DynamicProperty` がダメでした。`DynamicProperty` は main actor でアイソレートされていないのか、だから `nonisolated` なのかな、と思って指定してみたのですが、それでも呼ばれていなさそうです。これで検証をかければ分かりますけど、やはり呼ばれていません。これじゃダメか。うーん、ダメでしたね。

そうすると、`self` が得られて、かつ `DynamicProperty` の `update()` が呼ばれるところがちょっとなさそうです。結局、アップデートが検出できればよいわけなので、トリガーを貼っておけばよいのですが、あれもその一環だと思うんですよね。

`updateUIViewController`。うん。だから、そうだな、`updateUIViewController` で、ページビューで…どっちかというと、`UIViewController` に `present` をしてあげたほうがいいんですかね。その中で、まだ `self` を引き継いでいくみたいな、そういったアイデアを作ろうかなと思ったんですけど、ここでこれを作るときに自動的に、`makeUIViewController` と `updateUIViewController` を実装してあげる、みたいな。オブジェクト指向でやればできると思うんですけど、プロトコル指向だとちょっと難しいかな。自分で書いてあげる以外に、ここを自動的に入れ込むには、コーディネーターのオーナー…つまりコーディネーターのオーナーに `self` を渡さないといけないってことは、`self` が手に入るもので、ページビューコントローラーなので、ここが持ってないといけない。しかし、これが更新を検知するために…と思って `DynamicProperty` の `update()` を使うのはダメでしたよね。中身だけが更新されるからかな。

そうなると、更新されたときにどうにかする手段は特にないですかね。`onAppear` とか使えるのかな…いや、`onAppear` はないか。`UIViewControllerType` と、`makeUIViewController`、`updateUIViewController`、あと `dismantleUIViewController` がありますね。これは何だろう…`dismantle` はクリーンアップ。presented view controller をクリーンに取り除く、破棄することができるみたいです。あとコーディネーターがあって、`makeCoordinator` がある。`makeCoordinator` って `@MainActor` で動くのかな。で、あと `sizeThatFits` があって、これくらいか。`UIViewControllerRepresentable` のほうですね。

レイヤードオプションっていうのがあるね。何だろう、レイヤードオプションって。あと、`UIViewControllerRepresentable` の extension。この辺はデフォルト実装だけ知っても、ちょっとしょうがないところはありますね。

`Body` はある？えっと、`Body` は何だっけ。`Body` は求められているのかな。`Body` が `Never` の場合か。`Body` が `Never` の場合と、`Never` じゃない場合って何があるんだろう。いや、`Body` は `Never` って書いてあるはずですね。

`UIViewControllerRepresentableContext` というのがあります。これで `context` と `transaction` と `environment` があって、`environment` もある。ただ、`environment` を見てもしょうがないかな。あとはアニメータ系…あまり更新をする手段は用意されていなさそうだから、そうすると、これ（コーディネーターにオーナーを渡すやり方）が一番いい感じですかね。ちゃんとライフサイクルの属性を知っていれば、そのコンテキストでオーナーを渡して、そのオーナーを差し替えるのを忘れた、みたいなことは比較的少ないですよね。ちゃんとしたいわけですよね。

本当はここ、自分で自動でやりたいわけなんですけど、「オーナーを引き継ぐよー」みたいなやつ。そういったのはできないですかね。あと、`updateUIViewController`。ああそうか、`updateUIViewController` のね…まあ、まあ、自分で手でやるしかないですね。

ということで、とにかくコーディネーターのオーナー。これを `self` で代入してあげれば、最新版の…よく SwiftUI で、このビューを表現する構造体を設計図とか言われたりしますけど、最新の状態にできる。UIKit のほうをこんな感じでスマートにできて、よかった気がします。

後からいらないデバッグコードは消しておきます。この辺、いらないですね。`print` はこれもいらないかな。あとはここか、ここもいらない。で、ここもいらない。あと `print` は…コーディネーターも一回きりっていうのは確かめたんですけど、コントローラーもいいですね。あとはコンテキスト。はい、こんな感じで、いい感じにできたんじゃないでしょうか。

では次。いよいよ、ようやくですね、次のセクションに行けそうです。セクション3。ここはドラッグ不能だから、これが今回ハマっていたやつですね。やっと解消できてよかったです。とても気持ちがいい感じですね。

ではセクション4に行きましょう。カスタムページコントロールを追加する。ページコントロールというのは、丸いポチが並んでいて、今何ページ目にいるかを出すやつだと思います。カスタム `UIPageControl` をアプリに追加する準備ができています。SwiftUI の `UIViewRepresentable` を使って実装していきます。今度はコントローラーではないところが興味深いですね。面白い作りです。

これで、`currentPage` がバインディングされて、`UIPageViewController`（これはさっきやっていたビューですね）と連携します。それに対して、`UIPageControl` をコーディネーターに対しても `currentPage` を持たせる、そういった仕組みが取れるみたいです。そのために、新しい SwiftUI ビューファイルを作り、ページコントロールを `UIViewRepresentable` で実装します。`UIViewRepresentable` と `UIViewControllerRepresentable` は同じライフサイクルで動きます。UIKit の型（どれか）と調和するメソッドを持っていて、`make…` からそれを作っていきます。

ページコントロールをこんなふうに作ります。その中で、ページコントロールを `UIViewRepresentable` で作り、`numberOfPages` と、バインディングの `currentPage` を持たせます。こちらはオーナー／ペアレントではなく、`@Binding` で渡すようです。そして `makeUIView` で `UIPageControl` を作り、そこに `numberOfPages` を設定します。`numberOfPages` のイニシャライザーではなく、プロパティとして設定ですね。 それで、メソッド `update` の方で、カレントページを `UIView` のカレントページに代入します。`UIView` に渡ってきた `UIPageControl` にも、カレントページを設定します。なんかさっきのと似ている感じですが、`self` を代入するんじゃなくて、要はこの `struct` のカレントページがバインディングなので、そのバインディングを改めて更新のために設定する、ということですね。ここで一生懸命頑張って用意した内容が効いてきます。面白いですね。

じゃあ、あの考え方は合っていたっぽい感じがしますね。論理的に破綻していなければ、だいたいやれていると思います。考え方としてはそんな感じで、はい。今はその方針でやっていけば良いと思います。 なので、ページコントロールを作ります。まずはここまで作ってみますかね。うん、ページコントロールを作るので、どこかな……ページコントロール。ページビューにとりあえず作っておきますか。この中で、SwiftUIのViewの中にページコントロールを置きます。

そして、できたやつに対しては `UIViewRepresentable` ですね。これに適合させてあげます。ボディではなく、ここで `makeUIView` を実装します。この中で……テキストが分かってくるけれども、ここで `control = UIPageControl` を作ります。で、これで作ったものを `control` として扱います。あと、何かしたっけ……ページナンバーか。えーと、`numberOfPages` ですね。`numberOfPages` をこのプロパティで戻してましたね。`numberOfPages` は `Int` 型。あと、`@Binding` のカレントページ番号。今回は自分が使ったやつなので、ページ番号型（たとえば `PageNumber`）ですね。`PageNumber` 型を使います。

そして、`control.numberOfPages` に `numberOfPages` を設定し、`return control` だったかな。あと `updateUIView` でしたね。えーと、何かちょっと忘れている気がするんですけど、`updateUIView` の中では……。

レイアウトとしては、`VStack` から `ZStack` に変えつつ、ページビューの中のボディの `VStack` を `ZStack` に変えて、ページビューコントローラーの下にページコントロールを配置してあげる、ということをするらしい。まずやってみますか。ページビューの中で……えーと、このネットソフトの、そういえば実験のために作りましたね。これ動くのかな。動いた、動いた。エラー出てるけど、何だろうこれ。あ、終わっちゃった。まあいいか。まあいいや、あれはね、余計なものだから、いいんですよ。

えーと、これで `VStack` ではなく、何スタックにするって言ったら `ZStack` か。`ZStack` で、この `currentPageNumber` の代わりに、今作ったページコントロール。で、このイニシャライザで、`numberOfPages` が `pages.count`。それで、`currentPageNumber` が `$currentPageNumber`。うん、これでできた、ということですよね。うん。これはこれでいいのかな。`self` を渡したらいいかなと思ったけど、まあまあ、まだダメか。

これでビルドエラーが出てますね。えーと、ここが……はい、プレビューか。プレビューはどうしようかね。`currentPageNumber`、ページコントロール……まあ、ここはいいか。プレビューはなくてね、これでいい気がする。これで、ちゃんとできた、ということになるのかな。えーと、できましたね。ページコントロールがここ、真ん中に重なっていて、今この真ん中、これをずらすと隣に動きますね。で、もう一回動かすと……これ動かないや。うん、当てのが変な動きを見せた。うん、まだちょっとなんか変ですね。`numberOfPages` の周りが。この辺はこれからなのかな。

`ZStack` でそれを置いて、次にページコントロールをインタラクティブにします。`makeUIView` の中で、ページコントロールをインタラクティブにする。ユーザーがタップしてページを移動できるようにするやつです。何だっけな……あったあった。いや、忘れてるのかな、ちょっと思った。あ、戻った。これは操作間違えた。えーと、もしかして忘れてるのかな。ちょっと戻りすぎちゃったんで、もう一回セクション4のところから見ますが、これだけちょっとコードが出ないように見えるけど、ドキッと押すとあるんですよね。ここは大丈夫ですね。

で、それで、次。`ZStack` でやったときは、これで……やっぱ抜けてますね。ページコントロールのフレームとアライメント。フレームが「ページ数 × 18」、アライメントがトレーリング。これは何だろう。とにかく、実装としてページコントロール……なんか気になるけど、まだあるのかな。

あと、プレビューもあったね。プレビューも設定しておきますか。これね、やっぱプレビューはあったほうが何かといいですよね。あれ、今のプレビューは……えーと、どこだっけ。今のプレビューは、あ、これはいいんだ。既にあるやつだ。うん。

で、それで、次としてコーディネーターを作るよと。ここが今見てたやつですね。コーディネーターは `self` を取って、コントロールとして `self` を受け取る。うん。で、コントロールの `currentPage` に、親の `currentPage`。そうね、親の `currentPage` か。`UIPageControl` か。うん、やっぱりバインディングを更新するっていうのは基本中の基本みたいな感じですね。これを見てるとね。自分はハマったけれど、まあまあ。

とりあえず、これでページコントロール。ここでコーディネーターを作っていきます。コーディネーターはどうしようかな。ページビューコントロール（の型）ここで行くか。`private extension` で良さそうね。で、これで、ページコントロールに対して、`struct` じゃないや、`final class`。で、`Coordinator` として、`NSObject` を継承します。プロトコルの省略もできますけど、まあ省略しないほうが何を渡しているのか分かりやすいかなって気がなんとなくしますかね。何を渡してんだろう、みたいな感じになっちゃうんで、まあ「オーナーを渡してるんだ」って分かるほうがなんか良い気がする。なので、これでOKですね。

で、それでコーディネーターの中で、メソッドとして `updateCurrentPage` か。なるほど。`updateCurrentPage` という関数を独自に作って、その中で `currentPage`……これで、オーナーの `currentPageNumber` イコール……これもページ番号か。これはページか。`currentPage`。`Int` かな。えーと、どうなってる……`sender` か。あ、そうかそうか。ターゲットアクションだから `sender` が来ますね。バカそうなこと言ってる場合じゃなくて、`sender` は `UIPageControl` を取れるようにして、これが Objective-C のメッセージパッシングで呼び出される必要があるので `@objc` を添えると。だから、ここは別に `@objc` でもなくていいですね、じゃなくて、ここは `@objc` を付けてあげて、ページ番号はいくつかっていうと、ページ番号の値を入れてもいいけど、`PageNumber` をイニシャライズしておきますかね。`sender.currentPage`。で、こんな感じ。

で、これで選ばれている `currentPageNumber`。これが、えーと、`MainActor` 分離のプロパティか。オーナーの `currentPageNumber` ってそうだったっけ。あー、ページコントロール自体が `MainActor` か。だからコーディネーターも `@MainActor` で良さそうね。`@MainActor`。それが一番良さそうかな。でもこれ `@MainActor` ってやったときにターゲットアクションで呼べるのかな。それがちょっと気になるんですけど、呼べる……えーと、ちょっとなんかハマるかもしれない。ここ。まあまずやっていきますよ。とにかくこれで `updateCurrentPage` というものが呼べるようになったよ、ということで。

で、それで、まあここまではOK。さあ次。手順として、コーディネーターをターゲットにして、`valueChanged` というイベントで `updateCurrentPage` を呼び出してあげる感じね。だから、`addTarget(_:action:for:)` でコントロールに対してね、押してあげるぐらいのかな。ここはですね。はい、これをやりましょう、としたときに……またまた間違えた。えーと、そうね、また行かなきゃいけなくなっちゃったけど、まあまあ、この辺かな。うん。

で、あ、なんかわかったな。さっきのページが来るっての。えーと、どうしよう。まあまずはコーディネーターでアップデートもそうなんだけど……。 まずは `makeCoordinator` を作らないといけないですね。コーディネーターとして、オーナーに `self` を渡して返します。それから、ターゲット/アクションの設定で、イベントは `valueChanged` を指定します。

ただ、「セレクタが見つからない」と言われてしまったので、一応取り上げておきました。コーディネーター側にハンドラを実装して、ターゲットとして正しく引っ掛けないといけないのかなと思います。`Coordinator` はアクセス可能でないと困るので、ページコントローラーから見えるようにしておきます。

`UIViewRepresentable` なので、`makeUIView` から始まる想定ですよね。自分で作った `PageNumber` という型があって、値はページ番号を 1 始まりで持っています。`UIPageControl` に渡すときは 0 始まりのオフセットが必要なので、`currentPageNumber` をそのまま `currentPage` に入れるのではなく、オフセットに変換して渡さないとダメですね。`numberOfPages` はそのままで良くて、問題は `currentPage` と `currentPageNumber` の対応です。

オーナーの `currentPageNumber` に自分のカレントページを反映するときも、結果をそのままではなく、オフセットから設定する必要があります。そこで、`PageNumber` にもう1個イニシャライザが欲しいですね。`init(offset:)` のように、0 始まりのオフセットから生成するやつです。実装は近くに置いておいたほうが忘れにくいので、この型のそばに書きます。例えば、`value = offset + start` のようにして、`start` は 1 ページ目なので 1 にしておけば良さそうです。こうしておけば、オフセットからページを作れます。

これで、`UIPageControl` 側の `currentPage` にはオフセットを入れる、という形にすれば良い感じに動くはずです。ビューを書き直してあげると、ポッチが最初は左にあって、スワイプすると2個目、さらに戻しても大丈夫。逆順もちゃんと動きます。タップでも動きますが、1個隣に動くだけ、という動作ですね。

挙動を確認するために `print` を入れて、例えば `sender.currentPage` を出してみます。タップして、1、もう一度タップして 2、さらにタップしても変わらない、またタップすると 1…という感じで、1個ずつしかずれないのかな、という様子です。`updateCurrentPage` は呼ばれていることは分かりました。

`currentPageNumber` のほうはどうでしょう。オーナーを代入し直したかどうか……していないですよね。コントローラーとは何かが違うのかもしれません。コーディネーターが作られて `self` をオーナーとして保持していて、`updateCurrentPage` でオーナーの `currentPage` に対して `PageNumber` を代入しています。`updateUIView` の中で、例えば `context.coordinator.owner = self` としてみるとどうでしょう。変わらないかな、という感じです。どうしても動かないときがあるように見えるのですが、これはこれで大丈夫そうにも見えます。

`UIPageControl` がずっと生きている、ということになるのかもしれません。`UIView` はこのスライドでビューがザクっと外れてしまうけれど、コントローラーは画面に残ったまま押せる、みたいな挙動の違いがあるのかもしれないですね。万全を期すなら、念のためオーナーを書き換えておく、という対応も考えられます。バインディングで値は来ているので、基本的には良さそうに見えますが、親の存在や構成によっては、バインディングや `UIPageControl` の振る舞いが変わるのかもしれません。ちょっとよく分からないところもありますが、安全のために代入しておく、というのはありだと思います。今回はどうしましょうか。 とりあえず、`updateUI` の中で代入を行う部分について、コンテキストのコーディネーターのオーナーに `self` を入れようとしましたが、これは要らないのでコメントアウトしておきます。ひとまずこれで大丈夫です。

次に、`FeaturedCard` とランドマークの関係を整理しました。`CategoryHome` 全体の中で、`NavigationSplitView` の `List` に分割して配置していて、中央にひとつのデータ（モデルデータの `features` に含まれるもの）を `FeaturedCard` で表示しています。`PageView` なのでカードはページ分割されており、`featured` が入っていますね。`FeaturedLandmark` のような中間的なものは不要になったので削除し、`FeaturedCard` にランドマークを渡す形に統一します。

その際、`PageView` 内で特定のランドマークを `FeaturedCard` に渡す初期化処理について、引数ラベルを明示する必要があるパターンでした。つまり、`FeaturedCard(landmark: landmark)` のように、`landmark:` を付けた通常のイニシャライザー呼び出しにします。これで良さそうです。

合わせて、`List` の見た目を調整するために `listRowInsets` を追加しました。とりあえずリーディング側の余白だけ詰めるか、全辺ゼロにしたいので、`listRowInsets(EdgeInsets(top: 0, leading: 0, bottom: 0, trailing: 0))` のように指定しておきます。これで意図通りになりました。

なお、`FeaturedCard` の `init` 呼び出しは2カ所にあり、`PageView` で `FeaturedCard(landmark: ...)` として使っている箇所と、プレビューで使っている箇所があります。プレビュー側はそのままで問題ありません。両方に残っているだけで、実際には初めて作るもののようですね。

さらに、`CategoryHome` 自体にも `FeaturedCard` を組み込む方向で進めました。これでこの画面が `FeaturedCard` をスワイプで回せるようになります。良い感じに仕上がりました。

次のセクションでは、`PageView` を使って、UIKit と SwiftUI のビュー／コントローラーがどう動作するかを見ていきます。実際にやってみると、スワイプはしっかり動作しました。ページコントロールのボタンについては、隣だけは押せるものの、1個飛ばして移動してくれない挙動でした。1個ずつなら押せばちゃんと動くのですが、たまにタップが無視されるように感じることもあります。連続で押すとその回数分だけ進むようにも見えますが、基本的には隣へ動くだけですね。とはいえ、用意されていた仕様どおりに動いているので、これはこれで良いでしょう。

続いて、どのプロトコルを使うかという話です。UIKit のビューコントローラーを SwiftUI に組み込むには、`UIViewControllerRepresentable` を使います。これは間違いありません。これに準拠させ、要求されるメソッドを実装すれば、SwiftUI のビュー階層に UIKit のビューコントローラーを追加できます。

では、その `UIViewControllerRepresentable` タイプにおいて、デリゲートやデータソースをどのメソッドで扱うかという点です。結論としては、`makeCoordinator()` でコーディネーターを作り、`makeUIViewController(context:)` で生成した UIKit 側のコントローラー（たとえば `UIPageViewController`）に対して、`context.coordinator` を `delegate` や `dataSource` にセットします。こうすることで、SwiftUI 側でコーディネーターのライフサイクルが管理され、必要な連携が行えます。更新は `updateUIViewController(_:context:)` で反映します。

このように、コーディネーターを使うことで、UIKit のデリゲート／データソースと SwiftUI の橋渡しができます。以降は、別の OS 向けの実装を作っていく流れに入っていく予定です。ここまで作ったものは、そのまま流用・採用できる見込みです。

時間的にも良い区切りなので、今日はここまでにします。ありがとうございました。
