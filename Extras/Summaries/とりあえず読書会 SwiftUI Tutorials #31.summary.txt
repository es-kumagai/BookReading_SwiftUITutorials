Transcription & Summarize : とりあえず読書会 SwiftUI Tutorials #31

はい、では「とりあえず読書会」を始めていきます。SwiftUI のチュートリアルを読んでいて、いよいよ最後のセクションです。前回から数回は watchOS アプリ対応をやっていましたが、そのあたりは一通り納得できるところまで進みました。まだ微妙な動きが残っていたり、こだわれば改良点はありますが、ひと区切りということで、最終セクションの macOS アプリに移っていこうと思います。

チュートリアルは、これまでの iOS と watchOS の流れを踏まえて、次は macOS アプリです。少し大きめの題材に挑戦していく、という感じですね。これまで作ってきた Landmarks アプリを macOS に対応させていきます。英語だと「build on everything」「round out」みたいなフレーズが出てきて少し戸惑いますが、要するに、iOS・watchOS・macOS を通じて SwiftUI の構築経験を仕上げていく、という趣旨だと理解しました。

進め方としては、まず macOS のターゲットをプロジェクトに追加し、ビューやデータを共有・再利用しつつ、macOS に合わせてビューを調整していく流れです。続くステップに必要なプロジェクトは、いつも通りあらかじめダウンロードしておきました。

ではセクション1、macOS ターゲットをプロジェクトに追加します。プレビューや実行を可能にするための準備ですね。実行には、Xcode で実行先が “My Mac” になっていることを確認します。macOS アプリを作っていくと、広い画面で動作する様子を確認できるようになります。

手順としては、まず新しいターゲットをメニューから追加します。テンプレートシートが表示されたら、macOS のタブを選び、App テンプレートを選択します。このテンプレートを使って、新しい macOS アプリのターゲットをプロジェクトに追加します。ステップ2では、シート内でターゲット名を `macOS Landmarks` にして作成します。言語は Swift を選び、Finish を押します。その後、スキームを `macOS Landmarks` に切り替えれば、プレビューやビルド・実行が macOS アプリとして行えるようになります。

チュートリアルの意図としては、他のターゲットとファイルを共有しながら進めるので、共有ファイルの変更にどう反応するかを、スキームを切り替えて確認する場面があるようです。まずは `macOS Landmarks` ターゲットを作って、共有まわりは後から整える、という順序で進めます。

私は実際に `macOS Landmarks` を作ってスキームを切り替えました。ビルドを一度通しておくのは大事ですね。名前を変えたり設定をいじった直後にビルドが失敗すると、変更が原因なのか、もともと失敗していたのか切り分けが難しくなるので、問題がない状態を確認してから次に進むようにしています。昔はこのあたりで `Info.plist` のパス変更など細かい調整が必要なことも多かった印象ですが、今はだいぶスムーズになりました。念のためクリーンしてビルドをかけても通るので安心です。

スキーム名の整理もしておきます。メニューの Manage Schemes から、`macOS Landmarks` のスキームが正しく設定されていることを確認します。

次に、`Landmarks` グループの `ContentView` を選んで、キャンバスにプレビューを表示します。SwiftUI のプレビューでは、デフォルトのメインビューがそのままプレビューされ、メインウインドウの様子を確認できます。`macOS` アプリのフォルダ内にある `ContentView` のプレビューも見ておきます。

ただ、ここでプレビューがうまく表示されず、「プレビューのアップデートエラー」が出ました。`macOS Landmarks` の実行に失敗した、という趣旨のエラーで、権限関連のメッセージも含まれているようです。サインや実行設定などを一通り確認しても特に問題は見当たりません。Xcode を一度終了して再起動してみましたが、状況は変わらなかったので、いったん先に進みます。

次の手順では、プロジェクトナビゲータで `Landmarks` グループにあるデフォルトの `LandmarksApp`（macOS テンプレートが生成したファイル）を削除します。watchOS のときと同様に、デフォルトで生成された App エントリは不要で、すでにあるものを使う方針だからです。それを削除したら、続けてビュー、モデル、リソースの各ファイルを共用していきます。

具体的には、モデル側では `ModelData`（モデルデータ）など、ビュー側ではリストの行や画像まわりのビュー（たとえば `LandmarkListRow` や画像のコンポーネントなど）、コントロールでは `FavoriteButton` など、必要なものを macOS ターゲットから参照できるようにします。まずはこのあたりから順に進めていきます。 先ほどは、`MapView` と `FavoriteButton` を macOS でも使っていく、という話をしていました。残りで必要になりそうなのは、共有のアプリ定義です。これ以外は macOS でも動くということらしいですね。

ファイルは作業しながらどんどん増やしてきたのですが、まだターゲットに選ばれていないはずなので、このままだとビルドは通らないと思います。他にも、モデルと Resources フォルダのすべて（アセットも含めて）を取り込んであげます。アセットも少し変更してあるので、そのあたりも反映しつつ進めます。これらのアイテムは、アプリのデータモデルとリソースに相当します。まずはこれらを macOS ターゲットに入れてあげます。

次に、ファイルインスペクタで（いま選択しているものを含めて）必要なファイルをすべて選択し、Target Membership で `MacLandmarks` にチェックを入れて登録します。

続いて、macOS の App アイコンを追加します。macOS 用のアセットの中に AppIcon があるので、ここにアイコンを入れていきます。必要なサイズがいくつもありそうなので、iOS 用のアセットを参考にしてサイズ感を確認します。たとえば 1024 くらいのサイズのものを貼ってみました。用意できていれば、watchOS アプリ用のものもありますが、とりあえずこれはこれで良さそうです。

アイコンファイルを用意したら、`MacLandmarks` グループで Assets.xcassets を選択し、Empty App Icon を削除します。英語の手順書の表現が少し違う気もしますが、次のステップで差し替えるので、まずはこれを消します。そのうえで、先ほどダウンロードした Resources フォルダにある AppIcon を入れていきます。macOS 用のフォルダから該当するものをドラッグして並べれば、うまくいくはずです。 ちょっと並べてみますね。はい、並べました。ウィンドウを小さくしたら画面表示が少しおかしくなりましたが、ひとまず良しとします。App Icon はこのリソースの中にあるこれですね。これをアセットに投げ込めば良いという話っぽいです。アセットに追加して…はい、できました。サイズがたくさんあって手作業だと面倒ですが、いい感じに全部登録されたように見えます。これで準備は完了です。

次はダウンロード…ではなく、macOS アプリ用の部分はまだ定義していないので、その点に注意しながら次のセクションへ進みます。`LandmarkList` を `ContentView` に追加していきましょう。今回は各 OS ごとの違いは明示的に分けることにしたので、これは macOS 用の `ContentView` として定義し、共通部分は共通の場所へ移動して再利用します。そうしないと動かない箇所が出てくるので、ここは重要です。

続いて、ディテールビューを作ります。ディテールビューは、選択したランドマークの情報を表示するビューです。iOS アプリと同様に作りますが、異なるプラットフォームに対しては条件付きの調整を加えることで、ビューの再利用を実現できます。macOS は画面構成や操作感が異なるので、専用のビューを作るのが良いでしょう。具体的には、iOS のディテールビューをたたき台としてコピーし、それを修正して macOS の大きいディスプレイに合わせていきます。このために、新しいカスタムビューを Landmarks グループに追加し、名前は `LandmarkDetail` にします。3 プラットフォームに対応できるように、必要に応じて調整していく方針です。

では `LandmarkDetail` を作っていきます。iOS のディテールビューのコンテンツを流用しても良いので、必要なところを持ってきます。Xcode で新規に SwiftUI View を作成し、`LandmarkDetail`（macOS 用）という名前で追加します。プレビューを消すには、出力を少しだけ書く必要がありますね。プレビューを消せたら、`body` の中身をいったん空にして、iOS 版の実装から必要な部分を移してきます。プレビュー用のコードも合わせて持ってきます。

チュートリアル上は iOS の記述が前提のところもあるので、そのままでは噛み合わない箇所があります。そこは柔軟に読み替えて調整します。これで iOS 専用、watchOS 専用に加えて、macOS 専用の 3 種類という構成になります。

プレビューでは、`.environment(...)` の指定の下に `frame` を設定し、iOS 専用のナビゲーション関連（たとえば `.navigationBarTitle` など）は削除します。これでプレビューが動くはずですが、さっきは動くはずなのに表示されなかったので、必要ならリロードします。

レイアウトは `VStack(alignment: .leading)` にしてリーディング寄せにします。さらに `Divider()` を追加します。説明としてはここまでですね。`VStack` のアライメントを `.leading` にして、区切り線として `Divider()` を入れます。お気に入りボタン（`FavoriteButton`）や `@State` の扱いはこのディテール内で行います。ここまでが今回の調整箇所でした。 文字起こしテキストを貼り付けてください。以下の方針で読みやすく整えます。
- ですます調に統一し、句読点や文の切れ目を自然に整えます。
- 機械的な誤変換は正しい語に直します（例：「G言語」→「C言語」、「万全オキス」→「万全を期す」など）。
- コードはバックティックで装飾します。短いコードはインラインで表記します。
- 会話形式の記述は、発話者を区別せず、内容を踏まえた通常の文章にまとめます。
- 要約はせず、内容を削らずに整えます。
- 途中から始まる不完全な文は無視し、続く文から整えます。

長い場合は分割して送っていただいて大丈夫です。続きがあるときは「続き」と一言添えてください。 ここは`VStack`にして、`alignment: .leading`にします。コンテンツを置いたら、ここでプレビューできるようにします。

`VStack`にある`MapView`、つまり`MapView`以下のすべてを`VStack`で囲みます。エンクローズ（enclose）はその意味ですね。`MapView`に続くものをすべて`VStack`で囲んだうえで、`CircleImage`と残りのヘッダーは`HStack`でくくります。

具体的には、`MapView`の下を`VStack`でまとめ、その中でさらに`HStack(spacing: 24)`を使って`CircleImage`など一式をくくっていく流れです。ですので、この`MapView`の下を`VStack`でくくってあげて、その後に`HStack`でくくる、という感じで進めます。これで合っていると思います。

`VStack`、`HStack`の並びでいきます。結局`VStack`がベースですね。`VStack`に`MapView`、その下で`VStack`と`HStack`を組み合わせ、`spacing: 24`を指定します。`VStack`にもいろいろオプションがありましたね。ひとまずこの設定をコピーしておきます。

それから、全体をくくっているのは`padding`の前までです。つまり、境目は`HStack`の前になります。どこまでを含めるかというと、`HStack`の前までなので、これはいらなくて、これもいらなくて……ここですね。こんな感じにして、インデントを揃えます。あと、`Spacer()`を消すって言っていませんでしたか。 スペーサーを削除します。これでOKですね。それから、`VStack` にもオプションが設定されていました。ここまでできました。

次に、このコードはOKなので先へ進みます。プログラムとしては、まずサークルからオフセットを削除します。代わりに `offset` モディファイアを `VStack` につけ直します。つまり、`offset(y: -50)` をサークルから外して、`VStack` 側に移すということです。`padding` をどうするか少し迷いましたが、`VStack` につけ直す方向で、不要なものは消していきます。`VStack` のモディファイアとして `offset` を付与する形で進めます。良さそうですね。ここまではOKです。サークルからは削除しました。

次に、`resizable()` モディファイアを `Image` に追加します。`CircleImage` を小さく制限します。画像のリサイズはすでにライブでやっていた気がするので、`CircleImage` に対して `frame` を設定していきます。ユーザーがウィンドウを広げたときの可読性を良くするために、サイズを例えば `frame(width: 100, height: 100)` のように制限します。`offset(y: -50)` を扱っていたところですね。ここで調整します。ほかのコードの配置も忘れずに確認します。OK です。

次に、お気に入りボタンをプレーンボタンスタイルに変えます。`PlainButtonStyle` にすることで、iOS と同じような見た目になります。大きなディスプレイでも余白を取りすぎず、追加機能ボタンのスペースが適切になります。

ステップ10として、Open in Maps ボタンを `ZStack` に追加し、マップの右上のコーナーに配置します。そのために `MapKit` を導入し、`MKMapItem` を使ってマップアプリに目的地を渡します。具体的には、`LandmarkDetail` に `import MapKit` を追加し、`ZStack` にいろいろと要素を重ね、その上でボタンを書いていきます。

まず、`ZStack` を用意して、その中に `MapView` を入れる形を取ります。`ZStack(alignment: .topTrailing)` のようにアライメントを指定し、そのうえでボタンを追加し、`ZStack` を閉じます。見た目だけではイメージしにくいですが、問題ないでしょう。

`MapKit` は `import MapKit` を忘れずに。`landmark.coordinate` のあたりは先ほど変更したので、そこに合わせた修正も必要ですね。ひとまずこれで動きができました。ここまででOKです。では、セクション3へ移る形になります。 ここまでちゃんとビルドできるようにしておきますかね。えーと、このためにはまずは Xcode でビルドしてみます。おそらくエラーになると思うのですが、「スターイメージがないよ」というエラーは対応しやすそうなので、先に対処してしまいましょう。スターイメージが macOS 用に追加されていないので、まずはこれを macOS でも使えるようにします。ビルドは速いので、先にビルドしてしまいます。

それから、ラジーシーケンスがマグニチュードを持っていない、という感じのエラーが出ています。正しくは `LazySequence.Element` が `magnitude` を持っていない、ということですね。これは自分で定義した型の話でしたよね。マグニチュード系は `Magnitude`、`Double`、`Range` などがあります。ここに `magnitude` を追加してある、これですね。これも macOS で使いたいので、macOS を追加します。

はい、ではもう一度ビルドをかけます。次はサブスクリプト周りです。`Binding`……ランドマークからいきますか。まずプレビューはひとまず外して、ここですね。「ロケーションが必要な……」あ、これは違います。サブスクリプト、`subscript(dynamicMember:)`、`Binding<Landmark>`。`Binding` の仕様上、中身は隠蔽されていますね。この辺は全部そうか、なるほど。ではこの辺を直していきます。

`Landmark` は `Binding` で得られていて、`MKPlacemark` に座標を渡していきます。座標の型は `CLLocationCoordinate2D` ですよね。`CLLocationCoordinate2D` は `Landmark` の座標から変換できるように、確か作ってあったはずです。なので、ここでこの `coordinate`（これが `Landmark` の座標型です）を `CLLocationCoordinate2D` へ変換してあげます。

これで `MKMapItem`……この辺の変更はなんだろう。iOS 16 で非推奨になっていて、「`placemark` ではなく location と address を使え」と。うーん、location と address？ どういうことだろう。`MKMapItem` で location と……location を使うイニシャライザもありましたよね。これですね、location と address。`CLLocation` と address を渡す。`MKPlacemark` は、イニシャライザとして `CLLocationCoordinate2D` を取り、住所も一応取りますね。

`CLLocationCoordinate2D` は緯度と経度（`latitude` と `longitude`）を取ります。そうすると、`CLLocation` は `init(latitude:longitude:)` で作れますね。`CLLocationCoordinate2D` も緯度と経度を持っています。これは同じ中のロケーションの話。

その後の address というのは、今回は `Placemark`……`Placemark` 型は？ 座標だけか。うん、なるほど。いくつかの構造では address と location を別々に渡す形になっているようです。さっき見た address をどう渡すのか、もう一度確認しましょう。 MKアドレスは、ユニット、フルアドレス、ショートアドレスという構成でしょうか。あ、オプショナルになっていますね。では、ロケーションを作れば良さそうな気がします。`CLLocation` をランドマークの座標から変換できるイニシャライザを作ってみました。

`CLLocation` はどこに置くのがよいでしょうか。ロケーション系は Location の中、たとえば ModelData/LocationCoordinate あたりですね。`CLLocationCoordinate2D` です。これは extension で実装するのが良さそうです。`CLLocation` にイニシャライザを生やします。うまく出るかどうかはわかりませんが、ラベル省略の `init(_:)` にして、引数はロケーション、ランドマークの座標を渡すイメージです。

イニシャライザ内では緯度と経度を扱います。緯度は `CLLocationDegrees` ですね。`CLLocationDegrees` にするには、ランドマークの座標（latitude/longitude）が Double なので、少し計算が必要そうです。`CLLocationDegrees` のイニシャライザは、既定値のほかに `StringProtocol` を受け取るものや、値とフォーマット（モード？）を受け取るものがあるようですが、このあたりはまだ把握しきれていません。

ここで一度、根本的なところを最初に調べようと思います。`MKMapItem` の `placemark`、それから `MKPlacemark` あたりです。これらが非推奨（deprecated）になっているので、どう置き換えるのかを知らないといけません。`MKMapItem` と macOS で検索してみると、すでに誰かが調べてくれているかもしれません。一般的に、非推奨になった場合は書き換えの際にコンパイラの Fix-it で教えてくれることが多いのですが、今回はこう書いてあります。`MKMapItem` オブジェクトを `placemark` を使って生成する方法は非推奨で、その `placemark` 自体も非推奨でしたね。たしかに「`LocationAddress` を使う」と書かれていました。

つまり、`MKPlacemark` は非推奨で、代わりに MapKit の `LocationAddress` と `addressRepresentations` プロパティを使い、`MKMapItem` の関連 API を使え、ということです。さらに、`LocationAddress` の `addressRepresentation` で `MKAddressRepresentation` を扱い、MapKit が提供する機能で `MKMapItem` の `address` の文字列を得る、といった流れになっているようですが、まだ確信は持てていません。

やることとしては、ディスティネーションを `openInMaps` する、つまり地図を開くのが目的です。`MKMapItem` を使ってディスティネーションを作るために、ロケーションとアドレスを使えるようにしておきたい、という整理です。`MKPlacemark` が非推奨になっているので、一旦プレイスマーク周りの処理を切り出しておきます。これも非推奨なので、こちらは置き換え前提で、どこが本命なのかを確認しながら進めます。なるほど、こういうことですね。 ここでは `CLLocationCoordinate2D` を使うのが重要だと考えています。変数は `let item = ...` ではなく `let destination = ...` の形にしようと思いましたが、この `destination` は不要なので削除します。

次に、`CLLocation` と `MKPlacemark` をどう扱うかです。`MKPlacemark` の初期化時に使う `addressDictionary` は、おそらく `nil` で問題なさそうですが、確証はないので、とりあえず仮で `nil` を入れておきます。座標は `CLLocation` 経由で渡していけばよいのか、それとも住所情報は `MKPlacemark` 側（いわゆるプレイスマーク）が担うのか、このあたりはもう少し丁寧にドキュメントを確認する必要があります。本来はきちんと調べてからコードを書くべきですが、ここでは手探りで進めます。

現状、`CLLocationCoordinate2D` はすでに使えていますし、`MKPlacemark` も利用できます。ただし、`MKPlacemark` の `addressDictionary` を使う初期化など、旧来の一部 API は非推奨になっているので、代わりに `postalAddress` プロパティを使うようにというガイダンスだったはずです。そうなると、他のやり方では合わない箇所も出てきます。最終的には `CLLocation` をどう扱うかが残りますが、`CLLocation` の `coordinate` では `CLLocationCoordinate2D` が使えています。

緯度・経度については、`latitude` と `longitude` は `CLLocationDegrees`（実体は `Double`）です。`CLLocationCoordinate2D` 自体が `latitude` と `longitude` を持っていますし、初期化は `CLLocationCoordinate2D(latitude: ..., longitude: ...)` で行います。取得した値が `Double` であれば、そのまま渡せば問題ありません。 なので、`CLLocation` の `coordinate` だから、ここでイニシャライザーで `self.init` を呼んで、この中で `coordinate` を受け取ってあげて、その後は `distance` とか、いろいろ渡しているのがありますね。緯度・経度は `values` はあまり使わないですね。この他はいろいろ指定しないといけないのが厄介そうなので、そうすると地域で作っていくようになるのか……もっとかな。緯度・経度。この辺は `Double`、そうですね、`CLLocationDegrees` です。

これで楽になれば良いかなと思ったのですが、さっきは文字列っぽかったですよね。これ、`TextField`。で、デフォルト。`value` と `format`、それから `formatter`。`Double` はどうだろう。`NSNumber` と `NumberFormatter` でのフォーマットですね。`FloatingPoint` のリテラルではないです。あとはこの辺は `ParseStrategy` 的なところ。型は浮動小数点数ですが、`Double` で作っていますね。`value` と `format` とか、全部ストリング系でこれで終わってしまうので、なんか作りにくそうです。どういうことになるんでしょうね、これは。`init(exactly:)` の `BinaryInteger` ってのが、ちょっと難しそうだな。`NSNumber` とも絡みますしね。

こう考えると、やるべきことは、`let coordinate = CLLocationCoordinate2D(...)` として、これでロケーションの元になる座標を作ってあげた上で、イニシャライザーで `latitude` と `longitude` を渡す、という形ですね。`CLLocation` で `self.init(...)`。あれ、どこいっちゃいましたね。`latitude` と `longitude` があったような気がするんですけど。ここは波かっこが多いのか。こうしてあげて、それで `latitude` がありますね。この中で `CLLocationCoordinate2D` をここに渡してあげるのが、`location` の `latitude`。そうすると、ちゃんと渡せますよね。`latitude` と、あとは、こっち。

でも、なんか少し雑なコードになっていますね。本当にいいのかな、こんな長ったらしいコードで。これで `longitude` をリプレース……あ、間違えた。`Generate` を押した。`Apply` で十分。これは `Cancel`。

これでイニシャライザーを呼びはしましたが、まだ何か言われていますね。イニシャライザー失敗、あのイニシャライザーかな？ `CLLocation`。どっち？ こっちかな？ いいか。これはいいのか。これは成功するイニシャライザーで、こっち。こっちのイニシャライザーも成功するイニシャライザー。だったら良さそうって感じですけど。

`CLLocation` でここが言われているのは、指定イニシャライザーは extension で作れないからですか？ ってことですか？ 指定イニシャライザー。コンビニエンス……ああ、そういうことか、分かりました。`convenience init` を自分で作っておいて、書かないとダメですね。コンビニエンスイニシャライザー。そうですね、`CLLocation` のイニシャライザーを呼び出すんですか。なるほど。 とりあえず、これで変換ができるという状況になったはずです。そうすると、ここでコーディネートする `CLLocation` に、いきなり変換することが可能になっています。

少し解説を忘れていましたが、「変換可能イニシャライザ」は API Design Guidelines で規定されています。最初の引数ラベルを省略する形で引数を取り、その引数として渡された値と意味的に同等のものを別の型で表現するイニシャライザである、ということを示せるようになっているのです。ガイドラインに沿うと、こういったイニシャライザは「APIを変換するためのイニシャライザである」と標準的に受け取ってもらえる、というわけです。

変換先の型に対して変換元を引数に取るイニシャライザを作ることによって、`Int` から `Double` へ変換するような構文が可能になります。同じやり方ですね。ラベルを省略して `Int` 型の値を渡し、それと同等の浮動小数点数 `Double` 型のインスタンスを生成するイニシャライザと同じことを、ガイドラインに沿って `CLLocation` と `LandmarkCoordinates` の間でやっています。これによって、ランドマークの座標を `CLLocation` に型変換していることが、`Int` から `Double` への書き方と同じ感覚でイメージしやすくなっているのがわかると思います。なぜそれができているかというと、API Design Guidelines の Value-Preserving Type Conversions（値を保持する型変換）を意識してイニシャライザを作っているから、ということですね。

ここは私も少し自信がないのですが、変換のときにちょっと苦労しました。`Coordinates` の場合は `Location`（ここでは `CLLocation`）で良いですね。これは値を保持する変換です。その考え方でない場合は、ラベル付きで意図を説明しないといけません。いわゆるナローイング型変換（Narrowing Type Conversion）のルールに基づく必要があります。

これが `Coordinates`、こちらが `Location`。つい「Location」と言いそうですね。ここでアドレスを省略できるかというと、できませんね。`nil` を渡しておく感じにします。`nil` を渡してよいのかは少しわからないのですが、`MKPlacemark`。これが何に使われるかですね。郵便住所（postal address）と短い住所（short address）が絡む情報のテキストではないかなと思うのですが、今回は無くはないかもしれません。ランドマークがあるなら無くはないですね。これは後でよく考えます。まずはピンが落ちるかどうかを見てからですね。これでピンまでは OK ですが、`nil` を置いただけではまだ足りないですよね。

`showingProfile` パラメータがないよ、と言われています。これは `Environment` の都合ですね。なのでここで `ModelData` のモデルデータを用意して、これでプロフィール…`showingProfile` か。`showingProfile` はプロフィールを表示するかどうかのブール型のバインディングです。これは、このリファクタリングの中で複数画面からプロフィールの表示に対応させたためのものですね。なので、これはここですね。 まだ実際にプロフィール表示機能をmacOSで付けるかどうか分からないので、定数で`false`にしておきますね。まずはこれで。後でゆっくりやりましょう。

画面の構成に応じて、フラグをバインディングし、適切な処理を実装していく、と書いておきます。ビルドは通りましたね。良いんだろうけど、予想よりも早かったです。というのも、この辺はmacOSで共有するかどうか、その辺は全部やったんですよね。通知はwatchOSだけなのでこれも良くて、基礎作業は共有しました。それで`Categories`とか、この辺がiOS専用でしょう。このiOS専用はまだmacOSでは使っていません。コントロールはプロフィール周りに関係するものですね。これもmacOSではまだやっていません。名前付けが面倒ですね。あの丸いボタンでやったやつ。macOSだけでは合っていない、そういうやつです。

こういった細かいことは一旦置いて、これでプレビューが動くかな。どうでしょう。macOSの`ContentView`のプレビュー。これを表示して、プレビューが動けば開発がだいぶ楽なんですけど、さっきからちょっと動いていないんですよね。プレビューが表示できない。

拡大は、macOSのシステム設定でアクセシビリティのズーム機能ですね。キーボードショートカット、またはControlキーを押しながらのスクロールで拡大できるように設定できます。大した話ではないですが、こういうやつです。

起動できなかった。MacLandmarks、これを起動できなかったということで、このエラーを見ても大した情報は得られないのですが、「起動できなかった」「macOS」「XPCエラー」「Just-in-timeエラー」といった感じですよね。特定のディレクトリを作れなかった、パーミッションがなかった、みたいな重要な警告も出ています。`XPC`エラー、この辺を検索すれば良い情報が出てきますかね。とりあえず「launch error」「XPC error」で検索。出てきますね。まだ決定的な解決はないけれど、ワークアラウンドは見つけました。エディタのキャンバスの`Enable Legacy Preview Execution`というのがあるらしい。やってみますか。キャンバスのメニューですね。`Editor > Canvas > Enable Legacy Preview Execution`。これでプレビューが出てくるらしい……もう出てきました。コードがまだ追いついていなかった、みたいな感じですかね。拡大もできた。動いています。すごいな。ディテールが表示されて、これで「お気に入り」を押すと……動いている。もう完成。いや、完成ってことはないか。すごいですね。きれいに表示されていて、ほぼ完璧です。

次というか、おまけぐらいですかね。時間的に。そうしましょう。そうすると、この画面のプロフィール周りは今どうなっているんだろう。プロフィール周りはOSによって条件分岐したので、何も出ていない感じですかね。macOSだと多分メニューからやっていくのが自然だと思うので、この画面のプロフィールのボタンはわざわざ用意しなくていいんじゃないか、という気がしています。出ていないのは嬉しいんですが、ただ、ここで「お気に入りのみ」を渡すためのバインディングが不要になるのが少し気になっていて、実装を他のOSと共有しちゃっているんですよね。なので、`Your Favorites Only`のインターフェイスをどうするか、という話です。ここでも指定してしまえばいいのか。`#if !os(macOS)`、これ以外だったときにはバインディングを渡す、という風にすれば、イニシャライザが分岐して、ここで渡す必要がなくなります。これでいいですね。OK。できた。いい感じがします。

これでUI実装あたりはOKなのかな。あとはファイルの整理だけ考えていきたいのですが、パーツをどうしますかね。これはmacOSでは使っていないけれど、watchOSとiOSで使っているやつ。まだ他にもある可能性を考えると、今は気にしなくてもいいのかもしれませんが、忘れないうちにやっておいたほうがいいかもしれません。watchOSとiOS、この2つだけで使っていますよ、というファイル名にする、とか。ただ、ファイル名での管理はあまり良くないですかね。そう考えると煩わしいですね。フォルダを分けると、探す場所が面倒だなと思ったんですけど。 その辺は`Command-Shift-O`という便利なショートカットがあります。`Command-Shift-O`で例えば`HikeBadge`と入力すると見つかりますし、`LandmarkDetail`のほうがいいかもしれません。`LandmarkDetail`と入れても見つかります。パスが下にちゃんと表示されるので、macOS用かiOS用かといった違いも分かりますし、同名の候補が3つあるんだな、ということも把握できます。こちらのほうが合意が取りやすいかもしれません。とはいえ、ファイル名が長くて途中で切れてしまうと分かりにくいですね。

確かに、共通化するかプラットフォームごとに分けるかは悩ましいところです。共通にすると、例えば`StarImage`のようなファイルが将来OSごとに違ってきたときに、どれがどれか外からは分からないという欠点があります。なので並べてみたのですが、並べたら並べたで長い名前が続いて探しにくいという問題もあります。悩ましいですね。この辺りはフォルダ分けが良いのかもしれません。

それから、左にあるナビゲータを広げれば構成が見えるので、ひとまずはこれでも良さそうです。まずはこれでやってみましょう。`HikeBadge`は今のところiOSとwatchOSで使っています。`HikeDetail`も`HikeGraph`も同様です。この辺はそのままで良いでしょう。`MapView`は共通。`Platform`…これは`Profile`のことですね。この辺は今のところiOSとmacOSで使っています。ファイル名を一部間違えているので直しておきます。アニメーションは現時点では2つだけ使っていますが、そのうち全部使うことになると思います。`ShapeStyle`も同じ扱いです。

`ViewBuilder`はデバッグ用に作ったやつで、macOSにも入れておいて構いません。これを作っておくと、`SwiftUI`の`ViewBuilder`の中で`print`文が使える、という拡張ですね。デバッグしやすいように一応付けておきます。`LandmarksApp`は全部共通。レンダリング関係もすべて共通という状態です。はい。ではこんな感じで、とりあえず`LandmarkList`をmacOSへ移行できました。念のため動作確認しておきましょう。

`LandmarkList`は共通のものですね。これはmacOS用のプレビューと分けないとダメです。やることは、`#if os(macOS)`のとき用のプレビューと、それ以外のとき用のプレビューを用意することです。プレビューの中で条件分岐しても全然問題ないと思いますが、今回は外側でやってみます。プレビュー用のスタブがいらなくなって、引数も不要になったので、これでプレビューがちゃんと動く状況になりました。クロスプラットフォームはやはり難しく、こういうところが面倒ですね。

実行して、どこでアプリが動くか確認します。このメニューをここで出しておかないといけないのが少し気になりますが、実装を進めるうちに直すかもしれないので、ひとまず放置します。最終的に直す必要が出てきたらまた考えましょう。こんな感じで動きました。ここでmacOSが出てくるのが少し気になりますが、これはこれで良さそうです。

はい、これでOKです。次回はこのチュートリアルの続き、セクション3から進めていくことにしましょう。以上。今回はここまでにします。お疲れ様でした。
