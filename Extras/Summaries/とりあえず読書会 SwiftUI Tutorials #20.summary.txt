Transcription & Summarize : とりあえず読書会 SwiftUI Tutorials #20

では、紹介を始めていきます。SwiftUI と UIKit を連携させていろいろやっていく内容に入っていくので、これまでと雰囲気が少し違います。なかなか面白いところであり、意外と難しいところでもあります。プラットフォームというよりフレームワークの話で、まったく異なるライフサイクル同士を連携させるのは難しさがあります。そのあたりがどれくらい細かく触れられているかは分かりませんが、見ていきましょう。

リアルなところから、Chapter 4 です。「Interfacing with UIKit」のところから見ていきます。SwiftUI はシームレスに既存の UI フレームワークと連携でき、対象はすべての Apple プラットフォーム、つまり UIKit と AppKit ですね。その両者とシームレスに連携できるらしいです。たとえば、UIKit の `UIView` や `UIViewController` を SwiftUI の `View` の中で使えますし、逆方向の連携もありそうです。雰囲気だけで言っていますが、その逆もしかり、ということですね。

この Chapter 4 では、Featured Landmarks（ランドマークの注目項目）をどのように変換するか、ホーム画面からページングインターフェースへとラップしていくかを扱います。`UIPageViewController` と `UIPageControl` のインスタンスをラップする方法を見ていくようです。まずは `UIPageViewController` を表示し、SwiftUI の `View` をカルーセルのように表示するところから始めます。そのうえで、状態変数とバインディングを使い、`Coordinator` で UIKit（や場合によっては AppKit）側のユーザーインターフェース更新を橋渡ししていきます。UIKit と SwiftUI をどう連携させるかを扱う、という見え方ですね。

プロジェクトは事前にダウンロードしておき、必要になったら開けるようにしておきます。今、セキュリティとプライバシーの設定でダウンロードの許可ダイアログが出ましたが、Apple のサイトからであれば許可で問題ないでしょう。SwiftUI のチュートリアルは Apple のサイトですし、今許可しておきました。では、さっそく進めます。

ビューの再表現、つまり `UIPageViewController` を SwiftUI でラップして表現するところです。UIKit の型を SwiftUI で再表現するには、`UIViewRepresentable` または `UIViewControllerRepresentable` に準拠した型を作ります。対象が `UIView` なら前者、`UIViewController` なら後者ですね。カスタム型では、ラップする UIKit の型の生成と設定を行い、SwiftUI 側のライフサイクルに応じて必要な更新を行います。

まず、プロジェクトに PageView というグループを作成し、その中に `PageViewController.swift` を作ります。型は `UIViewControllerRepresentable` に準拠させます。チュートリアルではジェネリックになっているはずですが、まずは素直に作っていきます。

PageView グループと `PageViewController` を作ったら、ややリファクタリングが途中という感じもしますが、ひとまず進めます。`PageView` を使う想定なので、ビューに関係する場所に置くのが良さそうです。Xcode 上ではグループを切って、`PageView` の中に Swift ファイルとして `PageViewController.swift` を作成し、`import SwiftUI` と `import UIKit` を書いておきます。クラスではなく `struct` にします。`UIViewControllerRepresentable` はクラスである必要はありませんし、SwiftUI から扱いやすいので `struct` で問題ありません。

`PageViewController` は、ページとして表示するビューを配列で保持します。つまり `var pages: [Page]` のように、複数のページを扱う構成にする想定です。実際に何を使うかはこのあと決めるとして、方針としては、ページは SwiftUI の `View` で表現され、それを複数持つ作りです。使い方を見ながら整えていきましょう。

次に、`UIViewControllerRepresentable` が要求する2つのメソッドを実装します。まず `makeUIViewController(context:)` を実装し、`UIPageViewController` を生成・設定します。SwiftUI はこのメソッドを表示準備ができたタイミングで1回だけ呼び、その後はコントローラのライフサイクルを管理します。ここでは、`UIPageViewController(transitionStyle: .scroll, navigationOrientation: .horizontal)` のように、トランジションスタイルをスクロール、ナビゲーションの向きを水平に設定してインスタンスを返します。現時点ではインスタンスを返すだけで構いません。

続いて、もう1つの必須実装である `updateUIViewController(_:context:)` を実装します。ここで、表示するページのコントローラ群を `setViewControllers(_:direction:animated:completion:)` で渡します。SwiftUI の `View` を UIKit のコントローラに乗せるには、`UIHostingController(rootView:)` を使ってページ（`View`）ごとにホスティングコントローラを作ります。

その際、更新のたびに `UIHostingController` を都度生成すると非効率なので、本来は初期化時に一度だけ生成してキャッシュしておくのが効果的です。チュートリアルでも、より効率的な初期化にしていく流れになります。まずは簡単に更新のたびに生成して動作を確認し、あとで最適化する方針で進めるのがよさそうです。 なので、こんな感じでざっと実装しただけですが、`makeUIViewController` はまだ不完全で、これからこんなふうに実装していきますというお話ですね。ページビューコントローラーとコンテキストが渡ってくるので、ページビューコントローラーに `setViewControllers` を呼び出して、`UIHostingController` の `rootView` にページの 0 番目（`pages[0]`）を渡します。`direction` は `.forward`、`animated` は `true` にして、これを毎回の更新のたびに行っていく、という流れを想定しています。

いずれにしても、この普通のメソッドを実装することで、ライフサイクルの開始時に一度だけ呼ばれるものと、更新時に呼ばれるものの2種類を用意します。前者で UIKit の `UIPageViewController` を用意して渡し、後者で渡されてきたページビューコントローラーを更新する、といったことをやっていくことになるようです。

続ける前に、ページで使う FeatureCard を整えておく、つまり準備しておくようです。そのために、さきほどダウンロードした画像をリソースディレクトリの中からアセットカタログに入れます。ランドマークのフィーチャー用画像があるなら、通常の画像とは別にフィーチャー用の画像も入れておきます。やってみましょう。ダウンロードしたリソースを今持っていきますね。ダウンロードしたリソースを隣にフォルダごと持っていって……リソースフォルダを持っていって……あれ、ここに持っていったはずなのに見当たりません。どこ行った？ いなくなりましたね。どこ行った？ リソース、どこへ行ってしまったのでしょう。この横に置いたと思ったんですけど、完全に見失いました。もう一回開きますか。ダウンロードのリソースですよね。こうやって横に持ってきて、一旦これを自作して、ここで移していきますか。リソースフォルダ……置き場所がよくなかったかな。デスクトップでもいいか。では、リソースをアセットカタログに入れていきます。ここにリソースを入れていきます。できましたね。これでリソースは大丈夫です。

続いて、チュートリアルでは次のステップとして、コンピューテッドプロパティであるランドマークのフィーチャー画像を用意します。さきほどの画像を返すために、`Landmark` の中に、フィーチャー画像が存在する場合にそれを返す計算プロパティを追加します。もしそれがあるなら、その `featureImage` を返すプロパティ、ということですね。これを追加していきます。これが残っていた `Landmark` 構造体か。`image` は画像名で、フィーチャーだった場合にはその画像を返す、という形ですね。どこに置くかは少し迷います。変換イニシャライザーと捉えるなら `Image` に戻せますし、そうでないならここ（`Landmark` 内）でいいのですが、今は個人的な好みにより、`Landmark` 型にあまり余計なプロパティを持たせていないんですよね。 フェッチ済みイメージは、ここでも良さそうです。フェッチ済みイメージであれば、イメージが取得できてもおかしくないと思います。この通りでおそらくきれいに書けているので、基本はこれで問題ないと思いますが、今回は初期化（イニシャライザー）でやってみます。

イメージは独自のイメージ型を作っている都合で、そのイメージ型の中でランドマークのイメージを扱います。ランドマークのイメージからの変換イニシャライザーは、今のところ用意していますが、同じノリで、ランドマークイメージから `SwiftUI.Image` への変換も用意したいところです。今見ているのはランドマークイメージ側なので、この中に変換イニシャライザーがまだありません。作ってみます。

今回の場合は、いわゆる Narrow Type Conversion に当たります。API デザインガイドラインにより、ラベルを付けて説明するかどうかを決める必要がありますが、今回は「変換する」タイプなので、`init` にラベルを付けて説明する形にします。つまり、ランドマークイメージの初期化で「フェッチ済みイメージから初期化する」という意味が伝わるように、例えば `init(fromFeatureImage:)` のような名前、もしくは `init(fromFetchedImage:)` のようなラベルにします。ランドマークイメージをフェッチ済みイメージから初期化する、という意図ですね。これでランドマークがそれを受け取れるような変換イニシャライザーを用意します。

さらに、`isFetched` であれば初期化する、という条件が必要です。フェッチ状況によっては生成できないかもしれないので、失敗可能イニシャライザー（`init?`）にします。上のほうでは `guard` 文を使い、`landmark.isFetched` でなければ `return nil`、といった形にします。フェッチ済みなら画像を生成できるので、その場合のみ処理を続けます。一旦はこんな感じです。

ここまでできたら、あとは戻り値……というより `self` の代入ですね。`self = ...` とするか、あるいは別のイニシャライザーを呼ぶ形（`self.init(...)`）でもどちらでも大丈夫です。名前（`name`）としてはイメージ名（`imageName`）を使う想定です。ランドマークのイメージ名をどうしていたかは、以前いろいろ改良しているので、そのときの方針に合わせます。一般的には文字列補間（`String Interpolation`）で組み立てるのが多いと思いますし、そのやり方でも特に問題はありません。 こうすることによって、ランドマークからフィーチャーイメージへ変換します。とはいえ、これは単なるタイプコンバージョンではありません。どちらかというとファクトリーメソッドに近いイニシャライザーです。ちょうど `Decodable` の `init(from:)` がデコーダーから初期化するのに近い感じで、いわゆる型変換ではないですね。とにかく、`FeatureImage(of:)` でランドマークからイメージを生成するイニシャライザー、という位置づけです。

次に、手順として新しい SwiftUI ファイルを `FeatureCard` という名前で作ります。これはランドマークのフィーチャーイメージを表示するビューのようです。ここで、`aspectRatio` モディファイアを含めることで、`FeatureCard` が最終的にプレビューで表示されるビューのアスペクト比を模倣（mimic）します。つまり、最終的にこういうアスペクト比で見える、という形を事前に合わせておくわけですね。これはサンプルをコピーして使えばよいでしょう。

`FeatureCard` をどこに置くかですが、`PageView` というよりはコントロール寄りに見えるものの、このチュートリアル的には `PageView` に置いておきます。定義をコピーして貼り付けてみると、少し使い心地が悪いところがあります。ここがオプショナルなのでこうして…と調整していくのですが、失敗可能にしていたせいで使い勝手が良くなかったですね。

`Image` が `LandmarkImage` になっていて、そこから普通の `Image` にキャストしないといけません。なので、普通の `Image` を `FeatureImage.of(landmark:)` で変換するような仕組みを作るのはどうでしょう。やりすぎ感はあるのですが、`Image` が取れたときには、そこで `Image` に対して `.resizable()` を適用します。こちらのほうがしっくり来ます。

一般的には、`UIImage` を取り出して、UIKit で表示する形もあります。試しに、UIKit の `UIImageView` に対しても、`FeatureImage.of(landmark:)` のような同じインターフェースを用意して、失敗可能にしておきます。例えば、`else { return nil }` として、取得できた場合には `self.uiImageView.image = ...` のように代入します。こうしておくと、通常の `UIImage` もダイレクトに作れるようになります。つまり、`LandmarkImage` を経由せず、最初から `Image` 型に変換して、それが取れたら `.resizable()` を適用する、という流れです。

どちらが良いかというと、`FeatureImage.of(landmark:)` で失敗するかもしれないので、`nil` だったら何も表示しない、という形にするか、あるいは `if let` で取り出して処理するかの選択になります。個人的には後者のほうが好みです。単にオプショナルチェイニングを使わないで明示的に分岐しているだけですが、こちらにしてみようと思います。もっとも、このあたりは完全に好みの問題で、普通はここまで悩まないところだと思います。 とりあえずこうやってやって、それで、`FeaturedCard` のランドマーク、`ModelData` の `features` がないとですね……。`features` なんだっけ。えーと、`ModelData`、`ModelData` の中にランドマークズ、Identifiable ですよね。`features` は、もしかして作ったのに忘れているのかな？ えーと、`features` は、うーんと、`ModelData` でも問題じゃないですよね。あれ、えーと、なんだろう。レビュー……あれ、これは、この、分からない。どうなんだ？ まあいいか、とりあえず先に進んでみましょう。

`features` なんだったかな？ この `ModelData` に `features` が…ね。まあ、分からないからしょうがないや。先にいきましょう、まずは。

ステップ7として、オーバーレイで、ランドマークに関するテキスト情報を画像の上に重ねます。はい、テキストオーバーレイ。`TextOverlay` というビューを作って、それを使っていく、という感じみたいですね。うん、でもプレビューが出ているから、やっぱり `features` はあるんですよね、きっとね。`features` があるとなると、どこで定義していたっけ？ えーと、`features`、`features`……どこだ？ `features` は、どのあたりまで遡ると出てくるんだろう。戻っていくにしてもね。`features`……まあいいか、戻るしかないか。

「Working with UI Controls」、この辺に出てくるかな？ `features`……ここではないかな？ え、じゃあ、この前、えーと、こっちかな？ あ、間違えた。`features`、あ、あった。`features` 配列。えーと、New Computed Property を `ModelData` に追加していますね。えーと、どこだ？ ここか。`features`。`ModelData` の中に `features` として、`landmarks` を `filter` で `isFeatured` してますね。`isFeatured` でフィルターしているのを見ると、フィルターでやっているのは、これは画像名のやつですね。これがフラグですね。これはただのキーですね。これがランドマークの `isFeatured` でフィルターをかけている。`filter` と `landmarks` だ、これだ。`ModelData` の中にありましたね、これか。

そうすると、忘れちゃダメですよね。まあ、ような日もありますが。`features`、`featured` ランドマークスと、これでいいですね。そうするとプレビューが見られるようになるので、ピン留めは外して、これでいいかな？ それで、さっきコピペしたのはもう消しちゃった。これで何か表示ができた、と。こんな状況なので、続いて、さっきのね。ここに戻ってきて、コピペをする。

コピペはどこだ？ このモデル内ですね、ここだ。`TextOverlay`。これをコピペするけど、`TextOverlay` ってどこで使うんだろう？ どこで使うかというと、この `FeaturedCard` だけですかね、使うのは。だとすると、その中に所属させたいんですよ、個人的には。 なので、extensionとしての所属先は、ちゃんと考えるのが大事です。所属先に主体がある場合には、その主体に沿いなさいというのが API デザインガイドラインの指針になっています。これを守ると、「このプロパティはきっとここにあるよね」と想像しやすくなるので、所属場所を大事にしないといけない気がするんですよね。

FeaturedCard の中だけで使う想定にすると、private プロパティですかね。あそこまでフォーカス系はあるのかな？ わからないけど。とにかく `TextOverlay` 型で、これは…private プロパティかな。どっちがいいかは、まだわかっていないんですけど。

グラデーションの定義は、「このグラデーション定義ですよ」というのを計算型プロパティの `static` で持たせる、という通例でいいでしょう。ポイントとしては、こんな感じでグラデーションを…ZStack、グラデーション…グラデーションがわかるのか。`ZStack` の中で、ランドマークの `name` とランドマークの `park` を表示する、そんな情報になっていて、これをオーバーレイで表示するということですよね。なので、ここでしたっけ、`Image` に `overlay` すればいいのかな。`overlay` のランドマークとしてランドマーク…ここで通りですね。いい感じですね。ここまでやって、もうちょっと変えたい気がしないでもないけど、ひとまずここまでできました。

次に、CustomView。`UIViewControllerRepresentable` の View を表示するためのカスタムビューを作ります。そこで表示するための representable を…`UIViewControllerRepresentable` を実装するのかな。CustomView…こっちですね。そうですよね、表示するための CustomView を作ります。いいのかな。コードと違うような気がなんとなくするんだけど。

New SwiftUI File を作って、名前を `PageView` とします。それで、`PageView` は `PageViewController` でページを表示すると。この representable はまた未実装で失敗する、とにかくここまでやってみますか。`PageView` を作るよと。`PageView` を作るのは、`PageView` のファイルだけですからね。ここで `PageView` を作って、コピーした感じで完成させちゃって。

それで、`PageView` は「ページ」を型パラメータで指定して、`pages` を持っていて、これは今のところ `let` でいけますね。それで、`pages` を渡すことで表示する、と。`PageView` にはまだ `pages` を渡していないから、ビルド失敗している状態ですよ。そういった感じですね。

次のステップとして、アスペクト比を追加して、プレビューを用意すれば、ページの配列を渡してあげるように書き換えて、プレビューを動くようにしましょう。だから、`aspectRatio` を加えて、かつ、FeaturedImage…いや、ランドマークの FeatureCard か。`FeatureCard` を渡してあげると。なるほど、`FeatureCard` がページなのね。そうすると、また `aspectRatio`、アスペクト比を設定してあげて、それで `PageView` に対して、最初に `pages =` にしようかな。

それで、モデルデータの featuredLandmarks の `map` の…何だっけ。ページだけど、`PageView` じゃなかったな。何でしたっけ。 FeatureCardか。FeatureCard。カードでランドマークですね。これじゃダメだった。`FeatureCard`と`Landmark`。`featuredLandmarks`は普通にフィルターして`Landmark`を返します。

次のステップは、ビューコントローラーのデータソースを作ることです。`UIPageViewController`をコンテンツ表示に使います。データソースはコーディネーターが担い、ビューがあるという構造らしいです。

まずは、UIKitのビューコントローラーを再表現できるSwiftUIの`UIViewControllerRepresentable`や`UIViewRepresentable`では、`Coordinator`型を定義でき、これをSwiftUIが管理・提供します。ビューコンテキストの再表現のためのものらしいです。そしてステップ1として、コーディネーターを内包して定義します。`PageViewController`の中に入れ込んで定義する、ということですね。この名前の受け渡し環境は良さそうです。`PageViewController`の`Coordinator`を作っていくということです。

SwiftUIは、`UIViewControllerRepresentable`タイプの`Coordinator`をマネージし、上で定義したメソッドを呼び出すときにコンテキストの一部として提供します。とにかく`Coordinator`を作っていきましょうということなので、早速、定義を（ほぼ）丸写しでいきます。`PageViewController.Coordinator`ですね。この中に入れてもいいのですが、個人的に拡張したいのと、このViewでしか使わないので、`private extension`で良さそうです。

それで、`PageViewController`を拡張して、この中に公式のパターンをそのまま適用します。`Coordinator`は`NSObject`を継承していますね。これは求められているのかな？`Coordinator`は、`PageViewController`の`UIViewControllerRepresentable`タイプが求めているわけですよね。`Coordinator`ってデフォルトで`Void`か、`NSObject`を継承する必要があるのかな？あるのかもしれないですね。どちらにせよ、これを継承する予定は多分ないので、`final class`にしておきます。`parent`は`let`で良さそうです。イニシャライザーは`parent`を受け取る感じで良さそうですね。

そしたら、これを拡張してあげる感じですか。あとは謎メソッド、別のメソッド。`Coordinator`を作るための`makeCoordinator()`、これを実装します。続いて、フレームワークは`makeCoordinator()`メソッドを`makeUIViewController(context:)`の前に呼び出してくれます。コンフィグレーション時に`context`から`Coordinator`オブジェクトにアクセスすることができる、という流れらしいので、`makeCoordinator()`をとりあえず作っていきます。これはこの辺ですね。`makeCoordinator()`で、`Coordinator`を返すように定義します。あ、なるほど。プロトコルの要件に入っているから`private`じゃダメなんだ。これで`Coordinator`の準備ができましたね。

Tipsとして、よく使われる`Coordinator`の共通パターンがあります。例えば、Delegate、DataSource、ユーザーイベントへの応答、Target-Actionなど、いろいろな場面で`Coordinator`を使っていけます。`NSObject`を継承したからこそ、UIKitの各種デリゲートにもそのまま適合しやすい、という狙いもありそうです。そういうことにしておきます。

次に、コーディネーター内でコントローラーの配列を初期化します。ページ（ビュー）の配列を使って`Coordinator`を構成します。`Coordinator`内で`controllers`を初期化するのかな。いや、コントローラー内じゃないか……`Coordinator`内で配列を初期化する、ですね。この辺か。`controllers`を用意して、各ページのビューを持った`UIHostingController`を作る、ということになるらしいです。 では、コーディネーターを実装していきます。ここではルートコントローラーとして `UIHostingController` を用意する、という理解で合っていますかね。`UIViewController` を配列として持って、親となる `UIPageViewController` に渡す形にします。あれ、ここが閉じているかな……。`UIViewController` になっているのか。`UIHostingController` に入れていくのか。なるほど、`UIHostingController` の `init` で `rootView` に入れていく、という感じですね。

ここでいろいろと出てきましたね。まずは、久しぶりに Swift のコンパイルエラーが出てきました。とりあえず対処すべきは MainActor 関連のエラーだけでしょうか。ルートのページ（ビュー）は MainActor 上、つまり UI スレッド上で扱うべきです。これはペアレントが `UIPageViewController` で、`UIPageViewController` は `UIViewController` として表示されるから、ということですね。なので、このストラクチャは MainActor、ページビューも MainActor、という整理になります。ただ、コーディネーターが MainActor になっていないので、どう考えても MainActor から使うことが大前提でしょう。これで解決ですね。OK な気がします。

ここで、実際のコードについてもう少し。コントローラーを空の配列で初期化しているじゃないですか。イニシャライザーでコントローラーを初期化していますよね。あれは要らないですよね。自分の書いたコードでは発生していますけど、なぜだろう。やはり要らないですね。

それから、`UIPageViewController` に渡す配列を `UIViewController` の配列にしているのですが、ここは `UIHostingController` の配列でいいのではないでしょうか。わざわざこの段階で親クラスに上げる必要はない気がします。……と思ったのですが、`UIHostingController` はジェネリックタイプなのでダメですね。`UIHostingController(rootView: pageView)` の形で、`pageView` を `rootView` に入れていくこと自体は問題ありませんが、型引数がからむので、配列としては `UIViewController` にしておくのが安全です。`UIHostingController<Page>` のように同一のジェネリック引数でそろうなら配列でも扱えますが、今後ポリモーフィズムを考えるなら上位の `UIViewController` に寄せておくのが無難です。とはいえ、現状このコーディネーターがそこまでしようとしているようには見えないので、どちらでもよいかもしれません。明示的な方が分かりやすく、直感的ではありますが、ここはこのままでいいかなと思います。これで大丈夫な気がしますね。では、この方針でいきましょう。

次にステップ4、`UIPageViewControllerDataSource` を用意してコーディネーターに持たせます。ああ、このために `NSObject` にしたのですね。`UIPageViewControllerDelegate` と合わせて、プロトコルの要求を実装していきます。この2つのメソッド群でビューコントローラーとの連携を確立し、前後にスワイプしてページを移動できるようにします。詰まるところ、さっさと実装してしまいましょう。自分で一から書くと進むのですが、サンプルを追いかけながらだと意外と手が止まりますね。実装スタイルは好みの問題ですが、今回は拡張でまとめます。

つまり、`extension PageViewController.Coordinator: UIPageViewControllerDelegate, UIPageViewControllerDataSource` という形で実装していく、ということでした。 データソースだったかな。デリゲートかな、データソースか…あ、データソースでした。なので、その実装を書いていくことにします。デリゲートも必要だと言っていますよね。デリゲートメソッドはここにもあるかな……メソッドの型が合わないですね。じゃあどうしようかな。コーディネーター…まあ、デリゲートを付けていきますか。デリゲートはここでも設定できますね。これで、`UIPageViewController` とデリゲート（とデータソース）が必要です、ってことですが、ここで `UIViewController` と `UIPageViewController` を確認しておきます。うん、あーでも大丈夫そうですね。安全にいけそうです。やっぱり拡張ではダメ、ということを言っているので、では埋めていきます。

プラットフォームの状況…`UIPageViewController` でいいですかね。`pageViewController` が `UIPageViewController` で、ここに `UIViewController` が来るから、引数の `pageViewController` は `UIPageViewController`、`viewController` は `UIViewController` にしていたのかな。違うか。こっちは `pageViewController(_:viewControllerBefore:)` ですね。これが `UIPageViewController` に行って、ここもポリモーフィズムで解決できるやつだと思っていたのですが、まあこれはこれで大丈夫ですね。

こうしてあげることによって、`index` が `controllers.firstIndex(of: viewController)` で求まらなければ `nil` を返す、という形になります。これは `viewController` が `UIViewController` で、`controllers` がコントローラーの配列で、ここもジェネリックで大丈夫かな。大丈夫ですね。はい。後半で改行されたんだと思ったけど、ここら辺が改行荒れているから中途半端に見えますね。長すぎると改行した方がいいと一般的には言われますからね。

で、`firstIndex` がなかった場合には `return nil` にします。`index` が 0 だった時にはコントローラーのラストを返す。インデックスが 0 の時にラストを返す。それ以外は `index - 1` を返すだけ。`firstIndex` が見つかった場合で、`firstIndex` が 0 に見つかった時にラストを返す。そうでなければ、見つかったインデックスの1個前を返す。ああ、そっかそっか。はいはい。戻したいのね、とりあえずね。1個前にね。うん、`index - 1`。これ、インデックスが 0 だったらラストを返すのか。ラストを返す。まあ、ラスト…気持ちは分かります。インデックスが 0 の時にラストを返すって、すなわちそれはインデックス 0 のものを返す、ということではないですよね。ラストでいいのかな、インデックスが 0 だった時。まあラストでもいいんですけど、ラストでもいいんですけど、0番目を返すのとどっちがいいですかね。どう感じますかね、これ。インデックスが 0 しかないのと、0 を返すのがないかな。違うかな。

あと、ここは `switch` がいいの、個人的には。`switch`。これは個人の観点の読みですね。`case 0` だった場合には、`return controllers[0]`。スイッチ式にしたいかな、これくらいだとね。`return controllers[0]` ね。で、それ以外だったら `default`。そして、`return` は要らないけど、コントローラーの `index - 1`、つまり1個前ですよっていうことですね。うん、こんな感じ。これで良さそうですね。

で、次。こっちもネクストの方ね。どこだっけ。ネクストの、この `pageViewController`、`pageViewController` の `viewController`。これは何だ。`pageViewController(_:viewControllerBefore:)` と `after` でしたね。で、次に行くタイプですね。これも同様に、ここは絶対にジェネリック……というかサブタイプがもう明確に分かっているので、既定クラスではなくサブタイプに変えてあげれば扱いやすいですよね。で、それでインデックスを探して、見つからなかったら `nil`。そうじゃなかったら、`index - 1` がコントローラーの `count` か、とか。あの、`count` は数で、インデックスはインデックスなんですよ。 インデックスとカウントを比較するのは、本来は型が違います。たまたまInt型で一致してしまっているだけなので、ここはちゃんとインデックスで把握したほうがいいと思います。

そうすると、どうなるかというと、`switch`に書き換えたいですね。`index + 1`に対して、`case controllers.endIndex:`。要は、最終インデックスに到達した場合には…ここで`first`を返すのかと思ったのですが、カルーセルなので、0のときには…あ、`last`ですね。完全に自分のミスです。前に進んで0になったら、次は`last`を返します。後ろに戻る必要があるので、絶対に`last`です。

同様に、`endIndex`までに到達したのであれば…違っているのかな？ そうですね、合っていますね。だとしたら、ここは`return first`です。最後まで行ったので、コントローラーの`first`を返しましょう。

それ以外だったら、コントローラーの`index + 1`ですね。`index + 1`をもう一度書いているのが少し気になりますが、2回も書かなくていいのであれば、`firstIndex(of:)`でここで1を足して、`case let nextIndex`にしておけば良いでしょう。これで`nextIndex`が取れます。こうしてあげれば、ちゃんと取れますよね。

上も同様…いや、そうでもないか。`index`が0だったら`last`、そうでなければ1個前です。次は、`index + 1`と`endIndex`を比較したいので、`index`を1つ動かしました。`last`と比較するという手も、ないとは言えませんが、コントローラーが0だったらどうなるのかが少し気になってきました。ページが0のときにコントローラーが0になって、コントローラーが0になったときに`lastIndex`が見つからなければ`nil`ですね。うん、そうですね。だから、この時点で、この下は絶対に0ではないのだと分かります。 そうそう、ラストインデックスの話でしたね。インデックスに対して…あ、でも `endIndex` を使うほうが早いですね。`endIndex` でいいかな。インデックスに 1 を足して、`endIndex` と比較するか。うん、どうしますかね。1 を足しますか。1 を足したものがネクストインデックスですもんね。

こんなにややこしいことをするより、ここでネクストインデックスを一度 `index + 1` で計算してしまったほうがよさそうです。そして、そのネクストインデックスを比較して、もし `end` に到達してしまったら最初に戻してあげる。そうですね。ネクストインデックスに対応するコントローラーを取得してあげる、という感じです。そうすると、ここはデフォルトでも良さそうですね。こんな感じでいきましょう。

こうすると、`viewControllerAfter` と `viewControllerBefore` のコードが、見た目の雰囲気としてもそろってきます。これでいいか。そうしておきましょう。

はい、ここまでできたらスワイプができる、という話だった気がします。とりあえず、どうかな…まだかな。

それから、コーディネーターを `UIPageViewController` のデータソースとして追加します。もう一歩いっておきますかね。いったんビューコントローラーに戻って、動くことを確認しましょう。だから、ここまでですね。

つまり、ページビューコントローラーの `makeUIViewController`（`UIViewController` はここ一回だけ呼ばれるやつですね）の中で、作成した `UIPageViewController` の `dataSource` にコンテキストのコーディネーター（`context.coordinator`）を設定する、という話だったような気がします。違いましたっけ。はい、`dataSource` に `context.coordinator` ですね。

で、コーディネーター側にはデータソースを適用させてますよね、という話でしたよね。だから、これは何だ？設定できない。コーディネーター（ページコーディネーター）を `UIPageViewControllerDataSource` として設定できない。 まずは強制的に開けているけど、それは違うので、`UIPageViewController` のコーディネーターになっている。これ、間違っていますね。データソースですね、データソース。あれ、これで準拠していない。あー、やっぱりダメだったか。

えーっと、画面っぽい可能性があるのは、まずここですね。ポリモーフィズムというか、直指定したけど、`UIViewController` かな？ えーっと、ちょっと行ってみますか。それで、アフターとビフォアを見たときに、`UIViewController` を返す。で、もらうのも `UIViewController` なんですけど、とりあえずこうして、こっちも `UIViewController` を返すようにしてみましょう。`UIViewController`、コントローラーね。はい、こうしてあげると、これで、あー、ダメだった。そっか、こっちも型を揃えないとダメか。`UIViewController` の引数の方ね。ホスティングじゃなくて、`UIViewController` ね。`UIViewController`……あれ、置き換えできたのかな？ そうですね。で、これでもう1個。こっちも `UIViewController`。で、やると、準拠はできた、ということか。

もう1回、もう1個ちょっとやりたいんですけど、`UIHostingController` を元にして返す。あれは？ あれも準拠できたのか。で、こうして、なるほど、ここでビューコントローラーのインデックスを取るよっていうときに、ここの `controllers` が親クラスになっていることが求められていくのか。キャストでもね、いいとは思うんですけど、まあ、そこでどちらかで処理するくらいだったら、ポリモーフィズムで書いちゃった方が安全ですよね。なので、これで——あれ、こっちは大丈夫なのか。こうやって書き換え忘れているだけか。なるほど、これでできましたね。

そしたら `ContentView` まで戻るって言ったっけ？ `ContentView`。ここまで戻って、プレビューを確認しようと。で、FeaturedImage が……スクロールできないような？ ここじゃないのかな。えーっと、ここじゃないのか。えーっと、ここは違いますよね。ここがちゃんと作ったやつで、FeaturedImage が動かない気がする。プレビューどうなっているって……ここか。あ、これか。だから、ページビューに戻るか。間違えた。`ContentView` の中に戻らなくていいから、`PageView`。ここに戻って、これのプレビューを見ようという話か。で、ここがスクロールするからですね。

あれ、1個だけどうか。あれ、1個だけって、1個ですよね。あれは、そんなことなかったな。えーっと、今は何個かあるっぽいんですが、これがうまくいっていないのかな。プレビューはここに書いてないか。プレビューっぽいところはここですね。Featured Landmarks で見れますよね。だから、いいはずですが、いないですね。いないのか。

ここで、`PageView` のイニシャライザー。`PageView` のイニシャライザーで、あ、そっか、ページのボディで、プレビューで——ここでいいか、`print` で何か絵を出して、その上で `pages` ね。`pages.count` でいいかな。この、なんだ、この “MARK:” はメモかな。うん。で、これで3個ありますね。うん。3個あるのにスクロールしないのか。だから、バグっている——いや、大げさだな。自分のコードが間違っているということですかね。 ページビューをいったん止めておいて、ページビューコントローラーには `pages` が3つ渡っているはずです。3つ渡っているのに表示されない、という状況になっているはずなので、ここをちゃんと見てみます。

`makeUIViewController` でデータソース、`pages` があって、コーディネーターを作るときには `self` を渡していますね。だから `pages` は渡っています。念のため、`print` で `pages.count` を出してみます。これでコンソールに表示されるかな……出なかった。コーディネーターを `return` しないといけなかったんですね。こうすると「3個」って出るはずですが、あれ、変わらないどころか……`makeCoordinator` が呼ばれていないのかな。`makeCoordinator` と `makeUIViewController` の両方に `print` を入れてみます。UI 側が進んでいないだけかな。UI 側どうするんだ、これ。ソースコードを書き換えたら動くと思うんですが……あ、出てた、出てた。普通に「3個」ちゃんと出ていますね。ということは、`pages` が3個あるのは分かったので、問題は自分の実装側にあります。

1個目は表示されている、という前提で考えると、データソースは `self` ではなく `coordinator` を使う形で設定していますよね。それで、ページビューコントローラーの `setViewControllers` で、`pages[0]` を渡せばよさそうな気がします。これは本来、`updateUIViewController` のときに現在ページをセットすべき、ということですね。`UIPageViewController` に対して、最初の表示用に `setViewControllers` で1個渡す必要があるはずです。

コードをもう少し見直します。最初にフィーチャーイメージを用意して、その後にグラデーションオーバーレイの表示を用意して、アスペクト比を設定します。次にモデルデータを初期化して、ここでデータソースを設定し、コーディネーターを追加する。ここまでは合っていそうです。

分かりました。`update` で `context.coordinator.controllers[0]` をセットするのを抜かしていましたね。本来は `setViewControllers` に最初の1枚を渡す必要があります。ここは `pages` ではなく、`context.coordinator.controllers` を使うべきです。括弧の扱いはこれでよくて、要は「インデックスで1つ取り出して、それを1要素の配列に包んで渡す」という形にします。

`makeCoordinator` でコーディネーターを作っていて、イニシャライザーでは数は特に気にしていません。`next` などで次を求めるとき、インデックスが0になることはあり得ます。なので、このコードでは「まだ何も `UIPageViewController` にセットされていない」ケースが考慮されていませんでした。`makeUIViewController` でオプショナルの最初のコントローラー（`first` や `firstIndex` を使う）を取り、`updateUIViewController` で `setViewControllers` に渡すときは、nil の可能性を考慮しつつ、1要素の配列にして渡すのが良さそうです。

つまり、`updateUIViewController` で `UIPageViewController` がまだ何も持っていない可能性を考慮し、`let controller = context.coordinator.controllers.first` のように最初のコントローラーを取り出し、それを `[controller]` のように配列に包んで `setViewControllers` に渡します。`setViewControllers` の第一引数はオプショナルな配列（`[UIViewController]?`）なので、その点も踏まえておきます。

最終的には、「インデックスで要素を取る」「それを配列にする」という二重の括弧のイメージで問題ありません。インデックスと配列の役割を整理すれば動くはずです。 ここを`controllers`にすると、OKですね。上げたときにプレビューも動きました。いいですね。自分の行動を見せる感じで、これでカルーセルっぽく次へどんどん行けます。よくできています。これで一通りできたということですね。

この段階でやることは一通り終わりました。次に、ページまわりをそういうAPIのセットでいろいろ見ていく、という話になりそうですが、追いかけるのはまた次回にしましょう。コードをいじるところがあるかどうかだけ、さっそく今日は見ておきます。

対象としては、`PageView`と`PageViewController`くらいです。`PageView`の中では、`PageView`がジェネリックになっていて、ページが用意されています。そして`PageViewController`側で`pages`を扱います。つまり、`PageView`というホストを使って、その中で`PageViewController`を用意する、という構成になっています。ここで`pages`を渡してあげているわけですね。

`PageViewController`は`UIViewControllerRepresentable`になっていて、これ自体がUIとして機能します。そういえば、`UIViewController`とか、`import UIKit`をしなくても使えるのですね。面白いです。まあ、これはこれでよしとしましょう。

`PageViewController`はページ型でジェネリックになっていて、`pages`を持っています。`Coordinator`、`makeCoordinator`に対して自分自身を渡していますが、自分自身の何を使っているかというと、`parent`の中では余計なものを渡さなくていいなら、`self`を渡さずに`pages`だけ渡せば済むのではないかと思いました。ただ、コンテキストからアクセスするときに、`context.coordinator`が`controllers`を持っていて、`Coordinator`型は`controllers`と`parent`を持っています。`parent`をどこで使っているかというと、イニシャライザだけですね。もしイニシャライザでしか`parent`を使っていないのであれば、保持しておく必要はない、という話になります。実際、ここでは`pages`しか使っていません。ですから、`pages`だけ渡せば済むのでは、という考えもあります。ただ、`Coordinator`に`parent`を渡しても大きな問題にはならなそうですし、このままでよしとします。

`Coordinator`をイニシャライズしていますが、これは`fileprivate`でよいですね。外からイニシャライズすることはないと思います。`Coordinator`自体は、プロトコル（`UIViewControllerRepresentable`）が要求しているので型は見せる必要がありますが、インスタンス化はさせる必要がないので`fileprivate`で良いでしょう。`Coordinator`を含めて、この辺一式を`fileprivate`にしてしまう手もあります。ここまでやる必要があるかは微妙ですが、メソッドはプロトコル準拠のために公開せざるを得ません。

こんな感じで、良いですね。これで`PageViewController`と`makeCoordinator`がまとまってきたので、少し省略できるところは省略しようかなと思います。

`makeUIViewController`では、コントローラを作って、データソースを設定して、表示しています。OKです。`updateUIViewController`は`Coordinator`の対象になっていて、それを`PageView`のコントローラとして渡しています。ページ送りなどの処理は`Coordinator`側でやるので、ここはこれで大丈夫です。

重要なのは、`PageViewController`はSwiftUIの考え方に従って構造体になっている都合上、これ自身がDelegateのレシーバーにはなれないという点です。そのため、Delegate処理は`Coordinator`で受ける必要があります。 この辺は特に何もしないで、Coordinatorを追加で用意して、Coordinatorがデータソースをうまく担っていく、という方針で進めます。Coordinatorには特に要件はなかった気がしますが、念のため調べておきます。実装としては何もしていない、いわゆるボイラープレートの状態ですね。何もしていないとはいえ、Delegateや、アップデートのたびにCoordinatorを使い回すことを考えると、普通はクラスで作りますよね。その辺だけ注意すれば、問題なく動いていくという感じです。

コントローラーもこれでよかったですし、`map`の感じも、見た目の問題なだけで、メソッドチェーンを単純に縦に並べていこうかなという気分になっただけです。最終的には、先頭要素だけの配列をPageViewに渡して、そのPageViewが、デリゲートやデータソースによってスクロールを提供していく、という形にしています。

また、Coordinatorを`@MainActor`にしたので、ファイル内は全部`private`にしました。さっき言ったように、コントローラーを親側で保持する必要はないはずなので、それで良いと思います。ここもメソッドチェーンにしておこうかなという感じで、こんな感じでOKです。

それで、この辺は、コントローラーズのインデックスや、`-1`を返すとか、`UIViewController`周りの処理ですね。正直、`UIPageViewController`の仕組みを自分がまだ把握しきれていないところがあります。最初、複数渡せるじゃないですか。ここ、`controllers`。`UIPageViewController`の`setViewControllers`ですね。これだけ調べておきます。`UIPageViewController`の`setViewControllers`は、`viewDidLoad`後にトップページへジャンプするなど、スワイプ以外で表示する`UIViewController`を変更するときに使うやつで、配列の要素数は表示するページの枚数になる、という説明を見ました。デリゲートとデータソースの実装は必須で、`pageViewController(_:viewControllerBefore:)`と`pageViewController(_:viewControllerAfter:)`を返します。呼ばれるタイミングは、スワイプが完了してビューコントローラーが切り替わった後と、`setViewControllers`を呼んだ後のスワイプ開始時になるようです。例えば、1ページ目から2ページ目にスワイプすると、`after`が呼ばれて3ページ目を取得しに行く、という感じですね。

もしかすると…というほどでもないですが、たくさん用意していたのが間違いで、例えばこの`update`のところで、`first`の代わりに`.prefix(2)`とかやるのが良いのかなと思いました。`controllers`は`map`で配列にしましたが、`controllers.first`の代わりに`.prefix(2)`にすると、型が違ってしまいますよね。`.prefix(2)`は`ArraySlice`になるので、配列にしたいなら`Array(controllers.prefix(2))`のようにしないといけない。なので、ここで配列にしていきます。これで「2つ」というパターンにしたときに……これでもダメか。何かが違いますね。`Array`にはなっているし、大丈夫そうに見えるのに、やはりダメ。単に自分が`UIPageViewController`の使い方を分かっていないだけかもしれません。2個を設定しても、何個も設定するとダメ、ということで、どこでクラッシュしているんだろう。例外のところかな。

エラーメッセージとしては、引数に関するエラーで、「`controllers`の要素数は1にしないといけない。Required 1」という感じでした。あ、そうか。何かを増やさないといけないのか、つまりページの数をどこかで宣言しないといけないのかな、と考えました。どこかに「表示するページの枚数」といった指定があるのか。データソースを見れば分かるかなと、データソースの定義を確認しました。`before`と`after`のほかに、ページインジケーター用の`presentationCount(for:)`と`presentationIndex(for:)`があります。やってみましょうか。ダイアログを頻繁に出すのはUIのガイドライン的にどうか、という話もありますが、それは一旦置いておきます。

「ページ…」で出てこなくて、結局コピーもしなかったので手間取りましたが、ページコントローラーではなく、`presentationCount(for:)`でした。名前が全然違うのが面白いですね。デリゲート名ってこんなでしたっけ。これで`2`を返せば動くかなと思ったのですが、動きませんでした。`1`でもどうにもならないですね。よく分かりません。

`UIPageViewController`で複数ページを扱うにはどうするのか、もう少し調べたほうが良さそうです。`controllers`のところで複数のコントローラーを設定できるので、これでいいかと思ったのですが、これで良さそうに見えて、実際には……というところです。こういうやつですよね、というサンプルを見つけて、1枚目を表示するようにしておけばよさそうに思えるのに、実際には`UIPageViewController`の仕様で、`setViewControllers`に渡せる`UIViewController`の数は状況に依存していて、単純に複数を渡すだけではダメ、という挙動に見えます。3ページ分のコントローラーを並べられそうに見えるのに、現実には制限がある、という感じですね。 これは公開するインターフェースがこうなってしまっているだけなのか。1個だけ取れば何の問題もないのに、なぜか配列で返す仕様になっています。裏側できっと配列で持っているから、そのせいで配列で受け取るという事情なのでしょう。プレゼンテーションカウントは見たかったな。現在のページ位置の表示のことです。なるほどね。じゃあ、できないのか。まあ、できなさそうな雰囲気を感じますし、そういえばそうだったなという気もします。前にも同じことを感じた記憶があります。

とにかく1個だけにして、配列に変換しなくていいようにしたので、これでできました。結局のところ、ここからやっていきますよと。コードもいい感じに整っている気がするので、このくらいでよいでしょう。最後の方をもう一度見直してみますが、これはなくなりました。この辺もよしなに整えられています。

ここが気になるのです。`endIndex` を扱っているのでプラス1にしていて、これはこれで `endIndex` と一致しているかどうかを判定しやすいですからね。このノリでいくと、インデックスが 0 のときに1歩前に戻るインデックスは「先頭のさらに前」になってしまい、そういう表現はしません。左が閉区間で右が開区間になっているので、コードがずれるのは当然ですね。やっぱり 0 というより `startIndex` です。`startIndex` なので、コレクションの `startIndex` にたどり着いてしまった場合には 0 でよいのですが、配列は 0 始まりですから OK です。スライスが来ることもないので大丈夫ですが、インデックスの先頭という意味で一番正しいのは `startIndex` なので、`startIndex` に対して比較をします。

こんな感じで、「インデックスの1歩前」を取ります。厳密に言うと、ここも変えないといけません。本来はコレクションの `index(before:)` で前のインデックスを取り、同様に他の箇所もコレクションの `index(after:)` を使うのが妥当です。ややコードは長くなりますが、意味としては正確になります。

インデックスを1歩後ろに進めたものが `nextIndex` です。`nextIndex` が `endIndex` に到達してしまったなら先頭へ戻す。そうでなければ `nextIndex` でアクセスする。話は簡単で、インデックスが `startIndex` に到達してしまったら末尾にする。前のインデックスは `before` なので、これで OK ですね。こちらの方が気分がよいですし、コードも見にくくはありません。意味としてちゃんと説明されているので、これで良いでしょう。

こんなところで OK ということで、今日はこれくらいにします。次回はまたこの続きで、イベント同士の連携をちゃんとしていこうという話に進めていく予定です。今日はこれで終わりにしますね。お疲れさまでした。
