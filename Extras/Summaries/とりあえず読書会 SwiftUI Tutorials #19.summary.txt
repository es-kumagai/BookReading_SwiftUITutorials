Transcription & Summarize : とりあえず読書会 SwiftUI Tutorials #19

はい、では、とりあえず紹介を始めていきましょう。今日もいわゆるチュートリアルを読んでいきますが、前回の `EditButton` 周りを見ていて、やっぱり感覚がちょっと違うなというところがありました。そういったコードの書き方を見たことがなかったというか、一度このチュートリアルはやったはずなのに記憶になかった部分もあります。あの感覚に慣れておく必要がありそうなのと、もう少し別のやり方があるのではないかという点が気になるので、今日はその辺りを見ていこうと思います。どうなるかはわかりませんが、とりあえず進めます。

まずは Xcode から入ります。要は、`ProfileHost` で `ProfileEditor` を出すかどうか、といったところです。このビューが見当たらない、というか、エディタ内で表示するビュー…ナビゲーションかな、という感じで探していたのですが、環境を変えた都合で余計なビューが邪魔をしているので、まずはそれを消したいと思います。レイアウトの中…違う、右ボタン…ミニマップ、これです。ここにあるミニマップをオフにします。

改めて見ていきますが、要は `EditMode` 辺りですよね。この辺が少し不思議に感じます。どこが不思議かというと、`ProfileEditor` が表示されたときに `editingProfile` を設定して、`onDisappear` のときにモデルデータに書き戻す、というコードです。これ自体は悪くないのでしょうが、`onAppear` と `onDisappear` で反映する／しないを制御するのが、なんとなく不思議に思えるのです。だんだん見慣れてきた気もするので「こういうもの」と捉えればいいのですが。

さらにもう一つ気になるのは、書き戻す前のフローです。`EditButton` があって、それを押すことで画面の `EditMode` がアクティブになったりインアクティブになったり切り替わります。その切り替わりで再描画が走るのを利用して、`EditMode` がアクティブなときだけキャンセルボタンを用意しておき、キャンセルが押されたら `editingProfile` を元の値に戻す、というコードを書きます。その後に `EditMode` をインアクティブにすることでキャンセルを実現しているわけですが、`editingProfile` を元に戻した上で、`onDisappear` で `Profile` に書き直す、という流れになります。つまり、一度現在の `Profile` を読んで `editingProfile` にセットして、またそれを書き戻す、という、少し無意味に思える処理が発生します。これくらいの分量なら無意味でも問題ないのかもしれませんが、どうしても気になります。何とかならないのかな、という点です。

そもそもここで `EditButton` を使わず、普通のボタンを配置して、そのボタンが押されたときに変更内容を書き出すようにしてしまえば、基本的にはそれで話は早いのではないか、という気がしています。 例えばボタンについてです。モデルデータ…いえ、モデルデータの「Profile」ですね。Profile に編集用のプロパティを用意して、こういうふうに書いていきます。

ボタンの書き方は、アクションとラベルのイニシャライザを使います。例えば、`Button("Submit", role: .confirm) { … }` のようにします。role は何があるかというと、キャンセル、クローズ、コンファームがありますね。コンファームは iOS 16 以降で Available でした。では一度コンファームで挙動を見てみます。iOS 16 以上が必要です。

ところで、ボタンの role はどこで指定できるのかを少し調べます。SwiftUI の Button に role を指定すると、ボタンの色が変わるなど見た目が変化し、ボタンの意味が分かりやすくなります。role 自体はアクションの定義とは独立していて、見た目や意味付けが主目的だと認識しておけばよさそうです。

もしコンファームが使えない場合は、OS バージョンを上げる必要があります。エミュレーターを iOS 16 にして、プロジェクト設定の Deployment Target も iOS 16 くらいに上げておけばよいでしょう。ビルドが通るかはやってみます。

次にコツとして、String Interpolation を使いましょうという非推奨警告が出ています。古い書き方は Deprecated になっているようです。例えば `Profile.oldDate` を表示するところは、`Text("\(profile.oldDate, style: .date)")` のように文字列補間で書き換えます。ここで `style: .date` を指定できるので、期待どおり日付のスタイルで表示できます。これでコンパイルが通りました。ビルドも通りますね。

ただ、まだやりたいことは別にあります。この上で…これは ProfileSummary ではないですね。ここにボタンを用意して、`role: .confirm`（あるいはクローズでもよいのですが、iOS 16 ではコンファームで）にしておきます。とにかく、こうやってモーダル、というかコンファームを出して、その上で `EditMode.inactive`。このやり方だと、`EditMode` 自体は不要になります。エディットモードに依存した条件分岐はやめて、状態を自前で持つようにします。

つまり、`@Environment(\.editMode)` はここでは使わず、`@State private var isEditing = false` のようにプライベートなフラグで管理します。最初は `false` ですね。こうしておけば、エディットモードに頼らず編集状態を自分で制御できます。 そして、上でキャンセルボタンの表示はこの条件ではなく、`isEditing`（編集中かどうか）に基づくようにします。編集モードに切り替えて、キャンセルなどで `isEditing` を `false` に変える、という流れです。ここも同様に、サブミットでも `isEditing` を `false` にします。

あそこは `isEditing` で Submit を用意しましたが、これも Submit と分けないといけないですね。だから、`if isEditing` のほうがいいかな。`switch isEditing` で、`case true` なら Submit、`case false` ならボタンとして Edit、という形にします。ボタンの `role` は要らないのかな。普通のボタンとして、`isEditing` を `true` に変えます。

ところが、「case ラベルは `switch` の中にしか書けない」というエラーが出ました。つまり、カッコがないんですね。これを直して、`switch` のモード分岐ができるようにします。これも同様に、`isEditing` は共通の状態なので、一緒にまとめてしまえばよかった感じですかね。

`isEditing` で、ここに Edit ボタンと一緒に `ProfileSummary` を配置します。編集中のときは、Submit と一緒に `ProfileEditor` を置きます。これで、この辺のごちゃごちゃした部分がいらなくなって、「予期しない状況」への分岐も不要になり、だいぶスッキリした感じになります。

では、ちょっと動かしてみます。といっても、こちらのシミュレーターでプロファイルから動かすのではなく、上のほうからにしましょうか。`ContentView`、`ContentView` ですね。このビューから見ていく感じにします。

なんか `EditMode` は大仰すぎて、リストを書き換えるための組み込みの編集状態制御としては役に立ちそうですが、そうでないときにはかえってコードが複雑になりがちな感じがして、どうなんだろうね、という気がします。編集が終わったタイミングをフックできればいいのですが、できるのかな。できそうな気配はあるものの、よく分かりません。勘ですが。

とりあえずビューが出たので、これは一旦停止しておきます。あとでまた使います。とにかくボタンを押すとこの状態になり、Edit が二つ出ています。下のほうに出ているのは配置の問題かな、という感じです。

HStack でボタンがあって、その後…あ、そうか。HStack の中に入れたからですね。`Spacer` と Edit ボタンは、この HStack の外に配置していたんでした。 なので、あとエディットボタンが残っています。これですね。これが邪魔なんです。で、これで、人のものとは別に作ったボタン……。あー、`HStack` の `Spacer()` は、あとから横に詰めたかったのですね。なるほど。うん。そうすると、`if` 文はここではなくて、`HStack` の外にして……。あー、やっぱりちょっと、大した話じゃないんですけど、うん、ちょっとばかしうるさい感じになっちゃうかな。まとめすぎるとね。うん。

`true` だったときには、`HStack` で `Spacer()` の後にサブミットボタンを配置した上で、この `HStack` を終わらせて、`ProfileEditor` ですね。デフォルトのときには、同じく `HStack` でボタンを配置するために `Spacer()` を用意して、この上で `HStack` を終わらせて、`ProfileSummary` に、こんな感じですね。うん。そうすると、期待どおりの画面になってくれるのかな。おそらく、エディットボタンを押すとキャンセルとサブミットが出るようになってきて……。

で、あー、キャンセル。これは `HStack` の中に入れるのかな。だから、このキャンセルボタンも同様に入れておきますね。うん。この辺、消すのはもったいないというか、後でまた戻ってくる可能性があるので。このようにボタンはサブミットと一緒にキャンセルも置いておけば、まあいいという話ですね。要はこういう感じ。

こうしてあげて見ると、エディットボタンを押すと編集モードになって、サブミットとキャンセルがある、そういった状態になります。例えば、値を変更した上でサブミットを押すと、これで反映されましたよね。同じようにエディットを押して、今度はサマ―に書き換えて、このときキャンセルを押すと元に戻る、という挙動になりますよね。

つまり、`isEditing` というプロパティを `@State` として自分で作っておいて、`EditMode` には頼らずに、普通にサブミットボタンを押したなら編集中のデータを反映させる。そうでなければ現在の情報を維持する、ということですね。うん、余計なことを言う必要はないですね。こういうことです。

で、あとは `editingProfile` が今のままだと、表示されるときにどうなるだろう。`editingProfile` を `ProfileEditor` に対してバインディングで渡す、ということを踏まえると、これはまだダメですね。編集したときに……。だから一回やってみるだけやってみるか。これでエディットを押して、あれ、でも反映されてたな。あ、いいのか。編集して書き換わったやつをキャンセルすると、ウィンターですけど、これでエディットを押すとサマーのままなんですよね。だから、これを直さないといけないわけで。どうするか。キャンセルはどこでやるのかな。

`ProfileEditor` にバインドするとき、この状態で渡したい気がするんですけどね。うん。ここでといっても、上書きするわけにはいかないですよね。もう `onAppear` のときにやる手ではありますね。結局 `onAppear` に帰ってきちゃいますけど、`onAppear` のときに、ここで `editingProfile` に現在のプロファイルを入れてあげる、というふうにしてあげると、これだとちゃんとキャンセル後にまた現在情報を取ってくれるので、ウィンターをサマーに変えて、一旦キャンセルしたときに、もう一回エディットを押すとウィンターから始まりますよね。うん。これでいいのかな。表示するタイミング（`onAppear`）で `editingProfile` を更新する。で、バインディングされている情報が分かっている。うん。まあ、これでいい気もしますがね。

あとはもう一個として考えられる状況は……どうだろう、モデル……そうね、特にはないか。 キャンセルしたときに、モデルデータを既存のものに置き換えるという方法もありますよね。あ、モデルデータではないですね。`EditingProfile` を `PresentProfile` に置き換えることで、`onAppear` などはいらなくなります。こういった方法があるとして、どちらがよいのか悩みます。

キャンセルのときに現在の情報に対して `editing` を切り替えるという案もありますが、`editing` は編集のときに必要な情報なので、できるだけ編集直前に切り替えたい気がします。例えば、`onChange` や `onSubmit` がありますね。`onSubmit` って何でしょう。`SubmitValue`、すごく興味深いです。`onSubmit` は iOS 16 からかな？ そうだと嬉しい…いや、違うか、関係ないですね。`onSubmit`、`submit`、これは呼ばれるかな。

唐突ですが、`onSubmit { print(...) }` とか、例えば何でもいいのですが……。View が終わったと書いてあった？ 違うかな。えーと、`onSubmit` はどこに付けるんでしたっけ。`onSubmit(of: ...)` のトリガーって書いてあるのか？ ちょっとイメージと違ったので、別のを探してみましょう。

`onReceive`、`onDisappear`、`onOpenURL`、`onKeyPress`、`onTapGesture`、`onDrop`、`onContinuousHover`、`onPreferenceChange` など、いろいろありますが、特に編集系はなさそうかな。今どこを見ていたんだっけ。SwiftUI に用意された `VStack` とか、そのあたりを少し眺めてみました。`onAppear` や `onSubmit`、`onDrop`、`onKeyPress`、`onScroll`、`onReceive`、`onChange` などが並んでいて、`onChange` は使えそうな気もします。`onScroll` もあるくらいか。そうなると、やはり直接的な編集用はなさそうですね。

あとは、考えられるものとしてはボタン、特に `EditButton` です。どこかに置いていたはずですが見失ったか、消したかもしれません。まあどこでもいいので適当に配置してみます。`EditButton` 側に何か持っているのかなと見てみたのですが、イニシャライザはデフォルトのものしかなく、`body` があるだけでした。なるほど。やはり、両方を `EditButton` でうまく活用しようとすると、いろいろ工夫が必要になってきそうです。そうなると、今回のようなコードでは、デフォルトの `editing` をフラグで持っておき、それをうまくマネージしていくのがよいのかな、という気がしてきました。

あとはそうですね。`PresentProfile` がモデルデータからだけ取っていて……まあこれはこれでいいですね。`State`、`Binding` も問題なさそうです。そうすると、やっぱりデフォルトの `editing` でスッキリするかなという気がします。

この `EditMode` を、もう少しちゃんと考えたい気がするんですよね。ここがすごく楽でいいのですが。ほかにもう一つだけ。このデフォルトプロファイルを `EditingProfile` に入れてしまっている点が、相変わらず気になっています。意味のない値を入れておくのが苦手で、この後、結局 `PresentProfile` に置き換えることになるので、最初から `PresentProfile` が入っていてほしいな、という感じですよね。 ただ、これを強制アンラップのオプショナルにしてしまうと、バインディングができなくなります。頑張ればできますけど、そういった問題もあることを考えると、このステップは情報をデフォルトに入れておく、という発想なのかなと感じなくはないです。

あとは、Environment から取るのではなく、`ProfileHost` 自体が情報をもらう、というのもありますよね。Environment にする必要性は、状態を広く反映させたいからなのかなという気はします。ただ、そこまでせずに `ProfileHost` 自体がバインディングを受け取る、という設計でもよいのかなと思うので、ちょっとやってみましょう。

モデルデータ、要は `ProfileHost` を表示する時点で `Profile` を持っていますよね。であれば、その `Profile` をこの中に渡してあげればよいのでは、という発想です。具体的には、`@Binding var profile: Profile` のようにして、`ProfileHost` が `Profile` を取るようにします。イニシャライザで `profile: Binding<Profile>` を受け取る形でもよいです。この `profile` を `self.profile` に割り当てます。`Binding<Profile>` なので、必要に応じて `wrappedValue`（`profile.wrappedValue`）を使えば値にアクセスできます。編集中のデータは、もらったデータをそのまま使えばよい、ということになります。こうすると、この `profile` は初期化不要になりますし、余計なダミーデータを入れずに済むのでメリットがあります。結果として `Environment` は要らない、という判断にもできます。

加えて、`presentProfile`（現在のプロファイル）と編集中のプロファイルを分けて扱うようにすれば分かりやすいです。こうすれば、余計な計算プロパティが要らなくなりますし、`EditMode` も一度外してしまってよいでしょう。

例えば、編集中であれば `editProfileCancel` はこれでよいとして、サブミット時には `presentProfile.wrappedValue` に書き戻せばよいですよね。編集中でない場合は、表示は `presentProfile` を見せるだけで十分です。

この変更に合わせて、`ProfileEditor` のデフォルトや `ModelData` 周りも、`ModelData.defaultProfile` のようにして、バインディングした `profile` をそのまま渡すようにします。これで Environment は不要になります。呼び出し元もまだ直していないので、`ProfileHost` の呼び出し側（おそらくここ）を修正します。`ProfileHost` に何を渡すべきかという話ですが、普通は現在のプロファイルなので `presentProfile` を渡せばよいでしょう。

なお、あらかじめ情報を持っておいて、`ModelData` の中にデフォルトの `Profile` を入れておく、というのもアリだと思います。ただし、その場合は「デフォルトで与えられた値なのか、ユーザーが明示的に指定したのか」が区別できなくなる問題があります。そこを識別したいならオプショナルにするか、別のフラグを用意する必要があります。逆に、そこを知る必要がない場合は、オプショナルにせず最初からデフォルトを入れておく手があります。

このアプリ自体では不要かもしれませんが、一般的には必要になる場面もあると思うので、なるべく汎用的にしておきたいという気持ちもあります。オプショナルをそのままバインドしたい場合には、ここで `Binding` を自分で作ってしまう手もあります。例えば `Binding(get: { ... }, set: { ... })` のように自作すれば、オプショナルや変換を挟んだバインディングも柔軟に扱えます。 とりあえず、自分で作るのもそうですが、プレゼントプロファイル…というより、ここでは現在のプロフィールと呼びますが、プロファイルをここで作るか、別の場所で作るか、モデルデータがそこまで面倒を見るのはあまりよろしくない気がします。そんな気がするので、この場合はここで数値を詰める（バインドする）のが良いのですかね。`ProfileHost` に渡すときにバインディングです。

`Binding(get:set:)` のイニシャライザーは微妙に好きではないのですが、好き嫌いを言っている場合でもない気もします。`get` と `set` ですよね。`get` とイニシャライザーを見ておきますが…うまくいかなかった。`get` と `set` でいいのですが、いろいろありますね。まあいいか。

バインディングの中で、パラメータの `get` のときにどうするかをクロージャで指定します。クロージャで指定するなら書けなくなるのかな……。省略形をオフにして `set` を書けばいけるのか？ いや、書けない。わからない。ちょっと書いてみましょう。`get` でやりたいのは、元として親…ではなく、モデルデータのプロフィール、もしくはモデルデータのデフォルトプロフィール（`Profile.default`）を返すこと。`set` のときにはモデルデータのプロフィールに代入する、これなら書けました。

ただ、インデントが微妙ですね。結局のところ、`get` は表に現れないのに、`set` のラベルだけが出てくるのは違和感があります。構文の問題なので仕方ないのですが、まあ、ドットがいっぱい付くよりはマシかな。このインデントなら許容できますね。これで `get` としてここはクロージャ、`set` もこんな感じ……ああ、書けた。ここも `set` で……あれ、邪魔じゃないか？ なんかおかしくなってきた。まあ、こんな感じですね。どっちがいいかな。なんか決まらなくなってきましたね、バインディングが。

中に入れずに外で定義すればいいのだと思いますが、こうすると「プロフィールのデータを `ProfileHost` にバインディングしたものを書き戻す」というコードになります。そして `ProfileHost` の中身を見ると、ちゃんとバインディングが成立していて、`editingProfile` の内容をバインディング先に書き換えてあげる、と。サブミットのときはそうしますが、そうでないときは、現在のプロフィールを `editingProfile` にコピーはするけれど、そこは何でもいいというところです。

この下準備は、やはり `ProfileEditor` の `onAppear` でも良さそうです。`isEditing` だったときの `HStack`…まあ、周りとしては一緒ですね。`ProfileEditor` が表示されるときに `editingProfile` を更新する、というのが一番無駄がなさそうに見えてきました。表示前に現在のプロフィールを `editingProfile` に設定した上で編集モードに入り、編集自体はここではなく、`isEditing` が `false` になったとき、つまりサブミットのときに限って `editingProfile` を現在のプロフィールに反映する、という流れです。

`editingProfile` を現在のプロフィールから作ることで編集モードに入れる状況を整えつつ、プロフィールを表示しておきます。これで動くはず。試してみましょう。最初がウィンターになっているのをサマーに変えて、Submit を押すとサマーになりました。`editingProfile` をサマーから始めて、これをオータムに変えて、Cancel を押すとサマーのままです。もう一度 Edit を押したときにはサマーから始まります。できていますね。

オーソドックスではないかな。呼び出し部分は少しややこしくなりましたが、こうすることで `ProfileHost` の中では「このプロフィールを、書き込み可能なバインディング状態でもらっておき、編集モードが終わったときにそこへ自由に落として書き込む」ということが表現できました。こんな感じです。 とりあえず始めますね。こんな感じでやったら自然に見えるんですけど、この先はエディットモードをちゃんと使わないといけない状況が出てくるんじゃないかなと思うので、エディットモードを有効化します。エディットモードを有効化したと。例えば、これでエディティングプロファイル…じゃないや、エディットモードですね。

どうやら今回は、今はエディットを使わなくてもよくなった代わりに、将来的にはエディットモードを使ってルールで判定できれば十分かなと思っています。スイッチのエディットモードって、これを`case`で何とするかが分かりにくいですね。アクティブ、アクティブ、アクティブ…あれ、何だったっけ。エディットモードはエディットモード側ですよね。

エディットモード側は、バインディングがオプショナルということがあるのか。バインディングがオプショナルかという点を、前の話に戻って考えようと思っています。バインディングは、要はプロファイルが設定されていなかったときに、エディットモードをオプショナルでバインドすればいいかと思ったのですが、それだと使えなかったのでダメでした。 今回知りたいのは、`EditMode` の `.inactive`、`.transient`、`.active` です。`EditMode` が `.active` だったら、`.inactive` だったら `false` ですよね。あとは、`.case` にいるんだったら `false` ですかね。`EditMode` のバインディングだから `wrappedValue` ですね。オプショナルで、これで `wrappedValue` だっけ？ `EditMode` に `.inactive` が入っている場合になっている？ それ以外の場合、`.inactive` 以外だったら `EditMode` になるんだ。なるほど。他にも良い方法があるのかな？ いずれ `isEditing` があるということを知ったら、恐らくごめんですが。

これで `editMode?.wrappedValue?.isEditing ?? false` とやれば、`isEditing` ができましたね。ちょっとカットした感じで。そしてこれで、`isEditing` に書き込むということをしたいから、Getter と一緒にセッターが欲しいですね。セッターとして、`editMode?.wrappedValue = .inactive` ですね。`false` にしてあげれば読み書きができるようになると。ここまでは良くて、`self` が拡張されてない、ミュータブルか。この場合はいずれ `isEditing` だけど、この `EditMode` はミュータブルではない構造体でも書き込める状態のバインディングになっているので、ノンミューティングでいいですね。`nonmutating set`。そうすると、`isEditing` を通して制御が簡単にできるようになってくる。

この `ProfileHost` にとっては、全体的に `EditMode` を制御すればいい話なので、これで良いですね。そして、Submit があって、Confirm がオフ、これでもいいや。押してあげると、`EditMode` がオフの時だけ使わせてもらって、あとは Submit は独自のボタン機能によってプロファイルを追加するということができるようになると。この時は `EditMode` で動いているはずで、この時に例えば、Enable Notifications をオフにしてね。Submit を押すと、通知がオフになりましたね。Edit を押して、また Summer に変えてみて、これでもう一回 Submit するかな。Summer になりましたね。これで Edit を押して、この Summer を Ring に変えつつ、Cancel を押すと、Summer のままで、Edit を押しても Summer から始まる、というのがまず1個できたと。これを押してあげると、スマートというか、`EditMode` を活かしつつそれを制御しつつ、ちゃんと明瞭なコードで書けたよ、というふうに言えるのかなという気がするんですけど。

でも、もう1個ね、これでいいのかなって思うんですけど、Edit ボタン。これが `editing` モードの時、この時に Edit ボタンを用意してあげると、これでもまた動くわけじゃないですか。押して、Edit でここをね、Down に変わって、本来このボタンを使わせるのが `EditMode` としては本来の作り方じゃないかと思うんですけど、今は反映するコードが用意されてないんで、これで `Spring` に変えて Down を押しても、`Printer` のまま。これをなんとかしないといけないよ、という状況になっていて、これをどう解決するかというと、まあ一つの方法は、やっぱり `onDisappear` の時、この `ProfileEditor` が終了した時に Cancel。あ、いいのか。また Cancel ボタンか。また Cancel ボタンで。Cancel ボタンを押した時には、そこはやっぱり、ちょっとリアルなコードっぽくなってきますよね。`editingProfile` を `presentProfile` に書き直した上で、それでね、`onDisappear` だった場合には、`onDisappear` の状態で、`editingProfile` をモデルに書き換えてあげる。今回は `presentProfile` に書き換えてあげるですね。`presentProfile` に書き換えてあげる。こうすると、`onCancel` で `presentProfile` を `editingProfile` に書いておいて、要は変更をリセットした上で、それをちゃんと知っている前提で、リセットされた `editingProfile` を現在のプロファイルに書き戻すというコード。ここが気持ち悪いんですよ、個人的に。まあ良いんですけど、ちゃんと書けているので問題は何もないんですけど。

そうするとここで、ステータスをプロパティで戻せるとか、って言われてるんですかね。あとは、`active` のほかに何か良いステータスがあるのかな、`EditMode`。`.inactive` と `.active` と、あとはこれですよね、Temporary `EditMode`。Temporary `EditMode` は何を意味するのか知らないんですけど、でも書いてあるのか。一時的なやつ、ちゃんと訳せなくて悪いところ。プラットフォームやコントロールによって異なってきて、スワイプジェスチャーの実行時に一時的な `EditMode` が有効になる場合があるか。これは勝手に使うものではないようですね。そうすると、やっぱり別のステータスが必要になってくるのかな、っていうね。こんな感じになってきて。

例えば、そうだな。`editingProfile` みたいなね。例えば、`status` をプライベートに。あ、`ending` じゃダメか。`editing` に入れないといけないからね。`isEditing`、`cancelled` みたいなのを持っておく。これ気持ち悪いね、なんかね。キャンセルされた時に `true` にするよ、みたいなことを、仕様がどんどん膨らんでるわけですけど。これだと微妙ですね。これだったら、ちょっとリアルの通りに、`onAppear` と `onDisappear` をタイミングとして持ってあげて、その上で書き込みを適用する。

あ、でも一個ちょっと思いついたの。この Cancel とか抜きにして、`editingProfile` をオプショナルにするとやりますね、ちょっとね。こうしてあげると、書き換えのタイミングの時は `nil` でよくて、バインディングしないといけないんだ。オプショナルね。`editingProfile` と `endingProfile` みたいな感じで、`draftProfile` みたいな感じで持たせておいて、バインディングをそのまま入れておいて、やるのかな。ちょっとだけやってみますけど、例えば `draftProfile`、そしてバインディングで持たせてあげる。だから、正確に言うのはどうかな。これでバインディング。あとバインディングでいいかな。やり方は、これはバインディングの `profile`。これをオプショナルでちょっと用意してあげて、これプライベートでいいのかな。で、押してあげて、その上で `editingProfile` を設定する。これは、まあそうか、ここで設定することになるのか。で、`onAppear` で `editingProfile`。結局、タイミングしてないですね、何もね。`editingProfile` に余計なものを入れたくないという発想から始まった割には、何の意味もなってないような気がしてきた。

そうか。もしならば、`ProfileHost` が `Environment` から普通に `profile` を取って、それをバインディングしてあげて、`editingProfile`。うん、もうね、それでいい気がしてきたかな。で、それでバインディングの時に、よしなに計らってあげて、バインディングがキャンセルされた時。キャンセルされた時に、バインディングを `nil` にする。うん、まあちょっとやってみますか。そうすると、`Environment` が復活させて、`Environment` でモデルデータ、`modelData`。で、`var modelData` っていうふうにやってあげて、そうすると、イニシャライザーで `presentProfile` をバインドする必要がなくなって、これが計算型プロパティに戻りますかね。計算型プロパティになって、それで、何やったな、ちょっともう一回。計算型プロパティになって、これで `modelData` のデフォルトのプロファイル、というか `modelData` の `profile` もしくは、ここまではまず移動して、こうしてあげて、`profile` のイニシャライザーね。このイニシャライザーは、… とりあえず要らなくなったので、バインディング、バインディングプロファイルをオプショナルにします。これを state とかにして、編集モードで提供すれば良いから、編集モードかオンモードになればいい。まあでも一応、編集モード、プロファイルを state にして編集プロファイルにします。

で、だから、`nil` でいいわけですよね。うーんと、これで、プロフィールを presented with editing とあって、キャンセルボタンを押したときに、`editingProfile` を `nil` に設定してあげて、「編集中のものがない」という表現にして編集モードを許可してあげる。そうじゃなかったら、`editingProfile` を有効にしてあげて、それで `onAppear` のときに `editingProfile` を `presentProfile` にしてあげる。`if let` で `editingProfile` だったときには、それを `presentProfile` に入れてあげる。

というふうにすると、この `presentProfile` は、今は getter だけにしていたから、setter と getter 両方を用意してあげる。setter として持てるデータのプロファイルに対して、`newProfile` がいいな、`newProfile`、`newProfile`。こういうふうにしてあげれば、ここが書き込みにしたいから、これで書き込めたでしょう。ここに bind を当ててあげる。そういった形を取ります。

このときにトレーリングクロージャは、ここは同じ名前でできるのかな。ちょっとやってみますね。`editingProfile`。押したときには、だから、`editingProfile` バインディング、バインディング、バインディング。bind を取りたいときって、どういう名前にするといいんでしょうね。bind の binding の用は、`profile`、こういうふうにしてあげて、`bindableEditingProfile` みたいにしてあげればいいのかな。これで、バインディングを返してあげるというふうにして、この中で get はこういうふうにするんだ。get の場合には `presentProfile` ですよね。それで set の場合には、`newProfile` は、`presentProfile` に `newProfile` っていうふうに入れてあげると、これで bind 完成じゃないですか。難しいものでしたね。

ってことは、なんか面白い書き方あるかな。もう一回やりますけど、`Binding` で get と set に対して、ここに get って渡してるんですか。`presentProfile`、これで get はダメか。これでもダメか。どうか、これで定義はどうしようかな。この get は関数で取れれば取れていいんですけど、今 set も `presentProfile` の set、何か書けてそうですけどダメですね。この書き方を知らないだけなんで、ちょっと試しでやってみますけど、`profile` をどうするかどうなるか、これも関係ないよね。

このエラーとしては、「`presentProfile.get` がないよ」って言ってますね。もうね、言われちゃうと、またこれが取れないのか。そういうときに getter、setter を関数に渡すときには、どうするんだっけ。こういう書き方でもないよね。ちょっとやってみますけど。そうですね、これも違うよね。いいパターンではないもんね。これは聞いたことばかりで違うですね。こういう書き方できなかったかな。ちょっと私、調べてみますか。

そういうときに getter、setter、これを関数。関数、これ日本語だけど関数。関数として、何出てくるかな。getter、setter として。これかな、これかな、適当なことだけど、その省略とかで。あ、終わっちゃった。getter、setter、getter の効果。getter というわけではないね。やっぱり、シグネチャが取れなかったというのが書き方だった気がするんだけどな。これも、ちょっと GPT の出番ですかね。一応、義務的に書けたら嬉しいなと思うところから聞いてみましょう。「getter と setter を関数型の変数に保存する方法を教えてください」と。日本語が「教えてください」って言ってくれるかな。保存する方法は、アプリで保存する方法…それではないな。`get` `set`、`local`、`ticket`、`set`、こういう話ではない。

パターン全体はなく、基本的に表す仕組み、KeyPath か。KeyPath だと、KeyPath で取ることはできるんですけど、こうしたときには、KeyPath だと値になっちゃいますよね。セレクターみたいなやつが知りたいな。セレクターみたいなもの。例えば、関数なら、こんなやつと言いたいんだけど、`func value`、こういうやつ。また、これね、みたいなもの。詳しい人に聞いたら。こういったもので、なんかあった気がするんですけどね。getter、setter。そうそう、getter、setter を取りたいとき、関数参照として。関数参照って言い方なのかな。関数型ですよね。プロパティの場合には、クロージャに入れるのか。どうだっけな。どちらに近いのか。

なんか面白いね。こういうふうに質問を続けさせようとするように。ちょっとリピートになりましたけど。いるのかな。こんな…どうなんだろう。`getter`、`set` みたいな表記で、関数で解く…できなかった。AI ね、普通には変だな。まあいいか。どこの仕組み、関数参照、getter、setter。`.getter`、これはないよね。ないと思うんだけど。value、getter、setter、`getter`、`set`。まあいいか。なんかあった気がするんだけどな。忘れちゃったな。 プロパティの`.getter`や`.setter`なんてものはないですよね。どこに載っていた情報だったかと思いましたが、特に載っていませんでした。こちらの書き方ではない気がしますが、今はそれにこだわらず、ひとまず進めます。

こんな感じで、バインディングをバインダブルな`EditingProfile`という形で取得できるようにして、これを渡してあげれば問題ないはずです。書き戻しは、`editingProfile`が存在する（オプショナルが`some`）ときに行います。プロファイルエディターが表示されるときには、現在のプロファイルを`editingProfile`に入れておき、最初はオプショナルにしておくことで「編集中のプロファイルはない」という状態を表現します。オプショナルをうまく使って、「編集中のデータがあるのか」「あるならそれを書き出す」という流れのコードにできているはずです。

まだ呼び出しを書き直していませんでした。バインディングでプロファイルを渡すのではなく、`Environment`でよくなったので、プレビューのコードでもプロファイルを直接渡さず、代わりに`Environment`として持てるデータを渡すようにします。ここでは細かい呼び出しは不要になり、サクッとデフォルトに戻すだけで済みます。これでOKですね。プロファイルのプレビューが描画されるはずで、実際に描画されました。

今はウィンターなので、エディットモードでサマーに変えてから「Done」を押すと……ダメでしたね。いったい何が起きたのか、一瞬わからない挙動になっています。困りました。どこがおかしいか突き止めないといけません。

`editingProfile`が存在しているかどうかを確認するために、例えばここで`print`を入れてみます。そうでなかったとしても、`onAppear`で現在のプロファイル（仮に`presentedProfile`と呼んでいたもの）をどう扱っているかがポイントですね。バインドするときに、バインダブルな`editingProfile`と混同していて、動きが違っていました。ここが完全に間違っていました。`presentedProfile`を直接取ってきてしまうのはタイミング的によろしくなく、`editingProfile`の内容があるかどうかで分岐すべきです。

吐き出すとき（適用時）は`newProfile`でしたね。編集が終わってからのタイミングで、`editingProfile`の内容を`apply`し、それに合わせて`set`も行う、という順序を見直します。両方を`print`して確認してみましょう。

たとえば、`newProfile.season`と現在値の`season`を表示して、サマーに変更してから「Done」を押したときにどうなるかを見ると、一見サマーのはずがウィンターになってしまっています。やっぱりそうか、`set`の後に`apply`していますね。順序が逆で、`set`の後に`apply`してしまうと、意図と違う書き戻しが起きます。`presentedProfile`を`editingProfile`に`set`してから……とやっているうちに、どこかでバインディングの向きが混乱していました。

このあたりは、適用時に`editingProfile.season`などの値をプリントして突き合わせます。今思ったのですが、`presentedProfile`に反映させたら、そこで編集は終わりなので、`editingProfile`は`nil`を入れてクリアしないといけないですね。順序を少し入れ替えましたが、大丈夫かどうかを引き続き確認します。 とりあえず、これでエディティング側は`@Binding`にしてあげて、値をセットします。あ、そうか。今はセットされるのですね。`Binding`だから、今セットされるわけです。

セットされたときに、どこに入れているのでしたっけ。`presentProfile`に入れていますね。これはダメですね。`editingProfile`に入れないといけません。編集中のものを書き換えるからです。ですので、データソースは`presentProfile`でいいのですが、名前はよくないかもしれません。`editingProfile`で、渡すときには現在の値、書き出すときには編集プロファイル、という形にします。

なんか、思いがけず、いいコードを書けたのではないでしょうか。そうすると、`onAppear`は要らないですよね。 とりあえず `onAppear`。エディティング用のプロファイルに書き込む必要はなく、読み込まれてしまいます。`Binding` ではこれだとダメですね。ダメですが、このときに「プロファイル」「デフォルトプロファイル」「現在のプロファイル（present profile のこと）」をどう扱うかがポイントです。バインディングはエディティング用のプロファイル、または現在のプロファイルに向ける形になります。

もう一回やりやすくしてみました。これは分かりにくいところがありますが、コード自体の動きは良い気がします。これでサマーにするとサマーに、またオータムにするとオータムになります。最後に Done を押すと適用される、という流れです。これがサマーですね。アタッチがスクリーンになり、ここで Cancel を押すと適用はされず、オータムのままです。このとき `nil` になっているので、もう一回編集を押すとオータムから始まります。もうできました。Done でも OK ですね。これで良さそうです。ちょっと分かりにくいですけれど。

「エディティングプロファイル」という名前が分かりにくいので「ペンディングプロファイル（`pendingProfile`）」にしようと思います。こちらを `pendingProfile` にして、余計なこと（たとえば `@Bindable` など）は言わずに、エディティング用のプロファイル名をもう `pendingProfile` に統一してしまいます。そうすると、`editingProfile` は「`pending` があればそれ、なければ現在のプロファイル」という形にできます。セットするときには `pending` に書き込む。この方が読みやすくなってきた気がします。ほんとかな、慣れただけかもしれませんが。

こうしておくと、プロファイルエディターでは Done がいなくても…いや、やはり Done／Cancel は必要ですね。ここで `pendingProfile` に新しいプロファイルを入れておき、適用の判定は Done／Cancel で行います。この一部の中に `pendingProfile` を閉じ込めておく方が、より適切に詰められるでしょう。

これを `onDisappear` でやっている点が少し引っかかりますが、これはこれでいいのかな。`task` でもいけるかもしれません。ここに `task` を入れると、いつ動くでしょうか。いや、`task` ではなく `onAppear` でも良いのかもしれません。`onAppear { print(...) }` としておいて、表示したときに `onAppear` が出ましたね。押すと、やっぱり…書き戻しのタイミングはどこが一番良いのでしょう。`ProfileEditor` が `onDisappear` になった時点で、`pending` をどう反映するか、そのあたりの設計です。`onDisappear` が良いのかもしれません。なるほど。結局、`onDisappear`／`onAppear` と `ProfileEditor` の位置関係ですね。そういうところです。

では、大体表現ができたので最後の整備です。Edit ボタンは共通のものになるので、外に出しておくのが良さそうです。つまり、Edit ボタンは必ず `isEditing` の外側に置く。そうすると `ProfileEditor` の出し分けはどうするか。要件が複数の場所で必要になってきます。SwiftUI である以上、基本的にはこうした表現になります。

具体的には、`HStack` で「`if isEditing` なら Cancel ボタンを用意」「Edit を始めるボタンも用意」という構成にして、その後に `if isEditing` の分岐。個人的には `switch` が好みかもしれません。`if isEditing` が true のときは `ProfileEditor` を、false のときは `ProfileSummary` を表示する、という形です。

試しに書いてみると、最初はダメでした。`if` 文とボタンのところは良さそう。`switch` で `true`／`false` を分け、ここで `onDisappear` を付けるならカッコはいりません。`switch isEditing { case true: ... case false: ... }` の形で、`case true` に `ProfileEditor`、`case false` に `ProfileSummary`。括弧の閉じ方を直して、これで OK。`if isEditing` が二箇所に出てくるのは少し気になりますが、まあこれはどうしようもないですね。こんなものでしょう。

動作確認です。ボタンを押して編集に入り、ミターをサマーに変えて、Done を押すとサマーになりました。閉じたときにも反映されていて欲しいのですが、できるでしょうか。Cancel のときはそのままで良いとして、Done を押したときにネットに送るのが微妙に気になっています。これは `onDisappear` にしているからでしょうか。いや、違うかもしれません。タイミングを見ましょう。`onDisappear` が発生するタイミングと、`ProfileSummary` が `onAppear` するタイミング、それから `isEditing` の切り替えや Cancel ボタンのタイミング。影響しそうなのは `pendingProfile`。`pendingProfile` が変わったタイミングも見る必要がありそうです。

たとえば `onChange(of: pendingProfile)` を使ってログを出す。これはどうでしょう。`Profile` は今はユーザー名などのフィールドなので、`Equatable` でいけそうです。このままやっても問題ないでしょう。`Equatable` にして `onChange` を追加します。似たような名前が続くと読みにくいので、色分けなどの見た目は後で調整すれば良いでしょう。

一度リビルドし直して何が変わるかを確認します。表示したときに、まずは `ProfileSummary` が表示されました。 この後に、これをボタンに変えて、`Done` を押しました。なるほど、笑顔の後にこのマークがあるので、`onDisappear` が後で走っていますね。とりあえず、ここはこれで良さそうです。

次に、`onChange` での `pendingProfile` がいつ走ったのかをもう一度確認します。`onChange` で `pendingProfile` が動くとすると、`isEditing` がキャンセルされたときくらいでしょうか。あとは、ここで書き換えますが、そうすると、`onDisappear` ではなく `onAppear` のところで、表示する……いや、表示ではなく値を変えてあげる手法を取ると良さそうです。

これで、Edit を押して、表示を `Done` に変えて、`Done` を押す、という流れですね。Edit を押してからの一連の操作で、最初からその挙動になるようにしておくのが良さそうです。こちらの方が良いですが、×ボタン（キャンセル）の扱いはどうでしょうか。表示前に反映させる、`pending` があれば反映させる、という方針にします。

編集モードのときには、仮に `pendingProfile` があれば、それを反映して編集モードに入っていく、ということですね。Edit が終わったら、普通は `ProfileSummary` が表示されるはずなので、その表示時に反映すれば良いですし、何らかの事情で連続して `ProfileEditor` にもう一度入る場合でも、編集中のものが表示されるので、これで問題ないと思います。大丈夫な気がします。

終了時の扱いとしては、編集中の段階でこのビューを閉じてしまったら編集はキャンセルされる、というドライバーにするなら、これで良いですね。書き換わる感じがなくて個人的には嬉しいので、これでいきます。妥当だと思います。タイミングは `onAppear` 側に寄せます。

全体としてプリミティブな感じになりましたし、`Profile` の `Equatable` 準拠は、あっても良いですが、この形だとそんなに比較することもなさそうなので、やはり無しで良いかなと思います。これで良さそうです。

`EditMode` を活用する場合のコードの書き方としては、`editingProfile` が少しややこしいので、ここは先に分けることになりそうな気もします。ただ、`pending` があれば読み取りにそれを使い、なければ現在の `profile` を使う、という方針で良いですよね。書き込みは `pending` に対して `Binding` を書き込めば良いです。さらに `Optional` を使っていることで、`pending` があるかどうかを正しく表現できています。

現在のプロファイルは、モデルデータに設定されている値があるならそれを使い、なければデフォルト値を使うようにしておくことで、余計な場所でデフォルトを与える必要がなくなるのも良い点です。そのうえで、保存時にはモデルデータに書いていきます。`editing` は `EditMode` を使いやすくするためにこうして開く形で OK です。終了時に設定する場合は、`EditMode` に対して `.inactive` を入れれば良いと思います。 準備もそれほど大変ではありませんし、ぱっと見で、編集モードをブール型のフラグ `isEditing` に置き換えているのだな、とすぐ分かります。これで大丈夫ですね。

`isEditing` が `true` のときはキャンセルボタンを出し、キャンセルするなら保留中のプロファイル（`pendingProfile`）をリセットします。リアルタイムに現在のプロファイルを書き換える必要はないので、論理がシンプルで直感的に見えます。その上で、`isEditing` を `false` にすれば編集モードから抜ける、という流れにできます。

また、エディットボタンは `isEditing` かどうかによって、`Edit` ボタンになるか `Done` ボタンになるかが切り替わるので、ここも問題ありません。`isEditing` に応じてエディタ表示にするかサマリー表示にするかを切り替え、エディタ表示のときには `editingProfile`（保留があればそれを使うなど、いろいろ配慮されたプロファイル）をバインドすることで、うまく `pendingProfile` を書き換えていけます。

一方、サマリー表示のところでは現在のプロファイルだけを表示すれば十分です。`pendingProfile` があってもまだ反映されていないため、表示時には気にしなくて構いません。サマリーが表示される段階は、つまり編集モードが終わって表示モードに戻ったことを意味するので、ここの `onAppear` で `pendingProfile` があればそれを使って現在のプロファイルを更新し、`pendingProfile` をリセットする、という方法を取ります。こうしておけば、サマリーが表示される前に現在のプロファイルが保留内容に差し替わるため、最初から変更済みのものが表示されます。

今お話ししたように、理想的なところまで落ち着いたかなという気がします。`Edit` モードの使い方はプロジェクトによって変わると思いますが、基本的な考え方としては、少し難しかったものの、なんとか実装できたかなという印象です。特に、このあたりを `Optional` で表現できたところが、個人的には一番良かったかなという感じです。

では、今日はこのあたりで終わりにします。次回は、`UIKit` との連携に関するチュートリアルを読んでいく形になります。ご視聴ありがとうございました。
