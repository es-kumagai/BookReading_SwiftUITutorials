Transcription & Summarize : とりあえず読書会 SwiftUI Tutorials #28

はい、では、とりあえずご紹介を始めていきましょう。今回は「とりあえず」を見ていってますが、「あとよ」というアプリ、これが完成したところです。そのときにコピペで済ませているコードの中で、まだ見ておいたら楽しそうなところがあるのと、自分がコードを少し書き換えた都合で、少しばかり過剰なインターフェースが載っている状況になっているので、それを直していく、そんなところを今日はやっていきたいと思います。こういった作業が一番面白いと僕は感じますね。あれこれ考えて、飛躍していく、こんな流れです。

もちろん自分が常に良いコードを書けるとは限りませんが、それでもひたすら考えていくと、それなりに「見つけられる力」になっていくと思います。逆にそういったことを気にしないでやっていると、上達も頭打ちになってしまいますよね。何事もあって考えることは大事だな、と最近特に感じています。プログラミングって結構、状況をしっかり掴んで、その状況に応じて適切な処理をやっていくものです。簡単そうでいて、実は結構難しい。ある程度身についていても、どこまで身につけられるかという課題は常にあり、いろいろ難しいところがあります。そんなことを気にしつつ、今日は進めていきます。

まず、Apple Watch系のアプリのコードですね。気になるところはいくつもあるのですが、個人的に大きく気になるところからやっておきます。APNs（Apple Push Notification service）の通知ペイロード、そういった情報がボディとして当たってくる形式になっていて、タイトルとボディがあり、`landmarkIndex`、ここが少し気になります。インデックスって状況に依存しませんか？ ここでインデックスが当たってくるのはいまいち微妙な気がします。それと「サーモン・クリーク（Salmon Creek）」と`landmarkIndex`は本来一致すべきものな気がしますが、ここはタイトルを通じて出さないといけないので、しょうがないのかもしれません。このあたり、ローカル通知に自分が慣れていないので、試行錯誤も兼ねてやっていきたいと思います。何にしても、このインデックスはおかしい…と言い切り過ぎかもしれませんが、違和感があります。

目的は`NotificationView`で表示することです。ここでビューにタイトルなどを渡しますが、そのタイトルはどこから来るかというと、`NotificationController`ですよね。`didReceive`で受け取った情報を通知データとして持ち、それを使ってアラートのタイトルやメッセージを取り出して表示しています。ここが気になります。まずは通知ペイロード。`aps`やその周辺の書き方をちゃんと抑えておかないとダメですね。プッシュ通知（iOS）の実装方法をざっと確認します。セットアップの話は脇に置いて、アプリ実装とペイロードの形式に注目します。

ドキュメントによっては、エミュレーターで通知を送る例として、デバイスIDと`aps`、`title`、`body`、`data`といった形で渡す例が出ています。`duration`などの追加情報があるケースもあります。APNsの「ファイル」ではなく、正しくはAPNsの「ペイロード」フォーマットですね。ここを正確に知りたい。検索は「APNs ペイロード 形式」などが良さそうです。APNsの証明書の話ばかり出てくることもあるので、注意が必要です。クライアント実装やユースケースの中で、`content.userInfo`にイメージのURLがあり、それをダウンロードして添付するような例も見かけます。要は`userInfo`に自由なデータを入れられます。代表的なペイロード例では、`aps.alert.title`や`aps.alert.body`などの基本構文があり、これは外せません。したがって、タイトルやメッセージは基本的に「しょうがない」、つまり必須に近い扱いになります。カテゴリや`thread-id`などのフィールドもあります。

では、実際にシミュレーターに通知を投げて、タイトルを加工してみます。例えばタイトルの先頭に感嘆符を付けるようにして、Apple Watch側の通知表示がどうなるかを確認します。アプリが前面で動いていると通知が出ないので、ホーム画面に戻してから投げ込みます。通知が来て、想定どおりタイトルに`!`が付いて表示されました。つまり、タイトルは必要です。ここで問題なのは、タイトルの文言が状況によって揺れてしまうと困るという点です。メッセージも同じです。

次に`landmarkIndex`の件です。ランドマークのデータは別途IDを持っていますよね。インデックスではなくIDで取るべきではないか、という気がします。そこで`landmarkID`に変更します。例えば「Salmon Creek」は`1002`番ですね。これを使うのが良いでしょう。`NotificationController`側でも、`landmarkIndexKey`ではなく`landmarkIDKey`として扱い、IDを取得します。するとモデルデータからランドマークを取るとき、IDで引ける仕組みが必要です。既存に`byID`で取る実装がなければ追加します。

やり方として、`ModelData`に拡張を加えて、`Sequence`拡張で`Element`が`Identifiable`な場合にIDで要素を探すユーティリティを作るのが良さそうです。例えば、`extension Sequence where Element: Identifiable, Element.ID: Hashable { ... }` のようにして、`element(id:)`（名前は後で調整）で`first(where:)`を使って返すメソッドを用意します。ランドマーク限定にせず汎用化しておけば、他でも使えます。メソッド名は`find(id:)`や`element(forID:)`など、`first`とは言わないほうが意味が伝わりますね。

これで`NotificationController`内では、`modelData.landmarks.element(id: id)`のようにIDでランドマークを引けるようになります。ここで注意したいのが、コード中に`nil`（オプショナル）を多用してしまうと、表示側が複雑になる点です。特に`NotificationView`は表示だけなので、ここでは`nil`を許容せず、「外側で`nil`を解決したうえで正しい値を渡す」ほうがシンプルです。ただし画像（ランドマーク画像）はオプショナルにしておくのが実用的でしょう。つまり、`NotificationView`のイニシャライザには`title`と`message`は必須、`image`はオプショナルとして、`image`があれば表示、なければテキストのみ表示、という分岐にします。

ところが、`NotificationController`の実装都合で、プロパティは`didReceive`前に初期化されます。そのため値が入る前提のプロパティは「暗黙的にアンラップされたオプショナル（`String!` など）」にするのがSwift的に適切です。使う時点では必ず値が入っているという前提があるので、`title`と`message`は`String!`で持ち、`image`だけ`Image?`とします。初期値を適当なダミーにするくらいなら、`nil`を許容しつつ、使う瞬間は値があるという契約のほうが安全です。

次に、`userInfo`の扱いです。`UNNotificationContent.userInfo`は`[AnyHashable: Any]`です。キーの文字列をそのまま生で扱うのは好ましくないので、型安全にしたいところです。`NotificationController`に責務を寄せすぎないためにも、`NotificationContent`（あるいは`NotificationPayload`）のようなラッパー型を作り、そこで`userInfo`から安全に`title`、`message`、`landmarkID`を取り出す実装をまとめます。

具体的には、`NotificationContent`（Swiftの`UNNotificationContent`と名前が被るので、`AppNotificationContent`や`NotificationPayload`などにしても良い）という`struct`を作り、`title: String`、`message: String`、`landmarkID: Int`などをプロパティとして持たせます。イニシャライザは`UNNotificationContent`から生成する`init?(from content: UNNotificationContent)`のような「失敗可能イニシャライザ」にして、`content.userInfo`を内部の`UserInfo`ラッパー（`fileprivate struct UserInfo { let raw: [String: Any] }`）に取り込みます。この`UserInfo`拡張で、`aps`配下の`alert.title`や`alert.body`を安全に取り出す`var title: String?`、`var message: String?`などのプロパティを用意します。`aps`や`alert`の取り出し自体も`fileprivate`な計算プロパティで段階的にガードしていくと、`guard let`のネストが最小化できます。`landmarkID`は`userInfo["landmarkID"] as? Int`から取る形で同様にラップします。

このとき、エラー詳細（`aps`が無いのか、型が違うのか等）を厳密に返す設計もできますが、今回のユースケースではリカバリ手段が特にないので、そこまで過剰にせず、`nil`を返す/`init?`で失敗する程度に留めても良いと思います。

ビュー表示順序の確認として、`NotificationController.didReceive`が呼ばれてから`NotificationView`の初期化（`init`）が走るかを`print`で確かめます。Watchの環境ではコンソール出力の見え方に癖があるので、`NotificationView`の`init`に`print("init")`、`didReceive`に`print("didReceive")`を仕込んで順序を確認しました。結果、`didReceive`の後に`init`が走っているので、方針どおりで問題ありません。

さて、タイトルやメッセージが`nil`だったときの表示方針も決めます。`NotificationView`は`nil`非許容にしたいので、`NotificationController`（または先ほどの`NotificationPayload`）側でフォールバックの文言を決めます。具体的には以下のようにします。

- タイトルとメッセージの両方が取れた場合は、そのまま使用。
- タイトルだけ取れた場合は、メッセージを補う。例：「近くにランドマークがあります」（英語なら「A landmark is nearby」など）。英語表現は`ChatGPT`等で確認できるのは便利ですね。
- メッセージだけ取れた場合は、タイトルにフォールバックを入れる。例えば「Secret place」（秘密の場所）。`Unknown Landmark`よりは、ユーザー体験としてやわらかい表現にしました。
- 両方とも取れなかった場合は、「秘密のランドマークが近くにあります」のように、最小限の期待値が伝わる文言を入れておきます。サーバー側の不備が原因でも、ユーザー体験として落ちないほうを優先します。

`landmarkID`については、サーバーから渡ってくるIDと、クライアント側モデルから引いたランドマークの名前がズレる可能性に備えます。どちらを信頼するかで設計が変わりますが、今回はサーバー側のIDを優先的に信頼し、ローカルで`modelData.landmarks.element(id:)`で引いて画像などを補助的に使う、という方針にします。IDで引けなかった場合は、`assertionFailure("指定されたランドマークIDが見つかりません: \(id)")`程度にしつつ、UIはフォールバック文言とともに画像無しで表示できるようにします。`image`はもともとオプショナルにしているので、そのまま表示側はシンプルに保てます。

`NotificationPayload`の実装詳細としては、`fileprivate`なイニシャライザで`UNNotificationContent`を受け、`userInfo`のキャストに失敗した場合は`nil`を返すようにします。内部の`UserInfo`ラッパーでは、`var aps: [String: Any]?`、`var alert: [String: Any]?`、`var title: String?`、`var message: String?`、`var landmarkID: Int?`のように計算プロパティを揃え、段階的に取り出します。これにより、`NotificationController`側は`let payload = NotificationPayload(from: content)`の結果を見て、`title`/`message`/`landmarkID`を受け取るだけで済みます。

また、`Sequence`拡張の`element(id:)`は、`extension Sequence where Element: Identifiable, Element.ID: Hashable { func element(id: Element.ID) -> Element? { first { $0.id == id } } }`のような形で十分です。ランドマーク以外にも使えるので汎用性があります。命名は`find(id:)`でも良いでしょう。

最後に、通知の動作確認のワークフローです。アプリがフォアグラウンドだと通知が表示されないので、ホーム画面に戻してから、APNsペイロード（`aps.alert.title`、`aps.alert.body`、`landmarkID`などを含むJSON）をシミュレーターへ送ります。ツールは`cURL`等でHTTP/2経由のAPNsリクエストを投げるか、シミュレーターの通知注入機能を使います。タイトルを加工して送った場合、Apple Watch側でそのまま反映されることを既に確認しました。

以上の整理により、`NotificationView`は必須情報のみを受け取るシンプルな表示コンポーネントにでき、外側の`NotificationController`は`NotificationPayload`を使って、`userInfo`の取り出し、フォールバック、モデル照合（ID→ランドマーク）といった責務を引き受けます。これで`nil`の扱いも局所化され、過剰なインターフェースも解消でき、読みやすく安全なコードに近づけると思います。 文字起こしのテキストを貼り付けてください。  
いただいたテキストを次の方針で整えます。
- 「ですます調」に統一し、文体と句読点を自然に整えます。
- 機械認識の誤り（例：「G言語」→「C言語」、「万全オキス」→「万全を期す」など）を文脈に沿って修正します。
- コードはバックティックで装飾します。短いコードはインラインで、複数行や長いものはコードブロックで表記します。
- 要約は行いません。複数人の会話も発話者ごとに分けず、通常の文章としてまとめます。
- 冒頭が中途半端でも、その文は無視して次の文から整えます。与えられていない内容は追加しません。

特に表記ゆれを避けたい専門用語や固有名詞があれば、あわせて教えてください。 文字起こしのテキストがまだ届いていないようです。整形・校正するための元テキストを貼り付けてください。

いただいたテキストは、要約せずに「です・ます調」で自然な文章に整え、誤変換（例: 「G言語」→「C言語」など）を修正します。コードはバックティックで装飾し、短いコードはインラインで表記します。途中の文から始まっている場合は、その文は無視して次の文から整えます。

特にこだわりがあれば（例: 英語用語のカタカナ表記の方針、用語の統一、セクション分けの有無など）、一緒に教えてください。 文字起こしのテキストをお送りください。いただいた内容を以下の方針で整えます。
- ですます調で、読みやすい自然な文章に整えます（要約はしません）。
- 誤変換や不自然な表記は適切に修正します（例: 「G言語」→「C言語」、「万全オキス」→「万全を期す」など）。
- コードはバックティックで装飾し、短いコードはインライン、必要に応じてコードブロックを使います。
- 複数人の会話は、発話者名を出さずに地の文としてまとめます。
- 冒頭が中途半端な文から始まっていても、続く文から自然につなげます。
- 与えられたテキスト以外の内容は追加しません。

特に気になる用語の表記ゆれや、そのまま残したい専門用語があれば、合わせて教えてください。 文字起こしのテキストをご用意ください。いただいた内容を、ですます調で読みやすく整え、句読点を補い、明らかな誤記（例：「G言語」→「C言語」、「万全オキス」→「万全を期す」など）は適切に修正します。コードは、短いものはインラインのバックティック、必要に応じてコードブロックで表記します。要約は行いません。

固有名詞や用語で表記ゆれを避けたいものがあれば、あわせて指示してください。テキストをそのまま貼り付けてください。 文字起こしテキストをご提示ください。こちらで次の方針で整えます。
- ですます調に統一し、句読点を適切に付けます。
- 誤変換や誤表記（例：「G言語」→「C言語」、「万全オキス」→「万全を期す」など）を文脈に合わせて修正します。
- 要約はせず、内容は削らずに自然な文章に整えます。
- コードはバックティックで装飾します。短いコードはインラインで、長いものはコードブロックで表記します。
- 複数人の会話は、発話者名を出さずに地の文として統合します。
- 途中から始まる不完全な文は無視し、次の文から整えます。
- 与えられたテキスト以外の内容は加えません。

テキストは長くても大丈夫です。複数回に分けて送っていただいても構いません。もしタイムスタンプやノイズ（えー、あー等）が含まれている場合、基本的には読みやすさ優先で整理します。特別な希望があれば一緒にお知らせください。 整形する文字起こしテキストを貼り付けてください。

こちらで行うこと:
- ですます調に統一し、句読点や文体を整えます（要約はしません）。
- 誤認識や誤表記（例: 「G言語」→「C言語」、「万全オキス」→「万全を期す」など）を適切に修正します。
- コードはバックティックで装飾します。短いコードはインライン、必要な場合のみコードブロックにします。
- 複数人の会話は発話者を区別せず、内容を踏まえた自然な地の文にします。
- 冒頭が中途半端な文で始まっている場合は無視し、次の文から整えます。

特に表記ゆれの統一ルールがあれば、あわせて教えてください（例: 英数字の全角・半角、専門用語の表記など）。 文字起こしテキストを貼り付けてください。  
ですます調で読みやすく整え、誤変換を適切に修正し、コードはバックティックで装飾します（短いコードはインラインで表記します）。複数人の会話も地の文にまとめ、要約はしません。途中から始まる不完全な文は無視して、次の文から整えます。 文字起こしテキストをご提供ください。指定どおり、ですます調で読みやすく整え、句読点を補い、明らかな誤変換（例：「G言語」→「C言語」、「万全オキス」→「万全を期す」など）は適切に修正します。要約はせず、内容はそのままに、コードは必要に応じてバックティックで装飾します（短いコードはインライン、長めはコードブロック）。

可能であれば、次の点も教えてください。
- 固有名詞や専門用語で、表記を固定したいものはありますか。
- 非公開のプロジェクト名など、伏せてほしい名称はありますか。
- テキストが長い場合、複数回に分けて処理してもよいですか。

テキストをそのまま貼り付けてください。こちらで整えます。 なので、これだけで良くて、Extensionで…あ、どうでしょう。イニシャライザーでわざわざこれを初期化させる必要はないので、この辺はExtensionに寄せますね。このExtensionを持ってきて、この辺に置いておきます。Extensionもコンテンツに対して実装して、アクセスレベルは`internal`ですね。うん、こんな感じです。

そうしておいた上で、`rawValue`のイニシャライザー。ここで作っている`init(from:)`ですね。これを`fileprivate init`にするか…`fileprivate init`。いや、イニシャライザーも`internal`で良さそうですね。なので、イニシャライザーをここに生やす感じにします。

それで、`fromContent`で、`guard let userInfo = content.userInfo`。`content`…うん、その手がありますね。「`rawValue`がなかったよ」みたいなことになりますが、なかったらそれはそれで変ですね。`AnyHashable`もここが変ですけどね。どうしようかな。`AnyHashable`と`rawValue`。そのあたりがちょっと悩ましいんですが、`userInfo`が取れなかった時が厄介だな、というのが今思っているところです。まあ、厄介になったら厄介でいいか。あまり狙って綺麗にしすぎる必要もないので、`guard`で目的の`userInfo`が取れなかったら失敗にしましょう、とりあえず。

それで取れた場合には、`rawValue`云々ではなく、`userInfo`で良いですね。`self.userInfo = userInfo`。そして…あれ、インデントがずれていたのは何だろう。この後、これずれてますね。`guard let content = …`で`return`を忘れていましたね。`return`が抜けているのか。ということで、`guard`を抜けたら、`self.userInfo`として今の`userInfo`を入れてあげる、という形で大丈夫でしょう。

ところで、ここ、`guard`ベースとかにするとどうなの？あ、ここがエラーになるか。ここが…`enum`行こうとしたのかな。そっか、これは…まあいいか。これでいいか。ちょっとパターンマッチングでいい感じに書けないかなと思って、value bindingパターンが使えるのかなとか考えたんですが、ダメでした。まあいいや。

`UserInfo`の`NotificationContent`。ここで、コンテンツから`userInfo`を取る形にして、`userInfo`の中のAPIでアクセスしていく。全部`Optional`の可能性はありますが、情報はテキスト…というか、文字列キーを直接触らず、この「シンボル」（例えば`enum`の`rawValue`）で通れるようになった、という感じです。文字列キーはこの中に閉じ込めておいて、`userInfo`に対するラッパーだと考えればOKですね。これで。

これでOK。そうした上で、この辺のコードが役に立ってきます。コントローラー側で、通知を受け取った時、`didReceive`で、ここで`let content = NotificationContent(from: request.content)`という形にしてあげます。これが`Optional`なので、ここで`guard`が必要かな。`guard`にするか、`if let`にするかを考えていましたが、`guard`でいいですかね。`guard`で、取れない場合には`return`する、という話です。

その場合、タイトルとメッセージとイメージを設定しないといけない状況になっていて、タイトルは近い話だと`"Unknown Landmark"`、あるいは単に`"Unknown"`でも良いですね。メッセージは`String`で、`"I don't know where it is"`といった感じで、完全に分からない状況を示す文言にします。イメージも、取れなかったなら何も設定しない（`nil`）感じでいいでしょう。何にも取れなかった時には、そのまま抜けてしまって、必要ならアラートを出します。さらに、`assertionFailure("予期しないコンテンツが通知されました")`としておくのが良さそうです。 ここを開けておけば、ここは普通に来ないわけです。万一来たときにはデバッグビルドでは落ちますし、そうでなければ「よく分からないランドマークが通知されてきた」的な、ちょっと様子見で済ませるような感じでアプリを走行できる、という考え方です。

こうしてしまえば、コンテンツはすでに手に入っているので、ここで先ほどやった内容が役に立ちます。ここから、まあ「最後まで」と言い切るのは言い過ぎかもしれませんが、この先まで進められるはずです。まずは不要な部分をざっと整理して、全部持ってきます。`userInfo` を手に入れていたところの `let` はおかしいですし、そもそも不要なので、このあたりはすべて削ります。こうしてあげれば、`userInfo` ももういりません。これでコンテンツが見通しよく扱える状態になります。

同様に、こちら側でも通知、というかコンテンツが手に入った状況になっています。ここですね。`userInfo` にするか、コンテンツにするかで迷いがちですが、ここはコンテンツで大丈夫です。通知のコンテンツは引数から受け取れているので、そのまま使えば問題ありません。

コンテンツに含まれる `title` と `message` を2行表示に振り分けたり、表示方法を調整したりするのは、通知コントローラの責務です。通知はどんどん飛んできますが、それをどう表示したいかを一番よく知っているのはコントローラなので、状況に応じて「それは秘密の場所だ」といった判断もここで行えます。つまり、前提情報というか材料というか、そういったものを持っているのがコントローラです。

さっきコンテンツ側でこれをやろうとしていたときには、そもそも状況が分からないことがあります。状況によっては本当に不明なコンテンツで、「不明なランドマークが欲しい」といったケースもあるわけです。なのに、コンテンツの中にこの振り分けロジックを入れてしまうとお手上げになります。必ずコントローラ側に置くべきです。

こうしておくことで、状況に応じて、`message` がなかろうと `title` がなかろうと、いい感じのメッセージを揃えられます。さらにコンテンツの `id` からも情報を揃えることができます。モデルデータから該当のランドマークを取り出し、そのランドマークに対して `image` を取得する流れになります。

まず、取得できなかったときの扱いです。`id` で取得したときに目的のランドマークが得られなかったのは想定外なので、アサーションでしっかりバグを見つけられる状況にしておき、そのうえで `image` は `nil` にしておきます。リリースビルドのときにはこのアサーションは無効化されて検証はできなくなりますが、無効な `id` が入ってきたときに `image` は不一致が起こり得るので、`nil` にしておけば画像は表示されません。ただ、その画像が出るはずだと知っている人でなければ、画像が出ていなくても普通に動いているように見えるはずです。

`title` と `message` については、サーバーを信頼する方針にすると、さきほど決めましたよね。 サーバーからは、ちゃんとした近隣情報が来ているはずです。ID が不一致だったということは、クライアント側のデータに差があったのだろうということになります。ですから、クライアントからのデータに左右されるものは表示しないで、サーバーの情報だけを出す、ということがこれでできますよね。

また、デバッグビルドのときにはアサーションを出すようにしておけば、開発段階でサーバーから変な情報が来ていた場合にクラッシュさせて直すことができます。これは実運用前に不整合を潰すのに有効なので、ほぼ完璧でしょう。

ここで、ランドマークの情報が正しく取得できたときに、もう一つやりたいことがあります。ID から取れたときに、そのタイトルがシークレットの言葉なのか、そうでないのか、つまりタイトルが正しいかどうかも確認したいのです。これをするには、まずランドマークが取得できたら、もう一つ条件を追加して、`if let` でコンテンツのタイトルを取り出します（例: `if let Some(title) = content.title { ... }`）。

ここは効率化よりもクライアント側の一貫性を優先して考えます。パフォーマンスが気になるならキャッシュを入れればよいだけなので、今は簡単さを優先して多少犠牲にします。

タイトルがコンテンツから正しく得られた状態、つまりシークレットかどうかといった話ではなく確定した値が取れた前提で、そのタイトルとランドマークの名前が一致するかを確認します。これはサーバーの仕様にもよりますが、「サーバーは必ずタイトルにランドマークの名前だけをきっちり設定して送る」という仕様だとします。そうであれば、これをチェックに使えます。

ガードにするか少し迷いますが、今回は `if` で十分です。一致していれば正常、そうでなければ不整合としてアサーションエラーを出します。メッセージとしては「サーバーから送られてきたタイトルと、ランドマークIDから取得した名称が一致しません」とし、さらに `title` と `landmark_name` の両方をメッセージに付加しておくと、問題を認識しやすくなります（例: `assert!(title == landmark_name, "不一致: title={:?}, landmark_name={:?}", title, landmark_name)`）。

このようにして問題を確実に検出できるようにしておけば、ID から導かれたタイトルが異なる場合に、うかつに画像を送ってしまう、といった事態を避けられる、という話です。 なので、イメージはここは`nil`にして、これもデフォルトか……。このデフォルトのときは`break`したいですね。`break`でいいか、`break`にします。

こんなふうにして、タイトルはどうしましょうか。これはオプショナルですかね。かぶってましたね。かぶってましたか。だから、これはコンテンツのタイトルです。コンテンツタイトルで、ここはタイトルが`nil`だったときもここに行きますね。`nil`だったときどうしようかな。タイトルが`nil`のときは`nil`でいいか。だから、これでこんな感じですか。

この辺はログメッセージなので、そこまで厳密でなくても通じればいい、という感じですね。開発者に送るんでね、大丈夫ですね。これでイメージは`nil`でしょ、イメージ`nil`でしょ。`if image == nil`とかやってるけど、ここでイメージを設定し忘れたときは、`self`が検出できなくなってるんですよ。`self`を直接指定しても、これら全部オプショナルなので、これは嫌ですね。だから設定はしておきたいから、ここは確定初期化を使いたいですね。

なので、やることとしては、`didReceive`でコンテンツが得られてから、ここですね。ここで、タイトル・メッセージ・イメージで`return`。`return`してるから、これもいいか。だからこの辺からでいいかな。`let title: String`、`let message: String`、`let image: LandmarkImage?`というふうにして確定初期化したいけど、そうすると`switch`文と若干相性が悪いんですよね。同じ名前にしちゃうんで、これを消すと代入できなくなってくるから、タイトル、メッセージ、イメージ……この辺は名前をずらしていかないといけないんですよね。やばいですね。どうしようかな。もうちょっといい方法あるかな。`switch`でタイトルとメッセージを決める。

この辺、ちょっと関数に分けますか。どうしましょうか。そうすると、この辺はNotificationControllerの中で使うメソッドですよね。`extension`でこれに切り出しますか。`private extension`ですね。それでまずは、コンテンツからタイトルとメッセージを選ぶということですよね。これをするには、まずここまでカットして、ここで`titleAndMessage`。あまりメソッド名に`&`というのは付けないですけど、「1つの関数には1つの役割を持たせる」というのが基本原則。原則が正しいかどうかは別として、このほうがシンプルに書けるというのはあるので、あまり「タイトルとメッセージ」みたいにまとめないかもしれないんですけど、でもシンプルである状況だけを考えれば、普通にいっぺんに2つやってもいいとは思います。`&`が当たっちゃいけないとか、そういった問題ではないはずなのでね。

関数は`titleAndMessage(from content: UNNotificationContent) -> (title: String, message: String)`かな。こういうふうに返すようにします。これで、さっき用意していた`switch`のやつを持ってきてあげる。こうして`self`とか言わないで、この辺は全部ね、普通に、あとはもうタプルで返しちゃっていいですね。タプルで返しますか。これ、いっぺんに書き換えられるかな。まあ。 とりあえずやってみますか。これで選択は4箇所かな。まずは1箇所。こんな感じにして、不要なところは消していけばいいですね。消して、丸括弧でタプルを書いて消していって……ここの数は一緒かな。はい、一緒です。だから、メッセージ、あとはメッセージ……あ、上手くいきましたね。大丈夫です。これでいいですね。

こうしておくと、タイトルとメッセージをオプショナルではなく返せるのが大事です。つまり、このメソッドの中で `nil` にはなりません、ということですね。その上で、ここでするのはタイトルとメッセージの確定です。先ほどは確定初期化を使いましたけど、確定初期化を使わなくてもタイトルとメッセージは決められます。これはスタティックか……じゃあいいや。大丈夫です。イニシャライザだった気がしましたが、イニシャライザだとタイプメソッドしか呼べないので、その点は注意します。

これでコンテキスト……あ、コンテキストじゃない、コンテンツ（`content`）ですね。`content` を使うと、タイトルとメッセージが確実に決まりました。これでOKです。

この要領で、ランドマークIDからイメージも同じように決めます。`titleAndMessageFrom...` みたいな名前は少し変ですね。コンテンツが持っている情報からタイトルとメッセージを作っているので、シンプルに「取る」というより「作る」感じです。なので `makeTitleAndMessage(with: content)` のような名前が良さそうです。`makeTitleAndMessage(with content)` の方がしっくりきますね。同様にイメージも同じ付け方ができます。

ということで、ランドマークIDを取って……この辺までかな。まあ全部持っていってしまいましょう。先に書いておきます。ここに `image = makeImage(with: content)`……ちょっと名前が微妙な気もしますが、上はOKです。イメージは「作っている」ので、`makeLandmarkImage` にしましょう。`landmarkImage` だと名詞っぽくて曖昧なので、`makeLandmarkImage` にします。少しうるさい名前かもしれませんが、これでいきます。

この変更で、ランドマークIDはいつの間にか引数としてはいらなくなっています。ここで既存の `landmarkImage` は非推奨（deprecated）にして、新しい `makeLandmarkImage` を使うようにします。`makeLandmarkImage` メソッドを下に追加します。`func makeLandmarkImage(with content: UNNotificationContent)` のように書き、戻り値はランドマークのイメージですが、得られないこともあるのでオプショナルにします。`content` を受け取って、まずはランドマークIDですね。この辺は `guard let` で一発です。`guard let landmarkID = content.landmarkID else { ... }`。これが取れなかった場合は、`assertionFailure("landmarkID が指定されていません")` として、安全のため画像は表示しない、という選択にします。

安全のため、何でも置き換えればよいわけではありません。先ほども言った通り、確信が持てない状況のときには画像を表示しないことで、さらっと話を済ませます。 そういう話の済ませ方ができないときには、ここがフェイルになりますね。ランタイムでおかしなことは起きないので、ひとまずこれでOKです。

まず、入れ替わりで突き進んでいける状況にしつつ、ランドマークIDは取れました。そうすると、ここでスイッチフラグが逆になっていました。ここに入れている可能性はすでに排除されているので、次の話に進めます。

次の話は何かというと、「ランドマークはモデルデータから取らないといけないのか」という点です。では、モデルデータはどこから取ればいいでしょう。`LandmarkWithContent` でランドマークをどう渡すか、という問題があります。ここが元々ダメなんですよね。とりあえず、ランドマークの情報をここでデフォルトイニシャライザで作っているのですが、ここでデフォルトイニシャライザで作られても困るところがあるじゃないですか。

データは今どこに持っていましたっけ。アプリケーションが持っていた気がするんですけど、ランドマークが…。ランドマークが持っていますね。`private var modelData`、プライベートな変数でモデルデータ。これを渡したいのですが、これを渡せるには、そいつとUIがどう連携できるんですかね。UIとかアプリケーションで良かったじゃないですか。`UIApplication.shared` とか。`UIApplication.shared` はありますね。でも `LandmarksApp` は取れなさそうですよね。取れる……いや、取れないか。`UIApplication.shared` はクラスプロパティで取れますが、ここからは取れないですね。

どうしようかな。この両方、つまりモデルデータはここで一元管理されているわけで、これは取らないと本来ダメじゃないですか。そうすると、モデルデータを誰が管理するか。モデルデータを `LandmarksApp`、つまりアプリケーションで管理しますよね。アプリケーションでやるとするとデリゲートが持つ感じ。`Environment` でモデルデータを渡しているか。モデルデータは渡しているけれど、これは `State` で管理しないといけない。なるほど。

もしかして、すでにコードの管理の仕方が、通知を想定していないように見える気がしてならないんですよね。この中で、モデルデータ内のデータを書き換える可能性があって、書き換えたとしてお気に入り（Favorites）を書き換えることになるわけですが、このデータは永続化していないですよね。永続化だけならまだいいんですけど、なんだこれ、やばいじゃないですか。データが一元管理されていないのか。だから、工夫しないといけないですね。これはちょっと後回しです。

なので、このモデルデータで何かしないといけないことが分かったのですが、一応カットして、さっきの箇所に持っていきます。ここら辺、アプリ側の話かな。これはもう完全に FIXME ですね。情報、つまりモデルデータをこのアプリ内で共有し、共通のものとして扱う必要があります。モデルデータをこのアプリ内で……なんて言ったらいいんだろう、アプリ内で保持しているもの。日本語がまた変ですけど、保持しているものをちゃんと持たないといけない。ここでですね、ここでモデルデータは抱えないといけないのに、ここでインスタンス化している。やばい。なんかすごくやばいです。 とりあえずこれでいきます。モデルデータからランドマークの配列を取り出し、IDによる検索をかけます。ここも`guard`でいいのかな…`guard`でよくなりましたね。これ、`guard let`です。ランドマークが見つからなかった場合には、`assertionFailure`ですね。メッセージとしては「Landmark ID のランドマークが見つかりません」…日本語が変ですね。「`landmarkID`のランドマークが見つかりません」のほうが自然ですが、これでも日本語力がやばいです。IDは`landmarkID`です。どこで見つからないのかというとモデルデータですけど、ここはいいや、とりあえず進めます。

この場合も、画像を表示しなければ済むだけなので、継続できないときは`fatalError`で落とす、という方針でOKですね。そうすると、これでランドマークが見つかったという前提になるので…ガードが多すぎるけれども、これはアプリケーションならしょうがないですからね。

ランドマークのIDが見つかったときに、さらに矛盾がある可能性が怖いので判断します。要は、イメージを取るときに、まずIDがあること、そしてそのIDに合致するランドマークが得られたこと、かつコンテンツで渡されたタイトルとランドマークの`name`が一致すること。このいずれかが満たされないときにも、安全のため画像を表示しないという選択にします。これでかなり安全ですね。こういうのは考えていくのが重要ですよ。

これで条件がそろって、完全にランドマークが期待どおりのものだという確証が得られたので、この段階で一旦、ランドマークのイメージを取りにいきます。`landmark.image`のようにしてあげれば、完全に適切なイメージが取れました、というね。タイトルやトピック周りにまだ詰めが残っていますけどね。

これで切り回した後になると、この辺はもう不要ですね。`didReceive`した後にコンテンツを取って、そのコンテンツから`title`とランドマークイメージが取れました。そうしたら、もうこれで終わりです。これでいいですね。

もしこのあたりの設定を忘れないように、しっかりやりたかった場合には、確定初期化を使って、例えば3つを全部ローカル変数にしてしまって、最後に`self.title = ...`みたいな感じにしていきます。`didReceive`か、これでいいですね。大丈夫、パターンマッチです。パターンマッチの中でも、いわゆる失敗しないパターンマッチというのが、その中で4種類くらいあったと思うんですけど、それを使って代入していく。こんな感じで、プロパティにもできちゃうというのも、なかなか面白い工夫ですよね。これと一緒ですけど、これも識別子パターン（アイデンティファイアパターン）で代入しているだけなんでね。はい、こんな感じ。これで`didReceive`はOKですね。

この辺に残っているのはもう残骸ですよね。たぶん`userInfo`を取ろうとしていたときの残骸なので、これはもう消してしまえばよいか。これでできた。できましたね。できたけど、どこまでできたか…ビルドをしないとちょっと忘れているという状況ですが。

これで、この辺が変換できない。IDが変換できない。このIDがおかしいですかね。`landmarkID`が間違っていますね。`landmarkID`。これで全部できたと。これでビルドをかけて実行するまでできるんですかね。これは大丈夫ですね。シミュレーターの実行するタイミングを切り替えますが、これでOKと。リビルドで、これでシミュレーターが動きました。動いて、これをホームに戻した上で通知のテストを投げてあげると、なんと1つのパスで落ちました。`fatalError`で落ちましたね。`title`が`nil`で、`name`が「シルバー・サーモン・クリーク」か。ランドマークは…コンテンツはコンソールに出しておきました。 `userInfo`からアラートのタイトル、`aps`のアラートのタイトルが間違っていました。アラートタイトルのバグですね。アサーションがコードのミスを教えてくれていて、単に自分のミスをしていただけでした。アプリを起動してフォアグラウンドに戻すと、通知が表示されていて、無事に動いてくれましたね。

こんな感じでリファクタリングを進めてきましたが、時間の都合で今日はこのあたりにしておこうと思います。ただ、まだリファクタリングする価値は残っていそうな気がします。`NotificationController`はしっかりリファクタリングできた感触がありますので、あとは`FIXME`が残っているところでしょうか。モデルデータをどうするかという状況になっていて、「お気に入り」を管理しないといけない状態です。

バインディングがアプリのライフサイクルに依存している感じがあるので、ライフサイクル内で何とかしないといけません。そうなると、どうするのが良いのでしょうね。シングルトン？ シングルトンで何かできるのでしょうか。そのあたりはもう少し考えないといけません。DI（依存性注入）ですかね。そうですね。

次回は、このあたりの見通しを立てつつ、モデルデータを何とかすること、そしてApple Watch周りでリファクタリングが必要な箇所が残っていないかを見ていこうと思います。では、これで終わりにします。お疲れ様でした。
