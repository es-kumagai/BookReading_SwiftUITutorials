Transcription & Summarize : とりあえず読書会 SwiftUI Tutorials #54

はい、ではというわけで配信を始めていきましょう。SwiftUI のチュートリアルで完成したコードを、リファクタリングという感じでいろいろ見返してみたいと思います。だいぶ終わりに向けて進んできていますが、今日も早速コードを見ていきます。

今日は `LandmarkSettings` のところですね。残りのソースも少なくなってきています。ここで少し気になっているのが、文字列リテラルの扱いです。今どきのプログラミングだと、こういった文字列リテラルは定数として定義しておきたい、という気持ちが出てきます。打ち間違いをなくせますし、見通しも良くなりますからね。

ただ、今回の場合は文字列定数がある中で、さらにプロパティが定義されていますよね。ここはプロパティラッパーを使っていて、すでにうまくまとめられているので大丈夫そうです。`@AppStorage` は Swift マクロより先に入った機能で、こういった繰り返しを楽にするための仕組みでもありますし、標準のプロパティラッパーで十分に整理されています。`private var` でカプセル化されているのも良いですね。

次に `body` を見ていきます。`Form` があって、`Picker` があり、バインディングは `zoom` に向いています。`ForEach(MapView.Zoom.allCases)` のように、`MapView.Zoom` が `CaseIterable` に準拠しているので `.allCases` を使って列挙できています。選択肢の表示は `Text` で問題ありません。

プレビューを表示しようと思いましたが、キャンバスの設定次第でうまく動かないことがあります。以前はキャンバスの「Legacy Preview Execution」をオンにするとマップのプレビューが出ることもありましたが、今回は無理に使わずに進めます。

`Picker` のラベルや行の中身について、もう少し楽をするなら、`Text` に `MapView.Zoom` を渡すためのイニシャライザーを用意してあるので、ここは1行で書けます。もちろん、必ずしもその方が良いとは限らず、可読性はケースバイケースです。ラベル構文でも良いですし、クロージャを渡す書き方でも良いでしょう。こうした「関数に関数を渡す」書き方は高階関数とも言いますが、Swift では一般的になっています。今回は `MapView.Zoom` を受け取るイニシャライザーが特定されていて間違いにくいので、省略記法でも問題はないと思います。些細な差なので、好みで選んで良いでしょう。

全体として、`Form` → `Picker` で各行に `Text` を出していて、`Picker` のスタイル指定、`frame`、`navigationTitle`、`padding` といった修飾も素直で、`LandmarkSettings` はこれで大丈夫そうです。

SwiftUI は「値としての `View`」があちこちで活用されていて面白いですね。`View` があって、`body` があって、その中で組み合わせていくという流れです。例えば、ある `View` に対して `.backgroundStyle` を指定する場合、これは `ShapeStyle` を受け取りますよね。このあたりで「型消去（type erasure）」が必要になるケースを連想して、「`AnyView` ってどういうやつだっけ？」となることがあります。

`AnyView` は `View` のタイプイレイザーです。`struct AnyView` で、`View` を受け取るイニシャライザーがあります。ドキュメントを見ると、`AnyView(_:)` と `AnyView(erasing:)` の2つが並んでいて、どちらも（少なくとも表示上は）同じ時期から使えるように見えます。`erasing:` の方は「型消去して包む」という意図を明確にするための名前付きイニシャライザーで、実質的な差はありません。なお、`.backgroundStyle` が受け取るのは `ShapeStyle` なので、こちらの型消去が必要な場合は `AnyView` ではなく `AnyShapeStyle` を使うのが適切です。

ここは一度書いたコードをいったん消して、プレースホルダのまま「完成」としておきます。`EmptyView` を使っておく、のような形でも良いですね。とにかく、型消去の意図や対象を取り違えないようにするのがポイントです。 いま、`backgroundStyle` の話に戻ります。`Color` で指定したりできますよね。`Color` はあくまで `Color` 型であって、`ShapeStyle` そのものではありません。ただし、`Color` は `ShapeStyle` に準拠しているので、`ShapeStyle` を受け取るところに `Color` を渡せる、という関係になっています。

ここで、たとえば `Color` を普通に拡張して、`extension Color { static let dummyColor: Color = ... }` のように `static` な色を増やしたとします。このとき、`backgroundStyle` の引数位置でドットを打っても `.dummyColor` が補完に出てきません。`dummyColor` は `Color` に定義されているので、`Color.dummyColor` と書けば使えますが、引数が `ShapeStyle` のときにドットから始めて補完させる、という使い方はできません。

では `ShapeStyle` 側を素直に拡張すればよいかというと、それでも補完には出てきません。戻り値（あるいは要求される引数）の型がはっきりしている状況では、その型に所属している静的プロパティがドットからの補完候補に挙がる、という特徴があるためです。`backgroundStyle` が受け取るのは `ShapeStyle` なので、`Color` にだけ拡張を追加してもダメですし、`ShapeStyle` をただ拡張するだけでもダメ、というわけです。

そこで、少しひねったやり方として、`extension ShapeStyle where Self == Color { static var dummyColor3: Color { ... } }` のように、`where Self == Color` を付けて `ShapeStyle` を拡張します。こうすると、コンパイラは「`Self` が `Color` のときの `ShapeStyle`」と「`Color`」を同一視できるので、`backgroundStyle` のように `ShapeStyle` を取る位置でドット補完を開いたときに、`.dummyColor3` が候補として出てきます。実際、これは通りますし、補完にも出てきます。

逆方向、つまり `Color` 側から `where Self == Color` のようなことはできません。あくまでジェネリックな制約表現として、`ShapeStyle` を `Self == Color` で絞ったときに成立するテクニックです。

この方法を使うと、`backgroundStyle` が `ShapeStyle` を取るコンテキストで、`.foregroundStyle` や `fill` の `ShapeStyle` 引数の場面と同様に、`Color` ベースの拡張プロパティも含めてドット補完に出てきます。候補はたくさん並びますが、出ないよりはずっと便利ですよね。 リゾルブドとかいうのが出てきたのですが、これは関係ないですかね。なぜ出てきたのかはよく分からないので、ひとまず置いておきます。

とりあえず、ブラックとかも候補に出てくるんですね。なぜ出てくるのかというと、ブラックは `Color` だからです。ここにちゃんと書いてありますが、`ShapeStyle` に対して拡張して、ブラックなどを追加しているのですね。つまり、すべての色が出てくるわけではなく、`Color` 側で拡張したものが `ShapeStyle` として候補に出てくる、ということです。

こんなふうに SwiftUI が対応していて、`ShapeStyle` に拡張を施すことで、補完が良い感じに効くようになります。かっこいいなと思いました。最終的に「型から埋める」設計にして、バッジシンボルやエレベーション、タイポグラフィ、ラベルなど、こういった要素をすべて `ShapeStyle` に対して拡張しました。これによって無駄なコードが減り、書きやすさも可読性も上がります。SwiftUI を触るうえで、これはさりげなく重要だと思います。

色のバリエーションを増やしたいときは、`ShapeStyle` の拡張として追加し、その際は必ず `Self == Color` として同値制約を付けます。他も同様で、`ShapeStyle` に属するパターンを `static` プロパティで定型的に選べるようにしたいなら、`ShapeStyle` を拡張して「`Self` がこのパターンですよ」というのを明示するのが良いです。こうしておくと、見通しが一気に良くなります。

例で使っていた色については、ドキュメント上の色名に合わせて名前を付けたので、すでにここはリファクタリングが終わっている状態です。`ShapeStyle` 周りはこれで問題なさそうです。

次に、システムイメージ型です。これはこの前、リファクタリングの中で作ったばかりのものですね。システムイメージを `String` の `rawValue` に持つ型（たとえば `enum SystemImage: String` のようなもの）です。これを使って `Label` を生成するイニシャライザを用意し、`Image` も取れるようにしてあります。

`Image(systemName:)` に渡すとなると、どうしても `rawValue` を渡す必要がありますよね。システムイメージ型をパラメータに使うと、結局毎回 `rawValue` を取ることになるので、それなら最初から API として載せておこう、という発想です。たとえば `Label("タイトル", systemImage: systemImage.rawValue)` と毎回書く代わりに、`Label` 側にシステムイメージ型を受け取るイニシャライザを足しておく、ということですね。

普遍的な処理は、最初から気軽に載せてしまう、という感覚を持つと、使う人がとても書きやすくなります。こういった考え方は一般にプロトコルでやることが多いと思いますが、今回のような型（イメージ型）でも同じです。システムイメージという型で取り扱う以上、最終的には `rawValue` を渡すのが普遍的に起きるので、あらかじめ API を増やしておくのが賢いやり方な気がします。

これをやらないコードも多い気がしますが、やらないと毎回 `rawValue` と書くことになって、同じことを繰り返してしまいます。そこは素直に抽象化して、コードに落とし込むのが良いでしょう。そんな感じで、システムイメージもこれで OK、普遍的な設計になっていると思います。問題ないはずです。 文字起こしテキストを貼り付けてください。  
指示に従って、ですます調に整え、句読点を補い、誤変換を修正し、コードはバックティックで装飾します（短いものはインライン）。複数人の会話でもセリフ表現にはせず、内容を踏まえた通常の文章にします。不完全な冒頭は無視し、要約はしません。テキストの一部だけでも問題ありません。 まあ、とりあえずこれでエッジケースに対応したい人もいるかもしれないですが、ここでね、`ImageConvertible` みたいなものを作る手もあるかもしれません。ただ、今回はそこまではいりませんし、そういうものを付けるとややこしくなるので、このままのほうが良いと言えると思います。そんな感じでOKですね。ここもきれいにできています。

次は Transitions です。Transitions は必須という話ではないですね。`static var` の計算型プロパティで、`moveAndFade` のように2つのトランジションを組み合わせたものを用意しています。`asymmetric`（挿入と削除で異なるトランジション）で、`insertion` と `removal` を指定する形ですね。

ここでエラーが出ています。`static` プロパティの `moveAndFade` は並行安全ではない、という指摘です。Non-Sendable な型である `AnyTransition` をミュータブルな状態を通して扱おうとしている、という趣旨のエラーですね。`AnyTransition` は struct です。これに対して `@MainActor` を付けることで、`moveAndFade` の評価全体がメインアクター上で行われるようになります。そうすると、この変数への代入は安全になりますが、その代わりに `moveAndFade` はメインアクターからしか呼び出せないという制約が付きます。

ただ、`moveAndFade` はUIでしか使っていません。これを踏まえると、`@MainActor` を付けるのは現実的な対応だと思います。

もう一つの回避方法としては、並行安全チェックを無効化するというやり方があります。具体的には `nonisolated(unsafe)` を使います。これでコンパイルエラーは解消しますが、安全性はプログラマーが担保しないといけません。今回の場合、実際に `moveAndFade` を呼んでいるのはメインアクターからだけのはずなので（念のため検索すると、`BikeView` の1箇所だけです）、`View` の `body` の中で使っている限りは必ずメインアクター上で初期化・利用されます。つまり、この動画の中での使い方であれば問題ありません。 これなら問題ないので、安全に保護されているから `nonisolated(unsafe)` でもOK、という判断はできます。しかし今後、もし `moveAndFade` をメインアクター以外から呼んでしまうと、厄介な問題になることがあります。そこを恐れるなら、最初からメインアクターで保護して、この `moveAndFade` にはメインアクターからしか手を出せない状況にしておくことで、絶対に安全だと言えます。

さらに、これは静的に保持するので、基本的には静的領域に一箇所メモリが確保されて、`AnyTransition.asymmetric` などで作ったインスタンスの値がそこに置かれる感じですよね。それを使い回すことになるので、`asymmetric` をその都度計算型プロパティで作るより、多分速いのではないかという気がします。今回は `static let` で行きましょう。メインアクターで保護しましょう。これで良いでしょう。

こういう保護の仕方の例としては、`AnyTransition` 自体をメインアクターで保護する方法もありますし、どちらでも良いのですが、今回は extension の方法にしておきましょうかね。そのほうがスッキリする気がしますし、結局このトランジションを増やすことになったときに、この方針で行くならメインアクターを付ければよいだけです。計算型プロパティで行くなら `nonisolated` のままで、`Sendable` でなくても `nonisolated` な文脈に対して返す、という形にもできます。ただし呼び出し側の機能によっては問題になることもあるので、その点は注意が必要です。ということで、今回はこれで良いですね。これで初期化の回数も省略しつつ、メインアクターで保護して並行安全も担保でき、パフォーマンス面でも問題ないはずです。

次に、`print` 関数のように値を返す機能を `ViewBuilder` の場に入れ込めるようにするための実装です。デバッグのときだけ利用できるようにする、といった用途ですね。マクロが好きかな、まあこんな感じ。そのために作ったんですよ。何かというと、`ViewBuilder` に対して `static func buildExpression` を定義します。これは、ある値が `ViewBuilder` のブロック内に書かれたときに、その式の評価後の値が指定した型だった場合に、どういう変換を行うかを定義できるものです。

`ViewBuilder` は result builder（`@resultBuilder`）として作られています。result builder では、`buildExpression` で任意のコンテンツを受け取って同じコンテンツを返す（コンテンツは `View`。`View` を受け取って `View` を返す）という形のものがあります。同じ型を取って同じ型を返すので、表向きは何をしているのか分かりにくいのですが、裏でいろいろやっているのでしょう。こうした一つ一つを解釈するのに加えて、`buildBlock` もあります。

`buildBlock` は、波括弧で括ったブロックの中身が空だったときに `EmptyView` に置き換える、という実装になっています。さらに、`buildBlock` でコンテンツが `View` の場合、つまりブロック内に `View` が1個だけあるときにはそのコンテンツをそのまま返します。複数個ある場合についても別々に用意されています。これらをわざわざ分けているのは最適化のためでしょう。シングルビュー、子ビューなど、何も変更しないで返すケースを専用化しているのだと思います。そうでなければ、次の汎用の形だけで良いはずです。

汎用のほうは、`buildBlock` でブロックの中が `repeat each Content`（可変長引数のように受け取る形）になっているものです。ここでいうコンテンツは `View` プロトコルに準拠するさまざまな型で、ばらばらで構いません。そういった条件の中で、それぞれのコンテンツを `repeat`、つまり可変長引数的に受け取って扱う、というわけです。 様々な型のビューをここにいくつでも置くことができて、それによって `TupleView` を返す、というものを作っています。最終的には、これは何を返すのでしょうか。`@ViewBuilder` は `buildExpression` と `buildBlock` を使ってコンテンツをまとめ、戻り値を決めます。つまり、最終的には `Content`、または `TupleView` を返すことになります。では、最終結果はどうしているのでしたっけ。`@ViewBuilder`（Result Builder）は、最後は `buildBlock` でまとめ上げて結果を返すのだと思いますが、このあたりは適用される `buildBlock` によって挙動が変わります。

例えば、ある関数だけを `@ViewBuilder` にして、戻り値の型を `some View` にした場合、`some View` は抽象化された戻り値なので何でも返せます。ですから、そこで `EmptyView` を返すことも可能です。しかし、戻り値の型を `EmptyView` にしておいて、中身が複数のビューになった場合はダメになります。Result Builder には「要素が1つだけのときはそのコンテンツをそのまま返す」というルールがありましたよね。つまり、コンテンツが1つのときはそのコンテンツ自身を返します。

ここが `EmptyView` ではなく、例えば `HStack` にこういったものを渡してみると、エラーになります。`HStack` のコンテンツからは `EmptyView` を返せない、という感じで良いと思います。ブロックが空のときは、当然 `EmptyView` を返すのが普通なので大丈夫ですし、例えば `Text` を置いた場合には `TupleView` になります。つまり、`TupleView` から `EmptyView` にはできません。要するに、どの `buildBlock` が適用されるかによって、最終的な型や挙動が変わってくる、ということですね。 ただそれだけじゃなくて、ビルダーは `buildExpression`、`buildEither`、`buildFinalResult` といったメソッドのパスを順に回して最終形を作ります。これを適用すると、例えばコンポーネントが `HStack`……いや、`HStack`だと分かりにくいですね。`Text` のほうがいいでしょう。`Text` はこんな形ですね。これで良くて、ここを `EmptyView` みたいな形にしても問題ありません。とにかく「これはどういうものか」という点で、`buildFinalResult` とか `Text` とかが関係してきます。

例えば、要素が2個あるときに `buildFinalResult` が一度も適用されずにエラー、という状況もあり得ますが、`Text` が1個だけになると、ここ（空のところ）は何も書いていないので `EmptyView` になります。`buildFinalResult` や `EmptyView` のように最終形が指示されているので、ビルドブロックで出来上がった最終形を `buildFinalResult` でデタッチするメソッドがあれば、これに変えてくれる、ということですね。これを活用すると、`ViewBuilder` を拡張して「`Text` のビューだけ捨てる」といったことも理屈の上ではできなくはないです。ただ、そんなことは普通やらないと思います。最終結果のうち `Text` のものだけを捨てる、というようなことはできても、あまり応用はなさそうですよね。

そんな感じで、`ViewBuilder` もいろいろと面白いのですが、同じノリで「エクスプレッションがブロック」つまり、最初にコードに直書きしたものが `buildExpression` の対象になります。ここに応用があると `EmptyView` を返すかもしれない、という話です。`EmptyView` でいいんですけどね。`nil` のほうがいいかなと思ったんですが、`nil` だと普通に `EmptyView` にできるんじゃないかな……やってみますか。`@ViewBuilder` で `func something` を書いて、戻り値を `EmptyView` に固定した上で、その中で `nil` を返す。こうすると、`nil` はそのままでは型付けできないので、`Text?` にしてみますか。すると「`Text?` から `EmptyView` にできない」と言われました。`Text?` として認識して返すんですね。`nil` をどう扱うのか、という話になるので、ここは `EmptyView` でいいんでしょう。この式は何も返さないと思うので、こうすることによって「`Void` を返す関数を使った場合には `EmptyView` に置き換えてくれ」という振る舞いにできます。

これによって例えば、`Text("1")` と `Text("2")` があって、この間で何かを調べたい、という場合です。`Text("1")` と `Text("2")` の間に `if` を書いて、ランダムなどある条件を満たした場合には `Text("A")`、それ以外なら `Text("B")`、みたいな分岐を書いたときに、「今回は A と B のどっちに行ったのかな」を知りたいときがありますよね。そこで `print` を挟みたいのですが、普通の Swift だと `print` は `Void` を返すので、そのままでは書けないと思うんですよ。`ViewBuilder` 側でそれを書けるようにしている、というわけです。これがないと、ここはエラーになります。「`Void` は `View` に変換できない（準拠していない）」と怒られます。`Void` を拡張するわけにはいかないので、Swift の仕様で「ノンノミナル型（タプルなどの名義を持たない型）は拡張できない」と分かっています。`Void` は `()` の型エイリアスでノンノミナル型なので拡張できません。拡張できてしまったら影響が大きすぎますしね。そこで、`ViewBuilder` に対して「`buildExpression` が `Void` を想定する」ようにして、`Void` だったら無視する（`EmptyView` にする）。普通、`Void` は無視しますよね。そういう仕組みによって、いい感じに書けるようになっています。

`fatalError` はダメなんじゃないかな……と思ったんですが、ここは大丈夫なんです。そうだ、`Never` がポイントでした。`fatalError` は `Never` を返しますが、`Never` は `View` なんですよね。SwiftUI のどこかに書いてあったはずで、SwiftUI で `Never` を検索すると出てくると思います。`ImmersiveSpaceContent` とか、その辺のところに名前が見えたりします。とにかく、`Never` ってすべての型のサブタイプ（ボトム型）として扱われます。どんな型に対しても `Never` は適用できる、ただし実行時には落ちますけどね。なので、「`View` を取るところにも `Never` を渡すことができる」わけです。ソースコードそのままだと渡せないので、このプロトコルにちゃんと準拠させて、`Never` も `View` として扱えるようにしましょう、というやつです。実際、`Never: View` の準拠が用意されているので、「`Never` を返す関数（例えば `fatalError`）であれば、`ViewBuilder` に入れることが可能な `View`」という扱いになります。ということで、`fatalError` は大丈夫なんだ、という理解で合っています。なるほど。不思議ですよね。`Never` って後からできた型だったかな、最初からだったかな……まあ、どうでもいいか。ポイントは「`Void` は拡張できないのに、`Never` は拡張できる」という話ではなく、`Never` はノミナル型なのでプロトコル準拠させられる、ということですね。 とりあえずこれで、`static func` の…みたいな形にして、`Int` の回数用、実際の回数として `Int` を使う、という感じにしておきます。`Never` を返すようにアノテーションすることもできますよね。できますが、トップレベルではできないよと言っているだけで、どこかの型に対して書けばできます。たとえば、こんな感じで書けますよね。

`Never` はノミナルタイプなので、拡張できちゃう感じがします。で、`fatalError` についてですが、例えば `static func` の中で何かを処理して、最後に `fatalError` を呼ぶとどうなるでしょうか。そうすると、その関数は実行されないようになります。`fatalError` を呼んだ時点で処理が中断されるので、結果として絶対に到達しない関数、実行ができない関数ができた、というだけですね。呼び出し自体は書けると思いますが、いずれにしてもそこで止まります。

とにかく、こんな感じで `print` を入れたり、いわゆるプリントデバッグという手法を、SwiftUI でもデバッグモードくらいでは使いたいよね、ということでやってみました。これはこれで OK ですね。コードとしても問題ありません。

次は、`LandmarksApp`。こちらは `@main` 属性を付けた `struct` で、`App` に準拠しています。`@State` は private にしておきます。`body` は `some Scene` で、`WindowGroup` のコンテンツに `self.modelData` を渡します。iOS や macOS の場合には、コマンドメニュー（`.commands`）を追加します。

watchOS のときには、`body` の中で `WKNotificationScene` を使います。Apple Watch に通知が来たときのための `NotificationController` の登録ですね。このあたり、category が文字列リテラルなのは少し気になります。今は category を `"LandmarkNear"` にしていますが、これは何カ所かに出てきます。エラーや実際のデータ側にも出てきますね。なので、見つけやすい場所に置いておいたほうが本来は良さそうです。WatchKit の Notification の category です。

`#if` が増えるのは微妙に気になりますが、例えば次のように `static let` でまとめておくのが良いでしょう。`Notification` の category を表す名前を一箇所に集約しておけば、コードの中を探し回らなくても、代表的なところで名前を変えられるので、仕様変更のときにもやりやすいですし、もしこの `"LandmarkNear"` を複数箇所で使う場合にも、そこで引っ掛けられるので良いです。生の文字列を直接渡さず、専用の型で表現する方法もあるかもしれませんが、今回は category がひとつだけなので、やり過ぎかもしれません。とはいえ、ひとつだけでもやっておく価値はありますね。

`#if` で分岐して、`UserNotifications` 側（`UNNotificationCategory`）と WatchKit 側の両方で同じ category 名を参照できるようにしておけば、将来的に共通化や比較もしやすくなります。名前は例えば `UserNotificationCategory` のようにしておくと分かりやすいでしょう。いずれにせよ、`NotificationController` で使う category 名を一元化しておく、という話です。 なので、シーンコントローラー、ノーティフィケーションシーンでコントローラーカテゴリー、というところまでで十分ですね。これはこれで良しとしましょう。あとは分かりますかね。ここは大丈夫ですよね。OKです。

で、OSだった場合には設定画面を追加してあげる、ということです。OSによっていろいろと細々した拡張が必要になっているのが気になるのですが、これはしょうがないですね。プラットフォーム共通であることがポイントなので、このくらいの差はやむなしという気がします。

では、そんな感じで `Range` だけ見て終わりにしちゃいますね。ちょっと見ておきますか。これが拡張が必要なんですよね。`Range` の `Bound` が足し算できるときに、`Range` で中間値を取れるようにする、みたいなものをちょっと使いたかった、という感じです。`AdditiveArithmetic` でいいですかね。少し汎用的すぎるかなという気もしなくはないのですが、絶対値が距離、要はディスタンスですよね。どちらかというと「ディスタンス」ですね。`magnitude`（マグニチュード）という名前にどこまでかかっているのか、なんだかマグニチュードっぽくないなとふと思いました。

それで、オーバーオールの `Range`、つまり全体を包含する最小の `Range` を求めます。`lowerBound` と `upperBound` を使ってオフセット、軸のオフセットを作って、それをマグニチュード、あるいはディスタンス（距離）として扱う。まあ、絶対的な量なのでそれでよいですかね。多分、`Range` の `lowerBound` とオーバーオールの `Range` を使うパターンは `Double` ですよね。`Double` に限定するという手もありますが、`magnitude` でよいかなと。汎用にするなら `AdditiveArithmetic` にしておけば、`Int` も `Double` も普通の数値全般が使えます。ただ、ここでは実際には `Double` でしか使っていないので、これはこれでよいですかね。`magnitude` でいきましょう。

あとは、`Sequence` で `Element` が `Range<Double>` だったときの、プロパティの `enclosingRange` というやつです。これは、複数の `Range` が定義されているときに、それらすべての範囲を包含する最小の範囲を取る、計算用のプロパティです。本当はもう少しジェネリックにしたかったのですが、`Element` 周りで十分ジェネリックにできなかったんですよね。これで良いのか、というのが最後の話題になるので、確認して終わりにしますか。

実装はイテレーターでやっています。最初の要素が取れなかったら、そもそも無効な値を返す（早期リターン）ようにしています。それ以外なら、最初の `Range` の `lower` と `upper` を確保した上で、イテレーターを回せる限り回していって、`lowerBound` の最小値と `upperBound` の最大値をそれぞれ更新していき、最後に `min` と `max` を組み合わせて完成、という流れです。

この中で、`Element` を `Range` にして上では `AdditiveArithmetic` みたいなすごく汎用的な制約を付けている割に、下側ではどこかで `Double` を明記しているんですよね。ここに違和感があって、何とかしたいのですが、この `min`/`max` は何を要求するのでしたっけ。`min`/`max` は `Comparable` を取ります。ということは、`Range` の構成要素である `lowerBound` と `upperBound` は `Comparable` であればよい、つまり最終的には「比較できればいい」わけですよね。 なので、シーケンスで要素がレンジですよね。どうするといいのか。要素がまず、イテレーターの`next`、レンジ、レンジ。レンジはイテレーターで、`next`は自分自身に対して呼びますね。その後は、`match`は、あ、いいな。それで、レンジですよね。要素はレンジですよね、まずね。レンジ。

レンジにはレンジエクスプレッションがあるんですけど、これ、ロアーとアッパーが確かないんですよね。ロアーとアッパーがあればいいんですか。あれ、reverseとコレクションでreverseを見てますね。レンジは、あれ、定義がちゃんと辿れてないのか。なるほど。これはダメなんですよ。レンジ、えーと、そう。なので、レンジですよね。

シーケンスで要素がレンジであって、その要素、だから、なんだろう。えーと、要素がレンジエクスプレッションなのは間違いないですね。ここまでは書けますよね、とりあえずね。レンジエクスプレッションの定義を辿りたいけど出ないなら、こっちを決めた方が…レンジエクスプレッションで出てきますかね。レンジエクスプレッションが求める要件は、パターンマッチング、エクスプレッションパターンと、バウンドが比較可能。もう比較可能ですね、とにかくね。それで、`contains`ですね。リレーティブ、そうそう。リレーティブと`contains`しかなくて、リレーティブの動きを、これは自分が理解してないだけですね。まあ、とにかくリレーティブだって変換しないといけないという、そういった問題がちょっとあって、そうなると、リレーティブ2のための…2のCが、何にも書いてない気がするけど、コレクションですね、これね、Cね、コレクション、コレクションですね。インデックスがバウンドと一緒。まあ、よく分からない。インデックス、そうね。

まあ、この感じで、ちょっと変換のために対策するための値が必要で、それが情報ないわけですよね、これね。なので、ちょっと困ったなーという。ロアバウンドとアッパーバウンドというのが、これ、レンジの機能なんですよね。なので、`continue`使うわけにもいかないですしね。こんなことを思うと、レンジエクスプレッションでレンジですよね。これで要素がレンジだったとしても、ここをジェネリックに汎用的にしていったらいいなーと思ってたんですけど、ここがダメそうですかね。シーケンスで、えーと、`where`ですよね。だから、うん。ダメですよね。他の方法もあるかな。まあまあ、いいか。

これが例えば、またレンジエクスプレッションしかなくなると、ロアバウンドとか、この辺のリテラル変換、この辺がダメになっちゃうんでね、もはや成り立たないんで、なんとかレンジを出しないといけないんですけど、これで例えば、そうですね、ジェネリックにわざわざする必要ないんですけど、するとしたら、トレイト境界を追加ですかね。トレイト境界で、えーと、なんだろう。 まず、名前を思いつかないときにカスタムレンジにしましょうか。このカスタムレンジは、レンジエクスプレッションを求めることを目的としています。コードでは、`let lower_bound`や`let bound`という変数を使います。そして、`let range_bound`のようにバウンド型を設定し、その上で`impl`を用いてカスタムレンジに対しての処理を書くことになります。

例えば、アダティブアリスメティック演算を行う場合の条件や、比較可能という特性を持たせることになります。リテラーションの使用法では、`where`句を使わないといけないケースがありますね。`impl`のところで、バウンドとローカルレンジエクスプレッションが、`where`のバウンドがアディティブアリスメティックであるとしましょう。既に決まった設計でゼロを認めない仕様にしたとしても、アディティブアリスメティックはゼロを持っています。

レンジの表現として、新しい名前を考えていますが、どうにもしっくり来ない場合は少し手を加えて試行錯誤しています。結果として名前選びは大変ですね。アイディアとしては、スモールストエンクロージングレンジとか、アディティブレンジといった名前を挙げました。しかし、こういった長い名前や特殊なプロパティに基づく名前は理解しづらいことがあります。

このようなカスタムレンジの使い方は、イント（整数）バウンドを範囲内で使うことは可能ですが、エンクロージングレンジをイメージ通りに動作するように調整する必要があります。途中で、レンジインターフェースに関連する戻りの型が合わない問題も発生していますが、調整すれば汎用化できます。

この設計は、最終目標であるジェネリックな表現を得るために一旦諦めた部分がありましたが、全体としては満足できる内容になりました。エンクローザブルレンジの要件としてアディティブアリスメティックも満たされています。 プログラミングの話ですが、まず、プラスとマイナスという操作を使って足し算や引き算のような動作を表現する場合があります。その際、ゼロの状態を要求するという状況があり、アディティブな算術というのはそういった事柄を扱うものです。この文脈では、何かを両端で囲む必要があり、そのためにローアーとアッパー、つまり下限と上限があるとしても、何かしらの条件を抜き出すことが求められます。

さらに、その上で初期化が必要です。デフォルトの初期化が存在するかどうかも考慮しますが、この場合はないようです。ゼロとして扱えるかどうか、例えばピックやレッド、アジテイトと言った操作の中でゼロを扱うかどうかですが、このケースでは自己参照でゼロがないとされています。どちらのアプローチが良いかという点では、今回の場合はインバリッド、つまり無効な状態として処理するべきだという判断をしていますね。 イニシャライズ時に柔軟に対応する必要がありますね。最終的に必要な場合は、レンジを作って返すためにイニシャライザーが欲しいところです。個人的にはどうかなと思いますが、考え方として無茶な要求ではないと思います。エンジンの表現にバウンドを広げることによって、活用できる可能性もあります。ただし、初心者向けのコードではないので、興味がある場合以外は特に必要ないでしょう。

ジェネリックを表現したかったので、それに成功したのは良かったです。しかし、このメソッドたちはレンジ型がプロトコルなどに規定されていない状態で保持しているため、レンジであることを明示する必要があります。エレメントがレンジエクスプレッションであり、そのバウンドがアディティブ算術であることを理解することが重要です。

プロトコルを介さずにレンジとして扱えるようにするためには、レンジの要素などを明示することが必要になります。具体的な例としては、サムアディティブアリズメティックのようなプロトコルを作ると、有効に機能する可能性があります。ただし、途中で型が合わなくなることがあるので、慎重に進める必要があります。

最終的に、レンジ型の定義がコンペアラブルやコレクションであることを考えれば、ストライダブルのような専用のプロトコルも組み合わせる必要が出てくるかもしれません。さらに、高機能レンジプロトコルを作成して暴れましょうというアプローチも考えられるでしょう。内容が複雑なので、慎重に進める必要がありますね。 レンジダブルの配列に対して、スモーレスト・エンクロージング・レンジを呼び出すことが失敗している状況について検討しています。OS全般に影響を及ぼしているようですので、それを少し考慮してみましょう。

ライクグラフは、すべてのOSに関連するため、ここでマップを仕掛けましょう。レディフィールドを実行しようとしていた雰囲気がありますが、エラーが出ており、スモーレスト・エンクロージング・レンジはダブルストライドとダブルレンジを要求しているようです。それに関して、レンジエクスプレッションでバウンドを扱う問題があるのか検討中です。

バウンドがコンパラブルであることを前提にしたところで、イニシャライザーにレンジを設定すれば良さそうです。イニシャライザーはレンジの定義に存在しているべきですが、どうも適切に設定されていないようですね。この問題を解決するために、ストライダブルなレンジを使って処理を行う方法を探ります。ストライダブルは次のステップを進めるための条件ですが、これはサインドインテジャーに関連するようです。

さまざまな検証を行っても解決には至らないようですが、どこかでこのストライダブルの要件を満たしている可能性を探ります。しかし、範囲外の要素に対する処理がストライダブルの問題として浮上してくる可能性も考慮しなければなりません。

結局、ストライダブルの要件がどこに関係しているのかが明確にならず、困っている状況です。再度、関連するイニシャライザーの規定を確認し、エクスプレッション・アリスメティックを見直す必要がありそうです。最終的に、今はどうにもならず、元の状態に戻すか、次回に再度検討することになりそうです。

今日は一旦ここまでとし、次回に持ち越すかも知れません。お疲れ様でした。
