Transcription & Summarize : とりあえず読書会 SwiftUI Tutorials #2

さて、今日も「とりあえず読書会」を始めていきましょう。SwiftUI 2.0です。前回からこれに入っていきましたが、まだ本当に初めのところなので簡単ですね。簡単すぎて、まだ簡単だからかもしれませんが、読んでいてもあまり面白くないなーと感じることもあります。

なので、コメントなどで割り込んでもらってもいいのかなとか、もっと雑談っぽいことでもいいのかなとも思います。そのほうが身になるような気がしないでもないです。読むだけだったら、好きなペースで読んだほうが早かったりしますからね。

まあ、そういったところも含めて一歩ずつ、まだどうもうまくいかないところもあると思うので、まずは気ままに、リズムをだんだん掴めるようなつもりで読んでいきたいなと思います。はい、ということで。 今日はとりあえず読み進めていきます。えーと、今日は2章……「Creating and Combining Views（ビューの作成と組み合わせ）」かな。あれ、これ前に見たような気がします。SwiftUI Essentials、これは見ましたね。あれじゃないな。えーと、あれだ、ここは読んだ。まだ1章の話ですね、これは。あ、この一番下まで行けばいいのかな。いちばん下を見るとどうなるかな、と。あれだ、えーと……うん、ここを押せばいいのか。はい、これは Essentials だ。まだ、まだある。えーと、これも、あれでもやった？ これはやってないね。2章じゃないのかな？ もしかして SwiftUI Essentials を読むと、もう、リンクを間違えたかな。今トップページに行きましたけど、1章の、えーと、これを読んで……2章とか言ったけど、まだ1章か。1章だ。これの「Building Lists and Navigation（リストとナビゲーションの作成）」？ ここに来るんですかね。ここかもしれない。うん、まず読んでみて、読み終わってから次に進む、みたいな感じで行けばいいですね。

では、こんなところで、いきなり変なリズムですが、読んでいきましょう。えーと、リストとナビゲーションを作るらしいです。マスターとディテールビューを作っていく、と。ユーザーにランドマークのフルリストを見せる必要があって、それぞれのロケーションのディテールビューを見つけられるようにする、みたいですね。そのために、ランドマークの情報を表示するビューを作って、動的にスクロール可能なリストを生成し、タップでランドマークの詳細ビューに遷移できるようにするようです。UI を微調整（ファインチューニング）して、異なるデバイスサイズに合わせる方法については、Xcode のプレビューを使うやり方を見ていく、ということですね。とにかくそれをやるにあたってプロジェクトが必要らしいので、これをダウンロードしておきつつ始めていきましょうか。

セクション1、「ランドマークモデルを作る」。このチュートリアルの最初では、ハードコードした情報を各カスタムビューに直接追加していました。ここでは、データを保存（保持）してビューに渡すモデルを作っていきます。モデルというのは、あまり自分はこの辺のことをよく知らないんですけど、プログラミングでいうとデータを表現するもの、という理解でいいですかね。ちょっと見ておきますか。せっかくなら自分でも調べる……まあ、普通は勉強ってそういうものですよね。だから、「モデル（プログラミング）」で調べると、「プログラミングにおける設計手法やコードの構造を定義する枠組み」みたいな説明が出てくると思うんですけど、最近はこうやって AI による概要が先に出てきますよね。これって正しいんですかね、どうなんだろう。まあ「モデル」くらいだったら大きく外れないと思うんですけど、それよりは、こういうちゃんと人間が書いた解説のほうが自分は好きです。時々、こういったものにも間違いはありますけど、間違う分には大したことないじゃないですか。周りの人が直してくれたり、直さないこともありますけど、まあ、それはどっちでもよくてね。 とりあえず、AIは間違っても、その瞬間には自分で気づけないし、誰かに教えてもらえるわけでもないじゃないですか。そっちのほうが怖いですよね。なので、こういうブログのほうが安心感がある、というのが今のところの個人的な印象です。

MVC、モデル・ビュー・コントローラのアーキテクチャですかね。他にもいろいろありますけど。どっちにしましょうか。MVVM（Model-View-ViewModel）っていうこと？ まあ、どっちがいいかは分からないですね。普通の、一般的なプログラマなら分かると思うんですけど。どれにするか、MVVMか、MVP（Model-View-Presenter）系か、そのあたりかなと。まあでも、Appleってあまりこういうアーキテクチャに強くこだわらないところがある気がして、そこが自分は好きなんですけどね。状況によりますし。アプリ開発くらいだと、2〜3人で作っていく場合もありますし、プログラマの力量にもよると思います。アーキテクチャを最初に早期に選ぶのもそれはそれでいいのかな、と。ただ、状況に合わせていく、というやり方もあると思います。

この読書会で、前の回の課題として読んだ本がRustだったんですけど、その The Rust Programming Language を読んでいて、特に印象的だったのが、オブジェクト指向を前提にしたデザインパターンをRustにそのまま投入するとコードが複雑になるのに、言語本来の性能を生かした書き方に直していくと全く違う、非常にシンプルなコードになる、という具体例が示されていたことです。あれは、ちょっと賢い人じゃないとたどり着きにくい境地なのかもしれないですけど、それくらいのことを応用してやるのと、あと、MVPとかってオブジェクト指向でよく使われていたんじゃないのかなというところがあって、それをそういう手法で表現しようとすると本当にクラスがたくさん出てきて、クラスばかりになっていろいろと大変で、従来的な難しいコードになってしまうところがある。なかなか難しいところなんですよね。

なので、まあ、結局は両方です。基礎を知っていて、かつ、言語の性能を生かせるのが一番いいんでしょうけど。とはいえ、どっちかっていうわけでもないか。まずはどっちかできれば、という感じですかね。あまり欲張っても、まあいいや。

とにかくMVP、とりわけモデルですね。モデルをちゃんと見ておきたいなと思ったんだけど、出てこなかったな。うーんと、「モデルとは？」という話は、結局どこでも一緒とは言えないけれど、ざっと押さえておけばいいかなという気がするので、モデルについて。モデルはシステムの中で、ビジネスロジックやデータアクセスを担当しています。そういえばそうでしたね、というくらいの認識になったんですけど、自分は。

こういったことはなかなか難しいですよね。ちゃんと知っている人は知っているんでしょうけど。APIデザインガイドラインにも書いてあるんですけど、要は、用語は本当に意味がちゃんと通じるときにのみ使うこと、という指針なんです。あくまでも参考ではありますが、そういった指針があって、自分はすごく好きなんですよね。だからといって、この「モデル」という言葉を理解しないまま、他の言葉に置き換えろというわけでもないですけど。 MVC の文脈で「モデルとは何か」をちゃんと理解しておけば、意思疎通にしっかり使える言葉になりますし、悪くはない概念だと思います。まずはモデルを理解するのが大事ですね。モデルはビジネスロジックとデータアクセスを担当するので、守備範囲はけっこう広い気がします。個人的には以前、単にデータを表現するものというイメージを持っていましたが、それよりはるかに広いですね。ユースケースや、一般にリポジトリと呼ばれるデータアクセス層なども担当する方向を向いておいたほうがよさそうです。

MVC では、コントローラーがモデルとビューの中間に入る仲介役で、モデルは先ほど述べた役割、ビューはビューです。UIKit の構成としての MVC には慣れているので、イメージはつきやすいです。とにかく、具体的な機能としては、モデルはアプリケーションデータや関数を持ちます。コントローラーやビューとは役割が違います。そういった担当をするのがモデルです。

なぜモデルの話になったかというと、このあたりに関連する内容が出てきたからです。ここでモデルを作って、ビューに表示するデータを保存する、という流れですね。前のチュートリアルで作った完成版プロジェクト（コンプリーテッドプロジェクト）があって、`description` があり、タイプとしての種類など、いろいろなデータを持たせるということです。今まではこれをハードコードしていましたが、ちゃんとモデルに持たせてビューに流し込んでいくことを、今日は進めていくようです。

ステップ1として、さっきダウンロードしたリソースからランドマークデータの `landmarkData.json` をプロジェクトに入れてください。Xcode のナビゲーションペインに追加し、Add to Targets を有効にします。ここだけちょっとやってみます。前回のプロジェクトがあるのでそれを開きますが、その前にダウンロードしたリソースを使う必要があるので、これをプロジェクトに追加します。 最大化してもドラッグできるのかな、みたいなことは、こんなところで実験してみようと思います。えーと、ダウンロードしたやつ……あれ、ないな。さっきダウンロードしたのはどこだろう。ダウンロードは……あれ、ダウンロードフォルダにないですね。うーん、もう一回やりますか。

じゃあ、このXcodeのプロジェクトの中に、リソースを入れていきます。さっきの中に `landmarkData.json` というのが入っていて、やっぱりここからはドラッグで持っていけないか。だとしたら、まあまあ大きくなるのでおまけ的な感じですが、これを持っていきましょう。あ、ここ、そう、これいいですね。そうすれば、それっぽい。

ダウンロードしたリソースの中に `landmarkData.json` があらかじめ用意されているので、これをプロジェクトの「Landmarks」にドラッグ＆ドロップします。その際、「Copy items if needed」にチェックを入れて、ターゲットは「Landmarks」を選びます。これでOKです。コピーが行われ、ターゲット「Landmarks」に追加されます。結果として、`landmarkData.json` がプロジェクト内にコピーされます。ファイルのパスもここに表示されますし、File Inspector の Target Membership に「Landmarks」が付いているはずです。もしチェックを入れ忘れた場合は、あとから Target Membership でチェックを付けて追加してください。そこはしょうがないので、ちょっと頑張って対応しましょう。

これでコピーできました。実際にそのファイルを見ておきましょう。画面が拡大されすぎて見にくいですが、名前が何だったか、カテゴリが何だったか、ID が何だったか、ちゃんとデータが揃っています。ありがたいですね。こういったデータを用意してくれるのは最高ですよね。そんな感じで、とりあえず準備はできました。ここまでが下ごしらえです。

次はステップ3です。ランドマークの構造体を定義して、いくつかのプロパティを持たせます。さっきのデータファイルと一致する名前で構造体を定義して、`Codable` 準拠にして、データを構造体へ簡単に変換できるようにします。`Codable` の話がどこまで出てくるのか、楽しみですね。

具体的には、`Decodable` にも準拠させて、後でファイルからデータを読み込む形にします。プロパティは `id`、`name`、`park`、`state`、`description` で、`id` が `Int`、それ以外は `String` です。これは自分で書いてみますかね。コピーばかりに頼ると、なんか面白くないんですよ。 まずは、プロジェクトに`Landmark`を作ります。必須ではありませんが、一般的にはプロジェクトごとに進めていくので、Swiftファイルを選んで、`Landmark`という型を用意します。ここに、ランドマークデータと同じ項目を追加していくことになります。

その前に、エディタの調整を少しします。ミニマップが自分には邪魔なので消したいです。Xcodeのエディタ右上のメニューから「Hide Minimap（ミニマップを隠す）」を選ぶと消せます。あわせて、行番号の表示やコードフォールディングリボン、コードストラクチャ、セパレーター表示、非アクティブコードの減光、マッチングデリミッターの強調表示などの設定も確認しておくとよいと思います。ドキュメンテーションコメントの表示位置などもありますが、今回はミニマップだけオフにしておきます。これでエディタが広くなって見やすくなりました。

では、`Landmark`を作っていきます。プロパティはすべて`var`で良かったはずです。`id: Int`、`name: String`、`park: String`、`state: String`、`description: String`のように用意します。本当はドキュメントを見ながらやるのが確実ですが、項目としては`id`、`name`、`park`、`state`、`description`ですね。

ここで、`description`という名前は少し気になります。Swiftには`CustomStringConvertible`というプロトコルがあり、インスタンスの文字列表現をカスタマイズするために`description`プロパティを実装します。そのため、単なるデータ項目として`description`というプロパティ名を使うと、インスタンスのテキスト表現を表す`description`と紛らわしいのですよね。たとえば、「Turtle Rock」の情報を扱っているとして、この`description`を見ても「Turtle Rock」という名前自体は出てきません。あくまでインスタンスの説明テキストという意味なので、用途によっては名前を変えることを検討してもよいかもしれません。 なので、この説明を読んで「これプロトコルじゃん」という感じで、そういった前提が成り立つなら良いのですが、そうでないとすると、`CustomStringConvertible` あたりが気になります。とはいえ、今回は全部のプロトコルに準拠するわけではないので、深入りはしません。どこまで考えなくていいのかもしれませんが、`description` だとなんとなく微妙な感じがします。改造したい気もしないでもないのですが、余計なことはしないほうがいいかなと思います。余計なことはせずに進みましょう。各所から手を付けていって、もし混乱したら混乱したで頑張ればいいか、という感じでやってみます。

やっぱり SwiftUI チュートリアルの話です。せっかく Swift と言ったら、`Swift 5` とか聞きたいですよね。まあ、人によってはそれで良いところもあるかもしれませんが、まずはやってみます。なんとなく余計なことをしたくなる気がしますが、困ったら戻すことにします。まずは調べていきましょう。

どちらかというと、`description` という名前があまり好きではないので、`summary` にしようかなと今ふと思いました。`summary` にしてしまってもそれ自体は問題ないのですが、同じランドマークのデータを左右で見比べるときに、左は `summary`、右は `description` と言っているような状態になると、混乱につながりますよね。そうするとよろしくないなという気持ちがたまってきたので、ここは `description` にしておきます。

名前を一致させておくと良いことがいろいろあります。ここで `Codable` ですよね。`Codable` というプロトコルに準拠すると、同じフィールド名を使って `JSON` と型の間を自動で相互変換できます。`summary` にしてもマッピングを書けば大丈夫ではありますが、同じ名前にしておけば、そのまま `JSON` ファイルからインスタンスを作ることが容易になります。

あと、さっき `Hashable` も付いていましたね。これは後の都合だと思うのですが、ハッシュとは、あるものを有限な範囲の数値で表すことです。ハッシュ値が異なれば、元になった値は必ず異なることが保証されます。一方で、ハッシュ値が一致した場合には、元の値が同じかもしれないし、違うかもしれない、という性質を持ちます。これを利用すると、例えばランドマークなら、`id`、`name`、`park`、`state`、`description` のようなフィールドの組をハッシュの基にして、これらの値がすべて異なれば別のものだと判定できます。 なので、普通にチェックしようとすると、これら5つのものをすべて確認して、全部が合っているか違うかを判断しないといけません。ただし、ハッシュ値を使うと、これを一つの整数値にできます。つまり、ハッシュ値です。数値同士の比較にしてしまえば、元の値が同じか、あるいは違うことが確実に判断できます。たとえば、ハッシュ値が1のものと2のものなら、元の値は完全に違うと分かるので、1回の計算でサクッと違うと判断できます。

一方で、ハッシュ値が同じになってしまうことをコリジョン（衝突）と言います。両方のハッシュ値が一致したときは、値が同じかもしれないし違うかもしれないので、結局は全部を比較して確かめないといけません。同じなら問題ありませんが、違っていた場合は衝突が起こったということになります。ハッシュ値が一致したときには比較のコストが急に跳ね上がり、もともとのコストに加えて余計に処理がかかります。なので、なるべく衝突しないようなハッシュ値を計算する、つまりより良いハッシュ関数を使うことが大切だと言われます。ここはシステムや数学者が頑張ってくれているところなので、普通のプログラマーは自作する必要はあまりありません。自分も自作したことはありません。

このハッシュ値を計算できるのが、`Hashable` というプロトコルです。このプロトコルに準拠させると、ハッシュ値（ハッシュバリュー）を計算できる仕組みが、今回の場合は自動で作られます。なぜ自動で作られるかというと、`Int` 型も `String` 型もハッシュ値を計算できる型だからです。こういった型だけで構成されている型については、内部的に適切にハッシュを計算する機能を自動合成してくれます。ですから、`Hashable` に準拠させるだけで十分です。これはプロトコル準拠の自動合成という機能が用意されているからです。

また、`Codable` はさきほどの最初の話、JSON から変換するためのものです。`Codable` と `Hashable` はまったく別の話なので、この2つは混同しないでください。とにかく、こうして `Landmark` という構造体が出来上がりました。 これは `JSON` からの相互変換が可能で、ハッシュが取得可能なフィールドが5つあるランドマーク型、つまり構造体ですよ、というところまで進みました。

次に、いくつかのステップとしてモデル側でイメージを扱います。各ランドマークに割り当てられているイメージをモデル化するイメージです。`JPEG` ファイルをプロジェクトに入れてリソースとして扱うことになります。プロジェクトに入れるにあたっては、アセットカタログを使います。新しいイメージを追加すると、それぞれに対して自動的にイメージセットが作られ、アセットカタログに追加されます。表示上は「追加される」ということですね。

では実行します。前回からあるものは除外されているので、今回は含まれていないはずです。さっそく入れていきましょう。ダウンロードしておいたイメージを使います。見やすいようにウインドウを並べて、プロジェクトの左側のペインからアセット（Assets）を開きます。リソースの中にある Images フォルダに入っているイメージをすべて選択して、アセットカタログの中へドラッグ＆ドロップします。はい、入りましたね。これで良さそうです。

ドキュメントに戻ると、次はステップ5として、`imageName` プロパティ（データから参照するイメージの名前）を追加し、さらに計算型の `image` プロパティを用意します。少し珍しく感じるかもしれませんが、`Image` 型の計算型プロパティにして、イメージはアセットカタログからロードする仕組みにします。また、この `imageName` は `private` で定義します。なぜなら、`Landmark` 構造体の利用者には、`image` プロパティ経由でのみイメージにアクセスしてもらえば十分だからです。サンプルコードはここでは見当たりませんが、`Landmark` に `import SwiftUI` を入れて `Image` を使えるようにする、という話ですね。

まずはこれをやりたいところです。それからランドマークのロケーションの管理へと進んでいく想定です。

時間がもう終わりかけています。進め方が良くなかったのかもしれません。`imageName` プロパティを作る、というのが次の作業ですね。データから読み込む処理は用意してあったはずですが、まだ作っていません。プレビューはなくても大丈夫でしょう。`Landmark` に `import SwiftUI` を入れるだけなら、後でまとめてでも良いと思います。どう進めるかは少し迷いますが、まずは手順どおりに `imageName` と計算型の `image` を整えていきます。 次にコーディネート（座標）プロパティを作っていきます。`Coordinate` 型を定義して、JSON データの構造に合わせていく方針のようです。なお、このプロパティは `private` として定義します。次のステップで作るパブリックなデータ型・プロパティからのみ生成するためです。自分はふだん `internal` にすることが多いのですが、ここでは意図があるようなので `private` にします。プライベートな計算型プロパティで作るから、ということですね。少し違和感はありますが、その方針で進めます。

作るのは `Hashable` と `Codable` に準拠した構造体で、`latitude`（緯度）と `longitude`（経度）を `Double` 型で持たせます。名前は `Coordinate` です。`latitude` と `longitude` の2つで1組の座標（coordinates）になる、という理解です。英語では X と Y など複数の値をまとめて表すときに複数形の “coordinates” を使うことが多いので、緯度と経度の組も “coordinates” と呼ぶのだろう、という話でした。

ということで、新しく `Coordinate` 型を作り、その中で `struct Coordinate: Hashable, Codable` を定義します。プロパティは `var latitude: Double` と `var longitude: Double` で、これらは `private` にします。先ほどと同様に同じファイルに書いて、`Landmark` の中に所属させる（ネストする）形にします。こういった感じになっています。 これは`extension`で、ランドマーク的な書き方をしてあげると、ランドマークにひも付く`Coordinate`として表現できるようになります。型拡張というのですね。これを使ってランドマークを`Codable`や`Hashable`に準拠させて作っていきます。

大事なところとして、`Coordinate`というのはもともと「座標」という意味でしたよね。ランドマークに所属させない`Coordinate`は単なる座標です。それに対して、ランドマークに所属させる`Coordinate`は「ランドマークの座標」になります。このように、所属関係で意味合いが密接に変わってくるものは、状況にもよりますが、中に入れ込んでネストさせてあげると、なかなか良い感じに表現できます。こういった観点を考えながら型を定義していくのがおすすめです。

というわけで、ランドマーク側のプロパティには`private var`を使います。`Coordinate`をランドマークの中にネストしているので、ランドマークの定義内では修飾なしで`Coordinate`と書けます。逆に外からは`Landmark.Coordinate`とすることで、「ランドマークの座標ですよ」ということが明確になります。単に`Coordinate`と言ってしまうと「ただの座標なのか、ランドマークの座標なのか」で誤解が生じかねません。名前付けとネストを活かすと、ここがとても分かりやすくなります。

`Coordinate`は`private var`で……と、まだ少し半信半疑ではありますが、`private var`で定義します。そして、`Coordinate`から計算型の`locationCoordinate`プロパティを作っていくらしい、という話です。これは実は位置情報系で役に立ちます。そのために`import CoreLocation`を追加します。最後に、ファイルから……あれ、何か表現が抜けていない？ といった確認をしつつ進めます。

画面が大きすぎるのか、チェックするとどうなるのか……あ、ありました。`imageName`プロパティがありました。画面を拡大すると見えなくなることがあるようです。見えないのかと思ったら、出てきました。`private`にしたら出てきたので、これで良しとします。`SwiftUI`で定義して、`private var imageName`とします。えーと、`var image: Image { Image(imageName) }`のように、`imageName`から`Image`を提供します。こういうことは普通にやるのですね。最初は微妙かなと思ったのですが、SwiftUIだと自然に書けるので、なるほどという感じです。どうしようかなと迷いましたが、直したい気持ちはありつつ、悪くはないと思い直しました。

自分の感覚としては、JSONとの対応付けをきちんとしたいというのがありつつ、JSONの生データの一部を`private`にするのはどうだろう、と最初は感じました。ただ、改めて見ると悪くないですね。`private var imageName`にして`imageName`は隠蔽し、その`imageName`から`Image`を生成し、外側からは`image`だけが見えるようにする。ランドマークの`image`、確かに悪くないです。

ただ、こうしてしまうと、`Codable`にしているじゃないですか。まあ良いのですが、イニシャライザーも`internal`で公開されている中で、`imageName`がイニシャライザーで与えられるなら問題ないですね。うん、良さそうです。やってみましょう。`imageName`を`private var`で定義して、計算型プロパティ`image`で`Image`を返す。それでいきます。

自分の感じ方が微妙だっただけかもしれません。`SwiftUI`を`import`して`Image`が使えるようにした上で、`Coordinate`は先に出てきた都合で後で整理するとして、まずは`private var imageName`です。これは`landmarkData`に合わせています。`landmarkData`の`imageName`というフィールドがあるので、それに合わせます。JSONでは`String`なので、そのまま`imageName`に対応付けます。その上で、公開はしない（`public`にはしない）、つまり`internal`のままで良いでしょう。外側に見せるのは`var image: Image`です。

型は`String`と`Image`で、`Image`は`Image`型です。そうだ、`Codable`かどうかによっても面白いことができるかもしれませんが、余計なことは一旦置いておきます。`image`は計算型プロパティですよね。ということで、ここはいったんコメントアウトして調整します。 この `imageName` がそのまま `Image` だとするじゃないですか。そうすると、こちらはエラーになります。なぜエラーかというと、`Codable` に準拠していないからです。あとは、`Encodable`、`Hashable` も必要かもしれません。`Hashable` も来ますね。ちょっとややこしくなってきます。

独自の型を作る手もありますし、`imageName` のままでいく手もあります。どちらがいいでしょうか。`imageName` を `String` にして、そのまま `Image` に変換する、というやり方でもいいかなと思います。なんとなく微妙な感じもしますが、まずはそれでやってみましょう。

一方で、ランドマーク用の独自のイメージ型を作る手もあります。せっかくなので、こちらもやってみます。例えば、ランドマークの中で使うイメージ用の構造体を用意して、今回はこれに `Codable` と `Hashable` に準拠してほしい、という想定です。

その中で、プロパティは名前でよいので、`name`（イメージ名）を `String` で持たせます。ただし、このイメージ型を `Codable` にする場合、JSON 側では単一の文字列として表現されている前提なので、そのままだと厄介です。`imageName` の中でオブジェクトではなく文字列ひとつとして扱いたいので、JSON とコードの表現がずれないように、`Codable` が要求するメソッド、つまり `init(from decoder:)` と `encode(to:)` を単一値コンテナで実装します。

- デコード側は、`let container = try decoder.singleValueContainer()` としてから、`name = try container.decode(String.self)` のように文字列を取り出します。
- エンコード側は、`var container = encoder.singleValueContainer()` としてから、`try container.encode(name)` のように文字列として書き出します。

このようにしておくと、文字列ひとつで JSON にエンコード・デコードできます。これで、独自のイメージ型は `Codable` と `Hashable` の両方に準拠できます。

あとは、プロパティを `imageName` ではなく `image` にして、この専用のイメージ型を使うようにします。専用のイメージ型を作ることで、表現を保ちつつ型安全に扱えるようになります。

ドキュメントに戻ると、追加したのはこのコードひとつで、そのための準備が少し入る、という形になります。エディタの都合でファイルをリフレッシュすると表示位置が戻ってしまい、画面を開いたままだとコードが途中までしか見えないという問題がありました。今やっていたのはこの部分で、少し困っていましたが、間違えていたら直せばよいという感じです。

それから、`private` になっているのが気になっていたのですが、これについてはこの後で `locationCoordinate` プロパティを計算型で作っています。 MapKit フレームワークを簡単に使えるようにしようという話です。そのために、プライベートで保護していた部分を見直し、CoreLocation を使っていきます。このファイルの中で、`Landmark` の名前空間内に、座標を表現するための `Coordinate` 型を用意しているにもかかわらず、これをプライベートにするのはもったいないです。座標の表現は本来 `Landmark` 側の `Coordinate` に持たせるのが最適です。

一方、CoreLocation の座標型である `CLLocationCoordinate2D` による表現は、純粋に MapKit と連携したいがためのものです。`Coordinate` 型を `CLLocationCoordinate2D` に変換するコードになりますが、このときは API デザインガイドラインに従い、変換イニシャライザーを定義して表現するのが推奨です。変換イニシャライザーは「変換先」に実装するのがガイドライン流なので、`CLLocationCoordinate2D` を拡張して実装します。

まず、`Foundation` を `import` していますが、使っていないときは削除します。`SwiftUI` も不要なら削除します。インポートを消していくのは少し不毛にも感じますが、今回は整理しておきます。`Coordinate` を扱うファイルでは `import CoreLocation` を追加します。

変換イニシャライザーは「バリュー・プリザービング・タイプコンバージョン」と呼ばれ、値を失わない型変換を指します。この種のイニシャライザーでは引数ラベルを省略し、`init(_:)` の形で受けるのがガイドラインです。したがって、`extension CLLocationCoordinate2D` 側に `init(_ location: Landmark.Coordinate)` を用意します。

他のモジュールで定義されている型（ここでは `CLLocationCoordinate2D`）を拡張した場合、プロパティへ直接代入して初期化することはできません。安全性を担保するため、必ず用意されたイニシャライザーを通して初期化する必要があります。そのため、実装は `self.init(latitude: location.latitude, longitude: location.longitude)` と書きます。これで実装は完了です。

このやり方の何が良いかというと、API デザインガイドラインに沿った結果、書式が他の標準的な型変換と同じになることです。例えば、`Int` を不動小数点数の `Double` に変換するときは `Double(value)` と書きますが、同様に `Landmark.Coordinate` から `CLLocationCoordinate2D` への変換も `CLLocationCoordinate2D(coordinate)` と同じ書式で書けます。標準の `Int`→`Double` の変換と、`Landmark.Coordinate`→`CLLocationCoordinate2D` の変換が同じ見た目になる、これが狙いです。 なので、この形のほうが本来はよい、という感じです。まあ、それと言われると全然関係ないのですが、ガイドラインで「こう作るとよい」と言っているので、そう作りました、ということです。これでいいですね。

`CLLocationCoordinate2D` のための変換も用意できて、このセクションで言っているインターフェースについては、少なくとも手元では期待どおりに動作するようにできました。これでOKですね、とりあえず。これで、パースやデコードもできるのか。いいですね。やっと分かってきました。途中までしか出ていないと分からないんですよね。困りますね、これ。まあいいか。なので、このまま頑張る感じですかね。

次、ステップ8。New Swift File。これはいいのかな。ModelData を作る。ModelData。今作った ModelData じゃないのか？という気もしますが。

`load` メソッドは `Decodable` プロトコルに関係します。ジェネリックを使っていくんですね。面白いです。しかも、`ModelData.swift` で、今のところはフリー関数を使っていきますね。Swift APIデザインガイドラインの話になりますが、フリー関数は「適切な所属先（型や名前空間）が見つからないときに限って使う」のが推奨されています。`load` はどうだろう。ここにあっていいのかな。後々変わっていくかもしれないし、状況が見えたら改造していこうかなと思います。

ジェネリック関数ですね。関数名が `load` で、ジェネリックな型 `T` があって、`T` は何でもいいけど `Decodable` にしてください、ということです。それでファイル名を受け取って、`T`、つまり `Decodable` な型を返す。データがあって、`Bundle.main` から取って来られなかったらエラー、という流れ。まあ、これはこれでよいとして、`guard` の使い方に少し不思議さはあります。`do-catch` でデータを JSON からデコードする。`JSONDecoder` を使って、`Decodable` できる型のはずなのでデコードする、という形ですね。

ただ、APIデザインガイドライン的にはかなり微妙なところがあります。一般的に、戻り値の型だけで型推論させるのは避けたい場面もあります。ここは大きく戻り値の型で推論させているので、少し工夫が必要かもしれません。工夫の仕方としては、パラメータに「どんな型にするか」という情報を渡す、つまり引数側に型ヒントを持たせる、などが考えられます。

それから、`load(String)` のように引数ラベルを省略してしまうと、この `String` が何を表すのかが分かりづらいです。ガイドライン的には、ラベルを付けたいところです（たとえば `load(named:)` など）。

あと、このあたりの `guard` とか、宣言を先にして初期化を後にする、いわゆる「デフィニット・イニシャライゼーション」という考え方を使っていますが、これをここで使うのは少し珍しいですね。何も悪くはないのですが、違和感はあります。ここで `data` を用意して、`do-catch` でエラーを出して……ということは、エラーハンドリングをそれぞれバラバラにやって確実に拾いたかった、という意図でしょうか。これは気持ちは分かります。そのためにデフィニット・イニシャライゼーションを使うのは、悪くはないです。間違ってはいません。ただ、あまり好きではないかな、という感じもします。なので、少し書き換えていきましょう。良くないというほどではなく、動きとしては間違っていないので、こういう書き方でも問題はありません。

そのために、モデル……何モデルでしたっけ、作るの。ModelData。これはもしかして当たり前の呼び方なのかな。「ModelData って何？」という感じに見えてしまいますが、用語として一般的なのかもしれません。データを扱うので `import Foundation` は必要になりますね。今コピーしてきたやつはこうなっています。

まず `func load` をどこかに所属させたいんですよね。`load`。所属させたいけど、まあ……いや、やっぱり所属させたいですよね。`Bundle` です。`Bundle` のメインインスタンスを使っています。ということは、`Bundle` からロードしていますよね、という雰囲気です。`Bundle.main` からデータを取ってくる、今回やりたいのはランドマークデータを取りたい、ということなので、`extension Bundle` を生やしておきたいです。所属先に所属させると探しやすいのです。

フリー関数の問題は、「`load` という関数がある」と知っていないと発見できないことです。たとえば `String` があって、長さを取りたいときに、Swift では `count` ですよね、という発想になります。一方で、手続き型プログラミング（オブジェクト指向ではないやり方）だと、C言語の `strlen` という関数を知っていないと文字数が取れない、みたいなことになります。なので、所属先があると、`Bundle` からすぐ取れる、というのがよいです。

型は何でもいいとは言っても、何にしようかな。データ……いや、ここは「モデルデータ」でよいんですかね。用語に自信はないのですが、ここで使っていいのかな。まあ、`T: Decodable` ですね。`Decodable` である、つまりデータからデコードできる型である、という情報を与えます。`Bundle` 側では `url(forResource:withExtension:)` にファイル名を渡しているので、これを拝借するのがよさそうです。`forResource:withExtension:` です。

最終的には、「戻り値としてモデルデータ（`Decodable` な任意の型 `T`）」を返す、というインターフェースになります。こうして `extension Bundle` に所属させておけば、`Bundle.main.load(named: ...)` のように、見つけやすく、意味も明確にできます。 ただ、このインターフェースもまだ少し微妙で、さっき言ったように戻り値の型で型推論していくという状況になってしまいます。一般的にはここで、たとえば `ModelData.Type` のようにモデルデータのメタタイプ（型情報）を受け取ります。要は、戻り値の型で推論するのではなく、引数に渡した型情報をヒントにして型を作っていく、型を推論していくという方法を取ります。この型は、内部実装では使わないと何だったか分からないのですがね。ひとまず、これで API インターフェースができたかなと思います。

ここ、正直自信はないのですが、名前はモデルデータでいいですかね。どうなんでしょうか。「なんか変だよ」という感じであれば教えてほしいです。とりあえずモデルデータにしてみます。こんな感じでインターフェースを置き、これで実装していきます。

まず、`withExtension` に `nil` を渡しています。これは渡しておいたほうが勝手がいいですよね。その前に、`forResource` と `withExtension` を持つ API（`url(forResource:withExtension:)`）に合わせて、引数の名前ラベルも整えます。`withExtension` の型は `String` ですが、`nil` が渡っているということは `String?`（オプショナル）ですよね。一般的には、`forResource` にはリソース名を、`withExtension` にはたとえば `"json"` を渡すと思うのですが、どうなっているんだこれ……まあいいか。オプショナルは「読み込むのに使わない」ポイントはちゃんと使っておかないといけない気がするので、ここは `nil` のままで進めます。今後 `nil` だと都合が悪いというときは、また考えます。

そうしてあげると、まず `guard` で URL を取りたいですね。`Bundle.main` から `url(forResource:withExtension:)` を使って読み込むことができます。変数名の `allResource` はよくないので先に直しましょう。`forResource` に渡すのに `allResource` だとダサいですよね。ダサいだけでなく、可読性が下がると普通は言います。内部変数名としては `resource` が素直です。文字列が渡ってきたからといって、その文字列が何を意味しているのか分からない、ということが、表現力（汎用性）が高すぎる型だと往々にしてあります。そこで、この文字列は「リソース名」を期待しているというのを、引数ラベルを `forResource` と書くことで明確にします。`modelData(forResource:withExtension:)` のように表現すると、ガイドライン的にも最適な名前になってきます。

ファイル（正確にはリソースの URL）が取れなかった場合には、エラーメッセージを出して `fatalError` にします。今回はロジックエラー扱いでいいです。オプショナルも含めて文字列化するという意図を示すときには、`String(describing:)` を使います。そうですね、これだけでだいたい大丈夫でしょう。これで `fatalError` で OK です。

URL が取れたら次はデータです。`Data(contentsOf:)` は `throw` するのでエラーハンドリングが必要です。`do`-`catch` でキャッチして、キャッチしたときには原因を表示しつつ落とします。そういったロジックエラー経由の落とし方ですね。変数名は `file` ではよくないので `fileURL` がいいです。あるいは単に `url` でも構いません。リソースの URL なので `resourceURL` という名前もありです。

エラーメッセージは複数行リテラルにしましょうか。ダブルクォートを三つ並べたトリプルクォートで書いて、最初はいきなり改行させます。インデントはどこでもいいのですが、必ずそのインデントを揃えて、最後の三つのクォートの位置を基準のインデントにします。こういった書き方ですね。

これでデータが取れたら OK、取れなかったらエラーで落とす、という感じで「リソースを読み込めなかった」場合の扱いをはっきりさせます。ここで、`let data: Data` とだけ先に宣言して初期値は書かずに、`do` ブロックの中で一度だけ代入する、という書き方にしてしまいましょう。Swift のデフィニット・イニシャライゼーションのルールに従って、全経路で代入が保証されていれば問題ありません。悪いことではないです。 全然。あとは Result。Result はよく使わないですね。デコードしまして、あとは JSON のデコーダーですね。これも適宜やってみます。

とりあえず、データをパースできなかったときにはこのエラーを出す、ということで、そのためにブロックを分けた、というのが今回の「確定的初期化（Definite Initialization）」を使った理由です。こっちのモデルデータ側ですね。ここで `do` ブロック。あまりこういう書き方は自分はやってこなかったので違和感はありますが、まあ妥当ですね。

デコーダー、そして JSON のデコーダー、つまり `JSONDecoder` ですね。それで、戻り値はどうしましたっけね。ああ、`return` するか。なるほど、`return` でいいですね。`JSONDecoder` は失敗する可能性があるので、まずデコーダーを用意して、`decoder.decode` でデコードします。`decoder.decode(Type.self, from: data)` のように、型は最初に取っておきます。あとは、`from: data` からこの型にデコードする、という感じです。

これで `catch` しまして、エラーが出た場合には「リソースをパースできなかった」あるいは「モデルデータに変換できなかった」といったメッセージにします。これも複数行に対応した文字列にしておきますか。そうするとエスケープシーケンスが不要になるので、多少は読みやすくなるかなと。これくらいだと、まあ、そんなでもないですけど。これでいいですね。ここまででコードはできました。

自分がよく書くコードは、これをこの中に `do` ブロックを1箇所にまとめて、ネストして書く方法です。そうすると「確定的初期化」とかではなくて、こうやってネストして書いて…という感じでできて、これで `catch`。あれ、なんかおかしい。あ、丸括弧がないですね、ここ。で、`catch` して、デコードに失敗したときは `DecodingError` の詳細を使ってエラーを出す、というふうに書けばよいのですが、こうすると「バンドルからロードできなかった」と「デコードに失敗した」が混ざってしまうんですよね。

今回、モデルデータがエラーを出したときに細かい情報を含んだエラーメッセージを返してくれているので、そこは損なわないようにしないといけません。そういったエラーをしっかりと処理していこう、というときには、どうしてもエラーハンドリングが複雑になることはあり得るので、まあこれでどうしようもないでしょう、という感じでいいですかね。何も悪いことはしていないですし。

これでモデルデータができました、という感じになって、モデルデータは呼ぶときに使うのでよいです。これによって `load` 関数がちゃんと `Bundle.main` に属するリソースを読み込み、デコードをかけられるようになります。使い方としては、何かあったときにここで `Bundle.main` のリソース、たとえば `"landmarkData"`（拡張子は `"json"`）を読み込んで、`Landmark` のように書くことができますよ、という感じです。これを期待している、という感じでコードがリファクタリングできました。

まあ、これくらいにしておきますかね。今日はちょっと時間がかかってしまいました。とりあえず、このロードまでできて、次はこれくらいで大丈夫ですよね。これだけかな、ちょっと見ておきますが、そうですね、これだけですね。はい、これで OK です。ステップ10へ行きましょう、という感じでロードするわけですが、ここはまた次回にしますかね。ロードして、ロードして…うん、大丈夫ですね。大丈夫な気がします。

では、今日はこれで終わりにします。お疲れ様でした。
