Transcription & Summarize : とりあえず読書会 SwiftUI Tutorials #5

はい、では、とりあえず読書会を始めていきましょう。SwiftUI を引き続き読んでいきます。1章のいくつかのセクションの流れで、だんだんと形ができてきた気がします。コードもいろいろ変更しながら進めていて、なかなか面白い感じで順調かなというところです。では早速読み進めていきます。まずセクション7、データをチャイルドビューに渡していく話に入ります。

チャイルドビューで詳細を表示する、ということですね。`LandmarkDetail` ビューは、まだハードコードされた状態で、渡されたランドマークの情報を表示する形になっていません。詳細用の `LandmarkRow` はできているけれど、`LandmarkDetail` にはまだ反映されていないので、`LandmarkRow` で使っているデータをビューにも反映させていく、という理解で良さそうです。ざっと雰囲気で読みましたが、多分大丈夫でしょう。

ここから実装に入ります。チャイルドビューである `CircleImage`、`MapView`、`LandmarkDetail` に、渡されたデータを表示させるように書き換えていきます。プログラミングの感覚で「コンバート」というと変換のニュアンスがありますが、ここではハードコードではなく動的に表示内容を書き換える、という意味合いです。`CircleImage` も書き換えます。

まず `CircleImage` ファイルの中で、ストアドプロパティを用意します。`CircleImage` 構造体の中に、`Image` を持つプロパティを作っていきます。これは SwiftUI でビューを作るときの共通パターンで、カスタムビューは通常、特定のビューに対する一連のモディファイアをラップしてカプセル化します。そうやって `CircleImage` を作り、`Image` を適切にカスタマイズして、良い感じの見た目を出力するコンポーネントにしていく、ということですね。

では Xcode で作業します。いろいろ書き換えている都合で、コードがだいぶオリジナルから変わりつつあります。Swift 6 に対応させたいのと、せっかくなので自分が理想とするコードの形に寄せようと思って、いろいろ試しているところです。いまは `CircleImage` に `Image` を直接持たせていますが、これを動的に変えていこうと思います。先ほどのコードに戻ると、`Image`、`var ...` といった形になっています。まだ State の話が出てきていないのでこういう形なのかもしれませんが、プロパティが変わったら `Image` も差し替わってほしいですよね。そう考えると、`@State` のほうが良いのでは、という気もします。自分はそこまで慣れていないので誤っているかもしれませんが、間違っていたら直していく、という普通のプログラミングの考え方で進めます。

ここでは先ほどは `Image` を持たせていましたが、この `Image` 型は SwiftUI のものなので、それ自体は問題ありません。ただ、`CircleImage` が表示用の `Image` を直接持つのではなく、データモデルを受け取ってそこから画像を取り出すほうがスマートかもしれません。これは価値観の話でもありますが、自作した `Landmark` 型に画像名などの情報を持たせ、例えば `imageName` のようなプロパティから `Image` を生成する、という構成にしています。`Landmark` のデータをビューに渡し、そこから表示用の `Image` を得るほうが、いろいろと都合が良いのではないかという考えです。いわゆる、生のデータを持っておくイメージですね。 では、こちらを持たせてみましょう。ランドマークのイメージから SwiftUI のイメージへの変換は、このファイル内で、SwiftUI の `Image` に対するイニシャライザーとして用意します。これがなくても動きますが、今日扱う内容では、ないと分かりづらくなる場面があるので、チュートリアル的な分かりやすさを優先して省略せずに書きました。こんな感じで、`LandmarkImage` を SwiftUI の `Image` に変換できるイニシャライザーを用意したので、これを使っていけば両方うまくいくはずです。

つまり、データとしては、こちらでは `LandmarkImage` を持たせて、`body` のほうでは SwiftUI の `Image` を持たせたい、という意図です。そのときは `LandmarkImage` からの変換で `Image` を作れるので、こういう形になるはずだと思います。これでうまくいく…かと思ったのですが、うまくいきませんね。今、イメージをダイレクトに持たせた都合で、プレビュー側が引数なしという状態になっており、ここで `LandmarkImage` のイニシャライザーが見つからないと言われています。イニシャライザーがない？ `LandmarkImage` にイニシャライザーを実装していなかったのでしょうか。

どうしましょう。これは構造体で、何もイニシャライザーを用意しない場合、構造体にはメンバーワイズイニシャライザーと呼ばれる、すべてのプロパティを初期化するためのイニシャライザーが自動で搭載されるという特徴があります。今回はそれを使うのが一般的かな、という方針にしましょう。

そのうえで、Codable のために工夫した実装は、`extension` で `LandmarkImage` に対してイニシャライザー（`init(from:)` など）を載せることで、メンバーワイズイニシャライザーと、独自に用意した Codable 用のイニシャライザー、この2つが共存できるようになりました。このとき、Codable 系の実装は全部下にまとまっているので、グルーピングの観点でどちらに置くかは好みの問題かなと思います。Swift では結局、17行目のような書き方をするのが一般的で、どこかの `extension` にプロトコルへの適合があるはずだ、と探していくことになるので、分かりにくくはならないと思います。今回はグルーピングを優先して、`LandmarkImage` 本体はオープンなままにし、メンバーワイズイニシャライザーと、12〜14行目の定義だけで実装される形にしました。

これで、先ほどのプロパティ `image` のところで、イニシャライザーが…ここですね。先ほどは `init(from:)` しか出てこなかったのが、ちゃんと `init(imageName:)` も登場するようになりました。違う、ここではなく…あ、`Image` のほうでやっていましたね。いずれにしても `imageName` も登場するようになって、これで良さそうです。例えば、`imageName` なのでアセット名を使います。アセット内の名前を、仮に「ICP」としてみましょう。とりあえず「ICP」にしておきます。そうすると、プレビュー…ですね。`LandmarkImage` を「ICP」にして、`Image` は `Image` ですよ、という形で、こんな感じでしょうか。これでプレビューもうまくいくはずです。

…と思ったら、アセットがうまくいかないですし、`Landmark` のフィールド初期化にも失敗しています。これは他で使っているパラメーターが原因ですね。`CircleImage` の箇所です。ここは `Landmark`（今いじろうとしているページ）で使っているところですね。チュートリアルにもこの後出てくると思いますが、プレビューで確認したいので、`image` パラメーターを渡してあげます。これは `Landmark` が持っている `image` です。これで大丈夫ですね。

ではチュートリアルに戻ります。イメージはこれでできました（コードは少し違いますが）。次のステップ2はプレビューの更新です。`MapView` のプレビュー…今やった内容ですね。少し言いすぎました。引き続きプレビューのほうも直していきましょう。 プレビューのロジックが固定されている、でいいのかな。プレビューが失敗して、ビルドも失敗するから、今はガードできたみたいですね。これはこれでOKです。

次はステップ3に進みます。`MapView` ファイルに行って、`MapView` に座標プロパティを追加します。プレビューでは固定の座標を渡す想定です。チュートリアルでは `CLLocationCoordinate2D` を使っていますが、これは MapKit を前提にした座標型です。表側の `MapView` から見れば、中で使っている MapKit は外から見えないほうがいいですよね。なので、今回は独自のランドマーク用の座標型で実装しているので、ここも同じくランドマークの座標型で対応してみましょう。

`MapView` 側でプロパティを持たせます。これも `@State` かなと思ったのですが、`@State` について思い出したことがあります。`@State` は一般に `@State private var` にします。外から `State` をいじられないようにするためですね。さっきの `Image` のほうもそうしておく必要がありますが、忘れないうちに先にやっておきます。`@State private var ...` という感じで、これで大丈夫でしょう。

では `MapView` に戻って、この中で座標プロパティを持たせます。ランドマークの座標型を使います。これを持たせたら、初期位置用の `region` をどうするかですね。今は `coordinateRegion` で `center` を配置していますが、ここを新しい座標プロパティから計算して設定する形に変えれば良さそうです。`latitude` と `longitude` を `center` に使う、というイメージです。あれ、`region` で座標プロパティをまだ使っていなかったかもしれないので、そこは先に読み進めながら詰めます。

それから、プレビューをまず見てみろという話になっているのですが、実装できるところは先にやってしまいます。座標を渡して、`region` の `center` にその座標を反映させる、という流れですね。SwiftUI は、座標の入力が変更されたことを検知して、本体を再描画してくれるはずです。つまり、新しい入力値を用いて `region` を再計算し、ビューをアップデートする、という挙動になります。

このあたり、`@State` が必要かどうかはまだ自信がありません。`@State` にすると `@Binding` を介して他のところへ影響したりしますよね。なので、このプロパティには `@State` はいらないのかもしれません。いったん `@State` はやめてみます。最終的には出来上がった頃に確かめましょう。

`Image` のほうは変わらないはずですが、「入力の度に検知して変わる」とさっき言っていた点は、やはり確認したいですね。ひとまず、`MapView` で座標を持たせて、それを渡すところまで進めます。 マップビューの座標はランドマークの座標ですね。あとは、さっきのところがマップビューで、座標も設定しました。これをプレビューのほうでもちゃんとやっておきます。今回、この座標はデフォルトのイニシャライザーにして、`latitude: 0`、`longitude: 0` という感じで試しています。とりあえずどこかしらが表示されるだろう、という感じです。

まだこの話題は反映していないので、コードの中に埋め込まれているこのIDが対応されていますが、これを今から書き換えていくことになるのでしょう。はい、これでよくて…あ、もう書き換えてますね。これはステップいくつだ？ ステップ4か。コーディネートをセンターパラメータに渡しますよ、ということですね。なるほど、これでうまくいくという話です。

`CLLocationCoordinate2D` を要求しているので、今プロパティで用意しているのはランドマークの座標です。変換が必要ですが、変換用のイニシャライザーは前回すでに作ってあります。`CLLocationCoordinate2D` 型のイニシャライザーに座標を渡せば変換可能です。これでうまくできました。おそらく、そうですね。うん、できた。

こうしてビューができて、ランドマークディテールも、まだ後のステップだと思いますが、ほぼできていますよね。やっと、別のステップに進まなくても良さそうだという話になっていたので、こうしておきますか。これでも問題ないでしょう。うん。

これで、ビューやディテールが変わるのは、例えば最初のものではなく2番目のものを選べば情報が変わる、といったところです。とはいえ、現時点では写真と地図くらいしか変わりません。ほかの内容はまだハードコードされているので、これから直していくことになるのでしょう、きっと。

では次へ。マップのイニシャライザーで position input の value を `.constant` にして…あ、ここは自分のほうのコードですね。いけない、いけない。あれ？ でも覚えてなかった。マップビューの中の `Map`。初期ポジションとリージョン…あ、やってますね。`initialPosition`、そして `region`。うん。大丈夫でしたね。はい。

あれ？ でも `.constant(region)`…`region` か。`.constant(initialPosition)` でしょ？ あれ、違った。ここは `CoreLocation` がインポートされていないのかな？ `CLLocationCoordinate2D` から `MapCameraPosition`。あ、そっか。だから、ここはリージョンのバインディングですね。全然違っていただけです。

なので、とりあえず `region` で。`CLLocationCoordinate2D` はリージョン…あ、リージョンはこれだ。間違えた。`region` でいいんだ。こんなふうに単純に変換するんじゃなくて、すでにリージョンを返すための計算型プロパティを用意しておいたので、これで大丈夫ということですね。なるほど。うん、できました。ちょっと雑な進行になりましたけど、できた。

これで、イニシャライザーを使って position を渡す形になっていて、これによって value が変わったときにアップデートされます。この「value が変わったとき」という意味合いを、自分が捉えているのと少し違う形で使っているのかもしれないですね。マップビューの座標に値が渡ってきたときに、それに連動して変わる、みたいな雰囲気でしょうか。ステートにすると、ここから作用させることができるのかな？ 逆に、ほかから作用できるのかな？ とか。そうなると `.constant` ではなくなりますよね、多分ね。そんな感じで、ちょっと意味合いが違うのかもなと思いましたが、まあいいや。 とりあえず読んでいきましょう。新しいイニシャライザーはバインディングを期待している、つまり値に対する双方向のコネクションを求めているということですね。ただ、`constant` を使うことで、`MapView` はインタラクティブに変更された座標を直接必要としない、という意図を示せます。地図をいろいろ動かせたときに座標が変わっては困る、よく考えるとそうですよね。ここを `@State` にしてバインディングを渡していたとすると値が変わってしまいます。それは望ましくないので、この作り方が最適ということになります。危なかったです。自分はうっかり下手なことをしていた気がするので、そこは掴みました。

次に、`LandmarkDetail` に対して `landmark` プロパティを持たせます。これを各所に反映させていく、という流れですね。`LandmarkDetail` が `landmark` を持ったので、`LandmarkDetail` に渡してあげる形をとって、そこでいろいろ反映させていく、ということです。これで全てのコネクションが確立されて、ビューが動くようになります。ここまで書けば、ちゃんと動く、ということですね。

それから、流れを変える話になります。コンテナを `VStack` から `ScrollView` に変えます。ここ、つまり `LandmarkDetail` 全体を `VStack` から `ScrollView` に変えることで、スクロールしてコンテンツを読めるようにします。あわせて `Spacer` も不要になるので削除します（下の方の `Spacer` ですね）。最後に `navigationTitle` モディファイアを付けて、ナビゲーションタイトルに名前を設定します。さらに、スクロール時の振る舞いに関連して、`navigationBarTitleDisplayMode(.inline)` でインライン表示にします。これは、このビューが `NavigationStack` に乗ったときにナビゲーションバーへ影響を与える、ということですね。

そして `LandmarkDetail_Previews` に戻って、実際のランドマークの動きを見ていきます。たくさん見ているとわからなくなってきますが、見るべきところは `LandmarkDetail` です。`LandmarkDetail` は `landmark` を持っていて、それを各サブビューに渡します。`VStack` の代わりに `ScrollView` にしているのも反映済みです。

では先に反映させます。`MapView` は `landmark` から座標を取っています。`CircleImage` も `landmark` から画像を取っています。このあたりのテキストは `landmark.name` ですね。フォントはタイトル（`.font(.title)`）です。そして、ここがディスクリプション、つまり `landmark.description` です。

`park` と `state` の部分は、この辺ですね。今は何て書いてありましたっけ…そう、`park` です。ジョシュア・ツリー国立公園（Joshua Tree National Park）ですね。英語のデータが出ていますけど、読むデータが違うだけなので大丈夫です。ちゃんと差し替わっていきます。`landmark` のこちらはデータの参照です。これで OK ですね。

ディスクリプションはここです。それから「About Turtle Rock（アバウト・タートルロック）」の見出しもここに来るはずです。とにかく、`landmark.description` をこの位置に置く、ということですね。最後に、「Turtle Rock（タートルロック）」といった名称の表記は適切に整えておきます。 だからこれでよくて、次に「About」をどうするかですね。「Outlook」を消すのか、それとも「About」「Timing」にするのかで少し違ってきます。いずれにしても、Description の表示が点々で省略されてしまって、画面いっぱいにスクロールすることもできない状態でした。そこで、これを `ScrollView` に変える必要がある、という話でした。`ScrollView` にすることでスクロール可能になり、すぐに動き出すのがすごいですよね。これで OK です。

あとはタイトル関係でしたね。まずは `Spacer` は不要ということだったので削除します。それから、`padding` の下に `navigationTitle` としてランドマークの `name` を設定し、`navigationBarTitleDisplayMode(.inline)` を指定します。ナビゲーション自体はまだ完全には作っていませんが、これで問題ないはずです。

それから、忘れていそうなところとして、この辺の「About 名称」がありそうですね。これを付ければ完成でしょうか。一応、コードを戻る前に、さっきの `navigationTitle` などはどこか、`ScrollView` の下か上かという話でした。もう一段下でしたね。`ScrollView` 自体に付けてあげるのが正解でした。あれ、何か違う通りかと思ったら、`padding` の位置が違っていました。`padding` を間違えていたようで、位置が全然違っていたみたいです。これで OK です。

あとは、「About Turtle Rock」のところは Module 4.1 のコードで、String Interpolation（文字列補間）を使って、`About \(landmark.name)` としてあげる感じですね。これで良いです。そうすると「Silver Salmon Creek State Park」で、「About Silver Salmon Creek」と表示され、その後に説明が出てくる、という流れになります。やっぱりレイアウトが効いていない気もするのですが、とりあえず大丈夫そうでしょうか。一応ここまでできました。

続いて、リストへ戻ってプレビューしてみようということなので、`LandmarkList` に戻ってプレビューします。リストが表示されました。「Turtle Rock」を押すと、Turtle Rock の情報が表示され、タイトルも出ますし、説明も載っていてスクロールもできます。戻って、例えば「St. Mary Lake」を選ぶと、この辺の場所なんでしょうね、という表示になって、ちゃんと中身も St. Mary Lake で良さそうです。仕上がってきた感じじゃないでしょうか。これでナビゲーション周りも良さそうですね。最後に、これはもう読んだところで、リストで入れてみましょう、という形で OK です。

では、セクション 8 に行きます。プレビューをダイナミックに作ってみよう、という内容です。プレビューをレンダリングして、List ビューを異なるデバイスのコンフィギュレーションで表示していきます。「ダイナミックに」というのは、いろんなデバイスのプレビューを見ていこうということですね。既定のままなら、プレビューはアクティブスキームのデバイスのサイズでレンダリングされますが、ターゲットデバイスを変更することで切り替えたり、キャンバスのデバイス設定をオーバーライド（上書き）して変更したりできます。また、プレビューのバリエーションとしてオリエンテーションなども変えられます。

まずは、デバイスセレクタでプレビューを iPad にし、オリエンテーションを縦向き（Portrait）にします。`NavigationSplitView` はこの状況ではデフォルトで Detail ペインだけが表示されます。ツールバーのボタンを押して Sidebar を表示すると、そこに最初のビューが出てきます。ツールバーボタンで Sidebar を表示し、Sidebar を選択してナビゲートできるようになります。Detail ビューは Sidebar の選択によって変化し、Sidebar はどこかをクリック（タップ）するまで残り続ける、という挙動です。まずはここまでやってみました。 iPadでプレビューします。どこでやるのかわからなかった気がしていましたが、ここですね。プレビューのデバイス選択がAutomaticになっているので、iPadに切り替えると、ディテールビューの表示に変わるはずです。ディテールビューが最初に表示される状態になり、そこからディテールビューを切り替えるためのリストを表示していくと、こんな感じですね。少し時間がかかっていますが、まあ大丈夫でしょう。もうじきです。ビルドが入りましたね。そうするとプレビューが表示される状況になり、画面がガラッと変わるはずです。

今は11インチを想定していますが、シミュレーターにどのデバイスが入っているか、インストール状況によって変わってくるはずです。とにかく動いていて、「Select a Landmark」というディテールビュー用の既定の画面が出ていますね。ここからボタンを押して、出てきたリストの中で例えばこれを押すとこうなって、メニューがまた出っ放しですが、ここを押すと消えます。これが`NavigationSplitView`という機能ですね。いい感じです。こうやってプレビューできるのはすごいですね。

次に、キャンバスでデバイス設定を選び、オリエンテーションをランドスケープ（左）にします。これで、`NavigationSplitView`のサイドバーとディテールペインが横並びで表示されることを確認しましょう。隣のDeviceのConfigurationで、どういう見え方をするかも確認できます。ここは好みで試してもらえればよいと思うので、こちらでは横画面だけやってみました。オリエンテーションをランドスケープ（左）に変えると横になり、左のメニューと右側のディテールが隣り合わせに表示されます。タップしていくと簡単に切り替わります。サイドバーが隠れているときはスクロールするとどうなるかな……スクロールすると消えて、しかもディテール側のエリアがちゃんと広がりますね。実際に実装するときは、こういった挙動も考えておかないといけない感じです。とはいえ、これくらいのコードならきちんと対応できていますね。確認は以上です。

では、理解度チェックです。リストについて。ビューのリストを動的に表示するには何を使うか、という設問ですね。答えは`ForEach`です。前回は問題がいくつかありましたし、「次の問題」を押したときに自信がなくなることもありますが、これは大丈夫でしょう。

次。`List`は`Identifiable`に準拠した要素のコレクションから作れますが、要素を`Identifiable`プロトコルに準拠させない場合はどのアプローチを使うか、という設問です。これは`List(_:id:)`（あるいは`ForEach(_:id:)`）で`id:`引数を指定する方法ですね。問題文をちゃんと読まないと間違えがちですが、今回は合っています。

次の問題。リストの行をタップして別のビューへナビゲートできるようにするには何を使うか。これは`NavigationLink`ですね。合っています。よかったです。理解度はまあまあ。といっても4.1は今回で2回目ですし、まだ復習は終わっていません。

最後は、プレビューのデバイス設定に関する問題です。プレビューするデバイスの設定として適切でないのはどれか、といった内容だったと思います。候補としては、シミュレーターのアクティブスキーム、キャンバス設定、`Override Preview Device`で直接指定する方法、接続した実機でプレビューする、といった選択肢が挙がります。キャンバス設定からプレビューデバイスを切り替えるのは確かに正しいのですが、どれが「該当しない」かは少し迷いますね。ここは自信がありません。こんな話をしていました。 シミュレーターには機種の選択もありますし、アクティブスキームもありますよね。キャンバスに直接表示する方法もありますし、オリエンテーションの切り替えもあります。プレビュー用デバイスを使うのは、プレビューを見るのに良い方法らしいですね。デバイスプレビューボタンなんてありましたっけ。あまり意識していませんでした。

特定のデバイスをアクティブにして、キャンバスと実機のプレビューを切り替える、いわゆる「Preview on Device（実機で直接プレビュー）」のことのようです。開発用デバイスを接続してデバイスプレビューボタンを使う、と書いてありますね。ここではないのかなと思いましたが、デバイスの項目はありました。これのことですね。これを選べば、そのデバイスを想定したシミュレーションになるのでしょうか。

そこでプレビューしようとしてみましたが、実機を接続していないので接続待ちのままで、特に何も起きません。ケーブルでつないでいないからでしょう。とりあえず一度だけロックを解除しました。SwiftUI をほとんどまともに使っていないというか、そんな都合で手間取っています。いま「シンボルをコピー中」となりました。結局、実機でやろうとしていますね。画面共有でどう動くのか気になりますが、まだ 1% です。

とりあえずこの辺にして次へ行きましょう。デバイスが選べるとは知りませんでしたが、ひとまず進みます。全てに答えたので次へ行きませんか。実務的にどうかな、といったところです。ではここだけ読みます。「Handling User Input」、ユーザーの入力をハンドリングしていく章です。フラグでフィルタリングできるようにします。まずリストにスイッチを追加して、ユーザーがお気に入りのものだけにフォーカスできるようにします。それからスターのボタンを作って、ランドマークにお気に入りフラグを付けられるようにする、という流れのようです。そんな感じで進めていくことになりそうです。ダウンロードするところまでやってきました。

まず読み進めつつプロジェクトファイルをダウンロードして、お気に入りのランドマークを作っていく話になりますが、これはステップ1で手順がいろいろあるので、時間的に今日は落としましょう。ダウンロードだけした、という感じです。どこかでダウンロードしたスターマークの画像を入れておけ、という話が出てくると思います。リソースを検索して入れれば良いかな。おそらく「Assets」に入れろ、という指示が出てくるはずですが、スターマークは候補がたくさん出てきそうですね。「アセット」というキーワードで出てくるでしょうか……今は出てきませんでした。これはまた今度、チュートリアルに沿って実際にできるようになってからにします。

さっきのデバイス側はまだ 1% のままです。これもすぐには見られなさそうなので、いったんプレビューを非表示にして、コードが大丈夫かざっくり見ておきます。これまでの流れだと `@State` を使っていなかったので、次回からデータが出てくる雰囲気ではありますが、現状はデータを使わない形に直しておきました。本当に適切な使い方ができているか自信はないのですが、ひとまずはそれで良しとします。

今のところのバインディングなど、そういったリンクは外してしまって、この状態で `ContentView` のプレビューを確認します。まずはビルドエラーを直すところからです。プレビュー内の値は `.constant` や `Binding` ではなく、直接渡す形に変更します。こちらもバインディングになっている都合があったので、直接渡すようにすれば OK です。これでビルドが通り、プレビューも表示されます。今は `LandmarkList` が正なので、`ContentView` のプレビューを見て、ちゃんと動いていることを確認しました。この構成で進めると良さそうです。ひとまず適当に付けてみただけですが、動作は問題ありません。

次回は新しくお気に入りボタンを付ける、というところから見ていくことにしましょう。では、これで終わりにします。ありがとうございました。
