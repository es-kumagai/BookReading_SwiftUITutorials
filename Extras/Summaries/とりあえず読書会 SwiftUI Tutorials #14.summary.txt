Transcription & Summarize : とりあえず読書会 SwiftUI Tutorials #14

引き続き、TwitterやYouTube Liveを追いかけていきます。前回とその前あたりで、リファクタリングをやってみようという話になりました。大げさなことではなく、気になるコードを直していくという感じです。YouTube Liveの中でこっそりコピペしてしまったところがあって、そのままだと何をやっているのか分かりにくいし、気持ち悪いなと思ったので、手を入れてみました。実際にやってみると、やはり得られるものが多いですね。

ライブを追いかけているだけだと、なんとなく分かった気になってしまいますが、実際に手元でコードをいじって、書き直していくことで理解が進み、定着する感覚があります。そういう手間をかけるのは、学習という観点ではやはり良いのだなと、改めて感じました。とはいえ、ゆっくりやるのはなかなか難しいです。たとえば前回のように、YouTube Liveでコピペしたコードはファイルが5個くらいで、100行もないくらいですが、それを見直して整えるのに2〜4時間くらいかかりました。効率が悪いといえば悪いのですが、だからダメだとも言い切れない、難しいところですね。

さて、そんな感じでリファクタリングもいい具合に進んだので、次に進みます。今日はこれです。新しい画面レイアウトを用意していく中で、複雑なインターフェースを組み合わせていく話です。ランドマークのカテゴリビューでは、垂直スクロールのリストの中に、水平スクロールのランドマーク一覧（各カテゴリの行）を並べていく構成になります。このビューを他のビューに接続し、異なるデバイスサイズや画面の向きに対応していくアプローチを見ていきます。

カテゴリビューの話は少し曖昧だったので、訳を確認します。翻訳ソフトをアップデートしていたのですが、ちょうど終わりました。訳によると「ランドマークのカテゴリビューでは、水平方向にスクロールするランドマークの行が、垂直方向にスクロールするリストとして表示される」とのことです。概ね理解どおりですね。まずはサンプルのダウンロードがあるので、それを落としておきます。

次に、カテゴリビューを追加します。ランドマークをブラウズする方法を増やすために、カテゴリでソートしたビューを作ります。加えて、Featured（注目の）ランドマークをトップにハイライト表示する機能も用意します。つまり、Featuredの表示と、カテゴリごとの表示を組み合わせる形です。

そのために、まずはXcodeのプロジェクト内にカテゴリ用のグループ（フォルダ）を作り、`CategoryHome` というカスタムビューを追加します。Xcodeのバージョンアップで「グループ」はフォルダに統一されましたよね。`CategoryHome` の中で `NavigationSplitView` を使ってレイアウトしていきます。`NavigationLink` のインスタンスを使いながら、詳細側にランドマークの詳細を表示していく形です。まずはここまでやります。

ビューズのフォルダの中に新しいフォルダを作って「Category」とし、その中にビューとして `CategoryHome` を追加します。`CategoryHome` の本文には `NavigationSplitView` を入れ、ナビゲーションタイトルを設定します。ディテール側には、とりあえず `Text("selectedLandmark")` のような仮の表示を置いておきます。プレビューにも `Hello, world!` が出ていればOKです。

次に、セクション2としてカテゴリリストを作ります。カテゴリビューは、すべてのカテゴリを表示し、各行（row）ごとにカテゴリに属するランドマークを水平スクロールで見せる構成です。つまり、垂直方向のスタックと水平方向のスクロールを組み合わせて、`ScrollView` と `List` を適切に使っていく、ということですね。

このために、まずデータ側にカテゴリ情報を持たせます。ランドマークのデータファイルには既にカテゴリの文字列が含まれているので、`Landmark` 構造体に `category` プロパティを追加し、その型となる `Category` 列挙型を定義します。`Category` は文字列の rawValue を持つ列挙にして、必要に応じて `CaseIterable` や `Codable`（場合によっては `Hashable`）に準拠させます。ここまで実装していきます。

`Landmark` 型のファイル構成を見直していたら、`Coordinates` が独立した型になっているので、ファイル名をどうするか少し悩みました。`Coordinates` は `Landmark` の内部で使われるので、ファイル名を整理したくなりますね。`Coordinates.swift` のように分けるか、`Landmark.swift` にまとめるか、といったところです。とりあえず今回はファイル名を整理しつつ進めます。

それから、Xcodeのフォルダ構成について少し実験しました。別階層に同名のファイル（今回は意図的に）を置いてビルドしてみたところ、エラーが出ました。メッセージは「Multiple commands produce ...」というもので、ビルド時に同じ成果物を複数のコマンドが生成しようとして衝突している、という内容です。ログには `...strings` 系のリソース名も出てきたので、同名のファイルやリソースがバンドルに重複して入ろうとしているのが原因のようです。グループ（フォルダ）で分かれていても、ビルドターゲットの出力として同じパスに出るものが重複するとダメ、という仕様ですね。別名に変更すればビルドは通るはずです。この仕様は少しもったいない気もしますが、そういうものだと割り切るしかなさそうです。 名前空間が衝突しがちなので、やむを得ずファイル名に名前空間を付ける、という対応をしています。たとえば「Category」という名前が他とぶつちそうなときは、拡張で `Landmark` にネストして `Landmark.Category` とする工夫で良いでしょう。

今までのコードを書き換えた流れに合わせて、このカテゴリーは見た感じ `Comparable`……ではなく `Sendable` で良さそうですね。`RawValue` の指定の後にプロトコル適合を書く必要があるので、`enum Category: String, Codable, CaseIterable, Sendable` の形にします。やっと `CaseIterable` を使うことになりそうです。カテゴリーをリストアップするために `CaseIterable` が必要な感じですね。`Codable` も付けておけば扱いやすいので、そのまま持たせておきます。

次に、`ModelData` の中でカテゴリごとのランドマーク一覧を持てるように、カテゴリ名をキー、割り当てられたランドマークの配列を値とする辞書をプロパティとして用意します。最初は `category.rawValue`（`String`）でグループ化していましたが、列挙型として `Category` をキーにした方が型安全ですし、後でデータを持たせる余地もあるので、その方が良いですね。列挙型（関連値なし）は自動で `Hashable` に準拠するので、辞書のキーに使えます。

ランドマークの配列には `typealias` を使って `typealias Landmarks = [Landmark]` のように書いておくと読みやすいでしょう。グルーピングは `Dictionary(grouping:by:)` で実装します。配列（`Sequence`）から良い感じにグループ化できます。具体的には、`Dictionary(grouping: landmarks, by: \.category)` のように書けば、`[Category: [Landmark]]` が得られます。先ほどの `rawValue` を使う必要はありません。

一度 `rawValue` をやめて `Category` そのものをキーに切り替えたところで、`Dictionary(grouping:by:)` の定義を確認しました。これは「`S: Sequence`、`K: Hashable` のときに、`(S.Element) -> K` を受け取って `[K: [S.Element]]` を返す」関数ですね。つまり、エレメントからキーを返すクロージャを渡せば、値の配列が辞書のバリューとして構築されます。`Category` は `Hashable` なので条件は満たしています。

途中で Xcode が落ちてしまいましたが、型の指定を間違えていたのが原因でした。「これは `String` で持たせたいのか？」と迷いましたが、やはり `Category` のまま持つのが筋が良いです。`by: \.category` にしておけば、`Landmark.category` を使って期待通りにグルーピングできます。

最後に、`Landmark` 側にはカテゴリーのプロパティを追加します。`isFavorite` の後あたりに `category` を入れておけば良いでしょう。これで `Landmark` と `ModelData` の両方でカテゴリーを扱う準備が整いました。ビルドも通るはずです。 そのエレメントとバリューが一致するという条件しかなくて、バリュー側の条件はシンプルですね。該当箇所はどこでしたっけ……あ、ここですね。バリューに関する条件は特にありません。

そうすると、カテゴリー別にもう一段これをカテゴリーにします。あ、わかりました。カテゴリーにするとして、このカテゴリーはどこから持ってきたのでしょうか。Objective-C には Category という仕組みがありましたね。クラスを拡張するための機能でした。ここで言っているカテゴリーは、要はランドマークのカテゴリーのことです。ランドマークのカテゴリーにすれば分かりやすいですよね。

そうすることで、ディクショナリーのキーを列挙型で持てるわけです。列挙型で持つというのは、裏側では純粋に数値で保持しているということですね。たしか `int` だったかな。まあ、`int` などで持っているので、文字列で持たせるよりずっと良いですよね。せっかくこういう技があるのですから、そうするのが良いという感じです。 `Dictionary(grouping:by:)`でクロージャを渡せます。これって、もしかして`by`のことですよね。`by`は何を取るんだっけ？ ランドマークからカテゴリーを返す関数か。ここでは関数は自分自身のカテゴリーを返します。できますよね。キーパスがよくわからなくなってきましたが、そんなに改行しなくても一行で十分見やすいくらいです。これでランドマークをカテゴリーでグルーピングしたディクショナリを返す、ということですね。いい感じじゃないですか。

CategoryForm の中でモデルデータのプロパティを持たせます。これを`@EnvironmentObject`で持たせてあげると。必要なのはアクセスで、カテゴリーにアクセスし、後ほどその他のランドマークデータにもアクセスします。“as well as”ってよく聞きますが、同じような感じですよね。とりあえず`@EnvironmentObject`で ModelData を CategoryForm に持たせておきます。ここまでまずやりましょう。

なので、CategoryForm に行って、この中で struct に対して`@EnvironmentObject var modelData: ModelData`。`modelData`って書くたびに思うんですけど、名前はこれで大丈夫かな？ ちょっと汎用的すぎる気もしますが、分かるからいいのか。ここで`var`が抜けていましたね。`modelData`。プレビューのところで`environmentObject(ModelData())`を既に設定してありましたよね。これでプレビューも復活して OK ですね。大丈夫だと思うんで、次に進んで、止まったら考えましょう。

次、ステップ4として、カテゴリーのリスト。ランドマークの中のカテゴリーを表示するリストを使います。ランドマークの`Category`のケース名がリストのアイテムになる、という理解で良さそうです。ランドマークのカテゴリーと書いてありますが、それをどうしていたっけ……まあいいか。とにかくリストになって、それはユニークでなければなりません。列挙型なので、重複がないようにしておきたいわけです。

リストを使って表示して、その中で`ForEach`を使っています。`ForEach`でカテゴリーを要素として、`id: \.self`で並び替えたカテゴリーを使う。キーがカテゴリーなので、それを表示する、という流れです。CategoryForm ですね。

そのナビゲーションのところで、`List`にして、その中で`ForEach`にして、データとして`modelData`の「ランドマークをカテゴリーでグルーピングしたディクショナリ」の`keys`を使います。ここで`keys`を`sorted()`して、その並べ方として使うのは……これは特に何もしないのか。モデル側で並べ替えようとしたからですね。`sorted`したのは。これをまず直していくには、`id: \.self`にして、ループの中身としてキーを受け取り、`Text(key)`を表示する。ここではこれがキーですね。`Text(key)`と。こういうふうに、サンプルというか、実例ではそうなっていますよね。

ただし、自分が型の定義を整えながらやってきた都合で、これでは動かない状態になっています。これを動くようにするためにまず考えられるのは、この`sorted`が「何を基準にソートしたらいいのか分からない」状況になっていることです。まずはそれ。だからプレビューは一旦隠しますかね。

`categories`の`keys`をソートの対象にしている、ここがまず1つあります。なので`categories.keys`って取って、`keys`は何型なんだろう。`keys`は`Dictionary<Key, Value>.Keys`です。最適化されていそうなので、そのまま使えばいいですね。

同時に、このキーが、今はランドマークのカテゴリーを文字列ではなく、直接`Category`を持つようにしたことによって、`sorted()`が機能していないわけです。`sorted()`が機能していない理由は、大小比較ができない状態だから、というだけのはずです。今回の場合はカテゴリーを大小比較してソートできるようにしてあげる。それに尽きますかね。

今回、カテゴリーを「カテゴリー順」で並べる。ただしこのカテゴリーは、アルファベット順という並びがこのカテゴリーにとって常識なのかどうかで、実装の置き場所が変わってきますよね。アルファベット順が常識には見えない気がします、この順番。 なので、これはソートして丁寧に順番を設定した方がいい気がしますね。そこで、UI に対して CategoryForm の中で表示するカテゴリーは、順番があっても良さそうなので、ここで `categories` というプロパティを追加します。ここも一応 `typealias` でやっておきますが、`Category` は単数ではあまり使わない気がするので定義するか迷います。`Categories` はカテゴリーの ID（IDs）の配列、つまりカテゴリーの識別子一覧というイメージです。`Landmark` の `Categories` として用意して、この中でソートすればいいですね。

このときにやることとしては、モデルデータの `categories` があるので、これを `sorted` します。`sorted` のクロージャでは left-hand side と right-hand side を比較しますが、アルファベット順、つまり辞書順で並べたいです。`rawValue` があると思うので、`{ lhs, rhs in lhs.rawValue < rhs.rawValue }` のようにしたいところです。ただし、今は `Dictionary` の `keys` を扱っているので、そのままだと「left-hand side の `rawValue` が無い」と言われます。`Dictionary` の `keys` はそのままでは配列ではないので、`Array(modelData.categories.keys).sorted { $0.rawValue < $1.rawValue }` のように、いったん配列にしてから `sorted` ですね。

こうすることによって、CategoryForm におけるカテゴリーは、モデルデータによる順番を考慮したものになります。すると、ここで `ForEach` に対して `categories` を渡して、`id: \.self` ですよ、という形にできます。`Identifiable` に適合させて `id` プロパティを生やす方法もありますが、余計なプロパティが 1 個増えてしまうのが気になるので、`id: \.self` で回せるならそれで十分です。

表示については、まずはカテゴリーの `rawValue` を表示するのが手っ取り早いです。ただ、本来は `Landmark.Category` を `CustomStringConvertible` に準拠させて、`description` で `rawValue` を返すのがきれいですね。これは、この型の文字列表現を自分で定義しておきたいからです。そうすると、このカテゴリーはそのまま渡せるかと思いきや、さすがに `Text` に直接は渡せず、文字列に変換しないとダメそうです。

`Text` のイニシャライザを見てみると、`content` は `StringProtocol` を取る版があり、`verbatim` は `String` を取ります。一方で、`Text("\(category)")` のように文字列補間で書くと、`LocalizedStringKey` を取る初期化子が呼ばれてしまい、ローカライズキーとして解釈されます。これは微妙ですね。本当は `StringProtocol` のほうを呼ばせたいのですが、API デザイン上そうならない。もしかして `as String` のようなキャストや、`Text(verbatim:)` を使わなければいけないのか、という話になりますが、これも少し扱いづらいです。

一つの方法としては、`String(describing: category)` を使うか、`Text(verbatim: category.rawValue)` のように `verbatim` を明示するのが一般的です。あるいは、後のところでは文字列補間で自動的に展開する方法もありますが、ここでは `LocalizedStringKey` に解釈されてしまう問題や、非推奨の経路に入ってしまう警告が出ることがあるので避けたいです。

この辺をもう少しきれいにするなら、`Text` に対して `Landmark.Category` 用のイニシャライザを extension で用意してしまうのが良さそうです。たとえば、`extension Text { init(_ category: Landmark.Category) { self = Text(verbatim: category.rawValue) } }` のようにしておけば、`Text(category)` と書くだけで、毎回の変換を意識せずに表示できます。 整形する元の文字起こしテキストを貼り付けてください。途中の文から始まっていてもそのままで大丈夫です。コードが含まれている場合は、そのまま一緒にお送りください。

長い場合は分割してお送りいただいても構いません（例: [1/3], [2/3], [3/3] のように順番を明記）。こちらで「ですます調」に整え、誤変換を修正し、短いコードはインラインのバックティックで装飾して仕上げます。 文字起こしのテキストを貼り付けてください。  
「ですます調」で読みやすく整え、誤変換を修正し、コードはインラインでバックティックで装飾します（短いコードのみ）。要約はしません。長文の場合は分割して送っていただいても大丈夫です。 カテゴリーをとりあえず作って、この中で `String(describing:)` を使ってテキスト化する、という方法で表現するやり方がまず一つあります。もう一つは、カテゴリービューを作る方法です。基本的には、使う場所にいきなり直接書いてしまってもいいのですが、いろいろなところで使うとなると、ラベル（カテゴリー）をテキストとして表現する際に統一感がなくなると困ります。そこで、Views のところに SwiftUI のビューとしてカテゴリービューを作るのがよさそうです。名前は「カテゴリーテキスト」にするか「カテゴリービュー」にするか迷いましたが、ここでは「カテゴリービュー」にします。

この `CategoryView` の中で、`let category: Landmark.Category` のように受け取り、`var body` の中では純粋に `Text(String(describing: category))` を返すようにします。`CategoryView` はカテゴリーを取るのが自然なので、ラベルなしのイニシャライザを用意しておきます。たとえば `init(_ category: Landmark.Category) { self.category = category }` のようにしておくと、呼び出し側では `CategoryView(landmark.category)` のように、関数みたいにすっきり使えます。

これでカテゴリーは `CategoryView` にカテゴリーを渡して表示する形に統一できました。要らなくなったコードは消しておきます。以前、SwiftUI 側に書いていた一時的なテキスト表示用のコードも大げさでしたし、もう不要なので削除します。テキストでカテゴリーを直接取るようなヘルパーも残っていないことを確認しました。これでカテゴリーが表示されるようになりましたし、プレビューも問題なく出るはずです。

ところで、さきほど Dictionary のキーを使って並び替えましたが、それで良いと思います。押したときにカテゴリー側が `CaseIterable` を持っている理由については、今のところ使っていないので外しておきましょう。`CaseIterable` は「カテゴリーを全部まとめて取りたい」という場面で使う想定ですが、今回はグルーピングしてしまった関係で使いどころがありませんでした。`CaseIterable` を外してもプレビューはちゃんと出るはずです。

ここまでで、カテゴリーの表示はスマートにできたと思います。次は `NavigationLink` を作っていく流れになります。セクション3として、`CategoryRow` を生成していきます。Landmarks では、それぞれのカテゴリーを Row にして、水平スクロールでカテゴリーを表示します。そのために新しい View 型を作り、カテゴリーに対応するランドマークをこのビューに表示していきます。ランドマークビューの一部を再利用できるので、似たような構成で進めます。プレビューは、以前に Combining Views で作ったものと似た感じになると思いますが、そのあたりはあとで確認します。 とりあえず、`CategoryRow` というものを作っていって、それが Row を保持する、つまり「カテゴリ Row を保持する」ということですね。CategoryRow。Holding the contents of a row。業務のデータを持たせる方ですよ、という話か。それで、そこにプロパティとして `categoryName` と `items`。`categoryName`。また、ちょっと気になるプロパティ言いましたね。あとは、List of items。アイテムの…アイテム。アイテム。ランドマークね。これ、悩みますね。アイテムって言うと「何のアイテム？」ってなってくるじゃないですか。`CategoryRow` って言っている中で、そのカテゴリーに対して何、って話になってくるので、ランドマークのほうがいいんじゃないかな。

それで、プレビューをまずは動くようにしていこう、という話になっていますね。ランドマークの0番目。もうちょっと読んでからにしますか。続いて、`CategoryItem` を Stack に配置して、水平スタック、つまり `HStack` に配置して、それをプレビューでグループ、Group、カテゴリーのプレビューで、プレビューで `categoryName` を追加する形にすると。なるほど。

ステップ5まで行っちゃっていいのかな。パパパパッ…。ここまでにしましょうか。はい、じゃあどうする、と。なるほど。`categoryName` ですよね。やってみますか。`categoryName` と `items`。まずは素直にいきましょう。

そのためには、Views の中の Controls。Controls の中にカテゴリーを追加する。`CategoryRow` を追加して、Views の中の CategoryHome と Row…。Categories に入れたか。Controls と何が違うんだろうね。まあいいか。`CategoryRow` でしょ。

その中で `CategoryRow` が、まずプロパティとして、`let categoryName: String`、`let items: [Landmark]`、そしてランドマーク。`body` の中で、まずは `HStack` かな。`HStack` で、データが `items`。で、コンテンツとして、コンテンツとして `Text(landmark.name)`。ランドマークネームは、テキストの `items` というか、アイテムの変数を `landmark in` で受けた…グレグレな感じしますね。`landmark in`。合ってはいるんですけどね。`landmark.name`。

こうすることによって、プレビューをちゃんと整えないといけないですね。`let modelData = ModelData()` の初期値。その上で `CategoryRow` は、`categoryName`。`categoryName` は、どう指定してたっけ？あ、カテゴリーか。あーなるほど。`categoryName` はこれで、あーあーあーって感じだな。どうしようか。ここでもう1個入れておきますか。`landmarks = modelData.landmarks`。これでいいですね。`categoryName` が、`landmarks[0].category.rawValue`。`rawValue` ってやってますね。で、次で `landmarks` は、`landmarks`。こんなふうにできましたね。

これでプレビューも動くようになっていて、えーと、はい。何だこれ、すごいことになっているわ。プレビューがすごいことになっているのは、ランドマーク何か間違った？えーと、`reversed()` イコール…良くないかな。えーと、なんか間違ったっけ。配列に入れている `prefix(3)`。`landmarks.prefix(3)` か。あーなるほど。`landmarks.prefix(3)`。これを配列にして入れていると。うん、ここはしょうがないか。波かっこで配列にして入れて、`prefix(3)` を `Array` でもいいか。こうすると、あーこんな感じか。あーそういうことか。なるほど。3つ並んでいて。まあまあ、まずは OK ですけど、どうしようかな。

これを直していく前に、サイズとか変えていきますか。`padding` を整えて。だからスペースを与えることによって…。まずはこの辺、コピーしますかね。どこまでにしようかな。`Text` と `ScrollView` と、ここで分かるか。これで `Text` からにしようかな、分かりやすいように。そうしてあげると、`CategoryRow` の中で、テキスト、上の一番上のテキストからですね。こんな感じ。そうしてあげると、よしなに。いい感じにサイズが取れて、スペース入っていて、ここがよしなに。見えない人は画像に差し替えるんですよね。なのでこうやって作った、と。

それで、プレビュー、もしかして変わってる。`prefix(4)` に変わってますね。`prefix(4)`。これでスクロールすることが確認できるようになって。更新される。更新する。プレビュー。サンプルデータ。`ScrollView` の動きを確認できる。

それで新しいカスタムビューを作る。`CategoryItem` というものを作る。ここでいろいろ綺麗に整えていくのか。なるほど。ここまでやってから `CategoryItem` を作るよと。`CategoryItem` を作り、その `CategoryRow` の中でテキストとして表示していたものを `CategoryItem` に置き換えていくと。その `CategoryItem` に置き換える中で、テキストの置き換え。`CategoryRow` で置き換えるテキスト。`landmark.name` を保持しているテキスト。`landmark.name`。`CategoryItem` で `landmark` を指定するよと。これをやっていきましょう。名前もそのあたりは一緒かな。`CategoryItem` を Categories の中に作るのが妥当、ということをやりたいんですよね。`CategoryItem`。`CategoryItem` の中身は今コピーしてきたやつを貼り付けて、これで `resizable` ができていない。ランドマーク。ランドマークの `Image`。イメージは今、独自のイメージの言い方なんですよね。これが何型でした。 元々、書き換える前は何型だったかという話をしていました。イメージを取って、SwiftUI の `Image` にする、というイメージです。これにしようと思っているんですよね。なので、ランドマークの `image` を `Image` に変換してあげて、これでいいですね。できました。そういうふうにコードを改修した、という話です。

これでプレビューもちゃんと表示されて、こんなふうになるのがいいですね。ランドマークの `name`、`CategoryRow` の中で `Text` にしていたやつは、`LandmarkItem`、`CategoryItem` のように分けて扱う形にします。こんなふうにして、ランドマークはランドマークとして扱う、という整理で良さそうです。これで一旦できた、という感じですね。

ということで次に行ってもいいのですが、少しコードを手直ししておきましょう。まずはカテゴリービュー（外側）から見ていきます。一番外側からどこをやるのがいいのか自信はないのですが、とりあえず一番外側のプレビューを調整しておけば分かるかなと思ったものの、まだ使っていない部分もあります。`CategoryView` があって、`Row` はまだ使っていないのか。次のセクションで出てくる `CategoryRow` の完成作業、という形で出てくるはずですが、完成は後に回すことにします。ここは一旦良いとして……。

何を調整していくんだっけ、そうだ、`CategoryRow` でした。ここを直していきたい気分になったので、ピン止めしておいて見ていきましょう。上側にあったほうが気持ちがいいので、ここは `Group` にしておきます。で、この `CategoryRow`、上に寄るかな？ 寄らないか。寄らないなら `GeometryReader` か……。いや、`GeometryReader` はあまり使いたくないので、`VStack` にしましょう。`VStack` にするなら `alignment: .leading` ですね。`VStack` のアライメントは横方向のそろえ方なので、`.leading` にしておきます。Vertical のアライメントの話ではないですね。この程度の調整で十分寄るはず、という経験則どおりで大丈夫そうです。

ではコードをもう少し見ていきます。`categoryName` でいきなり `String` をもらっていますよね、というところが気になります。カテゴリーの名前だ、という話をしていますが、`extension Landmark.Category` に `name` という概念があるはずです。`name: String` を生やしておけば、`rawValue` を使わずに済みます。カテゴリーを表示するときには `name` を表示すればよいので、`description` は `rawValue` でもいいのですが、基本は `name` で良いですよね。これでいい感じに名前の扱いが整理できて、スッキリしました。

場合によっては `CustomStringConvertible` を採用するという選択肢もありますが、今回は不要なので入れない方針でいきます。まず、カテゴリーの表現が少し変わりました。すると、カテゴリーを受け取る側でも、`Text(categoryName)` のように `String` を受けるのではなく、`category: Landmark.Category` をそのまま受け取るようにできます。列挙型で持っておけるのでメモリ効率も良いですし、名前が欲しいときは `category.name` を表示すれば良いわけです。これまで「カテゴリーをそのままテキスト化」していたところは削ってしまいましょう。覚えることが多くなるのは面倒ですし、簡単にできる手段があるならそれで十分です。

`Text` を使う箇所では、`CategoryRow` での `categoryName` は `category` になった、という変更になります。つまり、ランドマークのカテゴリー（`Landmark.Category`）を渡してあげる形です。`CategoryView` 側でも、`Text(category.name)` のほうがシンプルで分かりやすいですよね。これで良いと思います。`CustomStringConvertible` も、これなら不要です。なくて問題ありません。

さて、`CategoryRow` をもう一度見ます。`CategoryRow` はカテゴリーとアイテムを受け取っていますが、カテゴリーが必ず一定であることを前提としている気がします。もう少しその前提を考慮した作りにしたいです。例えば、与えられたランドマーク（`landmarks`）からカテゴリーが決まるはずです。すなわち、アイテム群の内容からカテゴリーを導出する、あるいは受け取るアイテムをすべてそのカテゴリーでフィルタしたものに限定する、といった設計が自然です。この方向で調整していきたいと思います。 そのときに、ランドマークの中でカテゴリーが同じかどうかを判定できればよさそうです。コレクションでランドマークを拡張していって、インデックス…ではなくエクステンションですね。`extension Collection where Element == Landmark` のように、`where Element == Landmark` で制約をかける形にしましょう。そうすると、下の書き方にも違和感が出てくるので、こちらもプライマリー…というか型パラメータを使う表現にしてしまって良さそうです。

ここで `var withSameCategory: Bool` のようなプロパティを作ります。たとえば要素が0個だったときは、`guard let first = first else { return true }` のようにして、空なら `true` を返せばよいでしょう。最初の要素が取れたら、`dropFirst().allSatisfy { $0.category == first.category }` として、最初のカテゴリーと全部一致するかを判定します。これで「同じカテゴリーか」を判定できます。

プロパティ名は悩ましいですね。`withSameCategory` でもよいのですが、`isSameCategory`、`hasUniqueCategory` なども考えられます。まだ決めかねるので、ひとまずここでは `withSameCategory` としておきます。

その上で、イニシャライザを作り、そこでカテゴリーの整合性をチェックします。イニシャライザはランドマークを受け取り、取り方はジェネリックで、`some Collection<Landmark>` としましょう。`guard landmarks.withSameCategory else { fatalError("landmarks はすべて同じ category の Landmark を渡す必要があります") }` のようにして、同一カテゴリーでない場合は論理的なエラーとして `fatalError` にします。

さらに、カテゴリーがいまオプショナルではないので、空配列は許容しないようにします。`guard !landmarks.isEmpty else { fatalError("1つ以上の Landmark を渡す必要があります") }` として、要素数0も落とします。これによって、カテゴリーが一致していることが保証されるので、`category` は `items` の最初の要素の `category` にできます。

命名については、`items` だと `categories` に引っ張られがちなので、プロパティ名は `landmarks` にしておきましょう。ああ、`landmarks` にできるのは、引数をジェネリクスで受けているからですね。 なので、`Array`で変換してあげると、ジェネリクスで受け取る必要が出てきて、ちょっと微妙になってきましたね。イニシャライザーの中で処理できるのは便利でいいんですけど、ここで`items`という名前は分かりにくいですよね。ここは`landmarks`にしたほうがよさそうです。`landmarks`をプロパティとして持たせてあげることで、イニシャライザーは`self`か、`self.landmarks`を使って書けます。これは好みの問題ですが、両方とも`self`で統一して戻したいところです。

`landmarks`を分離することで、適切なものが渡っていればOKですし、適切でなければランタイムエラーで落ちます。ランタイムエラーで落ちるのが嫌いな人は別の工夫が必要ですが、このカテゴリの扱いを見る限り、そこまでは想定していないように思えます。ランドマークがゼロ件の可能性はあるのか、という点については、どちらを優先するかで設計が変わりますよね。このコードだと、取得の仕方の都合で、そのカテゴリーに対してランドマークが必ず1件以上存在します。ただ、場合によっては、今回は`allCases`、要は`CaseIterable`を外しているので起きませんが、`CaseIterable`を使っていた場合には、ランドマークが空のケースはあり得ます。これを考慮すると、両方（たとえばカテゴリーもランドマークも両方必須）にする必要はないかもしれません。両方はやりすぎですね。

カテゴリーはランドマークのカテゴリーです。`category`と`landmarks`を引数に取り、カテゴリを省略可能にして、`landmarks`は必須、という形にするのがよさそうです。その上で、カテゴリーを渡さなかった場合は、`nil`ではないことを確認して、`self`のイニシャライザーで、カテゴリーには`landmarks`の最初の要素のカテゴリーを渡し、`landmarks`はそのまま渡す、というイメージです。こういったイニシャライズでまず良さそうですね。

さらに、上の方のイニシャライザーでは、`landmarks`がすべて同じカテゴリーであることを確認し、かつそれが指定されたカテゴリーと一致しているかを調べます。`sameCategory`というプロパティがあるならそれでもよいですが、別に`isSameCategory(as category)`という関数を用意して、`landmarks`のカテゴリーを受け取り、指定されたカテゴリーと一致するかを返すようにします。ここでは`return`を書かなくても良いですが、最初の実装と比べると効率は少し落ちますね。

判定方法としては、まず`first`で先頭のカテゴリーを取り、`first`が`nil`なら`false`で良いでしょう。その上で、先頭が見つかったなら、`isSameCategory(as: firstCategory)`で、残りのカテゴリーと一致するかをチェックします。全要素に対して先頭と一致するかを調べるのは無駄があるので、`dropFirst()`に対して`isSameCategory`を適用して、先頭のカテゴリーと残りが一致するかを判定すれば良いですね。カテゴリー引数は`Optional`でいいですよね。これで`isSameCategory(as category)`という形でも大丈夫です。

これによって、渡されたカテゴリーはそのまま設定し、`landmarks`も渡されたものをそのまま設定します。ランタイムエラーにはなり得ますが、少なくとも`CategoryRow`が生成された時点で、カテゴリーと`landmarks`の矛盾が生じないことが保証されるので、その後の処理が楽になります。

ここまでで`landmarks`の消化が終わって描画に進めます。`body`の方は、`categoryName`を`Text`で表示して、`ScrollView`を水平方向にし、`HStack`を作って`padding`などを入れます。`landmarks`を1件ずつ回して、`CategoryItem(landmark: landmark)`のように配置する、という流れですね。これで`CategoryRow`の中で、`CategoryItem`に`landmark`を渡す形にできます。ここです。 すごく抽象的な名前を付けたかなというのが気になるところで、エクステンションで`CategoryRow`ってやってしまえば、かなり再利用が効いてくると思うんですよ。これで`CategoryRow`の`CategoryItem`という形でできるわけですけど、このときに`CategoryItem`というよりは、`CategoryRow`の中のランドマークですよね。だから`CategoryItem`というよりランドマーク。ただ、ランドマークという名前だと分かりにくさも出てこないことはない。それを踏まえると、`LandmarkItem`か、`LandmarkCell`っていう手もありそうですよね。Rowの中に出るからでもいいですけど、セルでいいかな、`LandmarkCell`。こういうふうに打ってあげて、これでいいんじゃないかな。

`LandmarkCell`って言ったらランドマークを取る、というのは良い感じになってきそうなので、イニシャライザーを作って`Label`を受け取らせ、ランドマークはランドマークですよ、というふうにして、実装で`self.landmark`として`landmark`を代入しました。ここまでくると、`LandmarkCell`に対してこのラベル要らなくなるよね、という話になり、これでおおよそ問題なく動くのかな。こっちも実は、ランドマーク、`CategoryRow`、`CategoryRow`、`CategoryRow`。今の`CategoryRow`で、カテゴリーが`first`と、`items2`と配列の`prefix(4)`で、`items2`じゃなくて`landmarks`か。

ちなみにさっき、ジェネリックで表現したので、配列に変換しないで`prefix(4)`を渡せばOKですよね、という感じですね。これで大丈夫ですが、今回の場合、最初のカテゴリーを渡した場合というのは、極力ジェネリックなインターフェースにしたので、`CategoryRow`に対してランドマークと`landmarks`を渡すだけでいけるはずです。ちなみに、僕はこれで完成のはずなんですが、動かない。ランドマークのラベルは要らないようだ。ここをね、`landmarks`で言えば、ランドマークのラベルが要らないようだ。これで`CategoryRow`、これがちゃんと動くはず。今度は大丈夫でしょう。

コンパイルも、一通りエラーになりそうなところは取った気がしたけど、動かなかった。しかもこれ、ランタイムエラーで落ちた。ランタイムエラーで落ちたってことはすなわち、フェイタルエラーで落ちた。ランドマークは…えーと、クラッシュした。クラッシュしたしか出てないですね。こっちはクラッシュログだ。エラーとかフェイタルエラー出てるのかな。フェイタルエラーなんか落としてる気がするけど。

これは`landmarks`。ここはダメだね。ここは…うん、ここはダメだ。ここのリスト、今これリストの…ダメですね。だからこれで、例えば、`let filteredCategory = ...`のようにして、ランドマークの`category`に対して、ランドマークの`category`が`selectedCategory`と一致するものだけにフィルタリングをした上で、このRowを呼び出すところに対して、カテゴリーはちゃんと取ってあるから、今回はそれも渡しちゃったらいいですね。カテゴリーとして`category`を渡し、ランドマークにして、ランドマーク。で、動くでしょ。

カテゴリーとランドマークが動き、ランドマークのカテゴリー、これが…ランドマークカテゴリー、ランドマーク、ランドマーク、カテゴリー、ランドマーク、ランドマーク、`LandmarkCell`。セルがこれ。セルのプレビューが、このカテゴリーを`Row`と見間違えてた。セルは良いんだ。セルは別に問題なかった。そんなことしなくても、逆にこれ、別の場所で使えそうな気がするから、これはコピーしておいて、ここに戻そう。そうそう、これでいいですね。これ、実際は問題なかった。消し過ぎた。これで、プレビューがランドマークだったら、今回は大丈夫ですね。直せました。 そして上でカテゴリーローのほうに戻って、こっちが問題ですね。カテゴリーローのプレビューが、このランドマークの…えーと、これですね。ここでカテゴリーを入れて、リバーに限定した上で、ランドマークの、`ModelData` の `landmarks.filter` でリバーに限定した上で…なるほど、これは `ForEach` でやっていたのか。`ForEach` でもいいんですけど、カテゴリーとしてはカテゴリー、ランドマークとしてはランドマーク、という形でやっていけば、今度こそ動くはずです。はい、動きました。これで全部リバーだけで揃っていて OK ですね。

ということは、リバーズを全部並べてしまう手もありますね、いきなりね。まあ、面倒というほどでもないですが、これで十分かな。うん、十分にしましょう。こんな感じで出てきました。逆に言うと、カテゴリーローがカテゴリーを勝手に表示しておきながら、すべてのカテゴリーのデータが水平にリストアップされていく、というプレビューになっていて、あれはプレビューとしては問題ですよね。以前は起きなかったけれど、こうやって増えた増えたとプレビューで…プレビューが落ちると面倒なので、あそこは何とかしてほしいなという気はしないでもないですが、まあでも、このおかげもあって、とりあえずは期待どおりのプレビューを見ることができるところまで、思いがけず行けましたね。

こんな感じで、だいぶカテゴリーローは形になりました。`ScrollView` でランドマークを `LandmarkCell` で表示するようにして…えっと、`ForEach` はこの後のほうが長いと思うので、このままでいいか。短くできるかなと思ったんですけどね。うん、これでいいですね。カテゴリーローができた。そうすると、`LandmarkCell` はカテゴリーローの中で使いますよね、ということで、ファイル内で移動しておきましょう。カテゴリーローの中のプレビューの前あたり、この辺に入れてあげて。`CategoryRow` のプレビューはちょっと大きいほうが良いので先に表示したい、という自分の中の価値観があるので、そちらを上に持っていきます。カテゴリーローはここで、`LandmarkCell` はここでしか使わないので、ここは `private` でいいですね。そうすると、完全にここでまとまって、できました。

プレビューとしては、このプレビューがカテゴリーローで、1個だけしか出ていないけど、これで合っているのかな……。カテゴリーロー、カテゴリーロー……あ、名前がよくないかな。こっちがセルで、上がロー、ですね。そうですね。最初はセルのプレビューが出ていたので、ローにするとできている。こんな感じで良い感じにまとめられたので、そうすると `LandmarkCell` のファイルは要らないですね。ということで、おまけみたいな話ですが。

というわけで、今度はカテゴリービューも完成させていこう、という話になります。このあたりのリファクタリングは、また次回一緒に見ていく感じになるでしょう。では、今日はこのへんで終わりにしましょう。次は、さっき言ったカテゴリービューを完成させる方向で見ていく感じにしましょう。では、これで終わりにします。ありがとうございました。
