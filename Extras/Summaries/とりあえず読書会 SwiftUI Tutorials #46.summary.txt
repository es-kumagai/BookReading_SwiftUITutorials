Transcription & Summarize : とりあえず読書会 SwiftUI Tutorials #46

はい、では、とりあえず読書会を始めていきます。SwiftUI Tutorialsはひととおり読み終えたので、現在はリファクタリングを進めています。前回は、Swiftのマクロを使ったリファクタリングまでやり終えました。少しやりすぎたかなという感触はありますが、経験としては良かったと思います。

引き続き、残りの部分について、リファクタリングできそうな箇所を探しながら進めていきましょう。どこからいきましょうか。マクロは前回しっかり見たので、もう十分ですね。このあたりは特に悪くはない、というか、悪くない気がします。

ここの`map`についてですが、今は`map`で文字列化していて、戻り値の部分はこれで良いでしょう。とりあえず、そんな方針でいきます。 なので、マクロはいいですね。ではこれはパッケージを閉じておいて、次にカテゴリーあたりを見ていきます。この辺は一度見ているので問題ないと思いますが、カテゴリーが `rawValue` を持っているのは別に悪くなさそうです。`String`、`Sendable`、`Codable`、`Hashable`、`Comparable` にしておいて、`Identifiable`、`CustomStringConvertible` で記述表現も持たせておきます。比較は現在 `description` で行っていますが、これはこれで良いのかなと。左辺と右辺の `rawValue` を使って並び替えてもいいでしょう。`rawValue` でやるか `description` でやるかはどちらでも同じですね。どちらにするかというと、`rawValue` でいける気がします。

また、このくらいのフィーバー感、というかカテゴリーを作っている人なら、`rawValue` がテキスト表現であり、並び順の基準でもあることは十分わかるだろうという雰囲気を感じます。左辺の `rawValue` と右辺の `rawValue` を比較するようにしておくと、他の部分のコードからも「何で並び替えているのか」が読み取りやすくなります。なので、これで良いでしょう。

次に Hike ですが、これも良さそうですね。フォーマッタは `nonisolated(unsafe) private static let` にしておいて、`Hike` の距離文字列（たとえば `distanceText`）を表現するときに使います。フォーマッタを外部からいじることはないので、これで大丈夫という結論にしましたよね。必要があれば `MainActor` で保護するという手もありますが、ここは `nonisolated` かつ `private` にしておけば十分でしょう。

それから、`Observations`（Hike の情報を持っているやつ）も `Sendable`、`Codable`、`Hashable` にしておきます。これでシングルバリューコンテナを使って、テキストからそのまま `LandmarkImage` 型をデコード／エンコードできるようにしています。イニシャライザや `CodingKeys` の実装で対応している、という理解です。`CodingKeys` は外部から使う必要がないので `private` にしておきます。`Codable` 自体がそれをパブリックに求めているわけでもありませんし、外から使われても意味はないので、隠蔽しておくのがよいです。

「値を保存する型変換（value-preserving type conversion）」も問題ないですね。ランドマークを表現しているイメージと、UI で表示するためのイメージは、内容を壊さずに実質的に変換できるはずです。Swift の API デザインガイドラインに従って、ラベルを省略したイニシャライザで変換を提供しておきます。例えば `featureImage(of:)` のように、ランドマークがフィーチャーイメージを持っていれば、それを作り出す（あるいは既にあるものを取り出す）ためのコンビニエンスイニシャライザ的な立ち位置になります。そう考えると、このくらいの提供は良さそうです。ということで、イメージ周りのリファクタリングも OK でしょう。

ランドマークに関しては、この辺で使っているはずですが、途中でいろいろ変わっていったこともあり、若干微妙なところがあります。ここで使っているし、`FindingLandmark` を使っていた気もします。検索して、むしろ重複しているところや、この型エイリアスを使っていないところがあったら、ちゃんと置き換えていきましょう、という感じです。

今見ているのがランドマークの型エイリアスで、`typealias` の `Value` のところに何かありますね。ここは ForEach などが求めるキー（ID など）との整合が取れるようにしておきたいところです。なので、ここを `FindingLandmark` にしておきます。多少わかりにくい気持ちもなくはないですが、今回はこれで良しとしましょう。 とりあえず、同様に `BindingLandmarks` を入力として使っているところは、ここには見当たらないようです。この一箇所だけで、ほかの場所では型エイリアスのほうが使われている可能性がありますから、これはこれでいいですね。`BindingLandmarksByCategory` はここで使っているはずですし、ここでも使っているはずです。`typealias ModelData` もいろいろなところで使っていますし、じゃあ良さそうです。

この時点で、周辺のコードはひとまず良いかなと思います。型エイリアスが定義されている状況で、`Landmark` は `Codable` で `Identifiable` で、`ID` とかいろいろありますが、この辺は問題なさそうです。`Landmark` への private extension を書いていて、`CodingKeys` を private（fileprivate でもよいですが）で定義しています。これで OK です。これによって `image` は `imageName` からデコード／エンコードすることにして、それらは `Image` 型ですが、`SingleValueDecodingContainer` を使っているのでダイレクトに変換が効きます。なので、ここは `CodingKeys` が不要で OK です。

やっと `BindingLandmarksByCategory` に対して、`categories` を `keys` から取るというプロパティがあるので、それに乗っかるなら、`keys` があるのだからそれを使おう、という発想になります。それにしても、`BindingLandmarksByCategory` の `keys` といったら category のことですよね。普通に考えると “〜By〜” と表現できているので、明示の `categories` はあまりいらないかなという気もしますが、念のため探してみました。検索してみたらやはり `categories` は使っていました。手元の勘違いだったかもしれません。

つまり、`LandmarksByCategory` の `categories` が、ここで `keys` として分かるかどうか、という話ですね。`LandmarksByCategory` は `keys` だけでも分かる気がしてきましたが、ここが category になってきたので、`categories` は残しておきますか。元のコード自体、そんなにややこしくないですし。

`BindingLandmarks` は名前がかなりややこしいんですよね。`BindingLandmarks` というのが `Binding` のランドマーク群を指しているのか、ランドマーク群が `Binding` になっているのか、といった感じで混乱しやすいです。これは片方向変換で、要は `Binding` 1 個 1 個のものをひとまとめにした `Binding` を生成するメソッドなので、これはまあ良いと思います。ゲッターとセッターを渡したいので、ゲッターはこうやって `wrappedValue` を使い、セッターは `zip` をかけて対応付ける、という流れです。クロージャの記法を差し引けば、そんなにわかりにくくはないですよね。

これ、型推論できるのかな、というので試してみると、ここだとエラーになっています。non-Sendable function だと。そうか、ここを Sendable にするには `@Sendable` を付ければいいのかな……あ、付ければいけるんですね。じゃあこれでいいや。そしたらセッターも `@Sendable` を使ったほうがここは良さそうな気がします。とはいえ、いったん外して試したりもしています。あと、ここでパラメーターの型について、型推論ができませんよと言われてしまっていますね。 なので、そうするとここで、ランドマーク、ランドマークスですかね。こんなふうに書かないといけなくなってきて、まあまあでもいいか、という感じです。型まわりはこの方針でやってしまったほうが良さそうですが、どちらが良いかはまだわかりません。ひとまずこちらのほうでいきますかね。

あとは `typealias` を使ってもらいますけど、ここはそんなにいじることもないでしょうから、入ってしまえばこれで良いでしょう。

バインディングで、バインディングをアンラップしてラップし直してイニシャライズして、というのはOKですね。ジェネリックなエレメントで、要素が `Identifiable` になっていて、IDで検索できるようにしています。サブスクリプトでも ID で参照できるようにして、ID をうまく活用していきましょう、という機能もここで載せています。

あとは、`isSameCategory`、`addCategory` を用意して、`allSatisfy` でカテゴリが一致するものを探す、という流れです。`isSameCategory` は、ここは空行を消しておこうかなという話ではないのですが、イテレーターを取って、`guard let`、`iterator.next()`……という形になります。イテレーターから次が取れる間は、最初のカテゴリ（`firstCategory`）を基準に、以降のカテゴリをチェックします。つまり、`Sequence` でイテレーターが取り出すカテゴリが、すべて `firstCategory` と一致するかを `allSatisfy` で見ています。最初のカテゴリを取り出して、残りのカテゴリ（イテレーターで順に取り出す分）が全部一致するか、ということを調べているコードです。ちょっと読むのに手間取りましたけど、悪くはないですね。ややこしいところはありますが。

この辺は `Collection` にすると、`first` と `dropFirst()` でいい感じに書けます。ただ、ここは生のイテレーター操作でやっているので、こうなります。

`next` でカテゴリが取れたら `firstCategory` として扱う、というやり方のほかに、一度ここでランドマークを取って、そのランドマークのカテゴリが得られるか、という形もあります。そっちのほうがわかりやすいでしょう。つまり、最初のエレメントを `firstElement` として取り、カテゴリはここでは取らず、`firstElement` のカテゴリと一致するかを後続で見ていく、というほうがわかりやすそうです。最初のエレメントを取り、続く要素はイテレーターで回す。エレメントを残しておくのも良さそうですし、`Sequence` の `Element` に揃えたほうがわかりやすい気もします。どうしますかね。

イテレーターから最初の要素が取れたら `guard`。ただ、`guard` もちょっとわかりにくいかもしれません。`switch` 文を使う案も今ふと思いましたが、`iterator.next()` が一度消費されている中で、残りをどう扱うかがややこしいです。なので、一回 `guard` で区切りをつけて、その後にイテレーターを再び回していく（`Sequence` としてね）、というほうが良さそうな気がします。 ファインディングランドマークのシーケンスで、`isSameCategory` のブール判定を `lazy` にした `map` で処理しています。これも1番目と2番目以降で分ける、という点では同様ですね。この `isSameCategory` を辿っていくと、想定としては `lazy` シーケンスになっていない箇所に行き着くようです。`lazy` とイテレーターで処理する想定なのかもしれませんが、そこまで厳密にパフォーマンス計測はしません。`lazy` が要るかどうかについては、もし不要で、`lazy` を使ってもパフォーマンスに差が出なかった場合、若干遅くなることはあっても誤差程度だと思います。ひとまずこのままで良いでしょう。

LandmarkCoordinate は座標の構造体ですね。緯度・経度（latitude/longitude）を持つランドマークの座標ですが、これは struct で `Sendable`、`Hashable`、`Codable` に準拠しておけば良さそうです。`CLLocationCoordinate2D` に変換するイニシャライザーを実装し、`CLLocation` からの変換用イニシャライザーも用意します。上のイニシャライザーは素直な実装で、下のイニシャライザーは上で作った変換イニシャライザーを使って、いったん `CLLocation` を `CLLocationCoordinate2D` に変換してから緯度・経度を取得し、そこから変換をかける、という流れです。`CLLocation` のデコードから入ってくるケースでもこれで問題なさそうです。特に変なコードには見えません。

次に、マップビューのズーム表現についてです。できあがったズーム表現を大事に扱う方針で進めます。これは列挙型（`enum`）で表現し、`RawValue` を持たせておくと、この情報を永続化する際に都合が良いです。`Equatable` や `Identifiable` を求められているわけではないので、そこに無理に準拠させる必要はありません。不自然ですし、不要なら外しておきましょう。

イニシャライザーはこの方針で実装しました。`id` はこれで問題ないですね。さらに `CustomStringConvertible` に準拠させ、`description` は `rawValue` を返すようにしておけば十分です。

Zoom 情報をテキストに表示する際は、`SwiftUI` の `Text` を拡張しておくことで、シンプルに、ダイレクトにテキストとして `MapViewZoom` を表示できます。もう1つのやり方としては、`MapViewZoom` 自体を `View` に準拠させ、`body` を実装して、その中で `Text(description)` を返す形にする方法もあります。こうしておくと本当にダイレクトに表示できます。ただ、Zoom がいきなりテキストで表現されるというのは、用途によっては不自然に感じる場合もあるかもしれません。用途に応じて選べば良いと思います。 ただ、直感的ではないと感じる点があります。個人的にもよく思うのですが、`Color.black` や `Color.blue` のように、`Color` 自体が `View` になっている UI だと「これ何？」という感じがします。横で見て、`Color` が `View` に属していることをどこで把握すればいいのか分かりにくいですよね。初めて見たときは、この `Color` がいきなり分かれているのを見て驚きました。その驚きと同じで、`Zoom` をそのまま `View` に準拠させるのは得策ではない気がします。テキストで表現したいなら `Text` ですよね。ということで、こんな感じで `Zoom`、OK ですね。

モデルデータ周りは、`Landmarks` と `Hikes` と `Profile` を持っていて、デフォルトプロファイルが決まっており、設定していないときの既定値があります。この辺りは、これまでチュートリアルを進める中で試行錯誤しつつリファクタリングしてきた範囲だと感じます。モデルデータとして「デフォルトの `Profile` がある」というのが一番伝わってほしいところですね。チュートリアルではそうではなかった気もしますが、`static let` でデフォルトプロファイルを持っています。デフォルトプロファイルは他の場面でも使うことがあるので、そのときにインスタンスプロパティとして取得できたほうが、なんとなく楽というか、きれいというか、スマートな感じになります。そこで、計算型プロパティで返すものも用意しつつ、`effectiveProfile` を設けます。これは、どのプロファイルが有効になっているかを選択して、デフォルトを使うかどうかを決める形にしてあります。

ここは、`profile` として取ったときと `effectiveProfile` として取ったときで使い分けを間違えると少し厄介なので、その点が気になっています。`profile` をダイレクトに使っているところがあるのかを確認し、もしあるならプライベートにしてあげれば発覚してくると思います。なければプライベートに保護する手もあるのですが、`ProfileHost` では使っていますね。

`ProfileHost` の中では、`profile` に代入する場面があり、その取得時には `effectiveProfile` を使います。`effectiveProfile` に代入機能も持たせる、そんな感じです。そうすると、`ModelData` 側で `effectiveProfile` を `getter` として、`setter` は `newProfile` を受け取って `profile = newProfile` とする形にできます。`getter` と `setter` を持たせることで、この `profile` 自体はホストには公開しないという方針が取れます。代入式のところも `effectiveProfile` を使います。

こうしておくと、現在のプロファイルみたいな補助プロパティを経由しなくても、`ModelData` の `effectiveProfile` を直接書き込む、というコードの書き方にできるので、それで問題ありません。大きくは変わっていませんが、`get` と `set` で同じ通り道を通せるようになるので分かりやすいです。 なので、こちらの方が良いかなという気がしました。あとは、少しオーバーバランスなのが気になっているんですけどね。`Profile`、`ModelData`、`Profile`あたりの名前を変えてあげるのでも良いんですけど、`RawProfile` のようにダイレクトな名前の方が良いかなとも思います。今回はここをプライベートにして、直接は触らずに `effectiveProfile` からアクセスしていく、という形にしようと思います。

名前も変えてみようかなと思っています。`ModelData` って名称がかぶっているだけで、`ModelData` はバンドルから読み込んだデータを保持しているだけですよね。`Landmarks`、`Hikes`、`Profile` をバンドルから読んでいるのか……。あれ、でもこれはバンドルから読み込む対象のモデルが `Decodable` で、`Decodable` を扱うのは `Bundle` のエクステンションです。`ModelData` を `extension ModelData` にしているわけではないですね。ここでの `Bundle` の拡張は、`Decodable` に準拠した型をリソースから読み込む、JSON ファイルを読むときに使っているやつですよね。

一方で、こちらの `ModelData` と違って、名前が微妙に分かりづらい気がしますが、`Decodable` ではないので、名前は自由に変えても良さそうです。そうすると、例えば `Stored...` のような特殊な名前にして、デフォルトを加味したプロファイルの方を、取得するときには `profile` という名前にしようかなとも思ったのですが、そうすると少し意味が分かりにくくなってきます。やっぱり、デフォルトを加味していろいろよしなにやってくれる方には、意味がはっきりした名前を付けた方が、多少の違和感があっても逆に良いかもしれないですね。

その名前を `effectiveProfile` にするか、`ParentProfile` にするか、`PresentProfile` にするか、あるいは `profileConsideringDefault` みたいなものにするか、`profileOrDefault` にするか……。それはダサいですね。まあ、いろいろ名前の候補はありますが、今回は `effective` ですからね。

それで、この辺はこうするときれいにまとまっている感じがします。一方で、バンドルのモデル読み込みまわりの名前がちょっと分かりにくいですね。`Bundle` に何かメソッドがあるのかなと思ったのですが、`Bundle.data` みたいなのはないですよね。じゃあ、`ModelData` ではなく `BundleData` の方が分かりやすい気もします。`Landmarks` はともかく、`Profile` はデータですし。だけど、`Bundle` に対しては `load...` でデータを読む、つまり `Bundle.load...` の方がしっくり来るかもしれません。`load` というのがありますね。ということで、今回は `readData` にしました。 モデルデータが取れていないのに「モデルデータ」という名前は分かりにくい気がするので、`readData` のような名前にすると分かりやすいと思います。`read`、`read` でもいいですね。「データを取る」のはまさにデータを読み取ることなので、`read` を使うのが自然です。ただし、`API デザインガイドライン`に従うと、ラベルの付け方によっては冗長になり得ます。`forResource` は `Bundle.main.url(forResource:withExtension:)` のような既存 API の引数ラベルとしては正しいのですが、自作の関数名としては少し変に感じます。ここは `read(fromResource:)` のように `from` を使うのがしっくりきます。

「モデルデータ」ではなく「`readData`」のようにしておくと、「`readValue`」「`data`」「`value`」「`element`」といった用語の使い分けも整理しやすくなります。`data` という名前は至るところで使うため、文脈によっては衝突しやすいです。たとえば URL から `Data` を読み取る変数を `data` としてしまうと、その後 JSON から取り出した値（デコード後の値）も「データ」と呼ぶことになり、紛らわしくなります。読み取り途中の生のバイト列は `content` や `rawData`、デコード後の値は `value` などに分けると見通しが良くなります。最終的に返すのは「デコードした値」なので、`return value`（または `decodedValue`）という形にすると意図が明確です。

読み込み処理の流れ自体は次のようになります。
- `Bundle.main.url(forResource:withExtension:)` で URL を取得し、取れなかったら `fatalError`。
- 取得した `URL` から `Data(contentsOf:)` で `Data` を読み取り、失敗したら `fatalError`。
- `JSONDecoder` でデコードし、`DecodingError` の場合は詳細なエラー情報をメッセージにして返す（あるいは `fatalError` で落とす）。その他のエラーなら「想定していない型である」などのメッセージを返す。
- 正常時はデコードした値を返す。

コードの雰囲気としては若干ややこしいですが、エラー分岐を丁寧に書くとどうしてもそうなります。ここはしょうがないですね。`DecodingError` の継承関係上、汎用的な `description` を直接持たせるのが難しいので、必要なメッセージはその場で組み立てて埋め込む形になります。いずれにせよロードできない箇所は `fatalError` にしていますが、メッセージの内容が状況によって変わる分、多少コードが重たくなるのは避けられません。

`ModelData` はそのままで良さそうです。`Landmarks` のバインディング周りも悪くありません。`landmarksByCategory` はカテゴリーごとにランドマークをまとめたディクショナリを返しますが、独自の型に見えても中身はただのディクショナリです。`filteredLandmarks` は `landmarks` に対して `filter` をかけ、フィーチャーなどのマークが付いているものだけを返すようにしています。`Bundle` からの読み込みも、`read(fromResource:)` のような形で統一すれば分かりやすいでしょう。

ここまでで一通り OK なので、次は `Profile` です。`Profile` は `Codable` で、`String`、`Bool`、`Season`、`Date` を持っています。`Season` はこう定義してあり、`Identifiable` にも準拠していて、シンボルを出力できるようになっています。この辺りはプロトコルで整理できていて問題ありません。

最後に、`NotificationContent` は `userInfo` から作ってインスタンス化します。`@UserInfoAccessor` というディレクティブ（マクロ）を使うことで、この `userInfo` をたどるためのプロパティが、良い名前で宣言的に表現するだけで自動実装されます。これは記述の重複を減らせるので便利ですね。 ただ、余計な汎用性を求めた結果、生成されるプロパティの名前がやや微妙になってしまうのは気になります。ただ、その点を除けば、ぱっと見のコードは比較的読みやすいと思います。これはDSL、いわゆるドメイン特化言語の一種でしょうか。DSLはDomain-Specific Languageの略で、SはSpecificのSです。

こうした言語は、対象とする領域の事柄を端的に表現できるというメリットがある一方で、そのDSL自体を学習しないと理解できないというデメリットもあります。まさにその通りで、ビューはいい感じに書いていけますが、そこに到達するまでにはそれなりの学習コストがかかります。今まさにその学習を進めているところです。
