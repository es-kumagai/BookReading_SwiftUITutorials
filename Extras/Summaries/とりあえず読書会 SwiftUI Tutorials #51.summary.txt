Transcription & Summarize : とりあえず読書会 SwiftUI Tutorials #51

やりたいのはチュートリアルのリファクタリングですね。チュートリアルで作ったコードのリファクタリングですが、だいぶ落ち着いてきたので、残っているところを解説しつつ、もう少し手直ししてみると面白いかもしれない、という感じで見ていきます。そんな調子で続けていきましょう。

さて、次はランドマーク周りです。ここまではすでに見たので、次に進みます。メニューに関わるファイル名についてですが、少し長いのが気になりますね。どの程度がちょうどいいのかは悩ましいところです。コードを一通り見終わってから、フォルダ構成も含めて見直すのが良さそうだと思っています。

ファイル構成は、そのときどきで「こうしよう」と決めることも多いですし、アーキテクチャが決まっていればアーキテクチャごとにフォルダ分けすることもあるでしょう。ただ、Swift のプロトコル指向で設計していると `extension` を多用することになり、必ずしもアーキテクチャどおりにフォルダを切るのが簡単ではないこともあります。結局のところ、その時点での気分や勇気というか、自分にとってしっくりくるかどうかを指標にフォルダを切り分けていくのかなという気がします。いくつかパターンを想像して試し、自分に合うかどうかを確かめる、というアプローチになってくるのでしょう。

何にしても、「自分にとってしっくりくるかどうか」という判断基準は大事です。それを突き詰めていった結果がセオリーになっていくのだと思います。最終的には「世の中がこうだから」ではなく、「突き詰めていくとこれが良いのでは」という考えが世の中に寄っていく、そういう方向を目指すほうが有益ではないかと個人的には思います。……と、フォルダ分けの話はこのくらいにして、とにかくコードを見ていきましょう。

今日はまずランドマーク、つまり `LandmarkCommands`（macOS 用と iOS 用）です。先ほど macOS と iOS と言ったのは、ファイル名にそういった名前が付いているからで、分かりやすさを狙って最初はそのようなファイル名にしています。分かりやすいなら良いという判断もできますが、同時に本当にそれで良いのか、という疑問もあります。実際にどの OS 用なのかは、`Target Membership` を見ないと分かりません。うっかりファイル名だけ直し忘れていると齟齬が生じます。そういう観点では、ファイル名に情報を重ねるのはあまり良くないかもしれません。

プログラミングでよく聞く「シングルソース・オブ・トゥルース（Single Source of Truth）」という言葉があります。大げさな言い方は個人的にあまり好みではありませんが、情報源が二つあって両方を保守しないといけない状況は、ずれが生じる危険性だけでなく、編集や確認の手間の面でも煩わしいですよね。疑った瞬間に両方を確認しないといけなくなりますから。

両方に同じ情報を書くのは微妙です。たとえば `Xcode` の設定でいうと、`Build Settings` の `Configuration` で `Debug` と `Release` に分かれるような管理の仕方がありますが、ファイル名と `Target Membership` の両方で同じことを表現するのは、やはり冗長になりがちです。`プロジェクトナビゲータ` 上の見え方も含めて、どこに何の真実を置くのかを決めておくのが良いでしょう。

あ、画面シェアを忘れていました。失礼しました。始める前に出しておけばよかったですね。では、この画面で `LandmarkCommands` を見ます。これは何 OS 用かな、と思ったときにファイル名を見て「iOS と macOS 用か」と判断しがちですが、やはり本当のところは `Target Membership` を見ないと分かりません。フォルダやファイルのナビゲーション、つまりプロジェクトナビゲータの表示上も、そのあたりは注意が必要です。……あ、`No Editor Content` と出てしまいました。ここで一旦切れてしまいました。 プルダウン的に同じファイル名で切り替えると、Xcode がそれを管理してくれるような仕組みになっていたら間違いが起きにくいのでは、という発展を期待しています。ローカリゼーションではすでにそうなっていたはずですよね。いまはローカライズしていないので断言はできませんが、日本語と英語の切り替えのように扱えると良いなと思います。統合開発環境側でサポートしてくれると嬉しいのですが、複数を管理しないといけない状況になると、それはそれで難しさもありますし、Xcode から離れられないという問題も出てきます。いろいろ難しいですね。

さて、LandmarksCommands のリファクタリングできそうなところを探っていきます。構造体 `LandmarksCommands` が `Commands` プロトコルに準拠していて、フォーカスのバインディングとして `selectedLandmark` があり、これは良いと思います。`body` は `SomeCommands` で、`CommandMenu` があって、ボタンのラベルは、`selectedLandmark` のお気に入り状態に応じて "Remove" か "Mark" にしたい、という話です。中に直接書くには少し長いので外に出している、という感じですね。

ここで、`Bool?` のオプショナルなバインディングを使っているため、`true` と比較して判定しているのですが、こういうのは微妙に面倒で、フラグ的で分かりにくいところがあります。なので、`switch` 文で `withFavorite` かどうかを分岐するほうが明確かもしれません。たとえば、`case true` なら "Remove"、`case false` なら "Mark"。そして重要なのは、`Bool?` なので `true` と `false` 以外に `nil` が残っている点です。`nil` の場合はどっちなのかを明示的に考えなければならず、ここでは「選択肢がなかった」という解釈にして、`case nil` も "Mark" にする、というようにできます。つまり、`switch withFavorite { case true: Remove; case false: Mark; case nil: Mark }` というイメージです。こうしておくと、`nil` の可能性が明確に表現されます。

一方で、`selectedLandmark` 自体がバインディングの時点でオプショナルになっていました。ボタンを押すと `selectedLandmark` の `isFavorite` をトグルにする、つまり `selectedLandmark!.isFavorite.toggle()` のような処理になっている場合、`nil` だとクラッシュします。いわゆる強制アンラップ（`!`）で落ちますよね。ラベル側では `nil` を許容して "Mark" にしておきながら、実際にボタンを押したときに落ちる、というのは論理的にダメです。想定がちぐはぐで、プログラマー（今回は自分）が挙動を把握できていないということになってしまいます。 本来は、ケースが`nil`だったらフェータルエラーですよね。例えば「ランドマークが選択されていません」と表示するなど、きちんと扱うべきです。ボタンにマークが出ているのに、押してみたら落ちるというのは大問題です。その可能性があるなら、最初から落としてしまったほうが賢明かもしれません。もっとも、アプリを落とすのを嫌う人は山ほどいますが。

今回の場合は、`selectedLandmark`が`nil`になる可能性も考慮する必要があります。ランドマークのコマンドで「Remove Landmark」というボタンを表示するのは、要するに選択されているときだけです。選択されていないのにボタンが存在すること自体が不自然ですよね。なので、`if let selectedLandmark { ... }`のようにオプショナルバインディングを使って、選択されているときにだけメニューを出すようにします。そのメニューの中でボタンが効く、という構成にするのがよさそうです。こうすれば、`nil`時の無理な分岐を考えなくてよくなりますし、ここにあった強制アンラップ（`!`）のような危険なものも取り除けます。

ただ、その場合はミューテーションができなくなってしまうのか……なるほど、`Binding`じゃなくなってしまうのですね。`selectedLandmark`のバインディングが`Landmark`へのバインディング、つまり`Binding<Landmark>`だったかどうか。実際には`Landmark?`で、`Binding<Landmark?>`になっているはずです。今はコンパイルエラーでnon-zero exitになってしまっています。これは良くないですね。いわゆるexit codeのエラーで、このファイルをいじった結果、ビルド時にエラーになっているという状況です。

`if let selectedLandmark`があると、選択中のランドマークはOptionalの扱いになります。値が`Landmark?`になってしまいました。`@FocusedBinding`の動きが自分でも把握できていません。展開の仕組みがなさそうに見えます。ということは、プロパティラッパーの話です。具体的には、`@FocusedBinding`は`DynamicProperty`で、イニシャライザに`KeyPath`を渡します。`wrappedValue`と`projectedValue`は、いずれも`Binding<Value?>`、つまりバリューがオプショナルになっています。`FocusedBinding`の中身がオプショナル、つまり中身が`Optional`なんですよね。

ここでは中身がオプショナルで、`Binding`でバインドされている中身をそのまま使いたいわけです。にもかかわらず、バインディングの中身がオプショナルなのはなぜなのか、という点が引っかかっています。もう一度その観点で見ると、`value`があって、`wrappedValue`がその`value`、それなのにオプショナルになっている。新しいプロパティラッパーは、与えられた`KeyPath`でフォーカスをたどって……違うかな。ここはまだ自分でもよく分かっていません。

いずれにせよ、選択がないときはメニュー（やボタン）自体を出さない、選択があるときだけ`if let`でアンラップして処理する、という方針にしておけば、安全で自然な挙動になります。トグルできるのは選択されているときだけで、そうでなければボタンが存在すること自体が不自然ですからね。 そうすると、`@FocusedBinding` のランドマーク（`selectedLandmark`）で、`Wrapped Value` と `Projected Value` をどう扱うかがポイントになります。`Wrapped Value` はオプショナルなので、バインディングしていない可能性があります。つまり、フォーカスキーに値がない場合は `nil` になり得ます。そう考えると、ここをオプショナルにする必要がないのでは、と一瞬思うのですが、キーに値がない可能性がある以上、`nil` を表現できないと困ります。やはりオプショナルは避けられませんね。

いちばん楽なのは「オプショナルなバインディングを使わない」ことですが、それだと最短距離で理解できていない感じがして、今いろいろ試作しています。

`@FocusedBinding` で得たものは、まずはバインディングを取りますよね。ここで混乱しやすいのが、`Wrapped Value` と `Projected Value` の関係です。`Projected Value`（`$selectedLandmark`）はオプショナルではないのに対して、`Wrapped Value`（`selectedLandmark`）はオプショナルです。ドキュメントにも「`Projected Value` 自体は `nil` にならず、フォーカスがなければ `Wrapped Value` が `nil`」とあります。つまり、中身が `nil` かどうかで分岐していく必要がある、という理解で合っています。

この前提に立つと、`selectedLandmark` を素直にランドマークとして（つまり `nil` でなければ）取り出して、取り出せたときはラベルをランドマークの `isFavorite` によって変化させる、といった実装方針になります。ボタンが押されたときの処理では `$selectedLandmark` を使って値を書き換えたいのですが、ここでまた一点。`mutating` が必要になるような変更（たとえば `isFavorite` のトグル）をやろうとして、`$selectedLandmark.isFavorite` と直接は書けないことに突き当たります。中身がオプショナルなので、`Binding<Landmark?>` からそのまま `Binding<Bool>`（`isFavorite`）には行けないからです。

では、`if` でアンラップせずに `?`（オプショナルチェイニング）でいけるかというと、`Binding` に対するオプショナルチェイニングは思ったようには効きません。`$selectedLandmark?.isFavorite` のような書き方では `Toggle` に渡せる形にはならないので、やはりアンラップが必要です。要するに、「`selectedLandmark` が `nil` ではないと分かっている場面でだけトグルを出す」か、「`Binding(get:set:)` などでオプショナルをはがしてから `isFavorite` にマッピングする」必要があります。

まとめると、ポイントは次の通りです。
- `Wrapped Value`（`selectedLandmark`）はオプショナル。フォーカスがなければ `nil` になります。
- `Projected Value`（`$selectedLandmark`）はオプショナルではありませんが、その中身は `Binding<Landmark?>` のように「オプショナルな値へのバインディング」です。
- そのため、`$selectedLandmark.isFavorite` のように直接プロパティへはアクセスできません。`if let` でアンラップしてから使うか、`Binding(get:set:)` で `isFavorite` へ写像する必要があります。
- `Toggle` に渡すときも、オプショナルでない `Binding<Bool>` を用意できた場合に限って渡す、という形になります。

このあたりを踏まえて、`selectedLandmark` がオプショナルではないと分かっている局面ではそのまま進め、そうでない場合はアンラップしてから `isFavorite` をトグルする、という方針で実装していけば良さそうです。 ここからは、バインディングとランドマークの扱いについて整理していきます。セレクティブなランドマーク（`selectedLandmark`）ではなく、ランドマークの `isFavorite` をトグルする処理をメニューに入れます。`Sendable` やダイナミックな何か、という話ではなく、ランドマークの値（正しくは `Binding` の `wrappedValue`）の扱いですね。これでちゃんと動くのか不安だったので、動かしてみます。環境は macOS です。

メニューの中で、選択した状態でトグルできるかを試します。選択した状態で、メニューの「Landmark」から「Mark as Favorite」を実行すると……動きました。いいですね。選択した状態でランドマークの「Remove」も動きます。手応えは十分です。

一方で、選択がない状態でメニューに項目が出てしまうのは驚きます。いなくなった（=項目が消えた）のはすごいのですが、全部消えてしまうのは不安もあります。ランドマークそのもののメニュー項目は出てほしくない気がしましたが、メニューの根本（トップレベル）は残しておきたいですね。つまり、トップレベルの「Landmark」メニューは外に出しておいて、その下の項目は状況に応じて出し分ける、という形にします。インデントを直してビルド・実行します。これで良さそうです。

選択がない状態だと、メニューの中には何も出ないのでびっくりはしますが、選択すれば「Landmark」の中に項目が出て、選ぶと星が入る、という流れになります。ここはユーザーを驚かせない見せ方が課題ですね。

また、ここから先は `switch` 文は要りません。二択なら、`Remove` と `Mark`（お気に入り）だけで十分です。これで `switch` 文は不要です。

次にボタンについて考えます。以前「トグルお気に入りボタン」的なものを作った気がします。たぶん「FavoriteButton」ですね。`@Binding var isSet` があって、`body` の中で `Button` を押すと `isSet` がトグルされ、表示は `systemImage` によって切り替わります。メニューの項目もほとんど同じ振る舞いになりますが、そのまま共通化するわけにはいかないので、メニュー用は別に用意します。

そうすると「FavoriteMenu」を作るのが良さそうです。同じファイル内で定義します。`private` な extension で `LandmarksCommands`（仮）を用意して、その中に `FavoriteMenuItem` という `struct` を作り、`some View` を返すようにします。`CommandMenu` の中身は `@ViewBuilder` な `content` で、コンテンツは `View` です。`FavoriteMenuItem` は、つまり `some View` を返し、その `body` を定義します。

`body` の中では、ランドマークがある場合にボタンを表示します。既存のボタンを流用し、`@Binding` でランドマークを持たせます。`@Binding var landmark: Landmark?` のようにしておけば、`Binding` の `wrappedValue` を直接扱わなくても済みます。先ほど「ランドマークのラップドバリューが必要かも」と思いましたが、これは不要でした。さっきはプロパティの位置がずれていたので、それを修正します。これでランドマークの `isFavorite` にアクセスできます。

`disabled` は、`selectedLandmark` が `nil` のときに使うのではないですね。ここはコンテンツの外側で制御すべきです。つまり、メニューの中で `FavoriteMenuItem` を用意し、`landmark` として現在のランドマークを渡します。`disabled` があるならそれで良かったはずで、以前はその方向でモディファイしていました。

ただ、`nil` のときにも無理に名前を設定してクラッシュを避けようとするのは良くなかったです。無効（グレーアウト）のときに落ちてしまいます。つまり論理的に無理があるので、`nil` のときはそもそも表示しない、という方針にします。そうすれば、この場合は `disabled` 自体が要らなくなります。表示されないのなら、無効化する必要はないからです。

この状態で一度実行して挙動を確認します。表示しない方針なら、`disabled` は不要かもしれません。 この状態ではランドマークは何も出ません。何かを選んだときにランドマークが出てきて、使うとフェイバリットが動きますね。大丈夫そうです。そうすると、無効化（ディスエーブル）がいらない代わりに、該当の要素は消しています。これでいいのかな、バインディング。では一度押しましょう。うん、できました。

こうすると、もう1つ得られるところとして、ここでランドマークのラベルを作っていますが、これはフェイバリットのメニューアイテムなので、そのタイトルとして持たせることができますよね。文字列にして、このフェイバリットメニューアイテムの `title` は、ランドマークのお気に入り状態に応じて変化します、というコードにしておけば、ここで素直にタイトルを使えます。こちらのほうが分かりやすいです。

これを別のパターンに切り出していなかったとすると、この「タイトル」というのを作るのがなかなか難しいところがあります。たとえば「ランドマークのコマンドのタイトル」などと言ってしまうと、どこのタイトルのことなのかが曖昧になってしまいます。しかし「フェイバリットメニューアイテムの `title`」と言えば、明らかにこのアイテム用のタイトルなので、お気に入り状態によって切り替えても何の問題もありません、という実装にできます。これが実装できれば、あとはボタンも簡単に表示できます。タイトルは `Unfavorite` か……まあ、そこは良いとして、これで分岐できますね。

今のところ、いい感じに大体の結果が出た気がします。やってみると結構簡単でしたね。ただ、このバインディングでキャストする、というところが1つポイントになっていて、中身が空（`nil`）の可能性があるバインディング、要はオプショナルな型を取るバインディングは、それを取らないバインディングの全体をオプショナルにする、という変換イニシャライザーがあります。バインディングの `extension` で、オプショナルを取るものから、オプショナルを取らないバインディングへ自分自身を変換し、`nil` の場合は失敗する可能性がある `init?` を用意しておく、というやり方です。このイニシャライザーを使って、オプショナルの可能性を外側（バインディングそのもの）に回しました。それによってオプショナルバインディング（`if let` など）が効くようになり、適切なバインディングが取れたときだけメニューアイテムを表示する、という実装にできました。これでメニューはOKですね。

次にページコントロールに行っておきます。1個くらい触れれば十分かな。ページコントロールは iOS だけみたいですね。ページビューコントローラーと `UIViewController`、そして `UIKit` との連携のときにやったやつです。バインディングで持っているページ番号を、`PageNumber` 型としてバインディングしています。これも今のところの方針では `private(set)` にしたいですね。

この `PageNumber` は中身は `Int` ですが、`Int` をラッピングすることによって「ただの数字」なのか「ページ番号」なのかをはっきり分けています。今回は遊びではありますが、最初のページを 1 としましたよね。でも、配列のインデックス操作は 0 から始まります。なので、配列のインデックスとページ番号を取り違えてしまうと厄介です。こういうときに、同じ `Int` を取るだけでも別の型として定義しておけば、型安全が働いて、同じ数値であっても取り違えることがなくなります、という実装をやりました。

これはコーディネーターでオーナーを参照する形にしています。以前、SwiftUI のチュートリアルをやっているときに「`self` を渡すのはおかしいだろう」と言っていましたが、`self` を渡さないとバインディングが新しいビューに更新されない、ということが分かったので、今のところは `self` を渡すほうが適切だという結論に至っています。 `makeUIView(context:)` では、普通に `UIPageControl` をベースにして作っています。コントロールには `numberOfPages` を設定し、ターゲット-アクションで `updateCurrentPage` を使います。`Coordinator` に対しては `updatePageAction` を登録して呼び出すように設定し、コントロールの値が変化したとき（`.valueChanged`）に反応するようにしています。

これで OK ですが、逆方向の更新については、`UIView` の更新のたびに `currentPage` を更新しているので、owner を書き換えられないといけません。オーナーは `UIPageControl` です。これを書き換えないとダメですよね。オーナーを書き換えて、`currentPage` を `currentPageNumber` のオフセット（0 から始まる）にする必要があります。こうしないとダメではないでしょうか。なぜコメントアウトしたのかは不明です。

先ほど述べた、バインディングが更新されない問題です。これは macOS ではなく、iOS でのページコントロールの話ですね。つまり、iOS シミュレーターでチェックしないといけません。やってみましょう。`Coordinator` の owner を書き換えないと、`updateUIView` の後で `Binding` が壊れるので、ここが重要だと思います。これで壊れなくなるのかな。まあ、ならないと思うんですけど。

シミュレーターはこれですね。今は “Landmarks for macOS” をビルド・実行中ですが、“Landmarks for iOS” に切り替えます。デバイスは iPhone で、iPhone 17 Pro あたりでいきましょう。iPhone 17 Pro、今ビルド中ですが、立ち上がるはずです。画面サイズ、これですね。こうして iPhone 17 Pro を使っているから、16 はとりあえずいいかな。iPhone 17 Pro だったら、何インチでしたっけ。ページコントロールか。ページコントロールがちゃんと動けば…。 とりあえず、謎にコメントアウトされていたものを復活させて、復活させたらそれで解決だった、ということになりました。では、なぜ `self.owner`（オブジェクトではなくビュー）を更新するのをやめたんでしょうか。実験中のコードがそのまま残ってしまっていたんですかね。以前は何のためだったか、ちょっと記憶が曖昧です。

とにかく、ここ、ページコントロール――というか、この点々のほうですね。これはちゃんと動きますよね。あ、遅れた。こうして…ああ、クリックした。これでスライドして動いていますね。クリックすると戻ったり進んだりします。よかったです。

やはり、この Coordinator の `owner` を書き換える処理は `updateUIView` ではやらないほうが良いです。さきほども言ったとおり、バインディングが古くなってしまうので、これは重要です。なので、これで OK ですね。

それで、あとはそこまででしょうか。ページコントロールの中に Coordinator を `NSObject` 継承した形で持たせ、ここで `@MainActor` を付けます。その `owner` がさっきのページコントロールですね。代入する必要があるので、ここで書き込みを管理していますが、書き込みのためにこれを internal や `open` にするのは嫌です。`private` にしましょう。これで良いですよね。

Coordinator はこの中でしたね。使わないはずなので、削除しておきましょうか。書いてた、書いてた。

ページコントロールのページコントロール……つまり `UIPageControl` のことです。`UIPageControl` は iOS のページコントロールで、持っているのはこんなデフォルトですよね。

`private extension` を貼ると……あれ？ `private extension` を貼ったときに `PageControl.Coordinator` が……あ、そっか、公開範囲の問題になるんですね。`UIViewRepresentable` が `Coordinator` を要求しているので、内部で使うといっても `public`（というより `internal` 以上）に露出します。つまり `private` ではダメ、ということです。では、この Coordinator がガタガタすると考えられることは……えーと、ここは普通の `extension` にしましょう。良いですね。

これで、`owner` への書き込みは `fileprivate` ですかね。これだとエラーですよね。では `fileprivate(set)`。こうしたほうが良いですね。そうすることで `owner` を勝手に書き換えられることはなく、このファイル内の内部からだけ書き換えられる、という形になります。このファイル内でどこから呼び出すかといえば、`SwiftUI` の `View` が再評価されたタイミングですね。これで良いです。

それで、イニシャライザーで `owner`。これもごたごた公開されているように見えますが、イニシャライザーは内部でしか作らないので `fileprivate` が適切ですね。これで OK でしょう。

あとは `updateCurrentPage` は `@objc` ですね。`updateCurrentPage` もここからしか呼ばないので `fileprivate`。これで良いですね。全部 `fileprivate` でした。

`fileprivate` はただ `extension` にすれば良いというわけでもないんですよね。ここは行けますけれど、`updateCurrentPage` は `extension` でも行けますが、そのために分けるほどでもないかな。まずやってみますか。`private extension PageControl.Coordinator` にして、この Coordinator に対して――型、いやメソッドを――追加してあげますよ、という形です。これなら `fileprivate` はいりませんね。イニシャライザーは欲しいので、そこは残します。なので、あまり分ける意味はなかったですね。何にしても、これでビルドは通るでしょうから、OK です。

こうすると、見た目も良い感じではないでしょうか。ページ番号が……これはまあまあ良いですね。ページ番号ぐらい見ておきますか。

ページ番号は、さきほども少し触れましたが、要は中身の `value` は `Int` 型です。つまり今は `Int` 型と同じデータコードなわけですが、`Int` 型を区別してこうやって構造体を定義しておくことによって、型安全を狙うことができます。`Int` とページ番号等を混ぜてしまったり取り違えたりするのを避けるために、こういったシンプルな構造体を作るのは、自分はよくやるパターンです。場合によっては、`RawRepresentable` にして `RawValue` で持たせたりします。`RawValue` はこれなんだけど、ネイティブ的にはこの構造体ですよ、という定義ですね。今回の `PageNumber` は、このままでいいかな。`RawValue` を使うのはちょっと大げさなのでやめて、本当に素直に `value` を `Int` で持たせます。

それで、`value` を `Int` で定義し、大小比較もできるようにします。必要なら `extension` で分けましょうか。`extension PageNumber` で `Comparable` 準拠、といった形ですね。さらに `PageNumber` の `description`（`CustomStringConvertible`）はそのまま文字列表示にして、`ExpressibleByIntegerLiteral` からの変換は自分自身のイニシャライザーで変換します。`PageNumber` を `AdditiveArithmetic` にして足し算・引き算ができるようにもします。

また、`PageNumber` を拡張して、`start` は必ず 1 から始まることを明記します。0 から始まるオフセットも用意して、これを使ってページを初期化することもできるし、0 から始まるオフセットで内容物を取得することもできます。`next` で次へ行けるし、`previous` で前へ行けます。`next` は `mutating func` にして中で置き換える……`next` の中で新しい値を作って置き換えるのは効率が悪いかな。`mutating func` であるなら `self.value` に加算したほうが速いのでは、という話ですね。

`PageNumber` を `LocalizedStringKey` の文字列補間に直接渡せなくなる、という話もありました。`String Interpolation` での扱いですね。ただ、ビルドが通ってしまいました。ビルドが通ったのは通ったんですが、ちょっと怖いので一旦戻しておいて、`PageNumber` 周りはあとで見ておきます。 ページナンバーを `String(describing:)` で文字列化しています。つまり、自分自身を `String(describing:)` に渡すということは、普通に文字列補間で値を渡したのと同じことになります。なるほど、まあそれでも良いかもしれません。いったんこのまま残しておいて、ページナンバーで文字列補間をしていそうな箇所を探します。

どこだろう。ページナンバーは、文字列補間をしていそうなところがあるでしょうか。文字列を渡している箇所はどこか、ソースコードを見ます。これですね。`String(describing:)` で文字列化しているので、普通に文字列の中に自分自身を置いたのと何も変わらない状況になってきている気がします。どうしようかな。あるとしたら `PageView` でしょうか。`currentPageNumber` がありますよね。`currentPageNumber` がラベルで使われるのかな。ラベル、ページコントロール……いや、`PageViewController` のコンテンツか。あ、ここですね。これは普通の文字列です。

さっきの `currentPageNumber` が文字列補間で使われるというのが `LocalizedStringKey` 絡みだったので、これは `Text` に対してですね。なので、`Text(...)` の形で使われているはずです。ここで検索すれば良さそうです。

「ページ番号」。ページ番号はどこだろう。「ページ番号ランドマーク」ではなくて、ページ番号そのものはどこにあるのか。ざっと見た限りでは見つかりませんでした。自分はこういうのを見つけるのが苦手なので、正規表現で当たってみました。正規表現で、`Text(` まで拾って、その丸カッコの中に何らかの文字が続いて「ページ」に関係するものがないか探しましたが、出てこないですね。これで出てこないから問題ないのかというと、そうとも言い切れない可能性はありますが、少なくとも文字列補間を使っていないのかもしれません。

ページ番号を表示する可能性のある場所といえば……そもそもページ番号って何かというと、このページコントロールのほうですね。あれを文字列化することはない気がします。なので、この感覚でいくと、ページナンバーに `LocalizedStringKey` の文字列補間は要らない、ということになりそうです。仮に入っていたとしても、差し支えるほどの複雑なコードを書いているわけでもないので、まあこのままでいいか、という感じになってきました。少し冗長な感じはしますが、100%無駄と言い切るほどでもありませんし、こういう部分は `LocalizedStringKey` でページナンバーを扱っていても、実行時のパフォーマンスに大きく影響することはないでしょう。「これ使っているのかな」という視点で見るとレビューコストは上がりますが、そこまでしなければバグを生むとも思えません（もちろん可能性はゼロではないですが）。

そうすると、ページナンバー周りは、`current` とか `next` とか `previous` を最適化するとすれば、内部の値に直接働きかける形でやるのが良いでしょう。`next` や `previous` でもやれば良いのでしょうけど、正確には `moveNext` ですね。こういったところでやれば良いのでしょうが、今回はそこまでは求めなくて良いと思います。

はい、ではこんなところでOKですね。時間もいい具合なのでこのくらいにして、次回はこの `PageView` のところを見ていく、というところからやってみようと思います。今日はこれで終わりにしましょう。お疲れ様でした。
