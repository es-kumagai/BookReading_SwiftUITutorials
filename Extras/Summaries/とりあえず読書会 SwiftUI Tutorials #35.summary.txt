Transcription & Summarize : とりあえず読書会 SwiftUI Tutorials #35

はい、では始めていきましょう。とりあえず、しばらくは SwiftUI のチュートリアルを読んでいきます。今やっているのは「Creating a macOS App」のセクション4です。前回あたりからリファクタリングを進めているところですが、まだ気になる箇所があるので、引き続き手を入れていこうと思います。

やることは、まずカテゴリーフィルターの見直しです。気になっているのは `Lakes`, `Rivers`, `Mountains`、そして `All` の4つです。前回の最後のほうでも言いましたが、このバランスが悪いと感じています。といっても、対象はあくまでもランドマークリストのフィルターカテゴリーで、リストとしてはこの4つから選べる、というだけの話です。見た目としては成り立っているのですが、実装として、`rawValue` に依存している点が気になります。

もう一度確認します。この中で「categories」が指定されている場合、カテゴリーフィルターの `rawValue` とランドマーク側のカテゴリーの `rawValue` が一致したときに、フィルターが適用されるとみなす、という形になっています。この `rawValue` 依存が引っかかりました。

まずはこの辺から手を入れていきます。リファクタリングの方針としては、カテゴリーフィルターをランドマークのカテゴリーと対等（型として整合的）に扱えるようにする、という方向です。対等という表現が近いと思います。

`rawValue` の定義をたどってみたのですが、うまく追えませんでした。ビルドは通るのに定義ジャンプができない、という状態です。`FilterCategory` はデフォルトが `All` になっています。`FilterCategory` の `rawValue` が `Lakes`, `Rivers`, `Mountains` で、これに `All` が加わる構成です。考え方としては「すべて」または「特定のカテゴリー」という二択にするのが素直だと思います。そうすると、意外と難しくなさそうです。具体的には、`FilterCategory` を `all` もしくは `specific(Category)` のどちらか、という設計にしたいです。

ではカテゴリーを誰が持つのかという点です。カテゴリーはランドマークが持っていて、リストでも使います。ただし、このアプリケーション（Landmarks）にとってのカテゴリーと考えると、`Landmark` にネストさせる必要はなさそうです。レイヤーとしてはアプリ全体のレベルで良いはずです。なので、ファイル名も変えて、ランドマークに所属させずに `Category` として切り出します。カテゴリー自体は名前と識別子を持つ、という形にします。`LandmarkCategory` ではなく、単に `Category` として扱います。

そうすると、`Lakes`, `Rivers`, `Mountains` が「特定のカテゴリー」のケースという位置づけになります。さらに、この構成にするなら `rawValue` は不要になります。したがって、`rawValue: String` は取り除きます。`CaseIterable` についても、`all` を含める構成や関連値（たとえば `specific(Category)`）を持たせる場合は相性が良くないので、これも外す方向にします。

最終的には、フィルターの判定は `rawValue` の一致ではなく、カテゴリー同士の等価比較で行う形にしていきます。これで、`All` と特定カテゴリーの扱いのバランスが取りやすくなり、実装も素直になるはずです。 とりあえず `Identifiable` は今は不要です。必要になったらそのときに考えましょう。ID が必要なら付けてあげれば大丈夫です。フィルターのカテゴリーは既に決まっていて、フィルター側が `FilterCategory` を持っています。これは送受信に関わるので `Sendable`、そして比較や集合で使う都合から `Hashable` にしておくのが良さそうです。フィルター自体も構造体なので `Sendable` は問題ありません。ローカル（internal）な範囲ではこのままで良いでしょう。

このあとエラーが出るのは、`Category` の `rawValue` を前提にしていた箇所を変更したためです。`FilterCategory` が `.all` なのか、`.specific(Category)` なのかで分岐したいので、ここはオプショナルバインディングではなく、普通に `switch` 文で分けるのが良いと思います。たとえば、`switch filter.category { case .all: ...; case .specific(let category): ... }` のようにします。

タイトル周りでは、いま作っている `favoriteTitle`（タイトル文字列）を組み立てます。`.specific(let category)` の場合は、その `category` の `rawValue` を使って `favoriteTitle` を作り、`.all` の場合は全件用のタイトルにします。タイトルができたら、最後に「お気に入りのみ（Favorites Only）」が有効な場合はそれを示す文言を付け加えてから、`return favoriteTitle` という形で返します。つまり、基本のタイトルを用意し、必要に応じて「お気に入り」を付けて返す、という流れです。

フィルタリングの実装については、ランドマークの `category` とフィルターの `category` が一致すれば採用する、という判定にします。ここは `rawValue` で無理に合わせる必要はなく、列挙子同士を直接比較すれば十分です。`rawValue` や `String` をわざわざ生成する必要がなくなるので、同じ列挙子同士で合わせてあげたほうが明らかに効率が良いです。以前と同じ形になりましたし、問題はありません。

次に、コンパイラの型チェックで指摘されるのは `FilterCategory` の `allCases`（`CaseIterable` 準拠）です。`FilterCategory` は `.all` と `.specific(Category)` という構造で関連値を持っていますから、自動合成はされません。そこで、`type extension LandmarkList` の中の `FilterCategory` に対して `CaseIterable` を実装します。`AllCases` は `Self` のコレクションなので、`static var allCases: [Self]` を自前で用意します。

具体的には、`allCases` は次のように構築します。まず `Self.all` を配列の先頭に置き、続いて `Category.allCases` を `map` で `.specific($0)` に包んで連結します。つまり、`[.all] + Category.allCases.map { .specific($0) }` という形です。こうしておけば、`FilterCategory.allCases` を安全に列挙できます。型の不一致が出る場合は、`map` で `.specific` に包むのを忘れていないか確認してください。これでビルドも通るはずですが、見通しが悪く感じる場合は、分割代入や一時変数を使って可読性を上げる案も考えられます。

以上の対応で、タイトルの生成、フィルタリングの判定、`CaseIterable` の実装がそれぞれ整いました。必要であれば、別案も検討できます。 まずはビルドが通ることを確認してから、もう少し変更していきます。ビルドは通りましたよね。なので、`CaseIterable` もそうなのですが、ここでは名前は仮として `allSpecifics` のようなものを用意します。`LandmarkList` のフィルタカテゴリに対して、返すものは `Category.allCases` を `.specific` で包んだ配列、つまり `Category.allCases.map { .specific($0) }` のような形にします。

こうしておけば、カテゴリの `allCases` は、あくまで `Category` 自体の `allCases` を `.specific` で作ったものを返す、という方針になります。あとは `allCases` は `allSpecifics` に `.all` を足してあげればよいので、`[.all] + allSpecifics` のようにすれば大丈夫ですよね。`all` と `allSpecifics` を足す、という考え方で問題ないと思います。

ここを効率化したいなら、`CollectionOfOne(.all)` を使って足し算してもいけるのかな、と考えています。足し算した後に配列になってくれれば大丈夫だと思うのですが、このあたりは `CollectionOfOne` がどう実装されているかに依存します。いずれにしても `CollectionOfOne` はおそらくヒープ領域を使わないはずです（たぶん）。ちゃんと見てはいませんが、`CollectionOfOne` は単一要素のコレクションで、単一要素同士の結合はできる、と書いてありますね。ヒープについては明記されていませんが、わざわざヒープに確保するのは非効率なので、きっとスタックで作ってくれるのではないかと思います。最終的な配列を作るときと、`allSpecifics` 側は必要ですが、この2つ以外のメモリ確保は少し抑えられるのかなという期待です。いずれにしても、`all` とそれ以外のカテゴリを `.specific` に包んだものを用意する、というところまではできました。

さて、ビルドは今したのでしたっけ。まだエラーが出ますね。1箇所、ここがタイプチェックのエラーです。さっきの `ForEach` ですね。`allCases` に対して `ForEach` していますが、`ForEach` は確かハッシュ可能性が必要になるかもしれません。つまり、今 `Hashable` が実装されていないのが原因かなと思います。定義をソースからたどれなかったので、Apple のドキュメントを見ます。ありました。`ForEach` のイニシャライザを確認すると、最初の引数はデータで、その要素型が `Identifiable` に準拠しているか、または `id` を指定する必要があります。

これを `allCases` でどう扱うかですが、`allCases` の要素からシンプルに ID を取るのは難しいので、`Identifiable` を付けるのが良さそうです。そこで、フィルタカテゴリの定義に戻り、`LandmarkList.FilterCategory` に対して拡張で `Identifiable` を付けます。では `ID` は何にしましょうか。できれば `Category?`（カテゴリのオプショナル）という案もありますが、少し微妙な気がします。`Identifiable` が求める `ID` は `Hashable` です。ここでは、`Self` を `Hashable` にしてしまう、という手もあります。`Category` 側が `Hashable` で、`.all` も問題ないなら、自分自身（`self`）を ID にできます。そうすると、実装を増やさなくても `ForEach(allCases, id: \.self) { ... }` のように、`id` に `\.self` を渡せばよいのでは、という結論になります。 またやってみますね。どうしますかね、これ。カテゴリが `Hashable` になっているので、`Identifiable` を実装してあげるべきか、こうやって「ID は自分ですよ」と書いてあげるか、なんとなく悩むところです。ID を明記する必要性、つまり実装する必要性は、あると言えばあります。ですが、結局まだダメですね。まずは識別子の扱いを調整してやってみましょう。

というわけで、ここです。`Identifiable` で `self` を返しても問題なしですね。`self` にして、戻り値も `self` と。これで `Identifiable` は OK で、`ForEach` の中でそのまま使えますよね。`ForEach` はどこでしたっけ。この辺ではないか。ここだと思うんですけど、`ForEach` ですね。はい。なので、ここは OK です。

もう一回ビルドをかけてみます。`Identifiable` で解決すればいいのですが、このボディのタイプチェックが通っていないのは、まだ何かを忘れている感じです。`Category`、`filter`、`Category`、`Category`……`filter` をいじっている最中に何かおかしくなって、このボディのどこかでまだ対応できていないところがあるのに、トップでエラーが報告されているのだろう、という感じだと思います。コンパイラが「この式を妥当な時間内に型チェックできません」と言っているエクスプレッションです。

`filter`、この辺が `onChange`。`onChange` は `Equatable` ですよね。だから `Hashable` なら問題ないはずです。あとは、`Category` フィルター。`Category` の `allCases` ですよね。`Picker` は `filter` の `categories`。この `Picker`、この辺なんかまずそうですね。`filter.category`、`filter.categories`、`categories`……あ、これは `selection` か。これはいいですね。`selection` で `allCases` はちゃんと `Self` のものになっているでしょうから OK です。

では、これで「妥当な時間内にビルドできなかった」と言っているのが、ちょっと厄介ですね。ビルドの結果は今こうです。見ているのはやっぱりここか。つまり「時間内に型チェックできない」ですね。どこがおかしいのか調べないといけません。

簡単なのは、きっとここの `ForEach` が間違っている、というか影響を与えているのではないかということ。`ForEach` を消してあげると多分ビルドが通りやすくなるのでは、と思うので、ちょっとこうやっていじっていきます。あまり賢いやり方ではないですけどね。

それにしても、これでもダメでしたね。あ、こうすると、`selectedLandmark` が置いてあっても別にいいですよね。`filter` の `onChange`、この辺かな。ちょっとこれをカットしてみます。`filter.onChange` 以外だとアニメーションと、あとはタイトルと、あとはツールバー。ツールバーでも `Category` を使っていますね。

あと、ここ `id`。あれ、`id: \.self`。消したのなんだ。なんか間違っている気がします。あ、ここか。`filter` と `landmarks`。違うのをやっていましたね。`filter` と `landmarks` は、`landmarks` のバインディングだから、これは `id` で指定しないといけなくて、忘れていました。こっちです。`id: \.self`。上は、そう、うかつでしたね、`id` を付けるのを。なので、ここを直しました。間違えましたね。

これを消してフィルターをかけて、これで通るんですかね。今のところ、この `onChange` は外したのと、`ForEach` はここは関係ないんでしたね。だから下の方の `ForEach` はちゃんと存在している。この状況でダメだったら、この `ForEach` をいったんコメントアウトして、「妥当な時間内に型チェックできていないのか」みたいなことを調べていく。ということで `ForEach` をカットします。これは成功しましたね。なので、原因はここですね、とりあえず。

考えられるのは、`Category.rawValue`。これか。`Category` が今 `RawValue` を持っていて、`allCases` を回しています。`Category` は今フィルターですね。`Text` を取ろうとしている、`rawValue` で。この `Text` を取ろうとしているのは表示テキストです。そうすると、`Text(Category.rawValue)` として、`rawValue` を使う、ということになります。 フィルターカテゴリーにテキスト表現を備えさせるか、あるいは外側でテキストに変換できるようにするか、どうするかを考えています。フィルターカテゴリーはモジュール固有（モールスペシフィック）でもあり、よりスペシフィックでもありますよね。これらの表現を「インスタンスのテキスト表現」という価値観で捉えると、フィルターカテゴリーとは別に、インスタンスそのものの文字列表現ではないけれど、テキスト表示のためのラベルのような文字列表現を持たせる、という発想もあります。つまり、ラベル用のプロパティを搭載するかどうかです。この3つくらいがとりあえず考えられますが、どれにしましょうか。テキストでもいいのですが、やはりラベルですかね。ラベルにする場合でも、ランドマークのフィルターカテゴリーがラベルという表現を持っている可能性は十分あります。

ポイントは、カテゴリーのラベルという存在を誰が知っているべきか、そしてどの場面でもこのカテゴリーのラベルが同じなのか、それともビューによって変わり得るのかで、タイトルの持ち方が変わってくるところです。今回のフィルターカテゴリーについては、誰も変えないような気もしますし、カテゴリー自身が自分の文字列表現を知っていてよさそうにも思います。そうなると、専用のラベルを別に持たなくてもよいかもしれません。

そこで、型エクステンションでカテゴリーに対して `CustomStringConvertible` を実装して、`description` を持たせるのがよさそうです。中身としては、カテゴリーには `name` がある、といった作りも考えられますが、普通に考えると、たとえば `Rivers` は `Rivers`、`Mountains` は `Mountains` のように、そのインスタンス自体がそのまま文字列で表現できますよね。そういうときは、別に `name` プロパティでなくてもよくて、「このインスタンス自身がテキスト表現として表せる値を持っている」という発想で表現すれば十分です。つまり、`description` は `rawValue` でよいと思います。そうすると `name` はいらないですね。`name` 以外の情報を持たせるのであれば別ですが、今回はそれ自体が名前ですから。なので、カテゴリーの `name` は多分不要です。

`CustomStringConvertible` の実装は、今のところ `rawValue` を `String` にしているなら、`RawRepresentable` に準拠しているわけですから、それをそのまま使えばよさそうです。`description` を `rawValue` にしておけば済みますね。では、それでいきましょう。

こうして実装してみると、`sorted` の左辺・右辺あたりでエラーになりました。ここはカテゴリーを比較しているところですね。一回ビルドして確認してみます。ああ、`description` にしたのに、まだ `name` を使っている箇所が残っていました。`name` ではなく `description` を使うように置き換えます。

ただし、プロトコルのドキュメントには「`description` プロパティを直接呼ばずに、文字列化するときは `String(describing:)` を使ってね」と書かれているんですよね。となると、表示用に文字列化するときは `String(describing: category)` を使うのがよさそうです。デバッグ寄りの表現が欲しければ `String(reflecting:)` ですが、今回はユーザー向けのテキストなので `String(describing:)` が本来の用途ということになります。コードが少し長くなるのは気になりますが、ガイドラインに従ってそう書くのがよいでしょう。`description` の値自体は `rawValue` にしておけば、見た目は従来どおりです。

まとめると、フィルターカテゴリーは `CustomStringConvertible` を実装して `var description: String { rawValue }` とし、外から文字列化したいときは `String(describing:)` を用います。これで `name` は不要になりますし、`RawRepresentable` の設計をそのまま活かせます。 `String(describing:)` を使ってくれと言われているので、分かるならこれでいきます。こうして表示ができるようになって、これでカテゴリの文字列化はOKです。

その上で、ここですよね。`all` か `specific` か。このあたりをテキスト表現にするかどうか、インスタンスそのものをどう扱うかを考えます。`specific` のカテゴリの中に仮に `all` が混ざってしまうと、最終的にこのフィルターカテゴリにとってのテキスト表現が破壊されてしまいます。ただ、カテゴリの中で `all` が出てこないような作りになっているはずですし、「すべての〜」と言っている中で `all` って何、という話にもなるので、そこは気にしなくても良さそうです。

そういう感覚でいくと、フィルターカテゴリとしても純粋にそれを意味するテキスト表現を持たせる、という捉え方もできます。どうするかですが、テキスト表現にしましょう。つまり、`CustomStringConvertible` に準拠させて `description` を実装します。`switch self { case .all: ... case .specific(let category): ... }` として、`.all` のときは「All」、それ以外は `String(describing: category)` を返す、といった形ですね。こうしてあげれば、`FilterCategory` というインスタンスが直接テキスト表現を持っている状況が作れます。これは使っていく、そんな感じです。

先ほど `rawValue` を使っていたところは、テキストでしたね。`Text` でカテゴリを表示する箇所です。ここでカテゴリをテキストで表示するわけですが、`CustomStringConvertible` に対応するイニシャライザが `Text` に入っていれば、これだけでOKで、使い勝手はかなり良いはずです。ただ、これは期待しすぎかもしれません。定義をたどりたいのですが、`init` の定義が出てこない。ドキュメントを見ます。`Text SwiftUI Apple` あたりですね。

`Text` のイニシャライザとして用意されているのはこの辺です。`LocalizedStringKey`（ローカライズ用のキー）を受け取るもの、`AttributedString` を受け取るもの、`String` を受け取るもの、あとは `subject` と `formatter` を受け取るものなどがあります。ただ、`CustomStringConvertible` をそのまま受け取るものはなさそうです。ないですね。ではしょうがない、自分で文字列化します。

文字列化する方法としては、もう一つ気になるイニシャライザがあります。意図としてはテキストをそのまま出力したいので、`Text(verbatim:)` はどうか。これは引数が `String` ですね。なるほど。そうすると、やるべきことは「文字列にする」ことです。方法は2つあって、`String(describing:)` を使うか、文字列補完構文を使うかです。文字列補完構文でやってみます。型のインスタンス表現そのままを `Text` に渡せる、という発想は少し大げさかもしれませんが、`String` にして渡せばOKです。

これで `.all` にすると「すべて」になること、`mountain` なら「Mountain」だけになることを確認できました。大丈夫ですね。リファクタリングは完成です。

ここで、文字列化の設計が気になります。今は「テキスト用の表現」として `FilterCategory` にテキスト表現を持たせていますが、少しまどろっこしい感じもあります。別の方法としては、`FilterCategory` に `CustomStringConvertible` を持たせるのではなく、`title` や `label` のようなプロパティを用意してUI用の表示テキストを提供するアプローチがあります。もう一つは、`Text` のイニシャライザ側で受け取れるように拡張する方法です。

また、「テキスト表現を持っている型は `Text` で表示できる」という普遍的な条件があるなら、`TextRepresentable` のような独自プロトコルを用意しておき、`Text.init(_ value: some TextRepresentable)` のような拡張をあらかじめ作っておく、という手もあります。こうしておけば、UIに表示するための責務が整理され、再利用性も上がります。 では、どこに書くかですが、ビューのこのあたりにしておきます。例えば、あまり外部から提供された汎用的な型に対して拡張を加えるのは、良くないことが多いと思います。今回はそれは採用しないつもりです。新規ファイルも少なくて済みますし、カテゴリーに戻りましょう。フィルターカテゴリーでいいでしょうか。ここで `import SwiftUI` しておいて……大丈夫、出力されていますね。

例えばですが、`extension Text` に対して `init` を用意して、`CustomStringConvertible` のようなものだった場合に、`self.init(verbatim: String(describing: x))` のようにしてあげれば、どんな `CustomStringConvertible` を持っているインスタンスに対してもテキスト化ができます。こういったコードにはなるのですが、影響範囲が大きすぎます。しかも、非常に汎用的なものを受け取って、一般的に使うものに対して拡張しているので、今後のバージョンアップで衝突する可能性や、オーバーロードの都合で動きが変わる可能性がありそうで心配です。これはちょっと大きすぎるかなと思い、やめておこうと最初は考えていました。

さらに、今このコードを書いてみて、別の理由でもやめようかなと思うようになりました。`CustomStringConvertible` というプロトコルは、「すべてのインスタンスは何らかのテキスト表現が可能で、それをカスタマイズする」という趣旨ですよね。そう考えると、カスタムなものだけを受け入れるのは少し変です。カスタムでなくてもインスタンスは作れるわけです。そうすると、受け取るのは `Any` にできます。どんなインスタンスであろうと Swift ではテキスト表現ができるというルールがあるので、これでも成立しますし、こちらのほうが妥当と言えます。つまり、カスタムだけでなく全部で良いわけです。

ただ、こうすると影響範囲がさらに巨大になって、さすがに危ないですね。ちなみに今の発想が使われているのが `print` です。`print` 関数はアイテムをすべて `Any` で受け取り、どんなものでも印字できます。これは「すべてのインスタンスがテキスト表現できるから、どんなものを受け取ってもプリントできる」という発想ですね。それと同じです。

ということで、`Text` にイニシャライザーを持たせるのは悪くないにしても、限定が必要です。`CategoryFilter`（仮）を受け取るようにしましょう。受け取るほうは `LandmarkList` の中の `Category` ですね。これを `String(describing:)` でテキスト表現してあげれば良い、という考えでイニシャライザーを書きます。

ところがイニシャライザーが通らない。原因はアクセスコントロールでした。どれかが `fileprivate` ですね。たぶん `FilterCategory` が `fileprivate`。そこで、イニシャライザーを定義する `extension` 自体を `private extension` にしておきます。こうすると、`Text` は `FilterCategory` をそのまま受け取り、それを表示できる、とても限定的で安全性の高い（大げさかもしれませんが）、とにかくシンプルな関数になります。これなら、この `Text` に対してラベルを用意したり、文字列補間を使ったりする必要がなく、素直に `FilterCategory` をテキスト表示できます。楽をしているだけとも言えますが、今回は影響範囲がかなり限られており、`private` な中だけで完結しますし、表現もシンプルで無理がないので、やっても悪くないかなという気がします。

こんな感じで `FilterCategory` は載せられましたが、`FilterCategory` という名前を見るたびに違和感があります。`Filter` は `FavoritesOnlyFilter` のようなフィルターで、カテゴリーはフィルター側に持たせればよいのでは、という可能性を感じています。いま `enum FilterCategory` としていますが、ここは勝手に今すぐ変えるのは少し怖いところです。

`LandmarkList` の `Filter` に寄せる方針にすると良さそうです。つまり、`LandmarkList` に `Filter` 型を定義し、その中に `Category` を入れ子で定義します。`FilterCategory` をトップレベルや別モジュール（例えば Foundation）に置くのではなく、`LandmarkList` の文脈の中に閉じ込める、という形です。これで `LandmarkList` の中では `FilterCategory` を直接定義せず、`Filter` を定義し、その中で `Category` を定義する、という構成にしていきます。 フィルターのカテゴリー名を見直し、ランドマークリストのフィルター名をもう一度整理しました。名称は「フィルターのカテゴリーズ」、つまり `FilterCategories` という感じに統一します。`FilterCategories` は `CustomStringConvertible` に準拠させ、さらに `Identifiable` と `CaseIterable` にも準拠させました。`allCases` などの参照は、さすがにもう `Self` でよいだろうということで `Self` を使う形にしています。

表示まわりでは、`Text` に `FilterCategories` をそのまま渡して、`description` でテキスト表現されるようにしました。これで、`FilterCategories` による各カテゴリーが `Text` として自然に表示されます。

ランドマークリスト側では、フィルターのカテゴリーを `FilterCategories` の `allCases` で扱えるようにしてあります。デフォルトは「全て（All）」で、ここは `FilterCategories.all` という形で参照しています。ビルドを通してみたところ、名前周りも含めてだいぶ良くなりました。macOS 側のターゲットでも、`FilterCategories` で統一されていることを確認しました。`LandmarksMap` も同様に問題ありません。

カテゴリーの内容としては、`River`、`Lake`、`Mountain`、それから `Turtle Rock` のようなランドマークが正しく分類されているかを確認しました。挙動は大丈夫そうです。お気に入り（Favorites）についても、こちらには影響が出ていないので問題ありません。

余談ですが、フィルターを操作しない場合は、最後に選んだフィルターが保持されるようにしてあり、これは前回のリファクタリング（改良）で入れた挙動です。これも引き続きうまく動いています。

`LandmarkList` 周辺で軽く見直しておくと、`selectedLandmarkID` は記録しているだけで今は使っていません。`Int` で受けてはいないですね。`displayLandmarkIDs` のほうで、リストに表示すべき ID を順序も含めて管理し、その順番で表示しています。フィルターにはフィルタリングに必要な情報が入っており、今日整えた `categories`（= `FilterCategories`）周りもきれいになりました。`FilterCategories` はシーケンスとして `allCases` を回せるので扱いやすく、表示も `description` で済みます。

ひととおり動作確認が取れましたし、カテゴリー周りはおおむねきれいに整ったと感じています。今回はこれくらいでよいでしょう。他にはヘルパー関数を作ったのも OK で、カテゴリー周りも OK。最後に触れられそうなところをさっと見て、特に問題はなさそうでした。今回のポイントはカテゴリーで、これまではフィルターから取れたカテゴリーの扱いが少し曖昧でしたが、`FilterCategories` を `Identifiable` と `CaseIterable`、`CustomStringConvertible` に揃えて、`Text` 表示も含めて統一できたのが良かったところです。 これまでは、カテゴリーとしてランドマークに設定されている3種類に、これとは別に並列で「All（すべて）」を置いて、ケースを4つ並べていました。しかし、明らかに「3つ」と「1つ」で性質が分かれているので、ひとまとめにしないほうが良いだろう、という判断になりました。そこで、残りの3つについて新しいパターンを作ろうと思っていたのですが、すでにチュートリアルにあったのか、あるいは自分で途中まで作っていたのか忘れましたが、「カテゴリー」という型がちょうど用意されていたので、それを使う形にしました。これは「そうそう、まさにこれ」という感じです。

この3つがすでに存在しているということは、フィルターの設計を「特定のカテゴリーを選ぶ」か「すべてを表示する」かの二択にして、前者には「何に特定するか」を関連値で持たせる、という構成にできます。これにより、`Bool`で分岐させるよりも、`specific` のほうが表現として明確になります。英語は得意ではないのですが、`categories` と `specific` で良さそうです。この二択がはっきりしていると、設計としてとても扱いやすいです。

若干、`allCases` が不思議な感じになりましたが、`Filter` の `categories` のすべてのケース、つまり `Category` に存在するすべてを対象にする、という意味になります。特定の場面の「全部」というのは、要するに `Category` の全件です。それらを `specific` で包んであげれば完成で、問題ないでしょう。今日はそこまで進めました。

このあたりは大丈夫だと思います。フィルターは今言ったように、特定のカテゴリーを関連値で持つ形でできています。変更すべきところが他にあるか一応見ておきます。全部を細かく追うのは大変なのでざっと見ますが、`Category` は今説明したものですね。問題なさそうです。`DistanceText` もこのままで良さそうです。

このテキストを見ていて思い出したのですが、やりたいことが1つありました。この辺はリファクタリングもかなり進んできたので、残っているものをもう1つだけ片付けます。`LandmarkList` で唯一、気になっているのがタイトルです。タイトルプロパティがどういう状態かというと、今は `body` の中でナビゲーションのタイトル、つまり `.navigationTitle(title)` として使っています。まあ悪くはないのですが、`LandmarkList` のタイトルとして `.navigationTitle` をここにずっと書いていくのは少しうるさく感じる、というのが気になっている点です。

やっていることは、タイトルを `categories` から決める、というものです。`specific` の場合は `Category` が関連値で付きます。この `Category` は `String` 化できます。すでに `CustomStringConvertible` に準拠させているだけなので、ここは `String` にできます。`rawValue` を取るというより、標準的な文字列表現を取りたいので、`description` を使うのが今回の修正の方針です。

つまり、`Category` を文字列化して、「Landmarks（全件）」なのか、それともカテゴリー名なのかを決め、さらにフィルターの `showFavoritesOnly` かどうかで、タイトルの前に「お気に入り」を付けるかどうかを切り替える、という形です。これをフィルター側に「フィルターを意味するテキスト」として持たせる手もあります。フィルターは条件をいろいろ指定しているので、フィルターが規律（基準）になっている感じはあります。ただ、「All のときは 'Landmarks' にする」といった UI 寄りの判断までフィルターに持ち込むのは、ちょっと UI の気持ちを知りすぎている気もします。ここはやはり、`Category` 自体を文字列化して、`All` のときは「All」が取れる、という挙動で良いと思います。

そう考えると、ここは素直にロジックを組むのが良さそうです。タイトルをどこに置くかは迷ったのですが、この位置で大丈夫そうです。考えられるもう一つの案としては、ナビゲーションタイトルのモディファイアを自分で作ることもできますが、それでも良いですし、現状の書き方でも問題はありません。コードが微妙に見えるところもありますが、`favorites` ならその表示、カテゴリー名ならその文字列、というルールが明快なので、このままで行けそうです。タイトルを `categories` に戻すのも大変ですし、これで良い気がします。ということで、気になっているところは解消できたと思います。

最後に、`LandmarkRow` も一応見ておきます。気になるといえば、クロスプラットフォーム対応のところで、共有関連の処理をもう少しスマートに収めたい、という点があります。ここはなかなかうまくいかないのですが、もう少し工夫したいところです。 専用に作るとか、配慮を分けるなどすればいいのですが、規模が小さいものにそこまで手をかけるのもどうかという気もします。とはいえ、`LandmarkList` については結構やっているので、まずタイトルは iOS と macOS 用ですよね。こういったところは、例えばカテゴリーフィルター自体を `private` にしているのも、ちょっと気になるところがあります。`#if` でベースの型に分けようかなと思ったのですが、そこは少し難しいです。

考えられるのは、プラットフォーム依存の部分を `private` として切り出し、下のほうに条件付きで、例えば iOS と macOS のときに限って `extension LandmarkList` を書くやり方です。つまり、

```
#if os(iOS) || os(macOS)
private extension LandmarkList {
    // iOS/macOS 専用の処理
}
#endif
```

のようにしておけば、その中で使っている API が iOS と macOS でしか使えない場合、うっかり watchOS でも使うコードに混ざってしまっても、ビルド時にエラーになってくれます。先ほども紹介したとおりですが、もう少しまとめて整理できると理想です。結局、iOS/macOS というカテゴリーのように、部分的なものは入れ込んでいくしかないと思います。その他は、あまり効果がなさそうですね。

途中で出てくるもので、すっぱり分けられるとすると、iOS/macOS 向けのところがいくつかあります。例えば、プロトコルの `ToolbarContent` と、モディファイアの `toolbar` があります。これも分けることはできます。ここも iOS/macOS だけで使う、というようにまとめられるのではないでしょうか。なるべく `#if` は少ないほうがいいと思います。

もう一つのやり方としては、例えば watchOS 用モディファイア、iOS 用モディファイア、macOS 用モディファイア、といった拡張を用意して、呼び出し側ではサクサクと `.xxx` と書くだけにしてしまう方法です。実装のほうで、プラットフォームによっては「何もしない」モディファイアにしておけば、`#if` をどこかに閉じ込めることができます。ただ、それをやるにしても少し大げさになったり、融通が利かなかったりするので、マルチプラットフォームである以上、ある程度はあきらめる、というスタンスでもいいのかなという気もします。長いコードを眺めていると、うっかり見落として「ここに watchOS 用の処理を入れてよ」という指示が混じることもあり得なくはないので、もう少し分かりやすくなる工夫は入れてもよさそうです。watchOS 用、macOS 用、iOS と macOS 用、といった整理ですね。ただ、これはある程度しょうがないところもあるので、その分、この辺りを短めに書く、といった工夫が現実的かもしれません。

ツールバー周りについては、定義として `ToolbarContent` と `@ToolbarContentBuilder` があるので、`ContentView` などからコンテンツを返す形にできます。例えば、iOS と macOS で使うツールバーだけを切り出すなら、

```
#if os(iOS) || os(macOS)
@ToolbarContentBuilder
private func platformToolbar() -> some ToolbarContent {
    // ボタンやメニューなどのツールバー項目
}
#endif
```

としておいて、呼び出し側は

```
.toolbar { platformToolbar() }
```

のように書けます。`var` にするか `func` にするかは迷うところですが、`@ToolbarContentBuilder` を付けるならどちらでも書けます。プロパティで書くなら、

```
#if os(iOS) || os(macOS)
@ToolbarContentBuilder
private var platformToolbar: some ToolbarContent {
    // ツールバー項目
}
#endif
```

として、呼び出し側は

```
.toolbar { platformToolbar }
```

とできます。ポイントは、戻り値の型を `ToolbarContent` そのものにするのではなく、`some ToolbarContent` にすることです。`ToolbarContent` はそのままのプロトコル型で返せない場合があるので、`some` を付けてビルダーで構築した内容を返す、という形にしておくと素直に動きます。もし戻り値の推論でエラーが出る場合は、`@ToolbarContentBuilder` が付いているか、戻り値の型が `some ToolbarContent` になっているかを確認するとよいです。 これなら大丈夫ですかね。…いや、ダメか。コンバートできない。あ、そうか。まあ、でもこれでいいんだ、普通に。関数は何のために作ったかというと、戻り値がジェネリックになっているので、ジェネリック関数という位置づけで問題ないはずです。こうしてあげると、上のほうもちゃんと整理されて、見た目がすごくシンプルになりました。`#if` がちょっと多いですが、これがあることで「この中は iOS と macOS 用だな」というのが分かりますよね。

では実行してみて、このボタンが出ているかどうかを確認します。ついでに、データが普通に上がっていくかどうかも見ておきます。OK そうですね。

Lakes はどんな感じでしたっけ。Lakes っぽいですね。Silver Salmon Creek をクリックして、カテゴリバーでも Lakes になっていますね。大丈夫そうです。これで少しスッキリした感じがします。

想定されるのは iOS と macOS の両方ですが、こんなもんですかね。ここは特に変更なしです。これは何のためだったのかというと、macOS で長押しを有効にしてしまうと一覧に戻れなくなる、という問題への対処の話でした。これはこのままでいいですね。

それから、`onChange` で監視している `selectedLandmarks` が変更されたときのコードですが、これはもう不要になりました。削って問題ないです。

あとは、iOS だった場合の分岐になっていますね。つまり、ここは iOS 用のコードということです。コメントアウトしていても意味はないですが、該当箇所はここです。長押しの実装については、iOS の場合はこの条件分岐自体が不要になりました。これで良さそうです。

ここは何だっけ…。あ、フィルターですね。ここの実装があまりきれいではないと思い出しました。これもやりたかったんでした。何をやりたかったかというと、フィルター付きのランドマーク一覧を作るときに、フィルターの型の条件に応じてフィルタリングを行っています。もっと言うと、`FilterLandmarks` は `displayedLandmarkIDs` を持っているもののすべてを受け取る、というところまでは良いのですが、このときに `displayedLandmarkIDs` がある前提で `updateLandmarkList` の中でフィルターに応じたフィルタリングをやっているんですよね。だから結局、`switch` でフィルターごとの分岐を延々と書くことになる。

ということは、「フィルターを満たしているか」を判定するメソッドをフィルター側に持たせてしまえば十分な気がします。なので、それをフィルター型に搭載したいと思っていたのを思い出しました。フィルターを満たしているかを確かめるために、フィルターに対して `…satisfies…` みたいなメソッド名を持たせればよいのでは、という発想です。何を満たしているかというと、ランドマークですね。ランドマークがフィルター条件を満たしているか、を判定します。

英語名をどうするか少し迷ったので、GPT にも聞いてみました。「フィルターの内容をランドマークが満たしているか」を英語にすると、"whether the landmark satisfies the filter" とのことでした。つまり、フィルター側にメソッドを持たせるなら `satisfies` という語を使えますが、他にも "matches" や "applies to"、"determine whether the filter applies to ..." のような表現も候補になります。ただ "applies" はプログラミングだと「適用する」という意味に引っ張られそうで、意図がブレるかもしれません。"test" もありですが、最終的には `matches` がしっくり来ますね。

ということで、`filter.matches(landmark)` のような API にします。戻り値は `Bool` です。フィルター型に対して素直に拡張を入れたいので、`extension` で定義します。型の定義本体とメソッド実装は分けて書きたい派なので、こうします。シグネチャは `func matches(_ landmark: Landmark) -> Bool` でいきます。 アップデートでランドマークの条件をいろいろ見直しましたが、要はここですよね。`listingLandmarkIDs` は、`ModelData` の `landmarks` にフィルターをかけ、フィルターにマッチするものの ID を集めたものになります。なので、ここでやれることとしては、フィルター側に `matches(landmark:)` のような判定メソッドを用意して、`landmarks` の各要素に対してそれを評価する、という形にすれば自然です。

これまで、長い条件式で書いていた部分は、そのままフィルターの `matches(landmark)` に置き換えられます。`matches` は関数（メソッド）で、引数は単一の `Landmark` のはずです。`landmarks` は `Landmark` の配列なので、各要素を渡して判定すれば問題ありません。こうしておけば、`updateLandmarkList` は「ID を更新する」という責務に集中できて、実装としては「`landmarks` の中からフィルターにマッチするものの ID を持っておく」という素直な形に落ち着きます。

あとは `matches` の中で判定を実装すればよい、ということですよね。判定の関心を `Filter` 自体に寄せたので、呼び出し側でゴチャゴチャと条件を並べる必要はなくなります。メソッドとしては `isFilterSatisfied(with: Landmark)` のように読めば終わるのですが、その中身が少し長いので、もう少しシンプルにしたいところです。

これまでの方針では、`filterConditions` のように「`Landmark` を受け取って `Bool` を返す関数」をいくつか用意して配列に詰め、それらをすべて満たせば OK、という発想で作っていました。実際に加えているのは `appendCategoryFilter`（カテゴリーのフィルター）と `appendFavoriteCondition`（お気に入りの条件）の2つで、これらの両方を満たせばフィルターに合致、というコードです。ただ、2つのためだけに関数型の配列を組み立てるのは少しやりすぎだなとも感じます。ここはもう少し素直に書き換えたいです。

具体的には、`favoritesOnly`（お気に入りのみ）とカテゴリーの2条件を直接判定します。

- `favoritesOnly` が `false` のときはこの条件は常に満たされます。`true` のときだけ `landmark.isFavorite` を確認します。
- カテゴリーは、`category` が `All` なら常に満たされ、特定のカテゴリーが指定されている場合は `landmark.category` と一致するかどうかを見ます。条件自体はとても単純で、この2つが一致するかどうかだけです。

この2つの判定を `matches(landmark:)` の中に素直に書けばよく、わざわざ関数の配列を作って畳み込みで評価する必要はありません。すでに用意していた private extension にこだわるほどでもないので、`Filter` の API として「お気に入り」と「カテゴリー」の判定ができれば十分です。

命名については少し悩みます。`filter.matches(landmark)` という形は読みやすいと思いますが、他の案としては `isSatisfied(by: landmark)` や `isSatisfied(with: landmark)`、あるいは「ランドマークがフィルター条件を満たしているか」をはっきり表す `landmarkMatchesFilter` のような名前も考えられます。`favoriteFilterMatches` や `filterChecks` といった名前も候補には上がりましたが、`Filter` というクラス名（あるいは型名）から始められる表現で、最終的には「ランドマークが条件を満たしているかどうかを判定する」という意図が明確になるものにしたいです。英語で言えば “determines whether the landmark satisfies its conditions” という感じですね。命名はなかなか難しいです。 どうしようかな……英語、英語力がないなあ。フィルターの命名、どうしよう。どこまで頑張らなくていいのかな。やるならちゃんとやりますか。カテゴリー・フィルター……うーん、よい言い回しが思い浮かばないですね。

結局、「フィルターがランドマークにマッチするか」ですよね。受け手はフィルターでよくて、ランドマークを引数に取る形にしたいです。たとえば、`aValidFilter.matches(landmark)` のような感じです。少しもやっとしますが、意味は伝わりますし、悪くはないと思います。ここではレシーバーがフィルター側で、`matches` の対象が `landmark` という関係にしたい、ということですね。「`aValidFilter` が `landmark` にマッチする」という読み方になります。

この `matches` の中身については、まず「お気に入り」に着目したフィルターを切り出します。`favoritesOnly` のフィルターがオンのときは、ランドマークが `isFavorite` かどうかで結果が変わります。`favoritesOnly` が付いていない場合は、常に `true` を返します。つまり、「`favoritesOnly` なら `landmark.isFavorite`、そうでなければ常に `true`」という単純な分岐で良いですね。この程度のコードなら、少し考えれば分かります。これで良いと思います。

表示まわりがちょっと変なところで解除されていたので、ウィンドウはいったん畳みますが、方針としてはこれで良さそうです。

同様に、カテゴリーによるフィルターも用意します。`categoryFilter.matches(landmark)` のような関数です。英語の命名については、先ほど ChatGPT に教わったときの話で、`matches(landmark)` に `with` は要らないのでは、という疑問がありましたが、ここでは `matches` だけで良しとします。これも `Bool` を返す関数にします。

カテゴリーは iOS や macOS 専用のものがある想定なので、そこは条件付きコンパイルで囲っておけば、他のプラットフォームで間違って使うことはなくなります。そもそも使いたいカテゴリーはその中にしかないので、すでに誤用しにくい構造にはなっています。マッチの条件自体はシンプルで、カテゴリーが `all` の場合は無条件で `true`、そうでなければランドマークのカテゴリーと一致しているかどうかで判定します。

こうして切り出しておけば、`validFilter` と `categoryFilter` のマッチ判定がそれぞれ独立に得られます。あとは、この2つがともにマッチしているかを `matches` の組み合わせで調べればよいわけです。わざわざ「フィルター条件」のような別の抽象を作る必要もありませんし、`is...` をたくさん並べて長く複雑にする必要もありません。最後に `allSatisfy` のような形で「要件を満たすか」をまとめるのもありです。たとえば、`validFilter.matches(landmark) && categoryFilter.matches(landmark)` と書けます。

ただし、ここで問題がありました。`&&` 演算子の途中で改行して `#if` を挟むことはできません。つまり、`#if` で式の真ん中を分割する書き方はできないので、ここは工夫が必要です。簡単なのは、条件付きコンパイルで「片側だけ評価する版」と「両方評価する版」を分けることです。`validFilter.matches(...)` を2回書くことになるのを無意味に気にしてしまいますが、実務的にはそれで構いません。

やり方としては次のような方針が考えられます。
- `#if os(iOS) || os(macOS)` のときは、`validFilter.matches(landmark) && categoryFilter.matches(landmark)` の両方で判定する。
- `#elseif os(watchOS)` のときは、`favoritesOnly` に関するフィルター、つまり「お気に入り」のフィルターだけを判定する。
- 2段階に分けて、あらかじめ個別のブール値に計算してから `&&` する方法もありますが、`#if` を演算子の間に入れられない制約は変わらないので、結局ブランチごとに式を完結させるのが安全です。

細かいことをあまり考えすぎず、プラットフォームごとに「両方のフィルターを使う」「お気に入りフィルターだけを使う」と分けて書くのが現実的だと思います。 Favorites フィルターのマッチ条件でランドマークを絞り込みつつ、`&&` を使った `if` をこうやって簡単に置いておくのは、たとえば `visionOS` 向けに作っているときに、`visionOS` では戻り値の扱いが未実装でコンパイルエラーになってくる、というような特定の条件なのかな、または別の条件なのかな、というのをこのとき考えられるので、いったん半分にしておきます。ここは `else` にする手もあるのですが、`else` にしておくと `visionOS` の場合に下へ行ってしまうので、まだ想定もしていないならそれで良いのですが、こういった感じであえて `if` 文を宙に浮かせておく、というのはこの `#if` においては重要になってきます。重要と言うと大げさかもしれませんが、実際そうするようになってきます。こんな感じですね。

とりあえずこれで、マッチ条件でちゃんと判定できるようになったらバッチリですね。それで、こっちの App でランドマークのフィルターにマッチするものだけをフィルターして ID を取る、と。これでフィルターできるかな。できると思うので、フィルターをかけてみて、ちゃんと動くか確認します。

一回落としますか。GPT は裏に置いておいて、これを動かします。App はどこかな……ここじゃないですね。動いてないかな。App を開いた……戻りました。これですね。これがいるのでフィルターで項目が全部出ていて、今はリストがいつも出そうですよね。Favorites にするとお気に入りだけになりましたね。Favorites を外すと外れますね。Rivers にすると River だけになりましたね。こんなふうに、お気に入りにすると両方わかりますね。大丈夫そうです。

こんな感じで、コードはマルチプラットフォーム対応のままですが、だいぶ良くなったかなという気がします。iOS でのランドマークリストは、流しすぎても困るのでこのくらいでいいでしょうね。同じ条件で作っていますが、ランドマークリストのフィルターに対する確定もできました。そんな感じでできたので、これで OK です。

あとはこの辺は気になったところですけど、しょうがなさそうですね。`macOS` とかになっているから、`minWidth` の対象値というものをリテラル……じゃない、スタティックな値で持っておく手はありますね。`minWidth` を `macOS` だったら 300 にして、それ以外だったら 20、という感じ。それでもいいですね。そうしましょうか。`macOS` だったらそうですよね。なので、extension というのかな、スタティックの場合、`iOS` と `macOS` で……でも面倒かな。どっちでもいい気がしてきた感じはしますが、この辺に持たせておきます。

`#endif` と同様に `#if`。これも微妙かな。`watchOS` の場合の条件と引き継いだネットワークはどうだ……ここですね。こんな感じ。ここもやってあげて、これで `iOS` だったら `nil` で、`watchOS` だったら `nil`、みたいな感じでリテラルを作ってあげて。それでこの中で……`minWidth` にしましたっけ？ない気がする。List、しかも List ですよね。これ、List の最小幅ですよね。なのでこの辺の名前を `listMinimumWidth` にしてあげて、それでこの名前を変えてあげれば、ディレクティブと関係なく変えられますよね。そうするとここが条件いらなくなって、立ち上がるようになりますよね。……でもダメだ。これは `self` ですね。この辺はしょうがないのでこれで。

タイトルの定義はどこでしたっけ。タイトルはこれか。これは大丈夫でしたね。`iOS` または `macOS` という程度ですね。だからこれは良いですね。`iOS` または `macOS` ならタイトルを設定していくよ、なので、ここはいいですね。こんな感じで良いかなという感じがしてきました。

ある程度は、こうやってディレクティブが目立つかつ大きい枠組みでさっくりと捉えてくれるので、これはいいか。これはいいですね。さっくりと捉えてくれれば、ある程度はいい感じにこの辺もパークできて、ちょっとこのタイトルが稀に出てきますけど、これはしょうがないということにして。大丈夫ですかね。良さそうです。

こんな感じで、これまでのアプリのリファクタリングが終わったので、ここでまた続き……でしたっけね。セクション 4 が終わったところなので、続いて `macOS` のセクション 5 のところですね。それをまた引き続き、この `macOS` アプリのセクション 5、これは後日やっていく感じにしますね。セクション 5 は何をするんだろう。セクション 5 はどこだ。セクション 3 でしょ。セクション 4 が終わってこれなので、セクション 5 はこれだ。Built-in Menu Commands。なるほど、`macOS` 用アプリなので、メニューからやっていこうよという、そういったお話になっていくと思われます。セクション 5 が終わったらまたゆっくり見ていきましょう。

では、今日はこれで終わりにします。お疲れ様でした。
