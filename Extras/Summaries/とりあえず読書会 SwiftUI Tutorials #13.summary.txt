Transcription & Summarize : とりあえず読書会 SwiftUI Tutorials #13

では今日も「とりあえず読書会」を始めていきましょう。ちょっとリアルのほうを見ていて、とあるアニメーション系のところ（これはあまり関係ないのですが）を追っている最中に、コードをまるっとコピペする場面に出会いました。そこで「このままコピペの方針でいいのかな、そのままでいいのかな」と気になってしまい、前回くらいからリファクタリングを始めたわけですが、まだ前回やっただけでは、もう少し変えていけそうなところがある気がします。これも引き続きやっていこうと思います。

前回も言いましたが、リファクタリングは結構難しく、主観によるところもあります。主観でなくても、世の中で「こうあるべきだ」と言われていることに従うことはありますが、それが絶対とは限りません。その辺は、行き詰まったら一度立ち止まりつつ、とにかく自分の感覚を養っていくのが一番重要なのかなという気がします。その中で思うように進めていきますが、その「思うようにやる」リファクタリングが将来的にコードを楽に、矛盾なく書けるようにすることが大事だと思います。うまくまとめられることもあれば、まとまりきらないこともありますが、その辺はやっていって試すしかないですね。

だいぶ書き換えてきましたが、まずハイパーグラフのところで「この書き換え、意味なかったね」という話をした箇所があります。オブザベーションレンジのリストを取って、それに対して最小包含レンジのリストとマグニチュードの最大値、これらを取っています。結局、コレクションを作ってから `max` にかける、という形になっていて、ちょっと微妙かなと思っています。ただ「最大マグニチュード」って要するに最大値なわけで、機能としては似ていますよね。とはいえ、機能が似ているからといって、それらをまとめて高速化するほどの価値がここにあるのかどうかは、また別の問題です。

今はクロージャを作って、イテレータの `next` で回していき、その中でいろいろ結果を取っています。なので、`reduce` を使って、最小包含レンジとマグニチュードの最大値、この2つを一気に計算してしまったほうが都合がいいのかな、ということを少し思いました。うん。まあ、何にしてもこれでいいのかな、というところです。 2回ほど `map` をかけちゃいますけどね。まあまあ、だんだんと良い感じがしますよね。

`observation_ranges` を2箇所で使っていて、さらに `map` も多用していて、これを2回使っているので、ちょっと怖いですよね。`Observation` 自体も後で使っています。いろいろとするときに、数理的に言えばそうしたほうがよかったのかなという気もしないでもないのですが、なんかループが多いなあというところがちょっと気になっています。

`Observation` のタイプは `enum` で持っていて、`Observation` 自体は `struct` です。だからここは定数的に扱える、タイプと同じ点で変化していないわけです。この中で何回もやってはいますが、まあこれはこれでいいかという感じもします。

`observation_map` でしょ。`map` してイテレータで取って……。`observation_ranges` を使っているのは、ここの2つの計算にしか使っていません。`overall_range` は、`overall_range` を渡すところで1箇所だけ使っています。`magnitude` の `max` は……あ、ここだ。なるほど、例のところで使っていると。

`observation_ranges` で `magnitude` と一致して計算していますけれど、さっき言った効率の観点で言えば、ちょっと使い勝手を良くするだけで効率はそんなに悪くならないと思います。これは絶対値を取ることがあるわけですよね。`observation_ranges` の配列の中でいろいろやりますが、ここで例えば拡張トレイトを用意して、`Observation` に対して実装しておく、みたいな書き方ができます。`where` で書かなくてもいいか。こんなふうに書いてあげて、その中で例えば、`Observation` のタイプ（`enum`）に基づいて……という感じですね。

この状況で、`observation_ranges` 側が `magnitude` の最大値を直接取れるようにしておけば良い、ということになります。行き場所としては、`Observation` のシーケンス（たとえば `Vec<Observation>` やスライス）に対する拡張トレイトにして、たとえば `max_magnitude` を生やす、というのが考えられます。`magnitude` は……何でしたっけ、W かな？ プログラミングの話をしているようですね。`マップ`や`マグニチュード`、`レンジ`といったキーワードが飛び交っていますが、具体的なコードについて整理している様子です。最初、`マグニチュード`を求めようとして試行錯誤しているようです。「マックス値を取る」という場面も出てくるので、最大値を抽出するためのコードを書いていると思われます。

途中で`レンジ`の扱い方で混乱がある様子ですが、それを整理して最終的には`レイジー`評価を使うことが好ましいという結論に至ったようです。`マックスマグニチュード`も取得できることを確認されていますね。こうした処理を改善できたことで、以前は変数に入れていたものを改善し、直接利用できるようにするなど、コードの効率化について考えているのが伝わります。

`オブザベーション`や`オーバーウォールレンジ`という語句も出てきて、プログラムの中で観測値やレンジを管理して、それに基づいた処理をしているようです。`キーパス`も出てくることから、何らかのデータ構造アクセスに関わる話をしているのかもしれません。

最後には`ジオメトリー`という言葉に触れています。`ジオメトリー`を回す処理について、プレビューを出した結果が気になっているようで、プログラム全体の流れの中でデータの扱いに思案している様子で終わっていますね。 現在の進行状況を元に描画するためのプレビュー作業を進めていますが、ジオメトリーリーガーを使用することでアクセルを全体に描くことができるかどうかが気になるところです。プレビューの段階でジオメトリーが崩れてしまわないか確認しながら進めていきます。前回同様、慎重に作業を進めていく必要がありますね。

まずはプレビューを確認すると、ジオメトリーリーガーを使ってバウンズしたい箇所がありますね。アクセルに関する部分です。しかし、プレビュー上で目指す結果が得られず、ジオメトリーが既に混乱しているようです。特に重なりのある部分を修正しなければなりません。

ジオメトリーリーガーをHスタックの前に移動してみると、サイズがずれてしまう問題があります。Hスタックの中で座標が変わってしまう可能性があるため、Hスタックでジオメトリーリーガーを囲う工夫が必要ですね。全体をジオメトリーリーガーで囲ってしまうと、横並びに問題が生じることがあります。

うまくHスタック内にレーシングとしてマージンを設定すれば、サイズ調整が可能ですが、ジオメトリーリーガーが原因で意図しない結果が生じてしまいます。プレビューの効果を考慮し、全体のHスタックを再検討する必要があります。

私の作業上の問題解決には、配布グラフの中で如何にジオメトリーリーガーをうまく組み込むかがカギとなっているようです。他の試行錯誤を続けながら、最適なアプローチを探っていきます。どのように配置するかは重要ですので、これからの調整が求められます。 これまでのスタイルを見直して、ジオメトリーリーダーにパラメータを渡すのをやめて、シンプルに進める方針にしました。これによって、バウンズが必要なくなり、配布グラフの中での設定が省略されました。今のコードでジオメトリーを使う箇所はありませんが、描画が少しおかしくなる可能性もあります。

現状では、ジオメトリーに関する処理や依存性は特に持っていないため、問題はありません。ジオメトリーが必要だった理由を見失ってしまい、リファクタリングはやや早急だったかもしれません。

再度確認したところ、`VSTACK`や`HSTACK`の組み込みにより、ジオメトリーの扱いが少し変わってきています。この方法ではジオメトリーが正しく反映されなくなり、特定の条件下でレイアウトが崩れます。最終的に、このやり方が失敗だったことが分かりました。この部分を改善する方法を探っていくことが次のステップになりそうです。 バイクディテールについて議論しています。もし特定のエリアで適切に振る舞いたい場合は、バウンズを取るのではなく、ジオメトリーリーダーを正しく使うべきだという話です。これはUIに詳しい人にとっては当たり前のことかもしれませんね。

Vスタックを使用して、コードの中で様々な操作を行っていくわけです。この手法を用いることで、以前は必要だったジオメトリーリーダーが不要になり、バウンズも削除されました。バウンズが呼び出し元で指定していたものも削除して、よりシンプルになったと言えます。

Vスタックはもう必要なく、純粋にバイクディテールとして存在します。これにより期待通りに表示されるはずで、グループの多数のグラフも正常に表示されます。ディテールの中で注目すべきなのは主にインテントやジオメトリー、Vスタック部分ですね。それらはバイクディテール内のグラフと関連しています。

次にボタンの処理についてです。ボタンは複数状態で存在し、それがジオメトリーとも関わっています。コードを見直す中で、中身をどう構成するか、ディテールをどのように作成するかを考えています。

具体的には、ダウンロードしたリソースを確認し、リソース内にあるHype Detailを見ます。そこにはVスタック内にグラフボタンがあるはずで、ジオメトリーを自作したという気付きもありました。このあたりのイベントはそれほど複雑ではなく、ボタンのビューを細かく分解しても問題ないでしょう。

これにより、プライベートエクステンションとしてHype Detailにボタンバーを搭載し、ボタンバー内のコードでボタンを描画することができます。ボタンの名前や構成を直すことで、正しい表示が可能になり、エラーの原因がクリアになります。

最後に、Hype Graphとボタンズバーを示すことで、ジオメトリーリーダーを使用せずにスムーズな動作が可能です。適切なインデントやバリューの管理についても確認し、全体のコードを見直しました。

ボタンの中身、特に値（バリュー）の位置や型に注目していますが、これはダブル型やストリング型の型の整合性が重要です。不足している要素（anyやSendable）があることにも注意が必要です。これらを踏まえて、再度コードを構築し、期待通りの動作を確認します。 型推論に関する議論を行っているようですね。まず、特定の型に`Any`と`Send`を付けて確認してみたそうですが、`Any`は必要ないかもしれないと考えているようです。ただし、型推論を2回行い、型を調べてみることにしました。ラベルを切るというステップを試しましたが、うまくいかなかったため、型推論に頼ることにしています。

問題のあるコードは、`String`、`AnyReadable`、`PPath`、`Any&Send`などを扱っているようで、`let`の記述を忘れていたことに気がついたようです。コピーしたコードを貼り付けること自体には問題ないようですが、`Send`が不要ではないかという仮説もあります。

最終的には`String`と`PPath`を使ってタイトルやパスを表現する方法を考えています。型推論を利用することで、冗長な型指定を省略できると考え、コードを簡略化することを試みています。

`KeyPass`を使うことに関しては煩雑さを感じているようですが、`ePath`や`eDouble`といった記述に修正すれば型を明示することができると考えています。`FakeObservation`の使い方や、データをどのように参照しているかについても分析を行っているようです。最終的には、複数の参照を確認しながら、型や変数の使い方を整理している段階のようです。 ファイクグラフにおいて、データのパスを使うことが重要ですね。データ通称という表記よりも、データパスの方が適切です。「データパス」と一言に言ってしまった方が明確になります。rename でデータパスを使用すると、データのパスについて考えることができるようになります。タイプエイリアスを使用してデータパスを作成し、それを `ePAS` として定義するとよいでしょう。これにより、データパスを取得するという意図が明確になります。

例えば、ボタンのパスを取る場合も同じで、データパスはボタンの特定の属性と一致させるようにします。条件が一致した場合には特別な処理を行うことができます。これによって、データパスをうまく活用できる状態に整えられます。

この方法でデータを構造化し、情報がシンプルになりました。たとえば、色を変更したり、オブザベーションのキーをマップで使ってパスを取得する際にも、このような構造を活用することでコードが明確になります。特に `MAX` 関数のようなところでは、アンラップを行う際に要素が存在するという保証が重要です。

また、ハイクディテールがステートとして使われている場面でも、明確なデータパスが利用されることで、エラーを回避しやすくなります。これにより柔軟な状態管理が可能になります。特に、ハイクを初期化する際には、データ構造内に要素が必ず存在するという保証が必要です。この保証に基づく設計が、コーディングをより安全で確実にしてくれます。 プログラムや設計を進める際、オブジェクトに必要な要素が足りない場合、どのように対応するかはよく考えるポイントです。例えば、イニシャライザーを起動する際に要素が0個の場合、それをエラーとして扱う方法や、必ず少なくとも1つの要素を含むオブジェクトを作る方法があります。

問題は、特に何も観測されていない状態がどう扱われるかです。そのため、プログラム内で空のリストを扱う際には、注意が必要です。オーバーレンジについて考えると、プログラムが0で割るような計算を避けるために、早い段階でエラーを防ぐ対策を施す必要があります。

具体的には、観測データが空の場合、それに対応するビューをどう扱うかが問題になります。何も表示されないグラフビュー、つまり「エンプティビュー」を表示するのが良いでしょう。それに基づいてビューを描画する際のサイズやオフセットを計算していくことになります。例えば、ビューの幅や高さが適切に計算されない場合も考慮し、プライベートなエクステンションメソッドなどを使用して、調整を行うことが必要です。

全体として、問題点とそのままでは無効となるような状態を発見し、それをどのタイミングで、どのようにハンドリングするかを慎重に判断し、実際の表示や処理に支障がないように設計するべきです。 ね。ここでは「オブザベーションズ」と「バウンズ」という言葉が出てきますが、これらが何を指しているのかをまず確認しましょう。具体的には、「オブザベーションズ」はデータの観測値のようなものを指している可能性があります。これが空であってはいけない、つまり少なくとも1つの要素を持っていることがグラフを描く上での前提条件となっています。

コード内で行われていることをざっくり説明すると、まずはデータのオブザベーションズが空でないことを確認するためにプレコンディションを設定しています。これは、アサート（`assert`）を使って実現していますね。プレコンディションが満たされると、安全にグラフビューのロジックに進むことができます。

その中で、「バウンズ」とはデータの境界、つまりグラフの表示範囲を設定するものと思われます。バウンズとしてプロキシサイズを渡し、必要なデータを管理しています。

オブザベーションズが空である場合についても考慮が必要で、その場合はエンプティビュー、つまり何も表示しない状態を戻り値とするように設計されています。

また、コードの中のロジックで、単純にデータをコレクションに集約する仕組みが見受けられます。データとしてシーケンスで管理し、必要に応じて操作を加えているようです。特にスイッチやケース文を使って、異なる条件に基づいて処理を変えるロジックが含まれています。

それぞれの処理を順々に行い、最終的にグラフビューが調整された状態で出力されるように仕組まれています。柔軟な処理が行われていることから、リアルタイムデータを扱うアプリケーションなど、様々なケースに対応可能な設計だと考えられます。 フレームのパターンを指定する必要があるのかもしれませんね。ジオメトリリーダーを使用して、エンプティにすることで、絶対に0の場合にはグラフビューを書かないようにできます。もともとそういう仕様になっていますが、言い切れるわけではありません。この設定で安全性がプロコンディションで担保されたと考えることができるでしょう。

オブザーベーションに頼ることで、ランタイムに依存する部分がありましたが、今回はそれで問題ないかと思います。ハイクのオブザーベーション自体が、必ず1つ以上の要素を取るという考えで実装するなら、新しい型を作るなどの対応も考えられますが、今回はその必要性が見えなかったため、このままで良いでしょう。

これで一通り実装できたかと思います。ハイクビューは読み取り専用で、内部で超ディテールを扱います。超ディテールは直接外から使われることはないと考えられるので、エクステンションで隠蔽する形が良さそうです。ハイクディテールをエクステンションにするために、ハイクビューのプライベートエクステンションを活用しましょう。

プライベートエクステンションの中に、ハイクディテールとして構造体を定義し、ボディなどを含めても構いません。こうすることで、プレビューも問題なく動作するはずです。データパスやラベルの表現をプロパティとして定義することで、ボタンとしての一貫性を持たせることもできます。

ボタンの状態を表すために、ボタンの選択状態のプロパティを持たせ、フォアグラウンドカラーを設定する方法なども一緒に考慮します。ボタンの見た目や動作が様々な状況にも対応できるように設計を進めます。

ボタンズバーでのボタンの選択状態も、プロパティで判断し、それに応じた表示を行えるように設定することができます。このやり方で、プログラムの構造を整理し、必要な機能を実装していくと良いでしょう。 エクディテールのボタンに関する修正を進めていきますね。まず、複数のボタンがある場合についてですが、個人的にはボタンの配列を示すために「ボタンズ」と書いておくと分かりやすいと感じます。ただ、これは人それぞれの好みです。イニシャライザーでは配列の中にボタンがあり、それにタイトルを設定しています。ここでタイトルをIDとして利用している形ですね。

次に、ボタンに関するビューの修正です。ボタンは「セルフ」の中にある「ボタンズ」で選択されています。過去にダウンロードしたファイルに関して、ボタンのディテールが手元にあるかどうか確認し、必要な情報はネットでも確認できます。

データ通称については「ディテールビュー」の中で管理されています。「データパス」はステータスを保持しており、セルフのデータパスとボタンのデータパスが一致するかどうかを確認します。もし同じパスを見ているなら、選択されていると見なします。

アクション部分において、データ通称をボタンのデータパスに合わせる形で動作しますが、上部にある問題については、イニシャライズ時に変更が必要です。ボタンのタイトルを「エレベーション」とし、データパスも同様に設定しています。

この部分で、なぜこれほど複雑にしているのか疑問に思うかもしれませんが、徐々に組み立てていくとこの結論に至るかと思います。キーパスは非常に便利ですし、全体をまとめて管理するのに役立ちます。

ボタン自体が完成し、エラーが解決されることを確認しています。ビルドが成功することでプレビューが問題なく動作すれば良いでしょう。4つのボタンについて確認したところ、エラーが出ている場合はビルドを再試行してください。ボタンが正常に動作するかどうか確認し、必要に応じてプレビューを動かして対応します。

以上のプロセスでボタンが正常に機能し、必要なすべての表示が行われていることを確認できます。複数のボタンを設定する段階で問題が解決できれば良いですし、問題があれば調整していきましょう。 3つ並んでいる場所を探していたんですね。ハイクグラフのプレビューを見ると、それがピン止めされているようです。3つ見つけることができて、問題ないようですね。それで、ハイクディティールが不要になったという状況のようです。名前についてもう少し気になるところがありました。現在、ハイクビューの中にハイクディティールを持たせていますが、これはディティールビューでも良さそうです。修正後の描画もハイクビューが正常に動作していることを確認できました。

名前はシンプルになったようで、個人的には良い感じになったと思います。次はフォード、ここで最後にグラフを確認します。ハイクの中でグラフを扱っており、これもグラフビューに変更できる可能性があります。ハイクグラフをプライベートエクステンションとしてハイクビューの中に構造体として組み込んでいきます。ここまででハイクグラフがハイクビューの中に入りましたので、これで名前空間を指定して、ハイクプライベートエクステンションにハイクグラフを拡張できる状態になりました。プライベートエクステンションとして追加されたハイクグラフは、名前空間内に3つ並んでいますが、これらすべてを名前空間で指定して、ハイクビューのハイクグラフとして扱うことができます。

さらに、ジオメトリリーザーは完全に不要になったことがわかりました。それについては自分の勘違いでした。 レビューの順番について考えていましたが、大きい順からチェックした方が見やすいかと思ったので、レビューの順番をハイクディテール、ハイクディテール、ハイクディテールという風に設定しました。この順番はレビューリストの順番と一致させておくと混乱が少なくなるでしょう。

また、いらなくなったファイルやコンポーネントも整理しています。例えば、ハイクグラフはもう使わないので削除し、関連するディレクトリも片付けています。そして、ハイクビューの再チェックも行い、ストラクトに必要なフィールド（ハイクやステータス、データなど）が適切に設定されているかを確認しました。

ハイクビューについては、プライベートなプロパティとして持ちつつ、詳細表示用のビューが変更される仕組みを整えていて、表示するためにエレベーションや他のデータを活用します。ディテールボタンはアニメーション付きで詳細をトグルするようにしています。

データの渡し方についても見直しを行っています。例えば、データ自体ではなく、データのパスを渡す方法も検討しました。ただし、問題として、外部から色を与えないといけないことや、描画する時にデータをどう扱うかという課題もあります。

全体的には「4-H」と呼ばれるものも見直さないといけないようです。意味が明確でない部分があり、読んでみても理解しづらい箇所があることから、これについても再度調査し、必要に応じてデータを配列にすることも考慮しています。

全体の作業としては、他に気になる点を洗い出し、適宜修正していくというプロセスを繰り返しながら進めています。 4-Hについて話していたところですが、他にも何かあった気がします。リストUIで4-Hと何かについて話していたのですが、忘れてしまいました。でも、思い出しました。リストのほかに4-Hについても話していました。ここでは4-Hで良さそうですね。この書き方にすると、パイクグラフが表示される感じです。カプセルを削除すると、バーの部分に関わる話のようにも思えますが、そうではないかもしれません。グラフビューはグラフだけに関係するものですね。

さて、4-Hでオブザベーションズに対して操作を行うと、プレフィックスごとに分かれていることがわかりますね。その1が入っているのも当然の結果です。この部分は4-Hで良さそうですね。ランダムアクセスコレクションにしたほうが良いかもしれませんが、みんなそうしているわけでもなく、少し大変ですね。

計画として、パイクグラフをプリスタックに積んでいるディテールビューがあります。ディテールビューは、絵が大きくても小さくても同じことをしていて少し難解ですが、ボタンでデータを扱っているようです。ボタンアイテムという名前にリファクタリングしておきましょうかね。これで少し整理されましたかね。ボタンはボタンアイテムとして扱うようにします。

TwistUIのボタンに関しては、名前が重ならないようにして、マーキュラーシーンで名前空間を元に戻します。これで大体OKですね。データパスを渡すところも整理しつつ、ボタンビューにアイテムとデータパスを渡して操作しているのか、どういう風に設計するか考えていく必要があります。ディテールビューでは、どのボタンであるかを識別するために履歴情報を持たせるのか、データパスで判断するのかといった具合です。デザインの際にこうした選択が重要になってきます。 データパスを使うとき、必ずしも一対一になるとは限らない点もあるようです。特に、歴叙型を使った場合には、その歴叙型による状態表示と受け取ったデジタルデータやオブザーベーション（観察データ）が一致しているかどうかが分かりにくくなることがあります。ただ、キーパスを使うことで、ボタンが良し悪しを管理し、ハイクのプロパティとオブザーベーションをうまく対応させることが可能です。オブザーベーションの配列の中から、それぞれのタイプのものを抽出する際、キーパスを利用するのは悪くない選択かもしれません。

さらに、コード内でボタンアイテムを作成した話をしています。ボタンアイテムにはLUやPUといったものがあり、その中でキーパスがクラスとして機能しているようです。具体的には、`エライタブルキーパス` や `パーシャルキーパス` として、これらがプロパティに対応しています。ただ、このアプローチで問題が出たり議論が必要になった時は、その時点で考え直すといった姿勢で進めているようです。

また、コードの中で`@センタブル`や`アンチェクト`といったものを付けるべきか悩んでいる様子です。ただし、現状では大きな支障はないため、とりあえずこのまま進めることにして、影響が出た時に対応を考えるという方針で進めています。

最終的に、ボタンアイテムのプロパティやコンディションについても一通り確認を終え、心配はないとしています。コードは良い感じに整えられたと感じているようです。次回は、もう少し複雑なアニメーションに進む計画のようです。今日はこれで終了ということでした。お疲れ様でした。
