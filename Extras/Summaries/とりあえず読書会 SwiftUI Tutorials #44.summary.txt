Transcription & Summarize : とりあえず読書会 SwiftUI Tutorials #44

では、とりあえず紹介を始めていきます。SwiftUI 2.0 リファレンスを読んでいて、ひと通り読み終わった感じではあるのですが、せっかくなのでサンプルコードのリファクタリングを引き続きやっていこう、という流れです。前回までは `Swift Macros` を使って、それを活用したリファクタリング……というと少し大げさかもしれませんが、練習として取り組んでいました。もう少しで完成、というか完成したつもりだったのですが、いくつかうまくいかないところがあったので、今日はそこを直すところから始めて、なんとか完成まで持っていけたらいいなと期待しています。まあ、期待はさておき、やることを進めます。

大事な問題としてコメントにも書いたのですが、`userInfo` を作る処理の話です。入力になっている型のケースは補足できているのですが、そうではない部分、つまり `userInfo` 型が包含しているケースがまだ補足されていない、という状況があります。ここはなんとかしないといけません。コードの共通化を図っていけば大丈夫だろう、というところまでが前回の流れでした。

Macro を展開すると、`aps` と、その中の `alert`、`title`、`message` が出てきます。さらに `aps` の中に `test` があり、その中にもまた `test` がある。そして `aps` の外側、つまり `userInfo` のルートに `case landmarkID` があるのですが、この `landmarkID` だけが反映されていない、という状況です。つまり、`aps` があり、`aps.alert` があり、`aps.alert.title`、`aps.alert.message`、`aps.test`、`aps.test.test` で終わってしまい、`landmarkID` が出てこない。これを改善する必要があります。

今は `enum` の宣言をビジターパターンで walk しています。考えたのは、`ContainingEnumVisitor` のような、このビジターパターンの中でケースをちゃんと考慮したコードが作られているので、それをどう拡張するか、という点です。`visit` の中で、メンバーの `EnumCaseDeclSyntax` に対して処理をしているので、この部分を内包するもの――`ContainingEnum` だけではなく、自分自身の `enum` そのものにも適用できるように作っていく、というのが大事なところです。

これをやるにあたって、ビジターパターンを使い、`EnumCaseDeclSyntax` が見つかったら次へ進む、といった形でもいいのかなと思いましたが、それだと階層が狂う懸念があります。いまのところケース分は `enum` の中だけで出てきます。`EnumCaseDeclSyntax` は絶対に `enum` の中にしか現れません。であれば、`Visitor` を使ってもよさそうです。

やってみます。やることとしては、`ContainingEnumVisitor` と同じ感じで、`EnumCaseVisitor` のようなものを作るイメージです。まずは `final class` で `EnumCaseVisitor` を用意します。どこに置くかですが、`UserInfoAccessor` の中に置くのは違いそうです。プロパティのコンテナを作る用途なので、`ValuePropertyVisitor` のような名前にし、`SyntaxVisitor` を継承させるのがよさそうです。

この中でやることとしては、まず展開結果を保存する場所（バッファ）を持つこと、そして `visit` の実装です。`enum` 自体に対する `visit(EnumDeclSyntax)` だけでなく、`visit(EnumCaseDeclSyntax)` も用意します。`enum` の中だけを対象にしたいので、他の `enum` にネストしているケースは無視したい、つまり対象の `enum` だけを処理したいわけです。であれば、`enum` に対する `visit` では子ノードを見ないようにし、`skipChildren` を返すようにします。

最初に `enum` を渡したときにどうなるか、動作を確認するために一旦 `print` を入れてみます。`enum` に来たらスキップしつつも、検出できたことをログに出す、という形です。たとえば `print(node.name.text)` のようにすれば、`enum` が検出されたことが分かります。

次に、`visit(EnumCaseDeclSyntax)` を実装します。ここでケースを検出したら、プロパティとして構築していく、という方針です。たとえば `PropertyInfo` のような構造体があり、`name: String`、`nameType: String` といったフィールドを持っているとします。`EnumCaseDeclSyntax` のノードから必要な情報を取り出して `PropertyInfo` を作る、という流れです。扱うのはこの `EnumCaseDeclSyntax` だけで十分です。

命名については少し悩みました。最初は `EnumCaseVisitor` を考えましたが、用途が「値プロパティに落とし込む」ことなので、`ValuePropertyVisitor` のほうが文脈に合っていそうです。一方で、`ContainingEnumVisitor` との対比を意識するなら、`HasEnumCaseVisitor`（スイッチに寄せた命名）といった案も考えました。ただ、今回はシンプルにケースを収集してプロパティへ変換するクラス、という意味で `ValuePropertyVisitor` で進めます。

まとめると、
- `ValuePropertyVisitor: SyntaxVisitor` を作る
- `visit(EnumDeclSyntax)` は対象の `enum` だけを処理する想定で `skipChildren` を返す
- 動作確認用に `print(node.name.text)` などで検出確認
- `visit(EnumCaseDeclSyntax)` でケースを検出し、`PropertyInfo`（`name: String`、`nameType: String` など）を生成して保存
- これにより `userInfo` ルートにある `landmarkID` のようなケースも反映されるようにする

という方針で修正していきます。これで、`aps.alert.title`、`aps.alert.message`、`aps.test.test` で終わらず、`landmarkID` もしっかり出力に乗るはずです。 まず、`enum case` で来る `Syntax` の中身をコピーして、`visit` の中に入れました。Visitor パターンの良いところは、`enum case` の `Syntax` にダイレクトにフォーカスできるところですよね。ノードのエレメントに対してループを回していけば、自動的にケースを拾っていけます。

この辺の処理は問題なくて、`name` と `type` が決まったらそれを `append` します。`partialResult` に `append` して、最後にプロパティとノードメンバーを作る、という流れです。ここですね。本来は `partialResult` に `add` するのではなく、`Expansion` 自体に `name` と（`name: type` のような）構造を持たせます。これが `name` ですよね。プロパティ名が `enum` 名になってはいけないので、`enum` 名はルート側で扱う必要があります。なるほど。一番上の `enum` が取れるかどうかで決まってきますね。

いったん `enumName` は空、つまり `empty` にしておきます。そして `enumName` の下でプロパティの `type` と `name` を決めていく形にします。この辺は Visitor パターンのおかげでシンプルになりそうです。これでまた一歩進みました。エレメントに対して走査していくだけで、`enum case` を扱う Visitor ができました。OK ですね。

次にやることとしては、親側の Visitor（たとえば `ContainingEnumVisitor` のようなもの）の中で、この Visitor を動かすわけですよね。`parentEnumName` を用意して、`visit` で `enum` で来る `Syntax` に対してプロパティを手作業で作る代わりに、Visitor を使っていきます。つまり、`enumName` を作ってからプロパティを作るのではなく、プロパティ系の処理は削除して、代わりに Visitor に任せます。

具体的には、`visitor = （enum case を集めるための）Visitor(viewMode: self.viewMode)` のように、`viewMode` は今回は引き継いで渡してしまいましょう。Visitor を作ったら、`walk` は `self` ではなく `node` に対して呼びます。このノード自体がマッチされるかどうかが注目点ですね。プロパティの生成は不要で、`walk` した後に、その Visitor が持っている `Expansion` を自分の `Expansion` にマージします。これで、`enum` の Visitor がとりあえず動きます。

あとは、親のほうの Visitorは動いてほしくない…とも思いましたが、そこはあまり関係なかったかもしれません。Visitor で `MemberBlock` を見て、`MemberBlock` が上がってくる。ここが、さっきの Visitor の処理箇所ですね。`rootName` の扱いはどこで落としてくるか少し迷いましたが、`enum` を見つけたら、さらに Visitor で再帰的に `visit` していけば良いはずです。つまり、新たに何かを「開く」必要はなかったということですね。

`enum case` を見つけたときにはそのケースを処理し、`enum` を見つけたら再びウォーカーを立ち上げる、これで十分です。そうすると、`ContainingEnum` 側の処理はそのままで、`enum case` を扱う専用の Visitor にあったオーバーライドは削除して、今まで使っていたほうの Visitor に統合してしまえば良いですね。これで `enum case` のコンテキスト処理も問題ありません。

結果として、`enum case` 専用の Visitor は不要になります。`walk`（あるいは `didVisit` 相当）で `enum` の宣言 `Syntax` が出てきたときに、`parentEnumName` を取り、`Expansion` を更新したうえで、専用の EnumCase Visitor を使うのではなく、再び自分自身を Visitor として使う形にします。これで流れがきれいにまとまりました。 コンテイニング・イナム・ビジターで visit のモードを検証して、それを差し合わせます。ここでは `visitChildren` ではなく、`skipChildren` を返すようにすると、いい感じに再帰的に、`enum` を見つけるたびに何か処理をしてくれるようになります。こんな感じですね。

このときに `parentEnumName` を取っていますが、これは取らなくてもよくなりそうです。なので、名前を少し整理します。`EnumVisitor`、`EnumMemberVisitor`、あるいは `EnumMemberBlockVisitor` といった感じでしょうか。`EnumMemberBlockVisitor` に名前を変えて、呼び出すときに「メンバーのブロック」をビジターに渡す、という形にするとイメージしやすくなりました。

この `EnumMemberBlockVisitor` の中で、名前をいろいろ受け渡します。例えば `let enumName: String` を用意して、イニシャライザで初期化します。`viewMode` も受け取って、`super.init(viewMode: viewMode)` を呼びます。あとは `self.enumName = enumName` のようにしておけば、`enumName` が手に入ります。

手に入ったということは、これまでの `parentEnumName` ではなく、`ownerEnumName` を使えば良さそうです。もしそれが空文字（empty）だったら、`nodeName.lowercased()` を使う、という条件にしておきます。長いので内部では `name` にしておけば `self` を書かずに済みます。以降は `ownerEnumName` を使って、たとえば生成用の関数に渡したり、別のところで使ったりします。`BlockVisitor` に渡す「親の `enum` 名」なので、この扱いで良いでしょう。空文字だった場合には「`enum` の名前はこれ」、そうでなければ「こちら」という分岐で問題ありません。

次に、`visit(_ node: EnumCaseDeclSyntax)` の戻り値ですが、ケースの中には子ノードが特にないので、`return .skipChildren` で良さそうです。

ここまででビルドして、マクロ展開も試します。どのメンバーも `LandmarkID` を持っていない、というエラーが出ていますが、それは今は重要ではないので、`LandmarkClient` で進めます。ビルドすると、ビジター拡張まわりの構文エラーのようなものが出ています。`enum` のメンバーのビジター拡張はこれで良いはずですが、戻り値の扱いを見直して `skipChildren` を返すようにします。

プラグインが失敗したので、出力が良くなかったのかもしれません。`enumName` の扱いを見直し、`visit(EnumCaseDeclSyntax)` でのローカルな `enumName` を消して、`ownerEnumName` を渡すように修正します。さらに、ビジターを回すところで `viewMode` だけではなく `ownerEnumName` も渡す必要があります。最初に生成するときは空文字で渡しておけば良いでしょう。これで再度ビルドします。

最後にもう一箇所だけエラーが残っていますね。`viewMode` だけではなく `ownerEnumName` も必要なので、ここでも空文字を渡しておきます。これで動くはずですが、まだどこかに問題がありそうです。 では、ここの`append`を一回消してみます。そうすると、ビルドは……これもビルド失敗ですね。もう一歩悪くすると、これを消したらしょうがないよね、という感じです。ビルドができたとか、ここが……えーと、これも失敗ですね。

ここでは一旦キャンセル、というかコメントアウトをやめて、これでビルドすると失敗します。受信が失敗しているので、マクロ展開ができないですよね。ここを何とかしないといけません。何とかするにあたって、どうしますかね。

ノードまわりを見ると、enum ブロックを訪問する`visit`のノードです。ブロックがまずそうですね。enum のメンバー・ブロックを渡したい。これでビルドをかけてあげて……ビルドは通りましたね。ビルドが通ったときに、マクロ展開はどうなっているか。こうすると、`aps.alert.title`が出ましたね。`asString`が出るか、`alert`のメッセージが出ていて、`aps.test`も出ていて、`test`も出ていて、`landmark_id`も出た。これで完成ですね。こんな感じで出来上がりました。

というところで、リファクタリングをやっていきますが、まずはコンパイルを通るようにしてしまいましょう。これを使うのは watchOS だけなので、watchOS のために頑張りすぎましたね。まあ、しょうがないというわけでもないですが、これをやっていきます。

そこで、「`landmark_id`がないよ」と言われています。`landmark_id`がないだけ、`userInfo`、`userInfo.landmark_id`……ビルドをもう一回かけてみます。`NotificationContent`ですよね。`NotificationContent`の、これのマクロ部分です。マクロをちょっと展開しますが、マクロが認識されていません。`import`で`landmark_id`は入っていますよね。`userInfo`アクセサはどうしたのか。これはマクロ、`public macro`ですよね。今は認識しました。それで`ExpandMacro`すると、展開されない。もう一回ビルド。メンバーを持っていない。展開されていません。

展開されていないときにあり得るのは、ここの Landmarks のプロジェクトで`LandmarksMacro`を入れていますよね。入れています。大丈夫ですね。そうすると、ビルドがまた別の段階で落ちているのですが、もう一回ビルドをかけてみると、OS でこれが見つからないと言っています。これは watchOS だけですね。`content.landmark_id`が見つからないと言っている。マクロだけのターゲットで見たときには、`landmark_id`はマクロ展開してもここに出てこない。

もう一回、クライアントに入れてみますかね。ビルドをかけて、これをマクロ展開してみると、ここで出てこなくなった。出てこなくなったとなると……出てこない。本当にないのかな。これがメインでしょ。メインで、`NotificationContent`からこれで、`let action`でいいか。インスタンスに対して`userInfo`しか出てこない。`userInfo`じゃなくて`landmark_id`を出したいのですが、ビルドをこれでかけると見つからない。`landmark_id`が見つからないということになったらしい。

そうすると、一回クリーンしてもしょうがないですよね。ビルドをかけても、ビルドが見つからないと言っています。展開は`ExpandMacro`……展開されなくなりましたね。どうしたのでしょう。展開されなくなった。`userInfo`のアクセサ側で特に問題はないという状況です。

それで、展開できなくなった。展開できないときは`ImportMacro`の展開と`Expansion`ですね。`Expansion`でこのクラスは`public`で。それで、宣言が`userInfo`だったら`continue`。これはいらなさそうなガードに見えますが、`userInfo`だったら……このガードはいらないですね。ビルドをかけて、それでも出てこなくて、`Expand`も効かない。`Expand`が効かない中で、`Visitor.walk`で`Expansion`を`return`する。`Visitor.walk`の中で、`parent`はいいとして、`parent`も試してみたほうがいいかもしれません。

今までは`parent`をたどって、`name`のテキストを付き合わせるという手法を取っていました。つまり、新しく`Visitor`を呼び出すときです。`Visitor`の enum を処理するコードを呼び出すときに、`owner.enum`か`enum`か、そのあたりを取り違えていますね。`owner.enum`に付き合わせます。 Visitorの初期化のところで、`Owner.enumName`は自分自身の`Owner.enumName`に`enumName`を足したもの、というふうにしたときに、APSアラートが見つからないのです。ここは何か名前が変わってしまった感じでしょうか。`enumName`が間違っていたのかな。`Owner.enumName`、`enumName`ですね。APSアラート。だから、`Owner.enumName`を作るところ、何かその辺を間違っているのかもしれません。

`static function`がありますよね。`MakeParentEnumName`がリターン値は空っぽで、Enum がなくて、取り出していって最初だけ小文字にする、というパターンがあります。これはこれで一旦コメントアウトします。そうしたときに、ビルドではこれも使っていなかったか。では、空っぽだったらこれ、そうでなければ `Owner.enumName` プラス `nodeName`、という形にします。これが `enumName` が空っぽだった。だから、`enumName` を足す必要はやっぱりなかったですね。`enumName` はそのまま使わせてもらう、と。

ビルドをかけて、これでビルドは失敗。ビルド失敗はいいとして、この辺がなくなって、これはまだダメという状況になっています。このときに表示がされないのが辛いですね。展開したいんですけどね。前にもありましたね、こういったこと。何が問題なのか。サブスクリプションしかとりあえずないわけですけど、そうすると、あり得るところは `MemberBlockVisitor`。これで `SourceUpdater`。これでこうやって walk して expand して。`Expansion`、これが何かまた気になる感じですか。

`print`で、例えばビジターの`Expansion`の中に入るかどうかを見ます。これを`map`して、`description`を取って、これに`"\n\n"`をプラスして。これで実行すればログが出ますよね。実行するか、ビルドすれば出るのか。ビルドして、やすやすとは出ないのか。やすやすと出ないとなると、ビルドのログですかね。ビルドのログで、クライアントだからここですか。これの中でエラーになったところは、どこを見ればいいんでしょうね。どこを見ればいいんでしょうね。`Compile Main.swift`。この辺はもうダメか。どこで展開するんでしょうね。

クライアント側で、この辺は `Extract Log`。これは関係ないと思うんですけど、よく分からないから見てみると、これは `LandmarksMacro`。これは関係ないか。他になさそうですね。それで、`Planning`。`Planning`は良くて、一応見ておきました。まあ、いいですね。だから、ビルドのところが問題なのかなと思うんですけど、この辺では特にログは出てきていないのか。なるほど。

Swiftマクロのログってどこで見るんでしょうね。Swiftマクロのデバッグ。別のプロセスで動いているのかな。Swiftマクロの`print`出力先みたいなものは、こういった感じで出てくるのかな。`STDOUT`、ログ、マクロ、`print`関数の出力先。ちょっとあまり良い情報が得られていない気がしますね。では、これとして問題箇所を手当たり次第探る。あまり賢くない気がするんですけど。あとは、コンソールアプリのログを見るとかになるんですかね。ログを手元に出して、後で見つかったら表示しようかなと思いますが。

ビルドは何だろうな。Xcodeかな。それでやってみるとして、ビルドをかけたときにビルドエラーになるとして。ビルドエラーは良いとして、どうなのかな。特に分からないですね。どこかに出ているのかな、Xcode。そこもよく分かると助かるんですけどね。Xcodeにはないかな。ないと言い切れるほど分からないですけど。ログの書き方を出せばいいのか。

なので、さっきのログのメッセージを出すところ、`print`ですね。ここの中で出すだけ、`print`。これを出すにあたって、一旦ここで絵文字を出しておけば、コンソールにこれ出てくるでしょう。出るなら、ですけどね。これでコンソール検索の書き方も出てきていないな。システムログかな。出てきていないですね。手当たり次第やってみますか。これがダメだったということで。

例えば、ここの戻り値。これを空で返す、というふうにしてみると、ビルドはこれも通らないのかなと思ったけど、これは実装がないというエラーですね。このときに `expandMacro`。エクスパンドしないですね。これを例えば「ビジターエクスパンション」というテキストを返すふうにして、これでエクスパンドすると、これも出ないか。根本的に間違っているんですかね。これを直すのは面倒ですね。見ていくしかないので。 とりあえず、`Expansion` でメンバーブロックの中を回していきます。`Visitor` でビューモード…いえ、これはビューモードではなく `Visitor` ですね。それで返しています。

今回、メンバーブロック用の `Visitor` で新たにやったこととしては、イニシャライザが新しくなった点と、`visit` で `Visitor` を動かすようにした点です。これを少しリアクトしてみましょう。ビルドを走らせると、いろいろビルドが出てきます。雰囲気としては良さそうですが、構文エラーが出ていますね。`expand` が原因でしょうか。`Visitor` の `Expansion` まわりで落ちています。あれ、ここは直したはずでしたが、`Visitor` の `Expansion` を返してしまう箇所は修正したつもりでした。`Visitor` の `Expansion` を文字列で返す…これは古い情報でした。もう一度コンパイルして、もう一度辿ります。一旦クリーンしてビルドをかけると、エラーは `Expansion`。これは `DeclSyntax` の配列ですね。`Expansion` の戻り値は `Expansion` の配列。コンパイル時に出るようなエラーではない気もしますが、挙動が変です。

`expansions.append` でしょ。`append` して、それで `Visitor` の `Expansion`…あ、そうか。`Visitor` の `Expansion` は配列でしたね。これはそのまま返せば良さそうです。これでビルドをかけると、こういうエラーになって、この展開は「`Expand Macro`」をしても展開されないですね。展開されず、インスタンス自体にあるもの、つまり `userInfo` だけになっているのは少し困ります。`landmarkID` が欲しい。お、`landmarkID` がなかった。いや、これは関係ないのかな。`landmarkID` だとレはしないですね。あとは、`landmarkID`…おもちゃ関係ないですね。

「あれが見つからない」と言われて `landmarkID` を思い出しましたが、同じかな。やっぱり `landmarkID`。ビルドをかけると、あまり見つからないか。あ、ここまでになってしまっています。ベースが `landmarkID`。これはキーの名前としては良いとして、仕方ないのか。`REST API` デザインガイドラインと名前の付け方が違ってしまうのが気になりますが、ここはまずは多めに見るとして、これはダメ。これがダメで展開ができていない。

ただ、根本的な構文ミスだったのが、何も指摘されずにパスしていたのは非常に気になります。とりあえずはそれとして、やっぱり `WIP` と `Expansion`。追加していって、これが `EnumDeclSyntax`、`EnumCaseDeclSyntax` ですね。ここを一回ざっと読んでみます。どこまでか…ここからここまでですかね。ここをざっと読んで、ビルドをかけてみます。そうしたときに展開がどうなるか。「`Expand Macro`」。やはり展開されないですね。

それで、`landmarkID` ではなくて、`aps` の他の辺があるかどうか。これもないか。あ、違いますね。`aps` でやったときに、これはプライベートの保護レベルに引っかかります。そうか、`private` ですね。`private` で定義している。そこは間違いない。展開ができない。`private` なのは確かなので、`private` をやめればビルド自体は壊れていない、という話になり、単に展開ができないだけ、という状況です。そこが困るのですが、つまりこの `Expansion` 自体はちゃんとできている、ということですね。

そうすると次に言えることは、`aps` の次は `alert`。これはまだないですよね。`alert` でビルドをかけると「ない」と言われます。その中で、さらに入れることで効果を設定してあげて、ビルドをかける。そうすると、`private` の保護レベルに引っかかる。ここで `title` は見つからない、という状況になります。こういった状況になっている段階なので、ここまではちゃんと動いている感じがあります。

続いて、これがセーブされるのか…そんなことはないか。されないですね。うーん。では、もう一方の `override`。これでビルドをかけます。このときもビルド成功で、`alert` の `title` はちゃんとできた。`alert` のメッセージもできた、ということですね。あとは、`aps` ではなくテストです。 これはないのか…テスト、ASTとか、ASTテスト。これは`private`指定でしょうか。これでテストは大丈夫そうです。では、あと1つ、`LandmarkID`ですね。

これをビルドすると「これがない」と言われるので、ツリー（AST）が悪いということですね。なるほど。ツリーが原因なら、`append`してビジターで`visit`する流れを見直します。`UserInfo`を渡してあげて…もしかすると親の`UserInfo`でしょうか。基本的には`UserInfo`という名前は無視したいのですよね。そのために、ノードからノード名やEnum名を取っています。ノードから名前を取ってキーにしているので、Enumを渡して`visit`…と考えましたが、これはダメですね。プロパティ経由でEnumの`MemberBlock`を渡すように作ればよさそうです。

やることとしては、Enumの`MemberBlock`をたどり、見つかったらプロパティをいろいろ処理する、という形になります。この辺が意外と難しいです。とにかく、親側としてはブロックのビジターです。`ownerEnumName`はそれで良いとして、ここで`UserInfo`が邪魔になっています。ブロックになっていて、その中で、例えば`UserInfo`の`LandmarkID`がどうなるか…これもありませんね。

`MemberBlock`ビジターで、最初の`visit`が`UserInfo`アクセサだとすると、ここで`EnumDeclSyntax`だったら、その`MemberBlock`ですよね。この`MemberBlock`はここにコピーしてくれば良いかな。これを持ってきたときに、一旦戻りますか。if分岐としてはこんな感じで、最初に`UserInfo`があって、その`MemberBlock`を渡しています。`MemberBlock`の中には、`EnumDecl`も存在すれば、`EnumCaseDecl`も存在しますよね。ちゃんと存在します。だから、この中で、ビジターに対して`MemberBlock`を渡しているわけです。

このフィルターはいらないかもしれません。これで、この`return`が良いなと。メンバーが空っぽだったら…という感じでやってみてもダメか。では、これはこれで良いとします。

では、これが良いとして、こちらのビジター。これを見たときに、こちらのビジターも上がるはずですよね。そのときに`element`を取って、`element.name.text`が`LandmarkID`ですね。タイプとして、パターンが`IdentifierPattern`である中で、それを使って`ownerEnumName.raw`を参照します。

あ、分かりました。ここが大文字でした。ここが`LandmarkID`の大文字。そうですね。つまり、字を間違えていました。原因はこれだけでした。 オーナーEnumの名前が空かどうかで挙動が決まってきます。ここでいうプロパティ名は `propertyName`、オーナーEnum名は `ownerEnumName` です。`ownerEnumName` が空だったときからの処理でしたね。思い出しました。忘れていましたが、`ownerEnumName` は空文字ではなくオプショナル、つまり `String?` で、`nil` の可能性がある想定でした。

そのため、`ownerEnumName` は `String?` にしておき、最初に `ownerEnum` を呼び出すときにルールを渡すようにすると、それっぽい設計になると思われます。デジタルではなく、×マークのような扱いですね。

ここで、`ownerEnumName` という名前は分かりにくいので、`ownerName` ではなく「ネームスペース」の方がよさそうです。これはターゲットのインスタンスで、こちらがネームスペース、こちらもネームスペース……という整理になります。`propertyName`、`ownerEnum`、そして `switch` での分岐ですね。`switch` で `targetDictionaryName` をここで使うということは、最初にやっておかないといけません。

`targetDictionaryName` があるときには、`propertyName` は `targetDictionaryName` に加えて、`targetDictionaryKey`、つまりエレメントの名前（`element.name`）を連結します。`dictionaryKey` は、たとえば「ABS」のように、大文字で始まらないといけない気がします。`propertyName` も先頭大文字で始まることが重要ですね。

`targetDictionaryName` はオプショナルにしなくてもよく、デフォルトは空文字にしておき、`isEmpty` で判定するのがよさそうです。`targetDictionaryName.isEmpty == false` のときに処理を分ける、あるいは逆の条件を付けたい場合はその逆にします。

`switch` で `targetDictionaryName` の `Optional` を分岐するか、`if let targetDictionaryName` とするかは好みですが、いずれにしても空だった場合のフォールバックを用意しておきます。ここでのパラメータ名は少し気になりますが、`dictionaryName` にしておくのが無難でしょう。少し微妙な感じはありますが、意味は通ります。 ターゲットの`DictionaryName`は`String`でほしいです。それ以外のときには、`targetDictionaryName`をそのまま使えば良いでしょう。まずはターゲットについての整理はこれで大丈夫です。`targetDictionaryName`が空の場合には、`elementName.text`を`lowerCamelCase`に変換して`DictionaryName`として使います。`DictionaryName`がすでにある場合は、そのままで問題ありません。`enum`のケース名はもともと`lowerCamelCase`なので、その点も特に問題ありません。

次に、`propertyName`です。ここでは`targetDictionaryName`が空であることが分かっている前提で進めます。では、`let propertyName`で決めていきましょう。`propertyName`は`dictionaryType`と`elementName`を使い、`namespace`を渡します。ルートのときは`namespace`は空にします。それから、`visit`で`enumName`と`ownerEnumName`を扱います。これは`namespace`の扱いに関する話でしたね。

判定としては、`namespace`が空かどうかで分岐します。空でなければ、`namespace`の中では型名はそのまま使います。逆に`namespace`がなければ、型名は`lowerCamelCase`にします。`enumName`はキャメルケースのままで良いです。`dictionaryType`は`enumName`を`lowerCamelCase`にしない方針で問題ありません。ここら辺は若干非効率に見えるかもしれませんが、`lowerCamelCase`への変換を挟んでも実害はありません。

`propertyName`は`namespace`に`enumName`を足したものになります。一方で、`dictionaryName`は`namespace`を使えば良く、特別な処理は不要です。`dictionaryType`も`enumName`（`lowerCamelCase`にはしない）を使えば良く、ここも確定的な追加処理は必要ありません。つまり、全体として特別な確定処理は不要で、素直に組み立てれば大丈夫ということです。

この方針にまとめると、通常は次のように一式を置き換えられます。条件が`true`のときには、`enum`の「`lowerCamelCase`にしない名前」を使って`propertyName`を作り、`false`のときには`namespace`に`enumName`を足します。加えて、`namespace`に対しては必要ならデフォルト値を設定しておきます。名前の組み立ては専用の関数にしてしまえば、ここで示したスタイルで名前を付けても問題ありません。

このユーティリティを使えば、処理をきれいに分けられます。名前の構築は`append`のような連結で十分です。たとえば、「`property`用の`dictionaryKey`は`namespace`と`enumName`を連結して作る」「`dictionaryName`は`namespace`そのものを使う」といった形にしておけば、独立した`dictionaryName`を別途用意する必要はなくなります。`append`も関数化しておけば読みやすくなりますし、`dictionaryKey`は「`enumName`の`lowerCase`版」という規則にしておけば、引数で毎回渡さなくても自明に導けるようになります。 プロパティ名については、2つの方法があります。三項演算子を使う方法がありますが、空っぽだったらどうするかという問題があります。`isEmpty` かどうかで三項演算子を使う方法はありますが、どうするのが良いでしょうか。

例えば、外側で丸括弧を付けてグルーピングする形にして、こうやって分けていくと、メリハリがあっていい感じになってきます。この中で、`namespace` がいつ `isEmpty` かどうかを判定し、空なら `enumName` を `lowerCamelCase` にして、そうでなければ……という書き方だと、かえって複雑になってしまいます。`namespace + enumName` の形で組み立てるようにしておけば、この部分の条件は不要になり、変化させるのは `enumName` 側だけで済むので、これで良いかもしれません。少しややこしいですが、これで良しとします。

同様に、展開（expansion）についてです。スルーする箇所がありますよね。ここも展開して `append` を使い、この `name` と（大きいところは）`namespace` を扱います。これで `namespace` は `namespace` として扱えます。

`dictionaryName` は `targetDictionaryName` です。これも `namespace.isEmpty` かどうかで分け、空なら `userInfo`、そうでなければ `namespace` にします。まあまあ悪くないですね。これで `dictionaryName` はOKでしょう。こうやって処理を分離しておくと、間違いに気付きやすいです。

あとは、プロパティ名も `isEmpty` かどうかですね。条件分けがいろいろと増えてしまうので、ここは思い切って分岐をはっきり分けた方がいいです。つまり、1) `namespace.isEmpty == true`、2) `namespace.isEmpty == false` のそれぞれに対して `append` していけば、もう少し効率的に動いていきます。こうすることで、`namespace` が空でない場面では別の `namespace` を使い、空の場面では `userInfo` を使う、という整理になります。良いですね、`namespace` はこれで問題なさそうです。

これは、`enum` のメンバーを visit するための `enum` ケースですよね。なので、`enumCaseName` が重要になってくると思います。 とりあえず上に置いておきますが、この `enum` ケースは小文字で始まりますよね。ということで、やるべきことは……`E` は `enum` ケース名で良いのか。どちらもそれで良さそうです。プロパティ名だけの話ですね。名前空間が空のときは `enum` ケースをそのまま使います。そうでないときはローワーキャメルケースで、ここに名前空間を付けてあげる感じにします。

たぶんここで、名前のテキストは `E` で良いのかな。`E` はどちらも一緒でしたね。キーは良くて、プロパティ名と `targetDictionaryName` が……あ、ここがデータバグでしたね。で、プロパティ名と `targetDictionaryName` はそれでよくて、これが要らなくなって、ここも要らなくなって……これで `type`。`type` が、`rawType` を忘れていました。`type` は、あと `append`。この `append` が間違っていましたね。`append(_: for e: namespace: nameForE:)` みたいな形にして、ここはその後ろですかね。`hasType`、そして `any StringProtocol`。`any StringProtocol` か……そうすると省略が難しい気がします。まあいいか、できるかな。いや、省略させなくていいですね、ここは。

これで `String` に、これを `type`。あー、`type` ですけど `rawType`。そしてここも `rawType` ですね。そうすると、`append` を呼んでいるところがエラーになるので、`append` を呼んでいるところ……あ、エラー出てきていない。もういいか。これで `append`。ここは、あ、ここが良いな。呼んでいるところがこっちですね。だから、もうこっちは要らない。ここで `for e`、`hasType` として `type` ですね。`type` とね、`type`、これです。で、こっちも `for e`、`hasType` ですね。もう1個呼び出ししていたこっち。いままで来る方は、`type` が `for e` の後に `has`……これですね。というふうにして、分かりやすくなった感じがします。

これでビルドをかけていいのかな。まあ、かけて試せばいいんですけど。あと詰まったところを見ておきますね。これで `append` 出して、`visit` して……良さそうです。これで、うまくいくかどうか分からないですが、ビルドをかけて……`as` が抜けている。ここか。うーんと、`as` が抜けている。`as` がいろいろエラーというやつ――それだけですかね。`enumName`、これが該当のところですかね。`enumName`。えっと `enumName` は……あれ、これですよね。`enumName` が、なんだ？どこを見ているか分からないですね、これ。色が付かない。まあいいとして。

こうすると、`namespace` を渡して、ここでも `namespace`――そのまま `namespace` を渡せますね。で、それであとはビルドをかけると……あと、これで `as`。で、`namespace`。`as` の展開……あ、こうか。こういうのがなんとかいうと半分になってしまう。これですかね。で、これでビルドをかけて……で、fail。`argument`。`as` に対して、`asType`、`missing arguments for … rawName`。`rawName` がいらない。あ、そうなのか。`raw` がいらない。`raw` がいらないですね。もう一度。で、ここもいらないですよね。`raw` をこのくらいで……ここもいらない。`raw` ここの……とことんこういうこと。

`namespace` をなぞってしまえば……いや、いらない。したいところで、必須アノテーションのパラメータとデフォルト、`as namespace`……えーと、`append`。あ、これね。`append`。`as`。ここで取り方が誤ってしまっているから、`as` は構文的に違いますね。これでビルドをかけないと。`as` はキャストのシンタックス。そうね、と思ったけど、デフォルトの `append` メソッドは `StringProtocol` にはありません。いかんやつ。えーと……なんだろ。これか。`append` でしょ。`append` で……あ、これしかなくなっているね、確かに。`MutableCollection`……あー、これも間違い。だから、どこまで戻せばいい。これは `as` がいらないですね。

それで、`MutableCollection` ではなく、`RangeReplaceableCollection` ですね。`RangeReplaceableCollection` に対して `append`。ビルドをかけて……ダイアグノスティクス……そう。あれ、`StringProtocol`、`appendInterpolation`。これを `raw` にすると、これもダメかな。あ、こっちは大丈夫か。では、ここと、全部ね、`raw` で。どうですかね。ビルドをかける。ビルドが通って、inaccessible due to private protection。あ、そうか、`private` ね。でもかなりいい選択ですね、これで。

では、選択できるかな。要は `private` になっているということですね。展開……展開はダメか。`private` かどうか、これ重要でしたね。これをするためには、まず `type`、えーと、プロテクションレベルを指定するかどうかですね。どうしようかな。そうですね、どうしますかね。では、プロテクションレベルを通していくか。文字列で渡すか、それとも何か別のもので指定するか。別のもので指定するとなると、それが `Dictionary` なのか、それとも実際の値なのか、みたいな感じになると思うんですけど、`private` プロテクション……ここは文字列で渡した方がいい気がします。そんなにルールを決めてプロテクションレベルを自動で切り替えるみたいなことをするよりは、汎用的ですよね。

プロテクションとして `any StringProtocol` を取るようにして、`private` のところを、プロテクションレベルを `any StringProtocol` のオプショナルにしますかね。それで、`let protection = protection.map { "\($0) " } ?? ""` みたいにして、指定があった場合には `$0` の後ろにスペース、なければ空文字、というふうにして、ここでプロテクションレベルを差し込みます。これでいいですね。あ、`raw` がいるので……ここですね。で、ビルドをかけて……あ、通らなかった。ビルド failed ですね。通らなかったけれど、これは……あれ、これは、通らなかったのはプロテクションレベルを渡していないですね。ビルドエラーがそもそもこの辺の問題です。

`namespace`、あとは `protection`。`protection` として、ここは `protection: "private"` ですね。いいですね。これで良くて、あともう1か所、2か所かな。`protection`。`protection` はどっちも同じにしたいので、`protection = nil`、`String?` ですね。`String?` というふうにして、その上で……あ、そっか。`protection` を `nil`。`extension`……まあ、そうね。こうしておきましょう。

それで、`protection`……`protection` は `String`。まあいいのか。`protection` をこうやって変数に入れておくのは、単純に `extension` する時に `public extension` とか、そういったことを将来やることがあったとして、その時に対応しやすいように――まあそのために用意しますが、今回はそこまでは提供しないことにします。

`protection` をこうやってやっていくものは、やっぱりちょっとマクロはリファクタで使うには大げさですね。より広いところを考慮して作らないといけなくなってしまう。そうすると、今回でいうと、`public extension` でユーザー向けのアクセサを指定したとしても、`internal` なメソッドを抱えてしまうので、これだと活用しようがあまりないですよね。そういったところも加味すると、`extension` についているアクセスレベルを継承して、それに応じた実装を追加してあげる、といったことをやっていかないといけなくなってきます。こうなると、もう少しライブラリ提供側のレベル感になってくるので、そこまではリファクタリングで求められていないですよね、普通に考えて。そういうふうに思うと、やりすぎだなということが今回やっていて分かったので、あまり深入りしない方がいいでしょう、みたいな感じになってきそうです。で、… とりあえずこれで良くて、できたので、これを展開したいのですが、展開して正しいかどうかを確認したいところです。ですが、今は動いてくれません。まあ、しょうがないですね。これはこれとして、watchOS に切り替えてビルドを変えたときにどうなるか、ということになります。

これについては、今はビルドエラーになると思います。ビルドエラーになった中で、たぶんプロパティをちゃんと使っていないのかなと思ったのですが、メッセージとしては「`Identifiable` に準拠していない」と言われます。これはまた別の話というか、単純に「`Identifiable` いらないね」とリファクタリングのときに言っていた気もします。Apple Watch で使っていたのがカテゴリーですね。Apple Watch 以外で `Identifiable` を使っていないとはいえ、どの言語でも用意しておいて悪くはないです。

カテゴリーを `Identifiable` に準拠させます。`ID` として `Self` を使って、`self` を返す、というふうにしておけば、enum として ID を制御できるということは、1 バイトで制御できますね。これでビルドをかけると、別のところでエラーが出ます。`Season` が `Identifiable` に準拠していない、と。これも同じですね。`extension` で `Profile.Season` を `Identifiable` にして、`ID` として `Self`、`self` を返すようにします。

これでビルドをかけると、いよいよ「プロパティがない」というエラーになる…かと思いきや、ならないですね。パスしちゃいました。本当に動くのかな。`userInfo` アクセサを使ったわけですよね。`userInfo` アクセサを OS のコードの `NotificationContent` で使いました。ここで使っています。これで展開できると嬉しいのですが、展開はできませんね。

これがプロパティにアクセスするわけで、`landmarkID` とかはダイレクトに呼べばいいので、このタイトルですよね。こういったところをちゃんと呼んだのでしたっけ。タイトルは `NotificationContent` を探して…あれ、コピーできていない？ `NotificationContent` を探して、使っている場所がこの辺ですか。プラットフォーム側だった。これで OS のコンテンツを作って、そのコンテンツはフェイクのタイトルとメッセージのコンテンツに書き換えていますね。大丈夫です。

それで、ランドマークのイメージ、`landmarkID` はどこでしたっけ。ここかな…。ここだ。`landmarkID`。この定義をたどると、ここへ来て `case` に来るんだ。面白いですね。`case` に来るのですが、展開が出ない。残念。

まあまあでも、動いてしまいましたね。いいですね。じゃあ、これでできてしまったという感じで、今日は一回ここまでにしますかね。だいぶやったので、いろいろ雑に作ったところがあるはずです。これのリファクタリングをやっていくことにしましょう。

では、これで終わりにしますね。お疲れ様でした。
