Transcription & Summarize : とりあえず読書会 SwiftUI Tutorials #22

はい、では、とりあえず読書会を始めていきましょう。今日は引き続き見ていくのですが、前回、なぜかちょっとリアルタイム進行とはいかなくなっていて、いろいろリファクタリングしながら自分なりに一応進めていっている中で、うまくいかない、しかもバインディングがうまく反映されない、みたいな状況になっていました。その原因は特定していかないといけないところではあるのですが、途中経過で、まだ反映が追いつかない状況なのか、それとも自分のコードのミスでダメなのかが半端な段階だと、やっぱり自分のほうが悪いんじゃないかなとは思います。ただ、どこが悪いのかは確かにわからないところでもあるので、まずは一通り落ち着くところまで、もういくつかステップを進めてから、原因がどこにあるのかをいろいろ見ていこうかなと、そんな感じで進めていこうと思います。

だから、どっちかというと、今やっている本を読みながら、いきなりリファクタリングしながら進めていくのは遠回りといえば遠回りですよね。あまり良くないやり方で、問題が起こったときにどこに原因があるのかわからない、というのはよくありがちなわけです。こういった練習のときじゃなくても、ソフトウェア開発で直さなきゃいけない問題があったときに、他の気になる箇所も一緒に直してしまうと、どっちが原因でその後うまくいかなかったのかを切り分けるのがすごく難しくなるので、余計なことはしない、というのが本来であれば正しいです。ただ、こうやって壁にぶつかりながらいろいろやっているのも、学習としては悪くないんじゃないかな、遠回りだとしても、という気持ちで自分はやっていきます。これを見て賢いと思うか否か……賢くはないかな。でも、それを良しとするかどうかは各自考えてもらえれば十分かなという気がします。

さて、見ていきましょう。とにかくステップ3まで行って、ページのドットボタンを配置はしたんですけれども、それを押してもページを移動してくれない、という状況になっています。まずはUIKitが、UIのステータスの連携、つまりステートの連携をやっているところで、その連携がうまくいっていないのかもしれないので、もう少しステップを進めていきましょう。次のステップは、テキストビューをカレントページのプロパティと一緒に追加する、ですね。これをまだやっていなかったのかもしれません。

自分のコードでは、まずやっているのがページビューコントローラへのバインディングですよね。次のステップとして、ページビューに `currentPage` を持たせる。その次、ステップ4は、テキストビューにカレントページのプロパティを追加して、この値がどうなるかを見ていく、ということらしいです。これは助かりますね。ページをスワイプしたときに、この値は変化しない、と書いてあります。ちょっと見てみましょう。

つまり、ページビューを置いた後に、`VStack` でページビューコントローラと一緒にページビューの `currentPage` を置いていますね。まずそこでやっていきましょう。ページビューの中に対して、ボタンを配置したコントローラが今あります。それで、ページを配置した後に、`VStack` ですね。ボタンはとりあえず置いておくとして（自作のやつです）、`VStack` の中にテキストを作ります。`Text` に `currentPage`、ページ、そして今のカレントページで、ページナンバーにしましたね。こうやって `VStack` の中で `currentPage` が表示されました。

この状況で見ていくと……もうちょっと広げたいかな？ まあいいか。はい、いいですね。これでも変わらないと書いてありましたよね。確かに、スワイプしても変わらない。ボタンを押しても変わらない。あれ？ 今、1個スクロールしましたね。ページが動いていきます。なんだろう。1個戻って押すと、あ、動いた。これを……あ、違う。あ、そういうことですね。とりあえず分かりました。今のところ、ページをスワイプしても `currentPage` が動かない、つまり連携がまだうまくいっていない、ということですね。

ところで、`appendInterpolation` が deprecated、という警告が出ています。`LocalizedStringInterpolation` はこの型の値の未ローカライズなデバッグ記述を生成してしまう。だから、`LocalizedStringKey` の String Interpolation を使うか、または `LocalizedStringResource` を使いなさい、あるいは `LocalizedStringResourceConvertible` に準拠させなさい、ということですね。そんなのがあるの、知らなかった。`LocalizedStringResource` を使う代わりに入れていたのかな？ ルートのナンバー以外だったのかな？ カレントナンバー？ `PageNumber`（自分で作ったやつ）に準拠させる、ということですかね。これの `debugDescription` がどこへ行っていますかね。これ（デバッグ出力）をなくしたところで、別に何もならないですよね。

とにかく、`appendInterpolation` が deprecated。`LocalizedStringInterpolation` は Unlocalized な debug description を生成している。`LocalizedStringKey` の String Interpolation をサポートするか、`LocalizedStringResource` を初期化するか、という話。`LocalizedStringResourceConvertible` ですかね。ちょっとやってみます。`import SwiftUI`。その中で、`PageNumber` の extension で `LocalizedStringResourceConvertible`。この型を見てみます。Foundation の中にありますね。iOS 16 とか、そのくらいからかな。

`LocalizedStringResource` は、`Codable` や `CustomLocalizedStringResourceConvertible`、`ExpressibleByStringInterpolation` などに準拠しているものを結構要求してきますね。キーとデフォルト値、テーブル、ロケール、バンドル。この辺が必要になってきて、バンドルは `Bundle.main` の URL とか、そのあたりを指定する感じです。イニシャライザがいろいろあって、その中で `StringLiteral` でのイニシャライザもありますね。これは `ExpressibleByStringLiteral` のことか。既定の実装はどこにあるんだろう。これを本当に実装するのかな。違和感というか、単に自分が知らないだけですけど。

`LocalizedStringResourceConvertible` は、`LocalizedStringResource`（これは構造体）を返すやつですね。なるほど。ローカライズは昔、確かに弱かったですよね。裏側で勝手にいろいろやらないといけなくて。それが、これによって統一的なインターフェースで情報を渡せるようになった、ということですかね。

`LocalizedStringResource` で、`String.Literal` からも返せるって言ってましたけど、今回はこれで良いのかな。イニシャライザの中で `StringLiteral` など、この辺はお決まりですね。あと、キーとデフォルト値。この辺です。イニシャライザはそれくらいか。キーとデフォルト値、この辺で良さそうです。キーとしては description ですかね。description を渡して、`StaticString` と言ってますね。キーだからリテラルじゃないとダメ、ということですね。なるほど。キーは確かにリテラルじゃないとダメですね。 なので、これでページナンバーをキーとしてこうしておけますかね。デフォルト値、`LocalizationValue`、`String.LocalizationValue`…知らない型がたくさん出てきますね。`String.LocalizationValue`ってなんでしょう。一方、この辺は値が`String`。でも、普通は`String`ですよね。

これでディスクリプションを渡してあげるという形を取れば、結構楽になったのかな。いや、そんなことないか。カレントページナンバー、これはどういうことだろう。この警告は今ので良かったんじゃないのかな。

これは`Text`側のストリングインターポレーションになるから、定義をたどると、ローカライズされた`LocalizedStringKey`ですよね。これでストリングインターポレーションの描画が可能になっていて、この中で`LocalizedStringKey`を使っていろいろやっていくのか。それで少し思い出した気がします。

カレントバリューですが、これが`rawValue`とかにもならないか。`rawValue`はないか。そうすると、`String`とかもないですよね。きっとないと思われます。そうすると、`Text(verbatim:)`って書いて、これで`String`を取ればOKですよね。

OKですが、これじゃなかったときに、例えば`Int`型で`let value = 10`とかやっておいて、こういったものをここに入れたとき、それは警告に乗らないのかな。そっちは乗らないんだ。そうなんだ。そのとき、これが何に呼ばれているのか知りたいけど、分からないですね。まあいいか。どうかな。この辺、気になります。

もう一回例えますけど、`Text`のイニシャライザーは`LocalizedStringKey`のインターポレーションですよね。 なので、これの文字列補間（String Interpolation）が関係してくるのは、これじゃないですね。文字列補間…あ、これか。こちらのほうですね。`LocalizedStringKey` の `StringInterpolation` の定義を見ると、`appendLiteral` で文字列を入れられて、`appendInterpolation` で補間文字列を入れられます。`Substring` も入れられます。あとは `Subject` があって、`Subject` が `Formatter` で表現できるときですね。`Subject` があって、それに対して `Formatter` を指定するというやり方と、補間のサブジェクトに対して `formatter` が `nil` のときで、サブジェクトが `NSObject` のとき。さらに、補間でインプットが `FormatInput` で、ジェネリックな `F: FormatStyle` を取るときと、`inputFormat` があるとき、そして値が `_FormatSpecifiable` のとき。これは先頭にアンダースコアが付いている内部用のものなので、あまり気にしなくていいかなと思います。それから、値が `T` で、スペシファイアを表す `String` を一緒に渡すやつ、いわゆるフォーマットスペシファイアですが、これもアンダースコア付きの内部用です。ほかにも、`appendInterpolation` で `Text` も入れられますし、`AttributedString` を入れることもできます。あとはこれは `AttributedSubstring` ですね。そして、補間で `T`（任意の型）をそのまま受けるもの、つまり `appendInterpolation<T>(_ value: T)` は deprecated（非推奨）です。

このあたりで引っかかっていたわけですね。任意のものをそのまま入れるわけにはいかないということになっていて、そのため、もう少し細かいプロトコルで説明されたもの、つまりフォーマットをちゃんと指定するか、あるいは基本的には `Substring` や `String` を `appendInterpolation` に渡す、といったやり方にする必要がある。なるほど、そういうことですね。つまり、ここでは `description` を渡せばよかったということになります。ただ、ちょっとでも味付けしたい気持ちもあります。そうすると、`parentPageNumber` を素直に渡したい気がしていて、これでも悪くないですね。ちゃんと対応させる必要が出てきます。

これで、SwiftUI は要るんだったか、要らなかったんだったか…分からないので、いったん外して試してみます。あ、要りますね。これはかまいません。今回は使わないとしても、Extension で `LocalizedStringKey` の中の `StringInterpolation` を触るから、やっぱり SwiftUI は要るのかな。`import SwiftUI` ですね。では開いて、その上で `LocalizedStringKey.StringInterpolation`。これに対して、イニシャライザではなく、`appendInterpolation` だったかな…`append` だったかな…やはり `appendInterpolation` ですね。`mutating func` の `appendInterpolation` に対して、ここに `pageNumber` を渡す、というふうにして、`pageNumber` を渡してあげると、ここでエラーが出なくなりますね。こうした上でページが表示されるようになって、でもまだこのページは送られないよ、ということを言っていましたね。

やっと来ました。これで再びチュートリアルに戻って、ここまでができました。観察としては、ページをスワイプしても値は変化しない、ということまで確認しました。ここまでですね。次に、`PageViewController` で、コーディネータを `UIPageViewControllerDelegate` に準拠させて、`pageViewController(_:didFinishAnimating:previousViewControllers:transitionCompleted:)` というメソッドを実装してあげます。`UIPageViewController` はこのメソッドを、ページスワイプのアニメーションが終わった時点で呼び出すので、`currentViewController` のインデックスを見つけて、`Binding` にアップデートできる、ということですね。`Binding` にアップデートが今できるのか、ちょっと分からないですが、やってみましょう。 とりあえず下のほうですね。これでコーディネータの中で、`UIPageViewControllerDelegate`を実装して、ここですね。これをコピーしておこうかな。コピーしてコードを読んでいく形にしましょう。なので、まずは PageViewController ですね。PageViewController の中のコーディネータ。コーディネータに対してデリゲートを載せていくけど、コーディネータ分離したっけ？ ここにいないように見える……あ、いたいた、いましたね。それで、ここにデリゲートを搭載していくと。あ、間違えた。`UIPageViewControllerDelegate` ね。これも搭載していき、メソッドとして、こうかな。これをコピーして、ここで合ってるよね。アクションとしても合ってますね。

そしたらこれで、`UIPageViewControllerDelegate` で、アニメーションがフィニッシュしたときのデリゲートメソッド（`pageViewController(_:didFinishAnimating:previousViewControllers:transitionCompleted:)`）を使って、`UIPageViewController` がわかってきて、それでトランジションがコンプリートしたかが Bool で返ってきて、コンプリートがあったときにいろいろやっていく、というお話ですね。コンプリート以外は今回特に何もしないのを踏まえると、コンプリートするまでの間はこの子は何かするつもりもなさそうな気がするので、`guard completed else { return }` でいいんじゃないかな。`guard completed else { return }` で、早期リターン。で、なんかここが足りない。

えーと、これが、この辺ちゃんと整形するとここか。ここが、この辺の配慮がよろしくないのかな。ちょっと一回、省略というか、改行をなくしてみますね。別にこうしなくてもいいんですけど。インデントが狂ってると大丈夫なのかなって心配になってくるので、これで一回インデントを合わせてあげて……あ、大丈夫。これでいいですね。

それで、このデリゲートメソッド。この中で `completed` なら早期に `return` してしまったほうがいいでしょう、ここはきっとね。で、それで、こうやって……あれ、なんか足りないな。うーんと、`return`、`return` ですよね。メソッドの何かここが足りないですよね。これが一個いらない感じかな。で、これで、ここがインデントが狂うのは……あ、これ if 文か。なるほど、コンプリートで全部やってたんだ。なるほど、コンプリートだったときに―― とりあえずダミー実装にしてしまったので、あとは`if`文で、`visibleController`が`pageViewController`の`viewControllers`の`first`として取れて、かつそのインデックスが取れた場合、という条件にするつもりでしたが、順番に`guard`でガードしていきましょう。

まず、`visibleController`（`visibleViewController`）が`pageViewController.viewControllers?.first`ですよね。これがなかった場合には、何も表示していないだろうということで、そのときはどうしていたかというと、何もなかったときはエラーにはせず、`nil`が入ることにしているはずです。そういう場合は普通にあり得るので、そのまま`return`で、何もしなくてよいと思います。

それ以外だったときには、インデックスをコントローラの配列から取っていきます。`controllerForPageNumber`（`controllerForPageNumber`や`pageNumber`や`index`まわり）くらいしか作っていなかったので、表示中のコントローラが今何ページ目にいるかは自分で調べる必要があります。ややローレベルなことをしている感じもしますが、`controllers`は名前を`pageControllers`に変えていますし、ここは`pageControllers`から`visibleController`のインデックスを取ります。具体的には、`pageControllers.firstIndex(of: visibleController)`でインデックスを取得し、これが取れなかった場合には`guard let`で落としておくのがよいでしょう。

インデックスが手に入らない場合は致命的なエラーです。`pageViewController`の中に、そもそも表示するはずのない`ViewController`が渡ってきて見つからない、という状況なので、これはランタイム上の致命的なものとして扱います。復旧しようがないエラーには`fatalError`を使い、プログラミング上のミス（ロジックエラー）を示す場合には`preconditionFailure`を使う、という整理でした。今回の場合は前者なので、`fatalError`にしておきます。

インデックスが手に入ったら、親のページ番号に対応づけるために、`pageNumberFromIndex(index)`のようにして変換します。最後に、エラーメッセージとしては「予期しない`ViewController`が`pageViewController`内で見つかりました」といった内容にしておくとよいでしょう。 表示はできています。なんだか変なエラーメッセージに見えますが、`visibleViewController` をこんなふうに使って、エラーならそれを返し、そうでなければ親のページ番号を更新する、というコードにすればよいということですね。

ここまでで言えるのは、ページをいくらスクロールしても、それが（外側には）反映されないということです。ページビューコントローラーの中に通常どおり `UIPageViewController` を配置していますが、何もしていないので、バインディングが変わらなくて当然です。なので、以前の挙動が「おかしい」と感じたのは、実は合っていたのかもしれません。まだ断定はできませんが。

このあたりはいい感じに作れてきたと思う一方で、ひとつ気になるのは、コーディネーターが少しローレベルなところを事細かにいじりすぎているのでは、という点です。ページビューコントローラーの中からマスターインデックスを取得して、その後ページ番号に変換する、といった処理をいろいろやっています。まあ、コーディネーターならこれくらいはできてもおかしくない気もしますが、概念的には「ページビューコントローラーのページ番号を調べる」ほうが一般的な気がします。なので、そのための関数を用意しておきましょう。

`controller(forPageNumber:)` の逆パターン、つまり `pageNumber(for viewController:)` ですね。型は本来 `UIPageViewController` に紐づくものではありますが、見つからないこともあるので戻り値はオプショナルにします。やり方としては、`guard let` でインデックスを取り、見つかったら `pageNumber(fromIndex: index)` を返す、という形でよいでしょう。例えば、`firstIndex` と `map` を使えば一行で書けます。`firstIndex` でインデックスが取れた場合に、それを `map` で `pageNumber(fromIndex:)` に渡して終わり、という具合です。これなら、見つかったときはページ番号が返り、見つからなければ `nil` が返るので意図どおりです。

問題は、これがそのまま使えるかどうかです。ここで `pageControllers` の型が `UIViewController` なので、`firstIndex` などがそのまま取れないケースがあります。そこで、`guard let pageNumber = pageNumber(for: visibleViewController)` のように書きたいのですが、このとき渡したい `visibleViewController` の型が `UIViewController` になっているという都合があり、`UIHostingController` や `UIPageViewController` として扱えません。なぜだったか忘れていましたが、親は `UIPageViewController` ではなく `UIHostingController` です。結局ここでは適切なダウンキャストが必要で、共変性が効かないために `UIViewController` を受け取る形にしておかないといけない、という状況です。その結果、この箇所でキャストを書かないといけないのが何かと不便だ、ということですね。

最終的には、`pageControllers` とインデックスの関係をうまく扱えるようにして、`pageNumber(for:)` を安全に呼べる形に整える、ということになります。 ただ、この辺、何とかしたくなってきましたね。ここまで言わなくていいと思うんですけど、実際に使っているパターンは、別にこれ、`UIHostingController`以外が入ってくるわけではないんですよ。コントローラーは、この中、ページコントローラーの中に入ります。なので、ここが気になっています。

だから、タイプエイリアスにして、タイプエイリアスの`PageController`を作りたいです。`PageController`は`UIHostingController<Page>`というふうに変えておいて、それで、ここで`PageController`を使いたいという状況ですね。ページビューコントローラーとページコントローラー、ページのコントローラーという呼び方でいいんですかね。

こうしておくと、ここで`PageController`とするわけにはいかないんですよ。そうすると、これの順序がダメになってしまうので、`UIController`にするしかなくて…いや、`UIViewController`にするしかなくて。で、ページコントローラーの中から`firstIndex`を取るときに、一つの方法としては、強制キャスト（`as!`）で確定させちゃう方法もあるんですけど、これは乱暴ですよね。実際は絶対それを使っていると思うんですけど、そうじゃなかったときに取ったとし…ね、厄介ですし。そうじゃなかったときには、見つからなかったとすればいいだけなので、これで取るのはやりすぎな気がします。

なので、ここで型を絞っておきますかね。ページコントローラー…ページコントローラーはホスティングコントローラーを、今、自分で消しただけだから、ここに作ればいいんだ。エクステンションとして、ページコントローラーの配列ですね。だから、配列は`Sequence`ですね。この中で、`Sequence`は`PageController`かな？ 押したときに、これはダメだ。`PageController`はあそこにない。

そうですね。誰が持ってたんだ？ ページコントローラーだな。ページビューコントローラーのページコントローラー…違うな。誰が持っていたっけかな？ タイプエイリアスで`PageController`…。あとはコーディネーターが持っていればコーディネーターでもいいけど、ページコントローラーが持っていれば十分でしょう。なので、これで、これでページの…ページビューコントローラーの`Page`、アソシエイテッドタイプ（associatedtype）…あそこか。ジェネリックかな？ `PageController`の`Page`。`PageController`の`Page`。ジェネリックかな？ ページビューだった気がする。アソシエイテッドタイプか。

あと、ここはなんだっけ。ページコントローラーの`Page`しか言ってないのか。ページコントローラーの`Page`で指定したのが何らかのビュー。だから、エクステンションで`Sequence`、`Element`がページビューコントローラーの…ジェネリックはページビューコントローラーの…ページビューコントローラーは型パラメータだけだったかな。ページビューコントローラーはイニシャライザのところで…。イニシャライザ、これで、あれ、どこか出てくるかな。`pages`。`pages`として受け取っているけど、イニシャライザですね。

`Page`は何かというと、ページ型か。`Page`型はページビューの`Page`か。`PageView`はどこで使っているんだ？ `PageView`、これか。`PageView`の`pages`だ。`FeatureCard`。

分かってきたけど、それだと長いな。`Sequence`で、ページビューコントローラーで…。そこまでやらなくてよかったのかな。ページビューコントローラーで、ページビューコントローラー…。やってみますか。一個の方法として書いてみます。 いま扱っているのは、「`UIViewController`のインデックスを取る」ための関数です。戻り値は`Int?`（オプショナル）にしたい想定です。インデックスの話をする以上、`Sequence`ではなく`Collection`を前提にする必要があります。

素直に`firstIndex(of:)`（以前の`index(of:)`）を使おうとするとダメです。`firstIndex(of:)`は`Element: Equatable`である場合にしか使えませんが、`UIViewController`は`Equatable`に準拠していないためです。そこで、`Element`が`UIViewController`（もしくはそのサブクラス）である`Collection`に対して拡張を生やし、恒等性比較（`===`）を使って`firstIndex(where:)`で探すのが正攻法です。

例えば次のようにします。

```
extension Collection where Element: UIViewController {
    func firstIndex(of viewController: UIViewController) -> Index? {
        return firstIndex(where: { $0 === viewController })
    }
}
```

これなら`Equatable`制約に頼らずに、同一インスタンスかどうかでインデックスを取得できます。以前の試みのように、自前の`firstIndex(of:)`の中で再び`firstIndex(of:)`を呼んでしまうと、同じシグネチャを解決して再帰的に自分自身を呼ぶことになり、循環してしまいます。`firstIndex(where:)`を使えばその問題は回避できます。

なお、戻り値を`Int?`に限定したい場合は、コレクションを`Array`に限定します。

```
extension Array where Element: UIViewController {
    func firstIndex(of viewController: UIViewController) -> Int? {
        return firstIndex(where: { $0 === viewController })
    }
}
```

キャストで`guard let element = element as? UIViewController else { return nil }`のように都度`UIViewController`へ変換する必要も、本件ではありません。ジェネリクス制約（`where Element: UIViewController`）で十分に表現できます。

汎用的なインターフェースを無理に広げようとすると、今回のように型制約やオーバーロード解決で複雑になりがちです。まずは上のような形で絞って実装し、必要になったら段階的に一般化するのが良さそうだと思います。 ここでは `UIPageViewController` で `firstIndex` とかを使いますが、この中でついでにやればいいのかなという話です。ビューコントローラーは `UIViewController` で受け取らざるを得ないので受け取りますが、そのときに `guard let` で、たとえば `guard let viewController = viewController as? PageController else { ... }` のように、ページインデックスをちゃんと取れることを判定します。これは良さそうですね。少し盛り込みすぎかもしれませんが、まあいいでしょう。見つからなくなっているときは、早めに逃げてしまう（早期リターン）ということで OK ですよね。

こちらも同様です。delegate でビューコントローラーが渡されてくるので、`guard let viewController = viewController as? PageController` としておけば大丈夫です。これで OK ですね。

もう1個、次はここで `pageNumber(for viewController:)` でビューコントローラーが見つかるかどうかの処理です。共通で使っているので、やはり何か共通化したいですね。ページビューコントローラーが持っているビューコントローラーの配列から対象を求めていて、それがさらに `PageController` であることが大事です。ここでも `guard let viewController = ... as? PageController` と、少し長々しいチェックをしてから `pageNumber` を取っています。`guard` を分けるのも一手ですが、同じメッセージを何度も出すことになってしまいます。だから、これを `pageNumber(for viewController:)` のように一本化して、そのまま使いたいのですよね。

ここはそうですね。ここでページコントローラーを取っていますが、`pageController(for pageViewController: UIPageViewController)` のような形になっているはずです。今はそれを `pageNumber` で指定していますが、もう1個オーバーロードして、`UIViewController` を受け取って中で `PageController` にキャストする版を用意してもよいでしょう。オーバーロードでなくても良いのですが、1つだけにまとめてしまっても全然大丈夫です。あえて分けるより、一緒のほうが見通しが良いかもしれません。

とにかく `guard let pageController = something as? PageController else { return nil }` として、そうでなければ `return pageNumber(for: pageController)` にすればいいですね。こんなふうにオーバーロードするのは少し大げさかもしれませんが、`pageNumber(for:)` を `PageController` 用と `UIViewController` 用に2つ用意すれば、さっきのあたりは全体的にスッキリしそうです。

次に、`guard` の中で、ここですね。`firstIndex` を使います。いろいろと用意してしまったので、ここはコーディネーターで `pageViewController(_:viewControllerBefore:)` ですよね。このときに、ページコントローラーのインデックスを取って、そのインデックスをループさせ、最後に目的のページコントローラーを返すことをやっているので、ここも `pageNumber` で済みそうです。

なので、`guard let number = pageNumber(for: beforeViewController) else { ... }` のようにするとページ番号が取れます。`guard` の `else` で早期リターンすれば良いです。ページ番号が取れたら、`moveBackTo` で処理します。この辺はログメッセージですね。とりあえずこれで良いと思います。

それから、`if` でページコントローラーの… `guard index` 的に比較していろいろやっている感じです。なるほど。つまり、ページコントローラーでページが見られればいい、ということですね。すでにコーディネーターが持っている `pageNumberRange` に `start` と `end` があります。だから、ページ番号の… ページコントローラーの `last` を返している？ それでも良いのかもしれません。つまり、`pageNumberRange` の `startIndex` … 文字起こしのテキストを貼り付けてください。複数回に分けていただいても大丈夫です。

こちらで行うこと:
- です・ます調で自然な文章に整えます（要約はしません）。
- 誤変換・誤記（例: G言語→C言語、万全オキス→万全を期す）を適切に修正します。
- コードはバックティックで装飾します。短いコードはインラインで表記します。
- 会話形式は発話者名を出さず、内容を踏まえた通常の文章にまとめます。
- 文頭が中途半端な場合は、次の文から自然に整えます。

長文の場合は、分割して順に送ってください。 スタートインデックスの代わりに`start`を使います。レンジなので`lowerBound`ですね。では、別のものを用意しておきましょう。スタートページとしてのページ番号を表す`startPageNumber`を作り、それは`pageNumber(from: index)`で`pageController`の`startIndex`を変換したものにします。同様に`endPageNumber`は、`pageNumber(from: index)`で`pageController`の`endIndex`を変換したものです。こうしておけば共通化できます。ページ番号のスタートとエンドが揃うので、だんだんスッキリしてきますし、意味もいい感じにまとまっていきますね。

これでページ番号を使うようにしたので、`lowerBound`などを壊すこともしていません。`startPageNumber`は…あ、`Range`ではないですね。デフォルトがある場合には`pageCollection`のインデックスを使うことになるので、その辺は`pageController`からページ番号に変換して対応します。

「ラスト」は用意していないので、`pageController`の「ラスト」で良いのか少し迷いますが、`pageNumber`側で用意してしまうという手もあります。とはいえ、`lastPageNumber`は`end`の一個手前で十分ですね。`end`の一つ前を取れば良いので違和感は最小限です。プレビュー的にはこれで良さそうです。

メソッド名の違和感も出てきたので、`controller`というメソッドは、`pageController(for:)`のように名前を変えておきます。ついでに他の`controller`という名前も、`pageController`のように揃えておきます。こんな感じで良いですね。

ここまででやったこととしてはとても良く、ページ番号で制御できるようになったので、わざわざ`pageController`をキャストしたり、インデックスを取る必要がなくなりました。まずはページ番号に対して処理を書いていきます。デバッグメッセージはデバッグらしい顔になるように整えておきます。同様に、`moveNext(after:)`の方も直していきます。これもカレントに対して`pageNumber = ...`として、`let controller = pageController(for: pageNumber)`という形にすれば、この辺まででページが取れますね。ここまでのデバッグメッセージもわかりやすく入れておき、インデックスを取る必要はなくなります。次のページに対していろいろやっていくところは、これまで`nextIndex`に対して処理していたものを、`pageNumber.next`に対して`switch`で分岐させる形にします。そして、`pageController`の`endPageNumber`を見ます。

先頭は`pageController(for:)`で`startPageNumber`から取っていき、そこから`end`まで進める、という流れにします。それ以外のケースなら`nextPage`を取っていく、という方針で大丈夫でしょう。とりあえず動いています。

完全に「ページ」と、それに対する「ページコントローラー」という構造に変わったので、その前の準備は少しややこしかったのですが、最終的には良い形になっていると思います。この辺で`nil`チェックなどもいらなくなっています。

あとは`visibleController`が気になります。`didFinishAnimating`（今作ったところ）では、`visibleControllers.first`を取って、それがあった場合にはそこからページ番号を取得しています。ここは`let pageNumber = ...`のように書けるようにしたので、余計な変換がいらなくなりました。とにかく`PageViewController`の表示中のビューを取ってきて、「このページ番号はいくつですか？」と問い合わせることができ、そのページ番号が取れたらそれを`currentPage`（バインディングされたページ番号）に入れていきます。良い感じにできていると思います。

記述は少し増えていますが、この辺も確認しておきましょう。さきほど作った`pageNumber`を`pageController`に渡し、`pageController`の`indices`に含まれるかどうかを判定します。含まれるなら、`pageController`の中の`indices`を参照します。これまで必要だったキャストは不要になりました。`ViewController`を`PageController`にキャストしなくても良いようにしたかった、という意図どおりですね。普通に取れたのならそれで良いですし、そうであればインデックスのチェックだけで十分です。 なので、これでいったんいいんだ、ということですね。もう想定外はなくなった、つまり適切にやっていけば想定外は減っていきます。想定外が減ればエラーチェックも不要になっていきます。これでいいですよね。これによって、純粋に絶対に別のページコントローラーが混ざっていないことが保証できるので、この辺は無視して、インデックスが範囲内にあるという点だけに着目すれば良くなった、ということです。いい感じじゃないでしょうか。

ページビューコントローラーの中のページビューコントローラーは、そのまま使ってもいいのではないかという気がします。ページビューコントローラーをここでやっているのと同じように、ここにも置いてあげれば、それぞれ別々にやるよりは、どこかを元にした方がいいと思います。つまり、ページビューコントローラーの中のページビューコントローラーをここでも使いますよ、という表現ですね。こうしてあげると、この辺で名前を指定しないといけなかったのが指定しなくても良くなりますし、コーディネーターで扱うページビューで扱うページコントローラーと同じ、というのは相当に扱いやすいですよね。なので、この方が表現としては適切でしょう。

これで良いとして、ここに戻ってきて、一回戻ってみますか。ここで、コンプリートだったら、ページが見つかったら親ページを戻してあげる、というふうにして、コーディネーターを……デリゲートパターンの設定では `delegate` のセットを忘れがちかなと思っているんですけれど、そういうことかもしれない。自分だけかもしれません。コーディネーターをデリゲートとして `UIPageViewController` にセットしてあげると、双方向バインディングで連結したよ、って言っていますね。テキストビューの更新とページ番号、スワイプ時のページ番号の更新。確かにそうですね。スワイプ時のバインドのことをすっかり忘れていました。これで動かないだけだったなら嬉しい。前回動かなかったわけで、確かめたいわけです。

`makeUIViewController` はどこだっけ？Command+Shift+O で `makeUIViewController` を検索すると出てきますね。この中でそれっぽい方、ページビューコントローラーの方に定義されている、これでしょうね。この中でページビューコントローラーの定義箇所と、これに対して、この `Coordinator` ね。これで完成かな？スワイプした時にページが移るかどうか。

動かしてみると、1のままですね。1のまま動いているよね。動かない。ここでポーズされている。よかった。ここで動きが変だな。こっちは3の時に変な動きをしたね。1、2、3……なんだこれ。変な動きが出ているか？間違えたかな。どこだっけ。デリゲート。デリゲートの中のこの辺ですね。`didFinishAnimating` で、`completed` だった場合。そうじゃなければ、一旦、表示中のコントローラーが得られた場合は、カレントページを更新する。いいですよね。これで、2、3の後の動きが違うんだ。1、2……これ、端とその辺の制御を間違っている感じかな。

とりあえず「Next Page」を押してみよう。これはページ番号だけ動いて、スクロールしないや。これはやばいね。2でしょ。3の時、これが2か。3の時に1に戻っていますね。1に戻って、1、2……めちゃくちゃな動きをしている。これは作りを間違えたかな、さすがにね。

次はカスタムページコントローラーを作る話になって、それで終わりなのか。カスタムページコントローラーって、ページのドットみたいなやつでしたっけ？それを作っていくのは、外部とはまた別ですよね。ここまででバグがあるということですかね。バグだろうと思われるところといったら、ページのコントローラーだと思うんですけれど、この中でページがあって、デリゲートがあって、ページのコントローラーのインデックスを取って、インデックスが0だったらラスト。この辺が気になるな。ページのラスト……ここまでは大丈夫ですよね。0だったらラスト、そうじゃなかったら1個前ですね。こっちは1を足してあげて、それが `count`、つまり末尾のインデックスに達した場合には先頭に戻し、そうじゃなければ次のページへ移動する。この辺が間違っているんじゃないかなと思っています。そうだろうね。

`didFinishAnimating` もちょっと気になるのですが、この辺については普通に表示中のビューコントローラーを取って、それがあった場合にはそれのページ番号を取って、ページ番号をアップデートするよ、という話なので。このスクロールが……例えばもう一回、ページの最初に戻しますけど、戻らないかな。ビューを戻すにはどうしたらいいんだ。これ、一回別のモードにして帰ってくればリセットされると思うんですけど。これで1というのがあって、これがスワイプすると2になって、こうなって、2からまた2になって、それから3。この辺のバグでバックトレースしてみると、もうちょっと分かってくるのかなという気がしますが。 とりあえず、これで「01」。アップデートで、値は「page 1、03、3」。次に動かすと、また「01」ですね。ページは「2」です。やっぱり相変わらずダウンなのかな、でも大丈夫。2 の 3 で、`moveBack(to: 2)` に、`moveForward(to: 2)`。これでまた……まあいいか。どこか変だな。どうしようかな。

「ページ番号で予期しないページが得られました」と出ていますね。`startPageNumber` は `startIndex` からページを出していますし、`endIndex` から `endPage` を出しています。`last` は `end` の 1 個前、つまり「マイナス 1」ですね。そのうえで「プラス 1」。`last` の場合は「プラス `offset`」……いや、こっちではないか。定義は「プラス」はここだ。値同士の足し算、引き算はいいですね。

`find` もありますが、`index(fromPageNumber:)`。ページ番号からインデックスは、ページコントローラーの `start` からのページ番号のオフセットで、オフセットというのはページ番号が 0 から始まること。だから、そこから 1 を引いているだけですね。OK です。

この辺は良くて、デリゲートメソッドを見ておきたい感じです。ここですね。`finishAnimating` ではなくて、データソースのほう。この辺が `viewControllerBefore`（戻るほう）ですが、戻るほうというより進むほうがまずおかしいので、そちらを見ます。

`moveForward(to:)` ですが、デバッグして 1 個進めると 2 個行ってしまいましたよね、今。これで `moveForward(to: 1)`、`moveBack(to:)` が動いていますね。`moveForward(to: 2)` も動いています。何かバグっている？ よく分かりませんね。

それで、ページ番号ですが、`UIViewController` からページ番号を探しています。この探索は間違っていないはずです。ページコントローラーをキャストできた場合は、そのページ番号を使う。ページ番号が `nil` の場合は、`controller.firstIndex` を取り出して、あった場合にはページ番号にする。ここは大丈夫ですね。

`moveForward(to:)` のログが出た後に、次のページ番号を計算します。つまりデータソースの `pageViewController(_:viewControllerAfter:)` です。見つけたページ番号の「次」を取得して、その「次」が `endIndex` に差し掛かっていた場合には、ページコントローラーの先頭ページ、つまり一番最初のページを取得する、ということですね。`nextPageNumber` が終端でなければ、そのまま使ってページコントローラーを取得する。合っています。合っていると思うのですが。

そうすると、この `move` の後に、いろいろログが表示されている。この辺の問題ですかね。`updateSelf` の `binding`。ここも少し気になります。`self` の `binding` が何か提供しているのかな。ここで普通に出していて、出力の中で `updateSelf` で `currentPageNumber` と、今回は `Binding` の値。値がちゃんと同じになっているかどうか。

ログでは `context` を出していますが、上は `binding` のページ番号、下はページ番号「2」。順番が違う気がします。2 個出ていて、`updateSelf` と `updateContext` で、`currentPageNumber` が `self` では「2」、`context` では「1」か。ここがずれている、という話をしていました。`Binding` の値は「1」が取れていますね。`Binding` の中は「1」になっていて、ここも「1」か。`parent.currentPageNumber` は「1」で、上のほうは「2」と……なるほど。`parent.currentPageNumber` を取ったときにずれている、という話です。

スワイプしたときに `updateUIPageController` に来たとき、ページ番号が自分自身の `currentPageNumber` は「2」になっているのに、`context` は「1」のままという状況です。ここはまだ解説されていません。どこかでおかしくしていますね。

とりあえず情報が多すぎるので、この `context` の中身は一旦置いておきます。`currentPageNumber` がここでアップデートされ、`self` と `context` をこんなふうに……`Coordinator` だけとか `Context` だけとか、そういう形でログが出る、という話ですね。

とにかく `binding` の値が更新され、その 2 つが表示されますが、結局のところ、この `update` が少し邪魔になっているかもしれません。コントローラーはもう早く取得できているので、ここを見ても分からないですね。`updateController` が来ていることは分かっていて、コントローラーが見つからなければ `fatalError` で落ちるので、ここに来ること自体は分かる。なので、ここは良しとします。

それで、ログを少し捨てて、もう一回。これで一回スワイプすると、1 から 2 に行った。`moveForward(to: 1)`。ここ、何か間違っていますね。`moveForward(to: 1)` はおかしい。さらに 2 から 3 に行って、`moveForward(to: 1)` に行っている。でも、次の値は「2」になっている。一回スワイプしたことによって `moveForward(to:)` が……これは `UIPageViewController` の `pageViewController(_:viewControllerAfter:)` が呼ばれたときですね。

そして、`binding` のページ番号、これが反映されていないという状況でした。ページ番号自体は今の `UIViewController` から出しているので、この「1」という状態のままです。これでページコントローラーを出して、それがコンプリートするまでは `binding` がアップデートされない。だから、ここを見ても意味がないのかもしれません。とにかく、この中でページがどこへ移ったかどうか、それが分かれば何か手がかりになりそうです。 これを知るためには、SwiftUIとか、そういう仕組みで中に何か入れたくなったときに崩さないといけないのか、すごく違和感があります。これで `print` を、例えばこうしようかな、`End`、`Start`、`pageNumber` か。`End`、`Start` とやって、こっちの `print` で `i` を入れて、`Move`、`Move`、いるのかな、`Move Next` とか。これでどっちに移ったかわかります。わかるけど、ページナンバーを出しておきたいです。ここでページナンバーを参考情報として出しておきたい気がします。

こんな感じのノリで、もう一つ、こっちの `Previous` もお世話になることがありそうなので、`Move Start -> Last`、ラストか。これが 1 分にしないといけないっていうやつですね。`return` で、それでもう一つ。ここは `End` じゃないですね。厳密には `Last` ですね。それで、こっちも `Move Previous`。こんなふうにすれば、だいぶ見やすくなってくるのかな。こんな感じです。

これでスワイプをかけると、いったんログを消して、スワイプをかけると、いよいよ起こりましたね。`Move Next`。1 からですね。1 から 2 に行って、`Start -> 2 -> Last`。`Start` から `Last` に行ったら、`Start -> 2 -> Last` に行ったら、`Start` から `Last`。1 から 2 でしょ、`Move` で。`Move Next` で 1 から 2 に行った。`Start -> 2 -> Last` だから、やっぱりこっちですよね。`Previous`。`Move`。あれ、`Before` 呼ばれるの、これ。呼ばれるのか。なんか間違っているのかな。とにかく戻ってましたよね。

`Move Next` で 1 から 2 で、`Start -> 2 -> Last` でラストに行っちゃいましたよね。ラストに行って、それで、これが 2 と 3。`Move Back 2` が出てきましたね。`Move Back 2` も何だっけ、バーッと残ってますね。ここだ。これもまあいらないかな。なので、これは無視してよくて、それで 1 回しかスワイプしていないのに、また `Move Next` で 2 から 3 に行ってますよね。1 から 2 に行って、2 から `Last` に行って、2 から 3 に行って、アップデートがかかって、コンテキストがずれている状態で、0 と 1。今、ここでいろいろ変えたからか。ここでいろいろ変えたからかもしれない。

これで、もう一回やってみますかね。これで動かすと、動きをちゃんと見なかったな。多分動かしたと思うんですけど、`Next` この人やろうか。もう一回これで、これでダメか。どうしようかな。もう一回、いらないログとかあったかな。この辺で、この辺のログは、ページコントローラーの、ページコントローラーが、コントローラーのインデックスとページナンバーか。ページコントローラーを取得するものだから、ページコントローラーを、コントローラー、インデックス、インデックスとページナンバーね。こんな感じで、ここがいいですかね。あとは、`print` 文が何か残ってるかな。`print update`、これはいいとして、`Start`、`Last`、他のもかとね。

それで、`pageController update 1` で、今 1 ページ目がいろいろいじられていく中で 1 ページ目が出ているので、インデックスが 0 で、ページナンバーが 1 で、そのコントローラーが得られているよと。こんな状況で、やっぱりスワイプですね。スワイプすると、やっぱり変な動きしますよね。そのときに、次へ移動して、ページナンバー 2 のコントローラーが得られて、それを表示したいんですけど、この後、`Start -> 2 -> Last` で、戻っちゃってるんですよね。`Start -> 2 -> Last` なんで、ここですよね、`Start -> 2 -> Last`。なんでこれ、`controllerBefore`。`Before` で呼ばれちゃって、1 から 2 に行ったやつが、`Start` から `Last`、1 から `Last` に行っちゃいますね。`Last` へ行って、ページナンバーが 3 のものを表示対象として、`Start` にまた `Move Next` しますよね。`Move Next` を押して、つまりもう一回、こっちの、こっちじゃない、こっちの、`After`。これのほうが呼ばれて、`Move Next` なので、2 から 3 へ行くっていうね。そういったもので、またページ 3 のものが表示されて、今、アップデートでインデックスは 2 なんですよね。インデックスというか、ページか。で、コンテキストのページ 1 が落とされて、ページ 1 が表示されているという状況になっていると。ダメだ、制御ができていない。どうか。

そうすると、あと考えられるのは、この辺のバインディング周り。更新したことがどういう影響を出しているんでしょうね。ページナンバーを代入している、カレントページナンバー。例えば、これを代入しなかったとすると、つまりアニメーションが終わったときに何かをするってのをしなかったとすると、このときにはページ番号が変わらないって話でしたけど、このスクロールだと 1 から 2 に行って、またやっぱり `Start` から `Last` に行ってますね。それで、`Next`。ああ、そうか。この辺の動きはそんなに変わらないか。この代入があることによって、スクロールしたときにまた 1 に戻ってくるという、そういった話になってきているのか。

ここで、ここも `print` してみたらいいんですかね。`print` で、ページナンバー。こんなふうにして、これが最終的に何番が設定されるのかっていうのを、スワイプで見てあげると。そうすると、ここが 2 になってますね。あ、実は 2 か。いいですね。2 になって、で、`Move Next` で 2 からなぜか 3 に行こうとしちゃってるんですよね。それで最終的になぜかページコントローラーのインデックス 1 番が欲しがって、その 1 番が表示されているという状況になっているから、完全に制御ができていないという、そういった状況になっていると。うん、これはどうしますかね。

チュートリアルのコードと手元を照らし合わせながら、ちょっと間違いがどこにあるかを見ないと、なんかわからない気がしますね。おそらく、ここまでちゃんとできているわけでしょ。きっとね。チュートリアル次はセクション 4 に行って、ページコントロールを追加するって言ってるくらいですからね。ページコントロールをこの後、ちゃんと動いている状況に追加していくんだと思うんですよね。これですよね、ページコントロールってね。だから、これがうまくいっていないってことは、自分のコードのどこか、ステートのリンクの仕方、多分間違っていると思うんですよ。で、実際この改編を行っている前までは、ページの管理はできていなかったにしても、スクロールはできていたんでね。 ページの変換まわりで、インデックスとページを入れ込んだあたりから、制御を間違えているのかもしれませんね。計算自体はそう間違っていなさそうなのですが、動いていないということはどこかがおかしいのでしょう。その辺りはまた次回、見ていきます。

一旦は置いておいて、頭の中を整理しつつ、この配信の前に考えるかどうかは別として、とりあえず頭を休めるだけ休めておきましょう。次回は、コードがどこで間違っているのかをパパッと見ていく感じで進めます。なので、次回はデバッグみたいな回になりそうですね。

はい、今日はこれで終わりにしましょう。お疲れさまでした。
