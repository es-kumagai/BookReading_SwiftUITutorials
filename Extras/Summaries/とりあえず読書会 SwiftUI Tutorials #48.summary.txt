Transcription & Summarize : とりあえず読書会 SwiftUI Tutorials #48

では、続いて紹介を始めていきます。SwiftUI Tutorials のリファクタリング的なところですね。リファクタリングもだいぶ落ち着いてきた感じがするので、コードを振り返りながら様子をチェックしたり、書き換えられそうな場所は書き直したりといったことをやっています。引き続きこの調子で進めていきましょう。

さっそくコードを映していきます。今日はサークルイメージのところからです。それより前は一通り終わっています。ここは変えるところがあるでしょうか。サークルイメージの `View` で、`Image` は `let` で良さそうですね。まだ、`View` に準拠させたときに、それを `let` にすべきか `var` のままで良いのか、そのあたりの判断は完全には固まっていないのですが、`@State` でないなら `let` にしておいて差し支えないかな、という感じがします。なので `let` で良いでしょう。

`Image` を表示して、サイズをいろいろ指定していきます。`stroke` を `Color.white` にしていますが、ここはカスタマイズできるようにする必要があるでしょうか。例えばコンポーネントとして、`lineWidth` と `strokeColor`（あるいは `lineColor`）を引数で受け取れるようにしておくのが良さそうです。名前としては「サークルカラー」より「ボーダーカラー（`borderColor`）」と「ボーダーウィズ（`borderWidth`）」の方がしっくり来ますね。デフォルトは白で、幅は `4` といった感じにしておくのが良いと思います。つまり `stroke` の色と太さを、`borderColor` と `borderWidth` でカスタマイズできるようにしておきます。

次に、`shadow` の半径（`radius`）もプロパティとして用意しておくのが普通だと思います。`let borderShadowRadius: Double = 7` のように、`Double` でデフォルト `7` にしておくのが扱いやすいです。SwiftUI では、わざわざ `CGFloat` を使わず `Double` で書いておいた方が自然な場面が多い印象です（UIKit では一般的に `CGFloat` を使いますが、SwiftUI のコードでは数値リテラルとの相性もあり `Double` を使うケースが目立ちます）。このあたりは好みでもありますが、ここでは `Double` にしておきます。

プロパティ名については「サークルカラー」「ラインカラー」なども考えましたが、「フレームカラー」とすると `View` の固定サイズを連想させてしまうので微妙です。やはり「ボーダーカラー（`borderColor`）」と「ボーダーウィズ（`borderWidth`）」が分かりやすいでしょう。サークルで輪を作るとはいえ、特別な意味を持たせなくて良いので、一般的な「ボーダー」で統一するのが無難だと思います。

これで、カスタマイズできる場所は一通り用意できました。プレビューで試す場合は、例えば `borderColor` を `Color.yellow` にしてみる、という具合ですね。あれ、`borderColor` じゃなかったっけ…というときは、名前や型の不一致でコンパイルエラーになりますので、しっかり型を一致させる必要があります。 イニシャライザを用意しないといけないのか、という話ですね。イニシャライザをきちんと実装しておくのは少し準備が面倒ですが、コンポーネントを用意するとなると、そういう作り方になると思います。カラーはホワイトが既定、幅は 4 が既定、角丸の半径は 7 が既定、というようにデフォルト値を設定しておいて、必要に応じてイエローにしたり、幅を広くしたりといったカスタマイズができるようにします。コード自体はきれいなので、これはこれで良いと思います。

次は「FavoriteButton」です。`Binding var isSet` のように `Binding` を使います。`Binding` は読み書き可能でないとダメなので、`let` にはできません。`let` にすると、`toggle` ができないと怒られますね。ここから分かるのは、`var`/`let` といった値の扱いや、通常の Swift の構造体を扱うときと SwiftUI の `View` を扱うときとで、構造体のプロパティの扱い方の感覚が少し違うということです。

通常の Swift の感覚だと、外からの書き換えは保護したくなります。例えば、ボタンを押したときに `isSet` が安定して変わる（トグルされる）ようにしたいので、外部から勝手に変更されないようにしたい。そう考えると、`private(set)` のように「外から読み取りはできるが書き込みはできない」形が Swift らしい気もします。このチュートリアルでも `@State` には `private` を付けなさいと言われていますが、あれも外からアクセスさせないための保護ですよね。そういう作りにするなら、`Binding` でも `private(set)` が欲しい気がします。ということで、方針としては `private(set)` に寄せていきましょう。

少し遡って確認すると、これまでのところ Button のビューはバインドしていませんし、Badge もしていなかったはずです。そこは大丈夫そうです。次から出てくるものについて `private(set)` を試してみましょう。本当にそれが最適かは分かりませんが、実務上の評価観点では悪くないはずなので、ひとまずこれで進めます。

`body` の中では、ボタンを押すと `isSet` がトグルされ、ラベルとして星マークを表示します。今はプレビューで `Constant` を使っていて常に同じ表示になっていて面白くないので、`PreviewProvider` の中で `@State var isSet` を持たせて `toggle` できるようにし、`$isSet` を `Binding` として渡す形にすると良いですね。こちらの方がプレビューらしくて動作確認しやすいです。`accessibilityLabel` も問題ありません。

次は「フィーチャーカード」です。これは iOS 用のほうですね。ファイルの置き場所は少し悩んでいて、フォルダを分けて iOS 用フォルダに置くか、ファイル名に iOS を付けるか、あるいは他のやり方にするか。どれが良いかはまだ決めきれていません。とりあえず今はファイル名で区別していますが、ファイル名が長くなってしまいます。ここみたいに省略表示されると分かりづらいですし、フォルダを分けると今度は階層が深くなってアクセスしづらいという問題も出てきます。クロスプラットフォームならではの悩みですが、まだ最適解が見えていないので、その都度ルールを決めて「今回はこうしましょう」という運用でも良いかもしれません。 ランドマークを取得して、ボディとしてはイメージがランドマークのフィーチャーイメージになるようにしています。ここで作っているのが `FeatureCard` ですね。`landmark` を受け取り、ボディではイメージとして `landmark.featureImage` を使います。フィーチャーイメージが取得できない場合があるので、そのときはしょうがないという扱いにしています。

コードが見にくかったので、横スクロールバーを動かして確認しました。`if let` ですね。イメージが取得できた場合にだけ、そのイメージを表示するという形にしています。ここはシンプルに書けていると思います。

ほかには、`landmark.featureImage` が取れた場合に `map` を使って表示する方法も考えられますが、`map` がオプショナルに対してどう動くのかを把握していないと想像しにくいですし、他の言語でも同様ですが、元々の型がオプショナルなのかどうかはコードだけだと分かりづらいですよね。`featureImage` が「イメージの初期化に失敗するかもしれない」という事実が見えにくいのが気になります。もしそれが目に見える形、例えば `try` や `?` のような記法が必要な形で表れていれば、また書き方の判断も変わったと思います。

テキストのオーバーレイに関しては、最初は「テキストオーバーレイ」と呼んでいましたが、ややちぐはぐに感じたので、「オーバーレイテキスト」とするほうが自然かなと思いました。`overlay` に対して載せるテキスト、という意味で「オーバーレイテキスト」にし、`overlayText(landmark:)` のようにランドマークを渡して、そのランドマーク名などを表示する、というイメージです。モディファイアに切り出して `ViewModifier` にしても良いと思いますが、今回はそこまでしなくても良さそうです。

オーバーレイに使うグラデーションは、規定の色を計算型プロパティで用意しておくことで、「グラデーションで塗る」と言ったら常にそれを使う、という形にしています。ボディでは `ZStack` の下側にグラデーションを置いて、その上に `VStack` でテキストなどを載せています。

このグラデーションは透明度で塗っているので、コメントアウトして挙動を確認してみると、さっきはそれが前景を少し隠す形になっていたことが分かります。名称としては「グラデーション」という実装詳細よりも、「バックグラウンド」という用途で名付けたほうが良さそうですね。`LinearGradient` は `ShapeStyle` なので、`View` の背景として使えますし、必要ならシャドウも載せられます。変数名も「グラデーション」ではなく「バックグラウンド」にしておけば、将来グラデーションではない背景に変えたくなっても名前が齟齬を起こしません。

まとめると、`FeatureCard` は `landmark` を受け取り、`if let` で `landmark.featureImage` を安全に取り出して表示します。テキストは「オーバーレイテキスト」として別に用意し、背景は `LinearGradient` を使いつつ用途に合わせた名前付けをします。APIデザインガイドラインにもあるとおり、変数名は実装の詳細ではなく用途に基づいて付けるのが良い、という方針に沿った形になっていると思います。 ここで変数名を「グラデーション」にしてしまうと用途が固定されてしまうので、制約になりますよね。「この変数はグラデーションです」という意味になってしまいます。背景を塗るために使うのであれば、「バックグラウンド」といった用途に沿った名前を付けたほうが良さそうです。オーバーレイするテキストに対して背景を敷く、という目的が明確になります。

`ZStack` と `Text` で Landmark の `name` と `park` を iOS に表示できていて OK ですね。`foregroundStyle(.white)` はオプションで良い気がします。例えば `Color` として色を持たせ、イニシャライザで受け取れるようにして、テキストの色を `foregroundStyle(.white)` ではなく `foregroundStyle(color)` にすれば、カスタマイズが効いて一律の色から適宜調整できるようになります。そうなると背景側もカスタマイズできたほうが良い気もしますが、ひとまず今回はここまでで良しとします。ボディも分かりやすいですし、こんな感じで `FeatureCard` は OK です。

次に、ハイクバッジです。上から見ていくと、`name` を取り、`body` があって、これが `ZStack` で重ねられて、バッジがこういったプロパティで表示され、テキストがこういったプロパティで表示される、という構成になっています。これはこれで良さそうですね。

検討事項としては、`scaleEffect` や幅・高さなどの扱いがあります。`scaleEffect` を外すと大きくなりますね。`frame` を 300 にすると小さくなる、200 にするとまた変わる、という挙動で、スケールとフレームの兼ね合いで余白の取り方が変わっているのが分かります。`frame` によって 3 分の 1 にしているのが、少し不思議に感じます。いわゆる「フィットする」系のプロパティがあれば良いのですが、SwiftUI の仕様としてはこういうものなのかもしれません。バッジに対して `frame` を設定して、`scaleEffect` を設定して、さらに再度 `frame` を設定する、といった手順で 3 分の 1 にする必要があるのですね。今回はそういうものとして扱っておきましょう。ハイクバッジは `name`、つまりバッジ名で OK です。

次は `HikeDetailView` です。これは OS によって `VStack` にするか `HStack` にするかを切り替えていて、型消去を使ってレイアウトを統一し、その下では同じコードで書けるようにしているのが良い選択だと思います。

`HikeDetailView` では、どのデータを表示するかを示すデータパスを、`Hike.Observation` に対する `KeyPath` で指定しています。具体的には `Range<Double>` を返してくる例のキー・パスです。`Hike.Observation` 型は、エレベーション（標高）ならこのデータ、ハートレート（心拍数）ならこのデータ、ペースならこのデータ、というように、それぞれ `Range<Double>` 型を持っています。ですので、`KeyPath<Hike.Observation, Range<Double>>` を選択できるようにしておき、`hike` は `let` で持ち、`@State private var dataPath = \Hike.Observation.elevation` のように、エレベーションを初期選択にしておく。これは良いですね。

ボタンアイテムは、エレベーション、ハートレート、ペースがそれぞれどのデータで利用されるかを宣言してあり、別途定義されています。ボディとしては、`HikeGraph` に `hike` と `dataPath` を渡せばグラフが描画され、下に `ButtonsBar` を配置する。このあたりは問題ありません。

`ButtonsBar` は、先ほどの型消去のやり方で縦横の配置を切り替え、`buttonItems` に対してボタンを並べています。各アイテムの `dataPath` と現在の `dataPath` が一致したときには、選択中であることが分かるようにスタイルを当てる。ボタンが押されたら、その押したアイテムが新しい `dataPath` として設定される。名前はやや迷うところもありますが、ひとまずこれで良いと思います。 とりあえずこうしてみようという感じで、名前を付けました。そうでなければアイテムにしたり、あるいはドラッグ&ドロップで調整したり、といったところですね。これは「プッシュアイテム」か「ボタン」か、「アイテム」と呼ぶか、どちらが良いか少し迷いましたが、「プッシュアイテム」だと今は違和感があるので、一般的に「アイテム」としておきます。

押したボタンに対するデータパスが、カレントのデータパスへリカバリできていて、動作はうまくいっています。OKですね。

次に `TypeGraph` を見ていきます。`TypeGraph` はパスも同様に持っていて、`Color` はパスの種類に応じて割り当てています。ここも悪くないですね。`Unknown` のときには `Unknown` 用の色を指定しています。ここはフェイタルエラーにすることもできますが、将来色を増やした場合に落ちるよりは、色が適切でなくてもフォールバックしたほうが親切だと思います。したがって、失敗時のリカバリを用意して落とさず、確認用の「分からないときの色」（今は黒）を返すようにして、想定外のケースでも落ちずにしのぐ、という方針にしています。これでOKでしょう。

`body` は `GeometryReader` で、`Hike` の `observations` を取り、その `count` が 0 なら `EmptyView`、そうでなければ `GraphView` を表示するようになっています。これもOKです。`EmptyView` の条件は、`observations.count == 0` と書かずに、`if !observations.isEmpty` で良さそうですね。

このときの `observations` は表示するときにしか使っていないのでローカルに閉じ込めても良さそうだ、と一瞬思ったのですが、最初に読まないといけない箇所があり、私の見落としでした。`Hike.observations` 周りで、もっと端的な良い書き方がないかとも考えましたが、特にないですかね。`Hike` に `hasObservations` のようなプロパティを持たせれば、もう少しスッキリしそうですが、そこまで必要ではなさそうなので、今のままで良いと思います。

次に `Capsule`（丸みのあるシェイプ）です。どこで使っているかはさておき、`Capsule` にはいろいろなプロパティがあり、それぞれの情報を計算型プロパティで用意しています。ここで自分のプロパティ名としても「capsule」を使っているので、UI の `Capsule` と紛らわしくなりがちですが、`body` の中に収めてあってスコープも限定されていますし、実害はないでしょう。`Color` を塗る処理も含め、この辺は問題なく書けています。

`GraphView` は `bounds` と `observations` を受け取ります。`observations` が空の場合は描画しない前提で使う、という形ですね。呼び出し側では、事前に `observations.isEmpty` でないことを確認してから `GraphView` を表示しており、この使い方なら問題ありません。実際、空でないときだけ表示するようにしているので、良い感じにできています。

時々見かけるパターンとして、`GraphView` の内部で「`observations` が空なら `EmptyView` を返す」といったコードがあります。`GraphView` という枠だけは必ず表示し、中身が常に真っ白でも構わないという要件ならそれで良いのですが、そうでない場合、「空だったら表示できない」というスタンスを取るなら入口で弾くべきです。つまり、呼び出し元が「空だったときにどうするか」を考えて実装する必要があります。そのほうが呼び出し側の意図が明確になり、より堅牢で分かりやすいコードになります。内部で `EmptyView` を返す設計だと、データの取得方法によって空になるかどうかが外からは分かりにくくなりますからね。 なので、そうすると対処が遅れたりすることもあるので、空判定は外側でやってしまうほうが基本的には良いはずです。一般的にもそうですね。

その感じで前提条件（プレコンディション）を入れた後、レンジの幅を指定して、最大の幅、つまり最大マグニチュードを取ります。これも、`observationRanges` が空ではないことが前提条件によって保証されているので、安心して `unwrap` による強制アンラップができます。そうですね、その感じでOKです。

次に、オーバーオールレンジ（全体のレンジ）のマグニチュードについてです。これ、0 の可能性はないでしょうか。アッパーバウンドとロワーバウンドなので、オーバーオールレンジは `observationRanges` に対する最小包含レンジ（Smallest Enclosing Range）になります。これが 0–0 というケースはありますよね。たとえば、レンジデータが空だったとき、あるいは要素が 1 個で 0–0 のレンジデータだったときです。その場合は 0 が返ってくる可能性があるので、ここで 0 で割る可能性が出てきます。そうですね。ということは、何とかしないといけません。まあ、そこで落ちる（アサートする）という選択も全然アリではあります。

これをコンディションにするか、別の何かにするか、どうしますかね。オーバーオールレンジマグニチュードについて、万全を期すとすると、`overallRangeMagnitude` をあらかじめ計算した上で、プレコンディションで弾くのが良さそうです。`overallRangeMagnitude` が 0 の場合はダメ、という条件にするべきかどうか、という話ですね。ドロップしたときにプレコンディションだけでいいか、全部書いてあげないと意味がない気もしますが、とりあえずこれで、`overallRangeMagnitude` をチェックして 0 での除算を除外することは可能になりました。

フィルタをかけて様子を見ます。何かおかしくなっているのかな……大丈夫ですね。では、こういう感じで厳密な姿勢を求めていくと、こうなってきそうです。

ところが、iOS（今は iOS ですよね）で落ちるようになりました。iOS シミュレータでアサーションフェイラーです。`in main`、それからオブザベーションを選択、`centerWithObservation`、これは普通の `updateValue`。何が起きるようになったのでしょう。何か悪いことをしたかな。

ここでマグニチュードが 0 なのは別に良いとして、レンジの数は `Double` の 0、`overallRangeMagnitude` が 0。なるほど。ということは、`overallRange` が 0 かどうかではなく、`overallRange` が空かどうかで判断すればよいのかもしれません。プレコンディションならそのほうが筋が良い気がします。なので、割り算は復活させて、`overallRange` を 0 かどうかで判定するのではなく、空かどうかで判定します。レンジに「0」という概念はないので、`Range<Double>` であれば `isEmpty` を使えば良いですね。`isEmpty` です。

実際的にマグニチュードが 0 になったら困るので、プレコンディションは「`isEmpty` ではない」という状況にします。つまり、「オーバーオールレンジは空ではない」を前提条件として明示し、そのうえで割り算を行う、という方針にします。 これで、こうすると、プレビュー通りになっていると思います。うん、いいですね。これで良いですね。これで、0と3が、まあ、範囲外として弾かれて落ちますけどね。

それで、あとは `HStack` でいろいろと、ちょっとマジックっぽい部分になりますが、「なんだこの120で割るの？」みたいなのはあります。ただ、`spacing` で見ると120なので、`HStack` で120で割っているのはまあしょうがないか、というところです。`HStack` の `alignment`、それから幅を120分の1にする、みたいな扱いですね。`H` だから水平並びです。点々のところでしょうか。うん、まあ、いいでしょう。120分の1、120分の幅。

それから、`ForEach` で `observations.enumerated()` を `id` 付きで回して `offset`。これは本当にそうする必要があるのか、という気持ちはあります。`ForEach` の `id` とコンテンツ。`ForEach` でデータを取っていきますか。データは `ForEach` に対して `content` と `data`。データはどこに定義されているか……どこにも定義されていません。データは `ForEach`。`ForEach` 型で、`ForEach` 型の定義はどこか。`ForEach` は結構適用条件を言われますね。`ForEach` で `data`。`data` はランダムアクセスコレクションですね。ランダムアクセスか。ランダムアクセスね。そこに当てはまらなかった、という感じでしょうかね。`enumerated()` はね。どうするか。IDを作らなきゃいけないな。なんとなくもったいないですね。どうにかならないか。これで、`index, observation` で `Capsule` を表示してあげて OK ですね。ここまで良しで、あとはプレビューか。プレビューも問題なしですね。これで良いという感じです。

じゃあ次、`HikeView`。`HikeView` の方は、`private var` で `let hike: Hike` で、`body` は `VStack`。そのあと `HStack` で、`HikeGraph`、`LandmarkSummary` を置いて、`Spacer()` を挟んで、"SHOW DETAIL" ボタン。これは分かりやすいですね。もし `showDetail` が真なら、`DetailView` を表示していくと。ここですよね。この動き。アニメーションがなんか変だったな。右から来ましたね、一回ね。右から来て後ろに抜けていく。レンダリングが速くなると、オーディオと一緒に処理するときに後ろから来ないことがありますね。これはしょうがないんでしょうか。`showDetail` で、`DetailView` にトランジションを `moveAndFade`。`showDetail`、この辺のプロパティは悪くないですね。SHOW DETAILボタンで、`withAnimation` で `showDetail` がトグルされる、と。これだけでアニメーションを制御していますね。

あとは、この画像とかですが、`showDetail`、この辺かな。`rotationEffect`。それは三角のボタンですね。ちゃんと適切に動いているので OK ですね。で、ボタンを押すと `showDetail` がトグルされる。`showDetail` がトグルされると表示が変わって、`moveAndFade` で動く。なんかアニメーションは変だけど、良いのかな。直し方が分からないというところもありますが、ボタンを押して `moveAndFade` をアニメーションのトランジションで、`move` でいろいろやって、コンバインのリムーバル。アニメーションが微妙な感じはしますけど、まあいいか。不具合が起きたら考えますが、たぶん起きないでしょう。そんな感じで、妥協するのもありといえばありですかね。

次は `HikeView`。`HikeView` も OK ですね。`Hike` と `body` で、`ScrollView` の中に `VStack` を置いて、`LandmarkSummary` と、ここの `DetailView`。この2つが、片方は直書きで片方はプロパティ、みたいに混在しているのがちょっと気になりますね。`LandmarkSummary` と同じような感覚で、ここで `landmarkDetail` みたいな名前のプロパティにして、その `landmarkDetail` が `some View` を返すようにしても良いですよね。`landmarkDetail` として `some View` にして、`DetailView` を返す。こっちの方がバランス感は良いですかね。ということで、そうしてみますか。

あれ、プレビューがうまくいっていないですね。`HikeView` のプレビューで `Spacer` を定義して、モデルデータの `Hike` を渡して、それでここへ来て、`LandmarkSummary` と `DetailView`。`DetailView` が何か特別なものを使っているんですかね。`DetailView` は `Hike` と `DataPath`。問題なさそうですね。もう一回。`Hike` と `DataPath`。`DataPath` は規定がある。なので、`Hike` だけで良し。 ただ、これは動いていないですね。これはなんでしょう。`HikeView`、watchOS のソースリストが見つからない。watchOS、`HikeView`、watchOS……これですね。`Exclude Source File Names`。これは見つからないって言っていますが、プラットフォームによって `HikeView` が実際に使われるのは watchOS だけですね。watchOS の中で、このプレビューがここだけですよね。これが動かないのがちょっと謎な気がします。これも解決したいのですが、今は分からない気がします。

watchOS の「No BuildTargetDescription found」「DefinedTargetDescription が見つからない」。`Exclude ...` を付けなければならない、という感じらしいのですが、ちょっと分からないですね。そうすると、プレビューがうまく動かない。プレビューは動いてほしいんですよね。当たり前ですけど。なので、これが動かないとなると、どこが悪いんだろう。

`DetailView` は定義をたどると、これは watchOS でも入ってきますよね。大丈夫ですね。そもそも watchOS でビルドが変わる、というか、watchOS になっていないからかな。もしかして……その可能性は非常に高いですね。`HikeView` のプレビューが watchOS だけしか動かない可能性は、watchOS 専用ファイルなので当たり前のようにある気がします。この辺が厄介ですね。プレビューが表示されないとなった時に、プラットフォームの違いを意識する。このあたりを今、自分が忘れていてちょっと悩んでいましたけど、こういうことになってしまうのでもったいないですね。

watchOS なのだから、watchOS 以外のところではプレビューが働かないようになってほしいというか、そういうことはできますよね。じゃあ、`#if os(watchOS)`。そうすればそれだけなんでね。悩んでいたのはこれですか。そうかもしれません。そうすると、ターゲットが iOS のときには、プレビューが……プレビューの中から外していますね。プレビュー用のコードがないですよね。コードがないから本来動かないんじゃないのかなと思ったんですが、そんなことないのか。

そうか。だとすると、あり得る方法としてはこっちですね。プリプロセッサディレクティブ、こっち側を入れてあげる。そうすると、プレビューが何にも表示されないという形を取ってくれるのかな、おそらく。あれ、違うか、watchOS。今は Landmarks を iOS ターゲットで動かしていますね。じゃあ、`#if os(watchOS)` は……あれ、書き方違います？ 1 個前、1 個前。あれ、違うか。`HikeGraph` だったかな？ どこかで使っていましたよね。あった、これ。じゃあ、`#if os(watchOS)` ですよね。それで `HikeView` の watchOS。 このときにプレビューが、プレビューが外れているっていうのは、何ですかね、これね。

watchOS だったときには表示する。なので、watchOS じゃないので、そんなことしないと思っているんですけど、そういう話ではないらしい。そうか。これは放置するしかないのかな。うん。なんか不思議ですね、これね、動きが。なんでこれでプレビューが生きちゃうんだろう。今、まだロードしていますね。頑張ってビルド中なのかな。これでプレビューから消えてくれれば、変な悩みの前に「ターゲットの OS が違うじゃん」みたいな感じで、プレビューが動かないことに対する早い発見ができるようになると思うんで、これで終わってほしいんですけどね。

なんかずっと読んでいるのは、もう止まっちゃってるのかな。もう一回、一切読み込み直して……うん。まあいいか。とりあえず、じゃあ、これを昨日はしなかったけど外側にしておきますか。外側のほうが本来の形な気がするんですよね。`HikeView` を読もうとしてしまっていますけど、これは読めなかったです。ここから帰ってきて、一回消してもう一回やっても、やっぱり表示しようとしますね。

このプレビューをちょっとアクティブにしておきますか。そうすると、`@available` になって `struct` を定義して、それを `makePreview` で呼び出しているよ、という感じのコードが `#if` の中に出来上がる。そうすると、うん、悪くない感じですね。こうした時にこの中でできるけど、このベーススタックはどう使っているんだ？ このベーススタックは、`HikeView` がここに転送されていたのか。なるほどね。

なるほどね。ということで、`#if` とかを付けておけば、ちゃんとここでも機能してくれるということにはなってくる、という感じですかね。なるほど。こうした場合は中でも外でも良いという、そんな感じに見えますけど、思ったように動いていないですね。まあいいか。 とりあえず形状は良い感じなので、次に進みます。まずは `ListMenuModifier` です。`ListMenuModifier` は `Binding` を受け取るようにしました。これらは先ほど述べたように、必要に応じて `private(set)` を付けるなど、言語仕様的に適切な形に整えています。

デフォルトでは、コンテンツに対して `onLongPressGesture` と `confirmationDialog` を設定します。`confirmationDialog` ではボタンを表示し、「お気に入り」ボタンと「ユーザープロファイル」ボタンを用意しています。どちらも真偽値で制御しており、これは意図どおりです。`View` のリストメニューとしてはモディファイアなので、`Binding` を指定して渡し、モディファイアへアクセスできるようにしています。ここも問題ありません。

次は `MapView` です。これは `UIKit` と `MapKit` を使っています。`MapView` の中では、`@AppStorage` として `MapView` の `zoom` が保存されており、`private var` で `zoom` プロパティを持ちます。`coordinate` は `let` で良いので、そのようにします。`body` では、マップをリージョンで表示します。

この「リージョン」という名前が少し紛らわしく、何のリージョンなのか（ランドマークの座標から作るリージョンなのか等）が分かりづらいところがあります。座標からリージョンを生成するので、命名は単に `region` で良さそうではあるものの、若干微妙さは感じます。`MapView` に対してリージョンのスパンを求める拡張を用意しており、近隣・中間・遠いといった区分に応じて倍率を決めるスパンを返すようにしています。ここでの「スパン（span）」は英語で「長さ・期間・範囲」といった意味があり、可視範囲の広がりを表す言葉として妥当ですね。そのため、`MapView` の「リージョンスパン」という名前より、`MapView` の「スパン」のほうが分かりやすいかもしれません。ひとまずその方向で名前を調整しておきます。いずれにしても、マップは問題なく表示できており、`MapView` もきれいに書けていると思います。

次はプロファイル用のツールバーです。これは `ViewModifier` で、`Binding` を扱うので、ここも `private(set)` を付けておくのが言語仕様的に良さそうです。`body` ではツールバーに、プロフィールを表示するボタンを追加しています。`extension View` でこのモディファイアを使えるようにしており、ここも整然と書けています。

続いて `ShowFavoritesOnlyToggle` です。名前はややこしいですが、要は「お気に入りのみを表示する」ためのトグルボタンです。トグルボタンを「トグル」と呼ぶ慣習に従って命名していますが、初見では少し分かりづらいかもしれません。今回は慣習に合わせる方針にしています。ここも `private(set)` を付けておくのが良さそうです。`body` は `Toggle(isOn: $favoritesOnly)` という形で、特に難しいことはありません。

最後に `StarImage` です。これは構造体で、`isActive` は `let` で良いのでそのようにします。`body` は `Image` でスターを表示し、色はどこから持ってくるかという点ですが、`StarImage` の extension で `color` を定義しているので問題ありません。 これで良いです。スターイメージとして、プライベートでアクティブのときはこのスターイメージ、インアクティブのときは別のスターイメージを使うことが簡単にできるようになっている、ということを示します。これ、自分で作っておいて何ですが、ちゃんと作れているかなと確認します。

フェイバリットボタンの`isSet`は、状態によって変わるのでしょうがないですね。あとはこの定義で良いはずです。ここも状態によって変わりますが、`isFavorite`だったときにはスターイメージのアクティブのものを表示します。あるなら使いましょう、という感じですね。アクティブで大丈夫です。実際にインアクティブに変えてみると、色が変わります。ちゃんと変わりますね。大丈夫です。`isFavorite`だった場合にはアクティブですよ、ということを取れていてOKです。

用意しておいたのに使い忘れていました。といっても、これくらいなら用意するほどでもないとは思いますけどね。

次に、スターイメージの拡張ですが、`systemImageName`を`private`で拡張することによって、ファイル内だけで使う（内部的に使う）ようにしています。`systemImageName`はこれですよ、と。具体的なシンボル名は外に出していません。

`isActive`で判断して選ばれるのはシンボルもカラーも同様です。`isActive`だとカラーが選ばれます。このカラーもカスタマイズできるようにする手はあります。たとえば、`tintColor`というカラーを持たせて、イニシャライザで`tintColor`を`yellow`のように渡せるようにしておきます。そうしておいて、`foregroundStyle`に`tintColor`を渡すようにすれば、カスタマイズが効くようになります。

たとえばプレビューで、`Image`に`isActive`を指定し、`tintColor`に`blue`を渡すと、青色の星になります。こういったことができます。`false`の場合は`tintColor`がどう効くのかという点ですが、たとえば`green`にするとグリーンになります。大丈夫ですね。どう効くかというのは、ここの`foregroundStyle`で決まります。これで`systemImageName`の色が変わっていきます。

今回の場合は星は黄色なので問題はありませんが、ライブラリとして提供するときには「ここでは緑で表示したい」といった要望にも対応できるようになるので、悪くない対応だと思います。ライブラリとして考えるときは、ですね。

そんな感じで、ここもうまくできています。区切りも良いですし、時間的にもいい具合なので、今日はこのくらいにして、次回はまたランドマーク周りのビューのところから、今みたいな感じで様子を眺めつつ、直したほうが良さそうなコードを見ていくつもりです。

まずはコードを直してきれいにします。これは`tintColor`ですよね。`tintColor`を受け取り、`tintColor`を渡しています。だからここ、`color`が`isActive ? .yellow : .gray`のように状態によって変わるのですが、ここは危ない、バグっていました。ここが`color`で、この`color`の中で、`isActive`なら`tintColor`ですね。ここで`tintColor`を返さないといけません。あ、そうか、非アクティブのときはグレーになるんだ、そうですね。

というふうに作っている、という感じです。ただ、仕様としては、先ほどのように非アクティブ時に必ずグレーにしないほうが良いかもしれません。本来はいろいろな場面で使えるように作るので、グレー固定にしない設計のほうが良いですね。その辺が難しいところです。

それと、この`color`という変数名の意味が微妙になっています。`color`はイメージの実際の色なので、`effectiveColor`のような名前にしておくと、「実際に適用される色がどんなものか」をこの中で決定したうえで、有効なカラーを返すという意図が伝わりやすいです。アクティブではないときにグレーにするのが嫌な場合は、`tintColor`とは別のカラーを指定できるようにする、という手もありますが、今回はこの方針でいきます。危ない、バグるところでした。

こんな感じでタイミングはOKなので、次回はまた近いランドマークのディテール周りから、リファクタリング（観察）を進めていこうと思います。

では、これで終わりにしますね。お疲れ様でした。
