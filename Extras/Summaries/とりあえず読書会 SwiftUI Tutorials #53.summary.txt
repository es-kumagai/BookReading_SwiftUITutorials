Transcription & Summarize : とりあえず読書会 SwiftUI Tutorials #53

それでは始めていきましょう。引き続き、SwiftUIチュートリアルを読み終えて、リファクタリングをしているところです。大詰めではありますが、前回の内容も踏まえて解説しつつ、直すところがあれば直していく、そんな感じで進めていきます。残すところもあと少しで、うまくいけばあと1〜2回で終われるかなというところですが、いつもどおりスムーズに終わらないことも多いので、もうちょっと続くかもしれません。何にしても、とりあえずコードを見ていきましょう。

チュートリアルで完成したコード、つまり完成したアプリがあります。その中のアニメーションまわりを見ていき、ここから変更すべき点がないか確認していく流れです。`Animation` をextensionしている部分があり、`ripple(index:)` のようなAPIを用意しています。ここでいう `index` は何を表しているのかが直感的に分かりにくい感じがします。

`ripple` はいわゆる波紋のように広がる、跳ねる感じのアニメーションで、`dampingFraction: 0.5` を指定し、`speed(2)`、そして `delay(0.03 * Double(index))` のように、`index` に応じて遅延をずらしています。つまり、`index` 自体は遅延のずらし量に使っているわけです。であれば、単に `index` とするよりも、用途が分かる名前にしたほうがよさそうです。例えば「遅延の係数」という意味で `delayCoefficient` のような名前にするのはどうか、と考えました。

ここで「係数」は英語だと「coefficient」なので、`delayCoefficient` というプロパティ名・引数名にする発想です。ただ、「coefficient」という語はやや数学寄りに聞こえるため、一般的なアニメーションAPIの文脈では少し硬い、あるいは不自然に感じられる可能性があります。英語のAPIデザインとして適切かどうか、表現が不自然でないかは一度検討したほうがよさそうです。用途が「掛け算の係数」であることを素直に示したいなら `delayMultiplier` なども候補に挙がりますし、より意味を限定したいなら `staggerIndex` や `staggerStep` のように「段階的にずらす」という意図を伝える名前も考えられます。数学寄りに聞こえすぎる命名は、一般的なアニメーションAPIでは不適切かもしれません。用途が伝わる、より自然な語を選ぶ方向で検討します。 どういう名前がいいかを考えています。絶対的な正解はないのですが、「倍率（factor）」や「multiplier（マルチプライヤ）」が候補になりますね。Swift でもよく出てきます。「factor」でも良さそうです。

「フェーズ（phase）」、あるいは「位相ズレ」という表現も思いつきますが、専門用語は誤解なく意味を伝えられるとき以外は選ぶべきではないという API デザインガイドラインがあります。今回の用途で「位相ズレ」が本当に適切かどうかは慎重に判断する必要があります。そう考えると、「間の刻み」「間隔」「インターバル」といった表現の方がしっくりくるかもしれません。このあたりであれば、`delayFactor` という名前で良さそうですね。難しいところではありますが。

`delayFactor` であれば、ブール値のフラグのようなものは不要になります。引数名は外から見えるラベルではなく、内部変数名として `factor` にしておき、呼び出し側では `delayFactor` として渡すのが分かりやすいと思います。

型については、ここは `Int` ではなく `Double` にした方が良いですね。そうすると、他の場所でエラーが出るかもしれませんが、そこは直せば大丈夫です。ビルドをかけて確認します。少し見にくいですが、このままで。もう一度ビルドします。

アニメーションのリップルで `delayFactor` を指定できるようにすると、何を渡したいのかが分かりやすくなります。インデックスは `Int` ですが、`factor` は `Double` として渡すものなので、呼び出し側で `Double` に変換してから `delayFactor` にインデックスを使う、という表現にすると良いです。呼び出し元の方が絶対に分かりやすくなります。言い過ぎではないと思います。こんな感じで、よく出てくるパターンな気がしますね。`delayFactor`、これでOKです。

ではここはOKとして、次に進みます。`ContentView` の iOS 版ですね。セルなどがあるかを見ていきます。`import SwiftUI` を書いておきましょう。`@Environment` があって、`@State` があって……。

ここの型推論は少し悩みます。下は推論されているので、上も推論したいなと思ったりしますが、`active` とかタブの `Featured` とか。`body` があって、`TabView(selection:)` があって、`CategoryHome` があり、`LandmarkList` がある、という構成になっていく感じです。ここは細かく分けなくても見やすい気がしますね。`CategoryHome` と `LandmarkList` があるよ、ということで、`tabItem` があり、ラベルのテキストとシステムイメージ（`systemImage`）を渡します。

この「ラベルのテキスト＋システムイメージ」という指定は、ややローレベルに感じることがあります。以前、`star` 用のラベル（や `Image(systemName:)` のヘルパー）のようなものを作っていたので、そのノリで `StarLabel` を作っておくのも良さそうだな、と一瞬思います。ただ、下のタブは `list.bullet` なども使うので、結局同じようなものを複数作ることになり、少し手間かもしれません。SF Symbols の名前を文字列リテラルで表現しているのが少し見にくい・怖いと感じることはありますが、そこに対応し始めるとキリがないので、今回はこのままで良いでしょう。ラベルのテキストと `systemImage` を素直に渡します。

この中での表現は、計算プロパティとしてローカルに用意して渡していってもよいかもしれません。タブは下側のタブバーなので、`tabItem` で設定します。`Featured` のタブと、もう一つのリストのタブですね。このあたりはこのままで良いと思います。

もう一つの手として、`ContentView` に拡張を追加して、タブの共通処理をまとめる方法もあります。そこまで必須ではないかもしれませんが、試してみましょう。`private extension ContentView` として、`tabItem` 用のヘルパー関数を用意します。`some View` を返し、`@ViewBuilder` でコンテンツを受け取る形が良いですね。`Tab` といった独自の型を定義して渡すのは、少しやり過ぎな気がするのでやめておきます。代わりに、ラベルのテキストとシステムイメージ名を引数に取ります。`systemImage` は実際にはシンボル名の文字列なので、引数名は `systemImageName` の方が誤解がなくて良いと思います。

たとえば、次のような関数です。

```
private extension ContentView {
    func tabItem(
        label: String,
        systemImageName: String,
        @ViewBuilder content: () -> some View
    ) -> some View {
        content()
            .tabItem {
                Label(label, systemImage: systemImageName)
            }
    }
}
```

最初は「Non-void return value」や「Return type を指定せよ」といったエラーが出るかもしれませんが、戻り値を `some View` にして、コンテンツを `@ViewBuilder` で受け取るようにすれば問題ありません。`Label` の引数も、`systemImage` は実体としては名前の文字列なので、`systemImageName` という引数名にしておくと意図がはっきりします。

このようにして、まずコンテンツを出し、それに対して `.tabItem { ... }` のモディファイアで `Label`（`label` と `systemImageName`）を設定する、という形にまとめられます。これで見通しが良くなりますね。 まずはこういうふうに書いておけば、タブを切り替えるときにタブアイテムとして Featured、そして `systemImage` が `star`。コンテンツはこの `CategoryHome` ですよ、というふうにできます。こういった書き方ができるので、どうなんでしょうね。いわゆる “それっぽい UI” らしくないと言ってしまえば、そんな気もしないでもないですが、まあ一応こういうふうに書くことはできます。

タブアイテムは今はブロックで書いていましたけど、もっと汎用性を持たせたい場合にはタブアイテム用の型を作って、`TabView` の中で使う、みたいなやり方も考えられます。こうしておけば、なんとなくきれいにまとまるかなと思うのですが、あえてそういう作りにしていないのも面白いですね。`ViewBuilder` 的なところでなんとかしているのでしょうけど。`TabView` は `ViewBuilder` なのかな。

「List」タブのほうは、ラベルは "List"、`systemImage` は `list.bullet`、コンテンツは `LandmarkList` ですね。こちらのほうが考えることが少なく、わかりやすいと言えばわかりやすいです。ちゃんと動いていますし。自分だったらこうやりたくなってしまいますが、UI の“遊び”という感じではちょっとないでしょうかね。

それと、`systemImage` の名前をリテラルで書かないといけないのが非常に気になります。まあ仕方ない面もあります。アイコンの種類がたくさんありますからね。もしそれが嫌なら、`SystemImage` みたいな型を作って、列挙型のケースで列挙し、それを選択するという手法もあります。少しここで試してみましょうか。とはいえ、ここでやってもしょうがない気もするので、`systemImage` の使用箇所を軽く検索してみます。まあまあ使っていますね。

では `SystemImage` 型を作ります。ちょっと二度手間な気もしますが、試してみる価値はあります。どこに型を作るかですが、ビュー周りはモジュール化しているので、このビューのコントロールではないですね。いろいろありますが、ひとまずこの辺に適当に作ります。まだまとめる場所が決まっていない、そんな感じです。

ここで `SystemImage` という型を作って、`enum SystemImage: String` のように `RawValue` は `String` にします。`systemImage` はどこで使うかというと、`Label` で使います。ケースとしては、例えば `chevron.right.circle`。ただ、こうしてケースを用意していくとキリがなくなるので、あんまり良い手ではない気もします。でも、ときどきこの“型で包む”やり方を普通に取ることもあるので、試して感覚をつかむくらいは良いでしょう。

このままだと、`Label` に渡すときに `SystemImage.chevronRightCircle.rawValue` のように書かないといけません。これは逆に嫌ですよね。そこで、`SystemImage` の中で `import SwiftUI` しておいて、`systemImage` を想定した `Label` のラッパーイニシャライザを用意すると良いでしょう。`extension Label` で、`Label` のイニシャライザの設計を参考にします。`Label` はタイトルが `View` のイニシャライザもありますし、`LocalizedStringKey` を受け取るイニシャライザもあります。とにかく、`SystemImage` を受け取って内部で `rawValue` を使うイニシャライザを定義します。

つまり、`extension Label { init(_ titleKey: LocalizedStringKey, systemImage: SystemImage) { self.init(titleKey, systemImage: systemImage.rawValue) } }` のようにして、`self.init` を呼ぶ形です。タイトル（`Title`）と、あとは `systemImage.rawValue` を渡すだけですね。

ここで少し引っかかったのは、`rawValue` がオプショナルに見えた点です。`SystemImage`、これですよね。`rawValue` を使うイニシャライザは `String` から期待する形で用意されています。なるほど、これは…どのイニシャライザを取ってきたのか、という話になってきましたね。あ、そうなんだ、`rawValue`、つまり取ってきたイニシャライザは何でしたっけ……。 もう一回これを取りましょうか。これはシステムイメージのネームと、`LocalizedStringKey`ですよね。`LocalizedStringKey`、`String`ですよね。これ、なんでオーバーロードが呼ばれないんでしょう。`Label`は構造体ですよね。構造体です。タイトルとアイコン、つまりタイトルとアイコンですね。

あれ、これなんで変わらないんでしょう。イニシャライザーでタイトルキーと、`self`でイニシャライザー、タイトルキーとシステムバリュー……いや、`systemImage`があって、あと`String`なんて書く必要はないと思うんですけど。これは補完、またはデフォルト、あ、そういうことか。イニシャライザーの定義の間違いでしたね。失敗可能イニシャライザーに…あれ、なってましたっけ？

もう一回定義例を取ってみましょうか。`nonisolated init`で、しかも失敗可能ではないですよね。もう一回、このイニシャライザーの中で、誰に怒られているんでしょう。引数ラベルの省略…もう一回、ラベル省略がありますね。`resource`と`systemImage`、うん、大丈夫ですね。で、これはもう一回、このフィックスを勝手に…なんでしょう。こういったときは大体、些細な自分のミスということが多いので、ゆっくり見たほうがいいんでしょうけどね。

これは`Label`があって、例えば、ここで引数ラベルを省略させないようにしたときも、結構出ますね。だから、オーバーロードのミスではないですね。で、タイトルは`LocalizedStringKey`に対して、イメージは`systemImage`で…いや、でも自動でこっちに補完されますね。だから、完全に誤認していますね。その上で、`self`に`init`があるかを見ると、あ、ないんだ。そう、ないのか。

`Label`ですよね。`extension Label`、`Label`のイニシャライザー。ちょっと一回、イニシャライザーの定義を消してみますか。これを消して、その上で何があるかですね。関数が何かあって、その中で`self.init`。`self.init`ってどっちか。`self.init`、そしてこれ。`titleKey`と`image`ではなくて、`titleKey`と`systemImage`、これですね。ここで`LocalizedStringKey`と`systemImage`ですよね。

こうしたときに、イニシャライザーで、`LocalizedStringKey`の`titleKey`をラベル抜きで取り、その後の`systemImage`というのを`String`型で渡します。`systemImage`の型は`String`型ですよね。これでオーバーロードしたはずなんです。その上で、何も初期化しないとダメなので、`self.init`を呼び出さないといけない。なので`self.init`ですよね。このときに、`init`の候補に出てこないというのは、どういうことでしょう。これは自分の勘違い…なんでだろう。`self.init`でしょ。`super`なわけないですよね、`Label`は。`self`の…あれでも`init`ここまでだと言いますね。あ、でも自分で定義したやつだ、これ。いない。あれ、`Label`ってクラス？そんなわけないですよね。ストラクトですよね。それでタイトルとアイコン。

で、`View`…あ、そういうことか。`ViewBuilder`、タイトル・アイコンの`ViewBuilder`か。`ViewBuilder`のタイトルとアイコン、そんなのもありますね。便利そうに。で、あとは…イニシャライザー、これですね。あ、あった、これだ。`Label`でタイトルが`Text`、アイコンが`Image`のとき、このとき限定だ。だからこれの条件が抜けていたってことですね。で、その条件はここだ。だから、タイトルとアイコンで…なんだっけ？`Label`で`Text`と`Image`でした。つまり、`where Title == Text, Icon == Image`の条件付きのイニシャライザーに当てはまるやつです。 こうしたときに `init`、ここでできました。これで今度は大丈夫ですね。オーバーロードになっているけれど、これでいいはずです。タイトルキーとシステムイメージは、イニシャライザのオーバーロードですね。もうできました。ジェネリックパラメータ、なかなか難しい作りになっているんですね、ラベルって。知りませんでしたが、これでできました。

そうすると、ここでいちいちローカライズを気にしなくていいですし、システムイメージを渡さなくても、システムイメージのタイトルを指定しない形で、さっと取得できるようになったということです。まあ、出来上がれば良いのですが、ちょっと自分でもやり過ぎかなという気は確かにあります。

それと、Xcode の動きが変わっている気がします。気のせいでしょうか。この勉強会で何回か設定している気がするのですが、Xcode 側が変わったのかもしれません。Option キーでクリックすると…そう、ナビゲーションですね。Option キーのときに Next Editor ペイン、えっと、Next Editor か Separate Editor、そんな項目があった気がしますが、今言ったところではないかもしれません。まあいいか。

これで作りました。次は、ここは `systemName`、`systemImageName`。これはそのまま持っている感じなのと、`systemImageName` はどこから取ってきたんだっけ…あ、これか。`star.fill` と `star`。なるほど。これも一緒に考えることができそうですね。だから、`star.fill` なので、`case starFill = "star.fill"` と、`case star = "star"` のように作っておいて、今回は `systemImageName`…あれ、`systemImageName`。イメージは `systemImage`。大丈夫かな。大丈夫ですね。なので、これは `systemImage` に変えて、`systemImageName` ではなくなりますよね。

それで、対象もアクティブの状態に応じて、`star.fill` なのか、それとも `star` なのか、という切り替えができます。全部が実際にできれば、書き心地はいいですよね。

そうした上で、ここでエラーになると、やっぱり `Image` で使っていますよね。なので同様のことをエクステンションで行って、`Image(systemName:)` になっているけれど、システムイメージとして引数を取って、`systemImage` で `self.init`…これもダメか。定義を辿ってみますが、あれ、定義が出ない。`Image(systemName:)` のオーバーロードの形になっちゃっていて、これはイマイチですね。

`Image` のイニシャライザを見ると、`Image(systemName: String)` ですね。`Image` 型はエクステンションではなくて、型定義としてどうなっているか…どこだ…ここかな。ここ、`Image: Equatable, Sendable`。パラメータとかには特にないですね。 エクステンションした上で、やはり `init` ですね。OK です。そうすると、このイメージもシステムイメージとして、この `systemImage` パラメータにそのまま渡せる状態が整いました。ここも、システムイメージが残っていたので書き換えました。これで、こちらはシステムイメージで、`person.crop.circle` を定義します。

この辺ですね。`case personCropCircle = "person.crop.circle"` のような感じです。これは `Label` なので、システムイメージとして普通に使えます。ここで `person.crop.circle` を渡します。中身を隠している感じはしないですが、まあまあ、この調子で進めていきましょう。これで次も大丈夫そうです。次も同様に問題ありません。

次は新しいやつで、同じような調子ですね。`line.3.horizontal`、3ってなんだろう？まあ、しょうがないか。`case line3Horizontal = "line.3.horizontal"` のようにしておきます。名前の歯切れが悪い感じはしますが、まあ、しょうがないですね。ここで `line.3.horizontal` を使います。選べるべきところが良いですね。

次は `ContentView`。この辺は良い感じにやれています。ここを持ったら、`systemImageName` か。`subItems` を改良しようとして頑張っていたところです。なので、これを受け取って、`systemImageName` ではなく `systemImage` にして、`systemImage` を使います。ここはさすがに、その目的で作っただけあって、きちんと効果が得られる、そういう感じですね。

システムイメージは、これはダメか。`Label` で、`systemImage` で、えっと、`systemImage` は `String`。これ、`Label` 変えなかったっけ？`Label` は、あ、これは `String` か。なるほど。`Label` のタイトルはローカライズのキー、`LocalizedStringKey` ですよね。これなら取れますよね。

今の書き換えは少し不毛に見えますが、最初からこの辺を整えておけば、書き心地は悪くないと思います。ここで使っているイメージがここでリストアップされるのは、あまり利点じゃないのかな。`list.bullet` のように並べられていて、一見落ち着くんですけど、並べる必要性はないですよね。`list.bullet`。まあ、とりあえずこれはこれで良いとして、次はここです。

あ、こっちも。システムイメージで、ラベルもシステムイメージで。できましたね。これで書き換えられました。こういうふうにすることで、「まあまあ難しいんだろうな」という処理でも、見通しの良いコードが書けました。 タブを増やしたいときにはサクッと書ければよいのですが、なぜこういうインターフェースをSwiftUIは用意していないのかという点は、少し検証しないといけない気がします。`TabView`の定義を見てみると、`init`で`@ViewBuilder`な`content`を受け取っています。つまり、`@ViewBuilder`経由で渡したビューが、それぞれきちんとタブとして認識されるわけで、これはすごいと言えばすごいですね。`ViewBuilder`の中でどうやって判別しているのか不思議です。`TabView`がひとつ得られるだけで終わりそうなのに、ちゃんとタブとして認識しています。この辺は本当にどうやっているのか気になります。

いずれにしても、これでいい感じに整ったので良いでしょう。`sheet`も悪くないですね。直感的に表現できました。`ContentView`として、タブに`Featured`と`List`があることが分かりますし、さらに`tabItem`といったメソッドを使って、コンテンツにタブアイテム（タブ）を付けるのを自動でやってくれるので、便利になりました。こんな感じでしょうか。

がっつり進めます。`ContentView`のmacOS版です。`Environment`や`State`ですね。`body`でちゃんと`List`があって、その中でいろいろ処理しています。ここは何かいじれるのでしょうか。`VStack`なので垂直方向のレイアウトです。この`VStack`は、`HStack`と`ProfileSummary`をまとめる役割ですね。`HStack`の中では、`Spacer`があって、その先に`Button`があります。`showingProfile`に関係するボタンなので、そのスタイルを当てています。`HStack`は`ProfileSummary`と`Button`で構成されている、と捉えると分かりやすいです。ヘッダーに当たる部分ですね。そう捉えると、定義を分解していくという観点も出てきます。

この間にちょっとプレビューしますか。あ、プレビューできませんね。これはmacOSだからですね。macOSのプレビューは厄介なので、`ContentView`のこちらを、別の`PreviewProvider`で見る形でしょうか。`ContentView`の中に`LandmarkList`があって、そのコンテンツで`showingProfile`を使い、さらにその中で`sheet`を出しています。シートの中には閉じるボタンがあり、`Image(systemName: "xmark")`を使っています。これはシステムのイメージ（SF Symbols）で、`xmark`ですね。

ここはヘッダー部分に当たるので、`ContentView`の`body`からヘッダーを切り出してもよさそうです。たとえば、`HStack`で構成しているヘッダーを`HeaderView`とし、`ProfileSummary`と分けるようにします。`private extension ContentView`の中で、`@ViewBuilder`を使って`var headerView: some View`、`var summaryView: some View`のように定義し、該当箇所をそこに貼り出すイメージです。こうやって細かくビューを分けると、今のところ自分には分かりやすく感じます。テーマ性も大事ですが、分かりやすさのほうが上回っている印象です。当面はこの方向性でいきます。無理に分けられないならそのまま書きますが、そうでなければ名前を付けて適宜分割していくほうが、コードは追いやすいですし、デザインとの関連でも追いやすい気がします。

これで一通りできたことになるでしょうか。一応動いていそうではありますが、本当にヒットしているのか、フォーカスが合っていなかったですよね。 なので、このアプリを2個開いていましたね。1個、というか両方いったん閉じてもう一回実行してみて、今のビューがちゃんと表示できるなら、ひとまず完成、というかリファクタリングは成功という感じになるのでしょう。うん、大丈夫そうですね。はい、OKでいいでしょう。

ではこういうことにして、シートの中ではヘッダービューとプロフィールサマリーが左側に詰まるように配置されています。ヘッダービューは先頭に`Spacer`を入れて右寄せにしています。つまり、Xマークのボタンが右側に表示されています。いいですね。これで完成として進めていけばいいでしょう。

次に`ContentView`のほうを見ていくと、プレビューですね。`body`では`List`があり、`Task`がいきなり上がってきます。シートがあって`ProfileSummary`だけなので、ここはいじることはないですね。`Task`についても、特にいじることはないと言えます。

タスクの中で`UNUserNotificationCenter.current()`を取得していますが、これは外に出してもいいかもしれません。`current()`ですからね。たとえば、`private let userNotificationCenter = UNUserNotificationCenter.current()`のようにしておき、タスク内ではそれを使う、というのが便利というか妥当な感じを受けます。

このとき、値を捨てているのが気になっています。なぜ捨てているのでしょうか。`requestAuthorization`は`async`版だと`Bool`を返します。エラー送出と`Bool`の組み合わせは一般にはあまり好まれない設計と捉えられますが、ドキュメントを見ると、`UNUserNotificationCenter`の`requestAuthorization(options:)`には、`completionHandler`を使う従来のメソッドと、`async`な代替メソッドがあると書かれています。`Bool`は`granted`、つまり許可されたかどうかを表します。`completionHandler`版ではクロージャに`granted`と`Error?`が渡され、`async`版では`Bool`を返しつつ`throws`します。いずれの場合も、今は`Error`も戻り値も捨てています。捨てるなら、空のクロージャを渡すか、あるいは戻り値未使用の警告を避けるために`_ =`で明示的に捨てる、といった書き方が必要ですね。

これが`.task`ではなく`onAppear`だったら、多分また別の書き方になりますが、どちらが良いかは好みの問題もあります。自分としてはこの構文があまり好きではないというだけです。ただ、これを書かないと「戻り値を使っていない」と警告されてしまうので、それはよろしくないですね。では、これでいいでしょう。

次はシートですが、これはサマリーなのでOKです。これでいったん表現はできました。そうすると、やはりこの`Task`が微妙に気になります。これのために`onAppear`にする手もあります。`requestAuthorization`で取得した認可情報は、一般的にはここで加味して何かしますよね。メッセージを出すなり。しかし、そのあたりも考えると、ひとまずは捨てておいて、将来的に何かしたくなったときに拾う、という方針で良さそうです。やっぱりこれにしましょう。

こんな感じで、ひととおり見てきた気がしますし、時間もいいところなので、この`LandmarkSettings`を見ていくのはまた次回にしましょう。では、今日はこれで終わりにします。お疲れ様でした。
