Transcription & Summarize : とりあえず読書会 SwiftUI Tutorials #32

ええ、では今日は、とりあえず移植をやっていきましょう。SwiftUI チュートリアルの内容を、iOS 用に作ったものをそのまま活かしつつ、macOS アプリに作り変えるというのが、今回の深い話ではないでしょうか。共有コードをできるだけそのまま使いながら、とにかく iOS 用に作ったものを macOS 用にも対応させていこう、というセクションです。もちろん iOS でやった内容ですが、それにしてもチュートリアル自体が先を見据えて作られている面もあり、思ったより iOS のコードだけでいい感じのものが macOS でもできてしまうのは、見ていてすごいなと感じます。

今日はセクション3の続きからです。とりあえずセクション3、「Row ビューを更新していく」。更新というのは、iOS 用のコードを macOS 用に更新するという意味なのかもしれません。ランドマークの Row ビュー、つまり `LandmarkRow` が macOS でどうなるか、ただしその `implementation`（実装）を `reusing`（再利用）する、という文脈のようです。英単語が2つくらいわからない、という状況は英語が得意な人でもあるでしょうが、日本語で知らない単語が2つも連続で出ることはあまりないですよね。出てきたときはとりあえず聞き流して後で理解したり、その場で調べたりといろいろやると思いますが、なかなか難しいところです。

実装をプラットフォーム全体にわたって再利用することには価値がありますし、より新しいビジュアル環境に合わせて良くしていく余地がある、という話も出てきます。このビューは今回の3つのプラットフォームすべてで使われるので、注意深く変更して、それらがきちんと動くようにすることが重要です。これはクロスプラットフォーム開発でとても重要なポイントで、同時に気を抜くと破綻しやすいところでもあります。そこを実際に体験していく、そんな流れになっているようです。

これが `LandmarkRow` ビューですね。スクリーンショットがかなり大きく載っていますが、まあそれでいいのでしょう。

Row を修正する前に、リストのプレビューをセットアップします。どのように Row が文脈の中で見えるか（looks in context）を確認するためです。ここで、チュートリアルの文に出てきた表現が少し気になりました。「You'll make a drive」というところです。いったん文全体を見てみよう、ということで、まずは意味を取ります。「あなたが行う変更は、その Row が文脈の中でどのように見えるかによって決まる」という趣旨のようです。

せっかくなので ChatGPT にも聞いてみました。ポイントは「the changes you'll make」という名詞句で、`you'll make` が関係詞の省略のように後ろから `changes` を修飾して「あなたが行う変更」という意味になっていること、そして `driven` が「導かれる、左右される」という意味で使われていることです。つまり、「あなたがこれから行う変更は、その Row がコンテキスト（文脈）の中でどのように見えるかによって左右されます」という解釈で良さそうです。なるほど、という感じですね。

こんな感じですかね。 では、そんな感じで次、ステップ1に進みます。LandmarkList を開いて、minimum width（`minWidth`）を追加します。これは、ビューを改良する、進化させる、改善する、改良するといった目的ですね。ユーザーが OS のウィンドウをリサイズしたときに、リストが破綻しないようにするため、最小幅を設定して、あまりにも小さくできないようにします。ランドマークリストのフレームに `minWidth` を付けてあげる、まずはこれをやっておきます。とりあえずはこの1行をリストに対して付けるだけで良さそうです。その予定で、まずはやってみます。

ステップ2として、List のプレビューをピン留めして、行（Row）の表現がコンテキスト内でどう変わるか、変更を加えたときに何が起こるかを見られるようにします。このためにリストのプレビューを固定しておきます。ランドマークの Row に進む前に、ランドマークリストが OS ごとに分かれていたかどうかを一瞬考えましたが、OS ごとではなく複数あるだけですね。ランドマークリストは OS のウィンドウに表示するもので問題ありません。プロフィールツールバーは自作のものなので、iOS のときにツールバーを表示し、それ以外のプラットフォームでは長押しの機能を作ろうとしたのですが、だいぶ違っていたので無効化している状態です。以降、macOS でも `minWidth` を付けてしまって良いのか、画面が小さいときにやばそうでは、という懸念はあります。例えば watch みたいな小さい画面では厳しそうです。今回はいったんそういうことにしておきます。ランドマークリストをウィンドウで表示しておいて、このあたりがこれでアップデートされるはずです。タイトルの略称が気になっていた件は、ちゃんと対処済みですね。同様に、今気になっている `minWidth` も適切に対処することになるかもしれません。

ステップ3。LandmarkRow を開いて、見栄えを良くするためにイメージに corner radius（`cornerRadius`）を付けます。ランドマークローのランドマークイメージに対して `cornerRadius` を設定します。続いて、`VStack`（`alignment: .leading`）でランドマーク名をラップし、その下にパーク情報を追加します。その際、名前は `bold()` にし、パーク情報は `font(.caption)` にして `foregroundStyle(.secondary)` を指定します。ランドマークローは `LandmarkRow` で行を扱っているので、そこを更新していきます。ランドマークローのイメージに `cornerRadius` を適用すると、角が丸くなります。その後に `VStack(alignment: .leading)` を置き、コンテンツの中で `Text(landmark.name).bold()` とし、さらに `Text(landmark.park)` を入れて `font(.caption)`、`foregroundStyle(.secondary)` を指定します。確かに、これで見た目が良くなります。

次に、ここまでできたら、続きとして `padding(.vertical)` を Row のコンテンツの周りに付けて、各 Row に適度な余白を持たせます。これは Row の `HStack` に対して `padding(.vertical)` を付けるイメージです。具体的な値はいくつだったか忘れましたが、これがないと詰まって見えるので、少しスペースができると良い感じになります。はい、これで次へ進みます。

この方針で iOS の表示が良くなったら、他のプラットフォームでも調整する必要があります。別のリストや他のプラットフォーム、特に watchOS が気になります。さきほどの `minWidth` などは watchOS だとやばそうです。 ここで watchOS ターゲットを選んで、watchOS のプレビューを `List` で見ます。すると、最小行の高さが適切ではないことが分かるらしいですね。これについての理由や、ほかの方針は次のセクションで直すので、ひとまず進めます。良い解決策としては、幅の制約にとらわれない watchOS 用の `List` を用意してあげるのが良いとのことです。

最初は Shared View を作れば済むかなと思ったのですが、`LandmarkRow` を watchOS 向けに作ってしまうのか、という話になっています。Shared View で済ませても良さそうな気もしますが、まあいいでしょう。`padding` と画像のサイズ指定があるだけですよね。型も指定されていますし。チュートリアルに従うか、それとも独自に進めるかという状況で今考えています。

では、`LandmarkList`。新しい `LandmarkList` を追加します。まずは追加してみましょう。あまり意味がなさそうであれば、後で統合します。`LandmarkRow` のソースがここに出ているのは何でしょうね。これがあって、プレビューがあって、ステップ7で追加するようになっています。

新しい SwiftUI ビューとして `LandmarkList` を作る、ということですね。Row と List も作ってしまうのか。そして、古いファイルはファイルのメンバーシップから外してあげる。それから、`LandmarkList` のコンテンツを新しい方にコピーしますが、`frame` モディファイアは外しておきます。今は横幅を使って表示していますが、それぞれの Row は情報が多すぎます。情報も削っていくので、専用のものを作った方が良いという話でしょう。まずはここまでやってみます。

やることは、一から作ると言っていましたが、複製すれば良いですよね。`Landmark` のビューの `LandmarkList` と、あとは Row、つまり `LandmarkRow` ですね。`Command-D` を押すとコピーされて複製されるので、これでいきましょう。これで watchOS 専用の作りになります。

まず古い方の設定で watchOS を確認して、新しい方はここで一旦プレビューを止めておきます。どうしましょうか。入れておきますか。`LandmarkRow` はすべてのプラットフォームに付いているので、iOS と macOS のメンバーシップを外します。これで watchOS だけになります。

watchOS のプレビューを見ていませんでしたね。watchOS のプレビューがまだ反映されていないようです。今も表示されると思うので、表示されるなら確認しておきましょう。多分、正解に近い状態になっているだろうとは想像がつきますが、実際はどうなっているか。プレビューが出るのを待ちます。待てればそれで良いでしょう。

`List` も複製しておきます。とりあえず、`Command-D` で `LandmarkList` を watchOS 用にします。これを watchOS 向けにして、古い方の `LandmarkList` からは watchOS を外し、新しい方は watchOS だけにします。こうしておいて、この時のデバイスプレビューがどれなのかは少し気になりますが、多分問題なく、新しく作った watchOS 用のものだと思います。

これで watchOS のプレビューが出てくるのを待つのも良いのですが、一回ビルドしてみます。ビルドが成功することを確認したら、もう一度 watchOS 用のプレビューを有効化します。これでどうなりますかね。あとはデバイスの設定は、Apple Watch で Automatic、サイズは一応 Large にしておきます。これでいきましょう。これで表示が少しまずいことを確認できるはずです。

プレビュー待ちです。プレビュー待ちの間に何かしてしまうと、プレビューのおかしいところを見られなくなってしまうのももったいないので、また表示されるのを待ってみます。 ただ、待つと言っても表示されないことが結構ありますよね。これまでの配信の感じだと、ライブにして止めておけばいいというものでもなさそうで、そのうちできるようになっていたりはするのですが、なぜなんでしょうね。ひとまず一回クリーンしておこうかな。ビルド自体はすぐ終わると思うので、クリーンしてビルドし直して、これで大丈夫かな。これで大丈夫ならいいのですが、プレビューが出ないときに何が邪魔しているのかは知りたい気がします。Xcode を再起動してもダメなときはダメだし、クリーンしてもダメなときはダメだし。今回はこうやって実行されている状況なので、そこは足は引っ張らないと思うのですが、いったん止めてみました。この状況でどうでしょう。

一回さらに、何モードって言ったっけ。選択モードみたいなやつを選んでから、プレビューモードを Select から Live に切り替えて、Preview in Canvas、Preview as App なども試してみます。Preview as App、アプリとしてプレビュー…何でしょうね、どうしましょうか。あ、思い出しました。例えばキャンバスで macOS 用のプレビューを出すために、前回は何か別のモードにしましたよね。もしかすると、その影響があるのかな。

あと、Preview as…どこだっけ。Preview in Canvas にして、Editor の Canvas の中の Use Selection for Previews と Execute Previews をこういうふうにしてみましょう。macOS ならこれでいけるんじゃないかな。macOS がダメなときは、さっきの有効化まで結構やらないと全然できなかったのですが…。うーん、変わらないか。

配信中はプレビューが動かないこともありますし、もしかすると LandmarkList のプレビューのアイドルが違ってずれている恐れもないとは言えません。一度プレビューのキャンバスを閉じて、もう一回キャンバスを開いてみたり、いろいろやれば動く可能性は上がると思います。ただ、いろいろやってしまうと何が不調の原因だったのか逆に分からなくなることもあって、悩ましいところです。…変わらないか。

変わらないとなると、あとはシミュレーターを落とすとかでしょうか。例えばシミュレーターを落として、プレビューに戻り、いったんビルドでプレビューを止めて、それからプレビューを再開して…これで動けばいいのですが。様子を見る限り、止めまくってクリーンになってきた気がします。今、プレビューのペアリングや Apple Watch シミュレーターの準備をしているので、これが終わったら動きが変わるかもしれません。

ビルドが終わったので、プレビューが出るかな…間もなく出たけど、今度は「プレビューが見つからない」みたいな、ちょっと面白い画面が出ました。プレビュー側が「コンパイルは親スキームと OS（デバイス）の設定に合わせてください」みたいなことを言っていて、デバイスは 11、つまり watchOS 11 かな。コンパイルのチェックも走っています。プレビューを表示するためにほかのターゲットのコンパイルも必要、みたいな感じですね。

今度こそクリーンでいけそうな気がします。クリーンしてビルドを出して、それで内容を表示して…というか、ビルドしたらプレビューで内容の表示を試してみる、みたいな感じですよね。プレビューを更新したので、今度はうまくいくかなと思ったけれど、どうかな。Automatic から Apple Watch 11 にしてみて、さらに Large、あ、さっき Small を選んだけど、混ぜてもいいんですが、Large を選んでみて…。いずれにしてもダメでしたね。

そうなると、Xcode を落としてみますか。もう一回起動して、プレビューとにらめっこしながらやっていくしかないですね。チュートリアルの流れでせっかく動かしたのに、プレビューでこんなバツ印が出るのは、ちょっともったいない気がします。「Carousel が予期しない…」みたいなのも出ていて、Carousel って何だったんだろう、そもそもそんな具体的な項目あったかな、という感じです。まあいいか。 とりあえずプレビューが覚えてくれるんじゃないかな、今度こそ。これでプレビューが復旧したら、watchOS 用にランドマークリスト、ランドマークローがめちゃくちゃな状況になっているはずなので、その中でいろいろ削っていくというか、コードを watchOS 専用に変えていく作業をやる、という流れですね。うーん、進まない。何か効けば、ここを一行消してみるとかね。で、これで…うん。まあ一回プレビューしてみますかね。ビルドをかけて更新して、あとはレガシーにもう一回キャンバスモードを直してみる、というのもあるかもしれない。watchOS のときに動かしたみたいに。

とりあえずあと10秒ぐらい待ってみます。それでダメだったら、ちょっとレガシーモードでやってみますかね。うん、ダメそうですね。なので、エディタのキャンバスでプレビューの `Use Legacy Preview Execution` をオンにします。これをオンにしたら、前回は OS で動かなかったプレビューが動くようになったので、若干期待しつつ。今ビルドが終わって表示されれば先に進めますが、プレビューされなかったらどうしましょうね。まあ、プレビューではなくシミュレーターでチェックしていく感じでもいいのかもしれません。なので…ダメですね。じゃあしょうがない。プレビューはとりあえずレガシーじゃない設定に戻して、そのうえでシミュレーターで見ていきましょう。いずれプレビューが勝手に復活したら、それを見ていくという感じにすればいいでしょう。

今シミュレーターを動かしている最中にもプレビューをオンにして、ランドマークリストのランドマークローからまず手を加えていきます。お、シミュレーターが動きました。このシミュレーターを Xcode の隣に置いておいて、様子を見ます。画面からはみ出しているのが問題なので、これを直していきます。プレビュー、完全に復活してきましたね。なんだろう、こんな画面は初めて見ましたけど。「LandmarkList の 67 行目」みたいな表示が出ています。`#if os(macOS)` の条件になっていましたが、今はファイルを分けたので、もういらないですね。macOS だったら…という分岐は不要です。これでプレビューが…あ、そういうことか。なるほど。プレビュー自体は動いていて、`#Preview` は認識しているんだけど、`#if` によって除外されているにもかかわらずプレースホルダとしては拾われているんですね。理由がやっと分かりましたが、ちょっと混乱しました。

ランドマークリストはとりあえずピン留めしておいて、ランドマークリストのフレーム、このサイズをシステム側に任せるようにして、これでサイズはいい感じになります。ただし、情報カードの表示のためには、ちょっとよろしくないですね、という状況です。OS ごとに分離したので、`#if os(iOS)` はいらなくなりました。`#elseif os(watchOS)` も同様に不要ですね。ただ、`#if` で分けて対応させておけば済みそうな雰囲気もあるので、それでも良いのかもしれません。まあまずはチュートリアルに習って進めていきましょう。

ランドマークローはそれで良いとして…いや、その前に、ここもリストですよね。ランドマークローをどうしたっけ？あれ、忘れてしまいました。ランドマークローの定義…これもすでに手当ては終わっていましたよね。その中でイメージに対して、画像のフレームでしたっけ？あれ、フレームはこのままで良いのか。何を消すんでしたっけね。ランドマークのリストからは、画像が多いからという話で、そして、ローからは…`LandmarkRow` の `#if` コンディション？という感じで、そこを目標にして進めていきます。 専用の `List` を作って対処します。リストを専用のものにして対応する、という方針です。

そのために、まずは `LandmarkRow` をコピーする話だったかどうかを確認しました。プレビューは前回見ましたね。`LandmarkRow` で `minWidth` などを設定して、`cornerRadius` を付けて表示していましたが、Stack の見た目が良くないということで、Mac ターゲットに切り替えて、watchOS のプレビューやリストのプレビューを見直しました。最小幅の設定がよくないので、次のセクションでリストを用意して、こちら特有のリストの設定をしていく、という流れです。`LandmarkRow` が出てきて、この中では幅の指定を消している状況です。

新しいファイルを作るのかと思っていましたが、勘違いでした。リストは新しいものを作ってコピー（複製）する、ということのようです。その後で `LandmarkRow` に戻り、コンパイル条件の `#if` を使って、2 つ目のテキストを watchOS から除外する対応をします。

具体的には、Xcode に戻って、`LandmarkRow` の watchOS 用のものは不要なので削除します。そして `LandmarkRow` の中で、watchOS にも適用できる形に整えつつ、2 つ目のサブテキストを `#if` で条件分岐します。つまり、`#if !os(watchOS)` の条件下でのみセカンダリのテキストを表示する、という形です。`watchOS` 以外だったらセカンダリのテキストを表示するようにします。こうすることで、watch ではそのテキストが消えて見栄えが良くなります。

さらに、`LandmarkRow` は watchOS 用に新たに作り直し、こちらでは最小幅（`minWidth`）の指定は入れません。watchOS では不要だからです。逆に、他の OS、特に macOS の場合は `minWidth` があると良さそうです。iOS には必要なさそうにも見えますが、とりあえず崩れていたら直す、という方針で良いかもしれません。つまり、`minWidth` は `watchOS` 以外で使う、という扱いで用意します。

最後に、iOS でちゃんと適用されるかをチェックします。`Landmark` のビルドターゲットを iOS に切り替えて、iOS で更新が正しく反映されることを確認します。これによって、他の変更が iOS では不要であることも確認できます。

では、iOS に切り替えてプレビューを見ます。特に気になるのは、リストのセル……ではなく、ローの幅です。ローの幅が大きすぎないかどうかが見どころです。`minWidth` が影響を及ぼしていないかを確認し、あってもなくてもいいなら外したいところです。iOS では潰れることはなさそうな気がします。多分、シミュレーターを用意しようとしているのですが、この時に開いていたのが watchOS 用のファイルでした。これではだめですね。 なので、watchOS のピンを外して、あ、そっか、iOS ですね。だから、ランドマークリストの iOS 用の方にないと駄目ですね。これで様子を見ますが、やっぱりこの `minWidth` が、あったかね…えーと、macOS ではありました。それだけなら、もはやこの `#if` を使っている都合、ファイルを分けなくても問題ない気がします。ここで何か問題が出てくるのかな。まあ、やっぱり分けたほうがいいよね、となったら改めて分ければいい気もします。

この後、プレビューができたら引っかかりを確認しますかね。うん。とりあえずそんな感じで、またプレビュー待ちの状況になってしまいましたが、どうしようかな。シミュレーターだけ落としてみて様子を見るか。こんな感じで、落ち切らないですね。あ、落ちた。これでプレビューを一回消して、もう一回出せば、起動するかな。えーと、起動している感じがあまりしない。落ちた。エラーが出てきた。えーと、あ、そっか、これがね、`#if`。だから、プレビューをやるには、この `#if` はよくないということか。これで `#if` に `#else` を付けて、プレビューをこういうふうにすれば…丸括弧がない。えーと、丸括弧がない。プレビューで、えーと、`#if os(...)`、まあ OS だったらこれ、そうじゃなければこれ。あー、てか、これが `#endif` か。こうすると「`PreviewProvider` が必要だ」とか言われているけど、`PreviewProvider` が必要？ えーと、「ルートスコープに必要」と。ルートスコープに置く必要があるということですね。こういった状況になるので、OK と。

で、さらにプレビューがいい感じに動いてくれて、まあ iOS は問題ないよね、ということなんだけど、スペースが多いのかって気にならないのかな。なんとなく隙間が気になるんですけど、まあ、こういうデザインならいいのか。ね、まあ、これでいいや、とりあえず。

こんなふうにしたけれど、やっぱり結局のところ、watchOS では最小幅を削除しただけなので…最小幅じゃないや。リスト側、リストから、えっと、どれだ、ありそうか。watchOS、Row…あれ、`Row` が、`Row` がコンパイルディレクティブで除外したんだ。だから、ランドマークリストは `minWidth` があるかどうかですよね、この下にね、`frame` ね。なので、やっぱり保留させちゃいましょう、ちょっと。

なので、この watchOS の条件を外してあげて、それでランドマークリストの、えっと、これね、ランドマークリストの watchOS を有効化してあげて、それで watch を直すのか。watch を直すけど、まあ、今は直せないかな。えっと、`#if os(macOS)`、これが macOS だったときに、`frame` の最小幅、これを指定してあげるようにしたときに、iOS の表示が崩れないかどうか。崩れないですね。大丈夫です。 なので、macOS だけ最小幅を指定することにした方が、今のところは自然かなという気がします。では、これで良しとします。これで良しにして、もう一回 watchOS を確認します。watchOS で表現に問題がないことを確かめます。今は問題なさそうですね。いい具合に表示されている気がします。watchOS 向けの Swift であればリストやメニューを使っていて、macOS だったら……まあ、そんなところですかね。

では、これでコードが3つのプラットフォームでちゃんと動いたというところで、次へ進みましょう。セクション4「リストビューを更新する」。`LandmarkRow` と同じように、`LandmarkList` はすでに macOS で動作しますが、このビューをさらに改善していきます。例えば、「お気に入りのみを表示（Show Only Favorites）」のトグルをツールバーのメニューに移動できます。これはやりたかったことの一つですね。さらに、追加のフィルタリングコントロールも追加できるようです。この変更は macOS と iOS の両方で機能するとのことです。ただし、残念ながら（Unfortunately）watchOS では難しいようです。

前のセクションで、すでに watchOS 用にファイルを分離していました。今は結合した状態にドッキング（というか合体）させていましたが、まあ、このまま合体させたまま行ってみましょう。まず macOS の Landmarks スキームに戻って、`LandmarkList` ファイルを開きます。iOS と macOS 用の `LandmarkList` に対して、ツールバーアイテム（メニューを含む）を新しいツールバー用モディファイアを使って追加していくらしいです。つまり、`toolbar` モディファイア内で `ToolbarItem` を使い、`Menu` を置いて、`Label("Filter", systemImage: "line.horizontal.3")` のような形でラベルを付ける、というものですね。これをコピーして `LandmarkList` のところに貼り付けます。

貼り付け位置としては、iOS と macOS の両方に適用したいので、その分岐の中になります。まずスキームを macOS に変えておきます。その後、iOS と macOS 用の分岐を書いていきますが、やっぱりコンパイルディレクティブ（`#if` など）が入るとなかなか難しいですね。iOS の場合はこれで、リストのこの位置に続けて書くと、次にシャープイフ（`#if`）が来たときにエラーになりましたよね。

watchOS 以外にしたい場合は、`#if !os(watchOS)` と書く手もあります。感嘆符の位置などを間違えると意図しない条件になるので注意です。ここだけならそれでも良いのですが、他にツールバーを書くときにコンパイルエラーがどうだったか……。まあ、`#if os(iOS) || os(macOS)` と書くのでも良さそうですね。将来的に、例えば（多分ないと思いますが）visionOS 対応などになったとき、プラットフォームが増える可能性もあります。なるべく厳密に固定した条件で分岐させたいので、今回はこの書き方にしておきます。

これで、シミュレーターは macOS にしてあるはずなのに、シミュレーターが macOS になっていないのは何だろう……。こちらで確認すると、「プレビューできませんでした」と出ています。 macOS で一回ビルドをかけてみます。固定しているわけではないので大丈夫だと思いますが、`Preview` を回してみます。macOS だったらこの `Preview` ですよね。これで macOS のプレビューが出てくれればいいのですが、なかなか思ったように出てくれません。1回消してもう一度やっても終わっているようです。プラットフォームは今、固定しているわけでもないと思います。スキームは特に何も覚えていなくて、選択モードを押したときに何が動くのかを見たいところです。`My Mac` が選ばれているので、プレビューの基本は良いはずなのですが。

やりたいのは、メニューの動作テストを回したいということです。3つのトグルをメニューに移動します。トグルをツールバーに移動するのはプラットフォーム固有の方法になります。これは追加の利点があり、ランドマークのリストがどれくらい長くても、あるいはどれくらいスクロールしても、トグルにアクセスできるというアクセシビリティ面のメリットがあります。テキストが長すぎるとメニューも良くないと思いますが、訳のニュアンスが違うのかもしれません。

ともあれ、「プラットフォーム固有の方法でツールバーに移動する。これによりランドマークのリストが長くなっても、スクロールしても、トグルにアクセスできる追加の利点がある」ということです。ああ、そういうことでしたね。最初のほうに直したのは、「Favorites only」のトグルが隠れるのは嫌だということで、場所を変えたんでした。今出てきたのは、まさにそれを解決する話でした。なるほど。

とにかく、トグルの中に「Favorites only」のラベルを置いています。あ、トグルですね。トグルを置いているということです。余白（スペース）が増えるので、新しいコントロール、つまりランドマークをカテゴリーごとにレンダリングするためのコントロールを置くことにするようです。まずはここまでやります。

実装ですが、トグルは `body` の中です。`Landmark` の `List` の中で…あれ、トグルが見当たりません。リストもそうですよね。あ、これだ。「Favorites only」のトグルです。これを iOS の場合に表示するようにして…あそこは消していたんでしたっけ。iOS のときに表示する？ そうでした。watchOS でも消して、macOS でも消しました。で、今は macOS と iOS を同じにしようという状況なので、これが読めば、ちょっと無くなってきましたか。

「showFavoritesOnly」のトグルは、トグルと `padding` です。`padding` はいらなかったですね。だからこれは安全に消して良さそうです。iOS のときに使うかどうかはこの先の話ですね。ここに `padding` があることが害になってきたので消しておきます。`padding` はここに入れておく…いや、iOS もいらなかったんですけどね。

とにかく `showFavoritesOnly` をここではなく、ツールバーのメニューの中で使うようにします。これで良いですね…あ、まだダメか。`showFavoritesOnly` は、ビューの中に用意されていないか。この、何に入れていたんだっけ。間違えたか。今は iOS でしか使っていませんね、まだ。なので、`showFavoritesOnly` を iOS と watchOS…ではなく、iOS と macOS で使うようにします。watchOS は使わないでしょう、きっと。なので条件を修正して、watchOS ではなくて macOS。こうしてあげると macOS で使えるようになったので、これで良しと。

そして、macOS だとツールバー経由で表示します。あ、ただ iOS も同じです。だから、これはもはや iOS でもリストの上にはいりません。いろいろ話しましたが、ひとまずコメントアウトにしておきます。これでトグルがメニューのほうに移動しました。

プレビューが動かないので、実行して具体的に確かめてみます。実行して出てくるのがこれ。ボタンがない状況で、メニュー…これか。あ、これですね。そういうことか。ツールバーでした。なるほど。ツールバーをあえて追加するということは、他にプロフィールも置けますね。 とりあえず `Favorites Only` を選ぶと、お気に入りの表示に切り替わりますね。あ、トグルでこうなるんだ。なかなかいいですね、これ。ボタン式のスイッチが何か出てくるのかと思っていたら、ちゃんと場所に応じて変わってくれるんだ。これはありがたいです。

何にしても、こうやってできたので、これで OK ですかね。では、次は macOS ではなく iOS も少し見ておきます。iOS のプレビューが出てくれるといいのですが、どうでしょう。iOS も、今ツールバーにしたせいで、ツールバーがきちんと出ていると思うので、これをうまく使えるなら、最初に書いておいたリストの上のボタンはもう要らないですね。ちゃんと出ていますし、これで選んであげると `Favorites Only` も動く。いいですね、できました。

そうすると、この iOS の条件が1つ要らなくなるので削除しましょう。これで OK。あとは、やはり OS の条件分岐周りをもう少しきれいにしたい気もします。

`#endif` はどうしましょう。ツールバーを使うかどうかで分けるとして、`ProfileToolbar` は `.toolbar` モディファイアでツールバーを定義していて、結果としてツールバーを2つ書いた感じですね。ツールバーが2個というより、ツールバーの中にボタンを複数置くイメージで、`ToolbarItem` がいくつかあれば、それらをいろいろ調整していく、という感じになりそうです。こっちのツールバーは項目が5個なので、まあこれでいいでしょう。ツールバーと `Profile`、`Favorites Only` の表示も、ここにあるならこれで良さそうです。

そしてもう1つ。`#if os(...)` だから、このツールバーの `Profile` を表示するにあたって、ディレクティブ…そう、アベイラビリティのディレクティブで、ここでさらに条件を足してあげる想定です。あれ、ダメか。型の関係でダメなのかもしれません。ツールバーをもう少し上に持っていって…どの辺かな。`#endif` までが対象ということですね。では、一旦ここをコメントアウトして、ビルドが通るかを確認します。OS の条件はこれで良いですね。

次に macOS。macOS でもちゃんとプレビューが当たるといいのですが、macOS はプロファイル用の部品をコピーしていない気がするので、それが必要ですね。プラットフォームをとりあえず macOS に切り替えてビルドをかけると、今は多分エラーになります。エラーになるのは `showingProfile` がないからですね。`showingProfile` プロパティも用意していないので、そこも対応が必要です。つまり、macOS 側にも一式が必要、ということです。

そして `ProfileToolbar` があるところは、iOS だけでなく macOS でも使うようにしておきます。これで足りないのは何でしょう。ビルドをかけると、`ProfileToolbar` の呼び出しやその他の箇所で不足が出ているようです。プレビューも macOS 用に寄せてしまうのではなく、共通化しておくと良さそうですね。

次にパラメータの `showingProfile`。ここは、iOS 側では `@Environment` あるいは `@State` の `showingProfile` を使っているはずなので、macOS 側のコンテンツにも `showingProfile` を渡してあげます。ここで `showingProfile` を用意して、macOS のコンテンツにも与え、さらに `showingProfile` として参照できるようにしておきます。

プレビュー側はボディの中で `showingProfile` を扱います。`CategoryHome` の `TabView` 周りで、`TabView` の `selection`（アクティブ）と `CategoryHome`…シートの表示ですね。このシートは `LandmarkList` に対してのシートで、`ProfileHost` を表示します。`ProfileHost` はプロファイルのホストビューです。これはモデルデータを参照する、ビュー内のコントロールでしょう。これを macOS にも付けてあげます。つまり、`ProfileHost` を iOS と macOS の両方で使えるようにします。さらに `ProfileEditor` も必要になりそうなので、同様に macOS を追加します。

ここまででビルドすると、今度は `EditMode` 周りで引っかかります。`EditMode` が `@available` 的に macOS では提供されていない（あるいは挙動が異なる）ようなので、プロファイルを表示・編集するためには、`EditMode` 相当の画面を自前で用意する必要がありそうです。となると、そこまで実装するのは少し手間がかかりますし、今の流れでは厳しそうですね。 そのため、`ProfileHost` は macOS 向けはやめて、完全に iOS 専用にします。そうすると `ProfileEditor` はどうするか…これはこのままで良いのか少し悩みますが、`ProfileEditor` を macOS 用にしても分かりづらいので、ひとまず保留にします。

とりあえずこの状態でビルドしてもエラーになります。`ProfileHost` を表示しようとしてしまうためです。そこで、ツールバーでは `ProfileHost` ではなくて、代わりに別の表示にしてみます。まずは暫定的にそうしておきます。

`#if` の条件分岐を見直します。これは macOS 専用でしょうか。`ContentView` だから macOS 専用だったはずです。ここで `ProfileSummary` を表示すれば良さそうです。`ProfileSummary` ですね。渡すのは `showingProfile`…ではないですね。`ProfileSummary` のイニシャライザが出てこないのは、`ProfileSummary` が macOS 対応になっていないからです。なので、`ProfileSummary` を macOS にも導入します。これで `ProfileSummary` が全 OS で有効になったので、ここで読み込めます。

次に `ModelData` が必要です。`EnvironmentObject` の `ModelData` を使います。下のほうはここから `ModelData` を参照するので、`self.environmentObject(modelData)` にして、渡す `modelData` はそのまま `modelData` です。`profile` はここは `Binding` かな…あ、間違いました。`ModelData` は `EnvironmentObject` の `ModelData` ですね。とりあえず `modelData` と `modelData`。`modelData.effectiveProfile` を使います。ここが問題です。渡した `ModelData` は `EnvironmentObject` です。`Profile` をそのままイニシャライズするときに、なぜ `Environment` と言われたのか…iPad からだったっけ？違いますね。まあいいか。`Profile` だけにして、`ModelData` を渡してあげます。ここかな。これでビルドをかけると…通るでしょうか。まだダメですね。

`HikeBadge` が原因です。`HikeBadge` を使っているからで、`HikeBadge` はこれですね。macOS でも使うようにします。対象 OS に macOS を追加します。ファイル名はこのままで良いです。`HikeBadge` の中で `Badge` を使っていますが、`Badge` も macOS が対象外になっているので、ここにも macOS を追加します。`Badge` を直したら、まだいくつか直すところがあると思います。

次に Generic parameter `C` のエラーが出ています。`Badge` の中で…どれでしょう。`FillStyle` は関係ないですね。`Point` も関係なさそうです。ひとまず他の箇所を見ていきます。`HikeBadge` はすべての OS に対応させました。

そうすると次は `BadgeSymbol` です。`BadgeSymbol` は `HikeBadge` の中だけで使います。`BadgeSymbol` にも macOS を付けます。`FillStyle` も macOS に対応させれば良いです。ビルドを再度かけます。

次は `HikeView` と `ModelData` です。`ProfileSummary` が `Environment` を持たない…いえ、`EnvironmentObject` の `ModelData`、`self.environmentObject(modelData)` ですね。これで OK。`HikeView` は iOS だけになっているので、iOS と macOS の両方を対象にします。macOS にも持たせます。

次は `Hike` 周辺を見ます。どれからいきましょうか。`HikeView` の中の `DetailView`、`HikeView` のディテール表示ですね。`DetailView` は…これは `LandmarkDetail` かな。`HikeView` の `DetailView` ということなので、これも全 OS 対応にします。iOS のみ指定を外して macOS を追加します。ビルドをかけます。

次は `HikeGraph` です。これにも macOS を追加します。`HikeView`、`HikeGraph` ともに同様に macOS 対応させます。ビルドをかけます。ここで本当は `Hike` 系がまとまるかなと思ったのですが、まだ「iOS の `HikeView` がない」というエラーが出ています。iOS と macOS の両方にあるように見えるのですが、何でしょうか。

`CategoryItem` を見ておきます。`Button` 系の項目も定義されていますが、これも iOS だけになっているので macOS を追加します。これでファイルを更新し、次に `FavoriteButton`…まあ、このあたりも同様に対応していきます。 まずはビルドをかけます。アニメーションのリップルがないという話だったので、これも対応します。リップルはどこだったか…トランジションフィルタはどこだろう。`CIFilter` のあたりではないですね。リップルは Core Image 側か。そうですね、こちらです。このファイルも macOS でも使えるようにしてあげれば大丈夫ですね。

アニメーションも、リップルの実装を OS 全部に対応させたので有効化して、あともう一つくらい直せば良さそうです。そうすると、`AnyTransition` の `moveAndFade`、これもどこかで適用しましたね。`moveAndFade` をここに登録して、iOS だけだったのを macOS でも使えるようにしてあげると、これでできました。iOS だけじゃなく、macOS でも動きます。

これでビルドが通るかな。あ、まだダメか。`ButtonStyle`、`ButtonStyle` 周りですね。これは `typealias` かな。`typealias` で用意していましたね。この OS 分岐だと macOS と iOS は一緒で良さそうです。`HStack` でいいかな。`#elseif os(macOS)` にするか、どちらかを OR にするか、分けちゃうか。`#elseif os(macOS)` にして、この場合も `HStack` にする、みたいなコードにしておきますか、今回は。

これでビルドをかけると…お、通った。リップルを動かしてあげると、それまでのプロフィールは macOS でも見られるようになりました。そうですね。シートで出しているのでこんな感じか。レイアウトがちょっと悪いですね。これは調整したほうがいいのかもしれません。

つまり、macOS のレイアウトだとプロフィールの…コストじゃなくて、サマリーですね。`ProfileSummary` を出したときにスペース、余白が欲しいということですね。`HStack` があって…ああ、`HStack` しかないか。`HStack` があって、だからこの前か。リストを出して、`HStack` が入っていて、それはそれでいいのか。

`ProfileSummary` を出すところというと、`LandmarkList` ですね。この中で、macOS かどうかで分岐していて、`ProfileToolbar` があって、`ProfileToolbar` が適用されているのがここですね。`ProfileToolbar` の中で、モディファイアとして `.toolbar` を付けています。ツールバーではないとすると、`ContentView` か。`ContentView` ならここが良さそうです。

`ProfileSummary` を出すところで、スペースを一つ用意してあげるというか、余白はどう用意するか。マージン…いや、`padding` かな。`padding` を付けましょう。例えば、UI のガイドラインみたいなものに沿う形が良さそうです。これで動かしてみましょう。ユーザーインターフェースのガイドラインも読んだほうがいいですね。 とりあえずこうして表示すると、入りましたね。いい感じで、これも表示・非表示の切り替えができて、ちゃんと動きます。ただ、これ閉じられないですね。閉じる仕組みを用意し忘れました。どうしましょうか。モーダルやポップオーバーにする手もあると思いますが、閉じる系のボタンを上に置いておく方法がありますね。それをやってしまいましょう。

リストの前にボタンを置いて、`Label`、そして `Text`、Close。Close というか、`Button`ですね。ボタンの中の `Image` に何を使うかを考えます。シンボル……何でしたっけ。SF Symbolsですね。まだ入れていませんでした。

SF Symbols はどこから入れるのでしたっけ。Xcode の開発者ツールではないですね。ダウンロードはどこでしょう。今は見当たりません。Developer Tools のページを開いてサインインします。この中に SF Symbols があったはずです。キーワードで検索するといろいろ出てきます。カーネルデバッグキットのような強そうなものも出てきますが、まずは Xcode でいいのかな……。Additional Tools や Fonts ツールなども見えますが、目的のものではないですね。ここではないのかな。developer.apple.com のダウンロードページのほうにあるはずです。ダウンロードの中から選びます。フォント系はツールでいいのかな。

SF Symbols ですね。これをダウンロードして開きます。インストールは、アプリケーション本体と San Francisco フォントの両方に同意して、このコンピューターにインストールします。パスワードを入力してインストールして、これでいろいろ見られるようになりました。インストール完了です。

どちらかを押せないのは何でしょう。バツで閉じればいいのかな。SF Symbols を起動して、バツ印を探します。お、開きました。バツ印はどこで探せばよいのでしょう。「バツ」では出ませんね。カタカナはダメです。「close」で検索して……ありました。X マーク。これで良さそうです。

いろいろ操作できるようですが、まずはコピーすればよさそうです。この上で、`Label` のアイコンとして `Image` を使い、`systemName` にバツ……いや、正しくは `xmark` を指定します。つまり `Image(systemName: "xmark")` ですね。メニューには「名前をコピー」「シンボルをコピー」「イメージをコピー」「イメージの別名をコピー」などがあります。「名前をコピー」だと `xmark` です。「イメージをコピー」は本当に画像データのようで、貼り付けてみるとうまくいきません。「別名」というのは何でしょう。画像の別名？ とにかく、これで良さそうです。

閉じる処理は、`@Environment(\.dismiss)` でした。 Environmentの`dismiss`を使って、クローズボタンは`dismiss`する、という感じで進めます。シートとフィルターはやったことがないので勘でやっていますが、これで実行してみます。

ボタンが右上に…ん？本当？あれ？これは違う。これはただのSF Symbolsではなかった。今のボタンは何だろう。ボタンがランドマークリストに出てきています。コンテンツビューによってランドマークに出てきますよね。だからここではなく、やりたいことはプロファイルサマリーのシート側です。`ProfileSummary`を出す直近のところにバツボタンを付ける、ということですね。

それで実行してみます。たぶんちゃんと動いてくれて、バツボタンも出ています。少し見にくいので色は調整が必要そうです。×印のボタンの色は2色にするのが良さそうですね。とりあえず動作を先に確かめます。

これを開いてプロファイルを出すと、こんなところにボタンが出てきました。ただ、色がいまいちですね。ボタンとしては出ていますが、ボタンのスタイルを変えたいところです。フラグを変えるということなのか。つまり、`dismiss`みたいなダイアログ用のことはやらず、ボタンを押したら閉じる。だから`showingProfile`を閉じるだけですね。`showingProfile`を`false`にします。いま表示されている時点で確実に`true`なので、`false`を代入すればいいです。

よくここで`toggle()`と書いているコードを見かけますが、`showingProfile`が確実に表示中であることを前提にしてしまいます。それを把握するにはコード全体を読まないといけなくなるので、このボタンが「閉じるボタン」であると明示したいなら、`false`をちゃんと代入するほうが読みやすいです。

閉じました。いいですね。場所はこのままだと微妙なので、`HStack`にしてボタンを配置し、`Spacer`で右側にボタンを持っていくのがよさそうです。あと、ボタンのスタイルが気になったので、`buttonStyle(.plain)`にしてボーダーを入れないようにします。これでクローズができれば今回はだいたいOKです。

プロフィールを出して確認すると、ボタンが少し主張しすぎてしまっていますが、押せばとりあえず閉じられます。ただ、ボタンの位置がよくないですね。`padding`を入れた場所が悪かったようです。`HStack`と`VStack`の両方をまとめて囲いたいので、上下のレイアウトを`VStack`で作り、その外側に`padding`を入れるのがよさそうです。

最初のころはインデントが深くなるのが気になって分解したりしていましたが、結局また入れ子にしちゃっていますね。とりあえずこんな感じで、ボタンの見た目もそこそこ。`padding`はもう少し少なくてもいい気がしますが、この程度でよいでしょう。少し微妙ではありますが、意図が分かっていれば問題ないと思います。動きはOKです。

ではこのあたりでいったんOKとします。次回は続きからで、ここがステップ3です。フィルターカテゴリを追加していくところから進めます。細かいリファクタリングなどはまたゆっくりやれば大丈夫でしょう。大した問題はなさそうです。今日はこれで終わりにします。お疲れ様でした。
