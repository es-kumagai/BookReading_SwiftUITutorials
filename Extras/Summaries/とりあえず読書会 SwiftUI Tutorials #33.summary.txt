Transcription & Summarize : とりあえず読書会 SwiftUI Tutorials #33

はい、ではとりあえず特集から始めていきましょう。リストビューはチュートリアルの内部の方ですね。いまはmacOS対応をしているところです。画面が大きいぶんレイアウトが変わって、その中でメニューなどをいじれるようになっている感じで、なかなか面白いです。プラットフォームごとの微妙な違いに触れつつも、コードは結構共通して使えるところが多いですね。リストビューは面白い反面、難しいところでもあります。

チュートリアルに沿って引き続きやっていきたいのですが、今日はここから、たしかセクション4だったと思います。パート3のセクション4の後半から軽く見ておきます。リストビューを更新して、macOSに合う形にしていこうという話ですね。iOS版ができている段階で、macOS版を作っていきます。チュートリアルをやりながらいろいろリファクタリングしていくと、掲載されているコードとはだいぶ違ってきます。そこが個人的には面白いところですが、そのせいで苦労しながら進めている面もあります。とはいえ、そういうところが勉強になって良いなと思いながらやっています。なぞるだけだと、どうしても気が抜けるというか、一回で終わってしまう感じがあります。実はこれ2回目なのですが、1回目の内容はすっかり忘れていましたね。

さて、ステップ1では何をしたかというと、Mac用の`LandmarkList`に関する変更を追加しました。とにかくツールバーを付けて、フィルター用のUI、たとえばセグメントコントロールのようなセレクタを用意しました。これは「Favorites Only（お気に入りのみ）」の切り替えですね。これをメニューに追加して、選べるようにしたい、というところです。これまではiOS向けで作っていたときは、リストの中にフィルターを用意していましたが、それをメニューに移動したことで、ほかのフィルターも付けられるよね、という流れで、今日の話題に入ります。

フィルターの状態を表現するために、`FilterCategory`という列挙型を作ります。これは「記述」という言い方が近いですね。それを用意して、マッチング用の文字列と`Category`列挙型、さらに`Landmark`構造体の`category`列挙型のケースを突き合わせていく、ということをやっていきます。すべてのケース、つまり`all`も含めてフィルタリングを行う想定です。ここは早速いじりたくなるところですね。

なぜいじりたくなるかというと単純で、`lakes`、`rivers`、`mountains`といったカテゴリがある中に、`all`が同列で並ぶのが少し気になるためです。列挙型は排他的に一つを選ぶ直和型として捉えると、これらの選択肢は対等に並んでいたほうが使いやすく、きれいに扱えると感じます。`lakes` または `rivers` または `mountains` または `all`——選択肢としてはそれで良いのですが、`all`は他のカテゴリと性質が違います。将来、たとえば`lakes`と`rivers`の2つを同時に選択できるようなカテゴリフィルターを作ろうとなったときに、`all`が同列にあると非常に邪魔になってくる、という懸念があります。ですので、ここは後でいじりたいところではありますが、まずはこのまま進めます。

いまは`FilterCategory`を`LandmarkList`の中に入れています。フィルターというのは`LandmarkList`から見たときの選択肢であり、名前空間をそこで絞れているので、この文脈ではこうした少し特殊な列挙型の置き方でも悪くないかな、という気もしてきました。まずはこの形で進めて、後でリファクタリングしていこうと思います。 とりあえずこれを使ってみようと思います。ただし、Resources と Links などは他に転用しにくくなってくるので、転用しないならこれでいいのですが、転用しようとすると、`LandmarkList` を汎用化しすぎて使いにくくなるはずです。おそらくそうなるのではないでしょうか。

コードの方に移ります。`LandmarkList` はすべての OS 共通でしょうか。今は macOS を使っていますが、他の OS でも使うのでしょうか。そこがとても気になっています。あとは、個人的にパターンを載せる時には、拡張を macOS でも使いたいと思っているので、`LandmarkList` を拡張する形で少し載せていきます。macOS 用なのではないかという気もしますが、ひとまずこのまま進めましょう。

もう一つ言うと、多分 `LandmarkList` の中でフィルターが完結するので、外では使わないと思うんですよね。なので、`private extension` で十分だろうと想像しています。必要があれば直していきます。`Category` は RawValue として `String` を持っていますが、RawValue が本当に必要なのかは少し気になります。`CaseIterable` はまあいいでしょう。あとは `Identifiable` で、ID を使って何かやっていく想定ですね。ここは良さそうです。では、この方針でまず進めます。

ステップ4として、フィルター用のステート変数を追加します。デフォルトは `all` ケースです。フィルターの状態は `List` ビュー内で保持します。複数の `List` ビューウィンドウを開いて、それぞれが異なるフィルターで表示できるようにする意図ですね。なるほど、異なる見た目で並行して扱えるわけです。

ということで、フィルターとして `FilterCategory.all` を `LandmarkList` に追加していきます。まずは `LandmarkList` にステートを追加します。`showFavoritesOnly` の上に追加していたでしょうか。どちらでも構いませんが、とにかくフィルターを追加します。追加できたら、スクロール位置が変わってしまいましたが、この辺りですね。

次に、追加したものがあるので、`filterLandmarks` メソッドを更新します。新しいフィルター設定、つまりカテゴリーでフィルターを追加していきます。なかなかややこしいロジックになってきました。フィルターは2つで、`showFavoritesOnly` によるお気に入りフィルターと、カテゴリーに応じたフィルターです。条件としては、フィルターが `all`、または `filter.rawValue` と `category.rawValue` が一致しているかどうかを見ます。`&&` によって、「お気に入り状態が条件に合致するもの」かつ「カテゴリーのフィルター条件にも合致するもの」に絞り込む形ですね。大きくはこの2本立てになっています。

ではここまでを書いてしまいます。`filterLandmarks` のフィルターで、`showFavoritesOnly` なら `isFavorite`、これは良いですね。ここで、`showFavoritesOnly` が `false` のときには何も表示されなくなっていると思ったのですが、違うかもしれません。コードが間違っていますね。トグルでまず切り分けているので、`showFavoritesOnly` によって、ここはもういらないですね。常に `true` で良いはずです。条件が変わったので、この部分が不整合になっている、ということです。 フェイバリットの条件をどうするか考えています。今のままだと少しおかしいので、ここに`let favoriteCondition`をフェイバリットの条件として置いて、フェイバリットのみの場合に`switch`で分岐しようかな、という感じです。フェイバリットのみであれば、それが`true`なら……という条件になりますが、ランドマークを渡さないといけないので、これは関数にすべきですね。つまり、フェイバリットの条件はランドマークを受け取る関数で、ルール（`Bool`）を返す、という形にします。

この条件としては、`true`ならランドマークの`isFavorite`を見ます。`false`の場合には、すべて表示する、という想定です。これは良さそうです。同様に、ケースごとのフィルタについては、その他のフィルタだった場合には、そのままフィルタがランドマークのカテゴリーを……あ、`rawValue`で比較するのではなく、カテゴリー同士で比較します。つまり、`landmark.category`と`filter`（カテゴリーのフィルタ）を比較するか、必要なら`landmark.category.rawValue`と`filter.rawValue`が一致するかどうかを見ます。

こんなふうにすれば、全体としてはスマートな印象です。ただ、`switch`のインデントはもう少し良い書き方がある気もするので、そこは要検討です。一応の方針としては、フィルタが`all`なら素通りし、それ以外ならフィルタの`rawValue`（または列挙子そのもの）を比較する、ということになります。

ここでこのコードを見ると、問題が2つほど見えてきます。1つは、`all`とその他のフィルタで分岐している点です。個別のフィルタ同士なら列挙型の比較で済むはずなので、`rawValue`経由にしないで比較できる可能性があります。もう1つは、`rawValue`に寄せた扱いが増えると型安全性が落ちる点です。このあたりは改善の余地がありそうです。

ひとまず比較できるようにしたら、パフォーマンスを気にすると少し無駄は出ますが、ランドマークを使用するときにこのフィルタを適用する形にします。フィルタとしてまとめても良いでしょう。まずは書いてみます。`isFavoriteConditionSatisfied(with: landmark)`と、もう一つ`isFilterConditionSatisfied(with: landmark)`のような関数を用意します。もっと良い英語の前置詞がある気もしますが、とりあえず`with`で進めます。それと、ここは`Binding`が渡ってきているため、`wrappedValue`をここで渡すかどうかも考えどころです。

この両方の条件を満たす、という表現にできるので、だいたい良さそうです。ランドマークについては、`wrappedValue`を取るのではなく、素の`Landmark`を取る方向にします。`isFavorite`（フェイバリット）の判定は`Landmark`で十分なので、`with landmark`で良いでしょう。とりあえずこれで進めてみます。

さらに、関数をもう一つ作って`isFilterConditionSatisfied(with: condition)`のようにまとめる案もありますが、そこまでまとめない方が美しく見えるかもしれません。そもそもフィルタの責務の置き方を考えると、ランドマーク自体に要件を持たせるか、ランドマークリストが持つか、という設計になります。`isFavorite`の扱いなどを考えると、ランドマークにやらせるよりは、ランドマークリスト側で責務を持つ方が自然かもしれません。このあたりはもう少し改善の余地を感じます。

また、名前として「フィルタ」というのも曖昧なので、これは「カテゴリー・フィルタ（`CategoryFilter`）」が適切ですね。ということで、もう少し書き進めてから、`isSatisfied(with landmark: Landmark) -> Bool`のように、フィルタ側に判定を持たせます。さきほどの2つの条件（フェイバリット条件とカテゴリー条件）をここに集約し、呼び出し側では`filter.isSatisfied(with: landmark)`のように書けるようにします。

`wrappedValue`については、ここでは`Landmark`が得られているので、`wrappedValue`ではなく素の`Landmark`を渡します。`Binding`を渡さない場合はどうするかという点ですが、ここは正しく値を渡さないといけないので、`is...`系の関数は`Landmark`を引数に取り、`Binding`がある箇所では適切に`wrappedValue`を取り出してから渡す、という方針でやってみます。ただし、`filter.isSatisfied(with: ...)`のところで常に`wrappedValue`を渡す、という形にはしません。ここは値とバインディングをきちんと整理して扱う必要があります。 `wrappedValue`に`filter`がないと言われたので、フィルターの`wrappedValue`の`wrappedValue`だけでいいのか、これを省略したいと思いました。ここで`KeyPath`で何とかできないか検討しました。できることとしては、フィルターでランドマークを`Binding`に渡すか、あるいはバインディングを返すようにする方法があります。無理やりいろいろやるよりは、バインディングを返す形にしたほうが良さそうです。そうすれば、フィルターが完成したという扱いになります。フィルターの`all`は仕方ないとして、これで良いと思います。

こうしてフィルターができたので、続いてステップ6に進みます。ツールバーアイテムのメニューにカテゴリーピッカーを追加し、フィルターカテゴリーをセットします。その前に命名を見直しておきます。いま「フィルター」と「お気に入りのみ（Favorites only）」という2つでフィルタリングをかけていますが、「フィルター」という名前が曖昧すぎて分かりにくいです。そこで、この名前を「カテゴリーフィルター」に変更します。フィルターの条件名も「カテゴリーフィルター」に揃えます。トータルで見たときに、何を指すフィルターなのかが明確でないと良くないので、ここははっきりさせておきます。これで、フィルターとランドマークが全体としてカテゴリで絞り込まれたランドマークとして扱えるようになりました。次に進みます。

ピッカーを追加します。ツールバーアイテムのメニューの中にカテゴリーピッカーを追加する方針です。コードをコピーしつつ調整していくと、話が見えてきます。iOSとmacOSの条件分岐については、カテゴリーフィルターも同様の扱いになります。つまり、不要なものを他方のOSに持ち込まないように整理します。

その結果、フィルター側も少し考慮が必要になります。ここは少し面倒なので、まずはmacOS専用にしてから、続いてフィルターの扱いを決める、といった段階的な進め方が良さそうです。やり方はいくつかありますが、ひとつの方法としては、一度`#endif`で閉じてから、`favoriteConditionSatisfied`（お気に入り条件が満たされているか）などの条件を分け、コマンド側を条件文で分岐させます。

このとき、論理積`&&`で条件をつなぎたくなりますが、そのままだと`return`が必要になったり、`&&`を期待どおりに解釈してくれないケースがあります。`&&`も`#if`の内側に入れて同じスコープで評価させる必要があります。そうでないとビルド時に意図どおりに効きません。であれば、`if`を二つに分けるなど、OS間の互換性を優先した書き方に寄せたほうが安全です。

最終的には、コードの簡潔さよりもマルチプラットフォーム対応のしやすさを優先します。そのうえで、例えば`isAllSatisfied`のようなヘルパーを用意して、複数の条件をそこにまとめて評価する形にすると、見通しが良くなります。名前は`isAllSatisfied`で良いと思います。 とりあえずこれで良いのですが、あまり良くない気がします。フィルターを1個作って、もう1個作って、整えていくので、リファクタリングですね。

`allSatisfy` は `with` を取るので、`allSatisfy` の述語（`Predicate`）を用意します。`allSatisfied` は配列にしておいて、ここにランドマークを受け取って `true` を返すようなものを仮で作っておきます。あまり綺麗ではないのですが、まずはこれで進めます。

それから、`allSatisfied.append(isFavoriteCategorySatisfied(with:))` を入れてあげます。iOS と macOS では定義した後に、`allSatisfied` に対して実装を追加する形です。あれ、何を入れるんでしたっけ……そうそう、`append` に対して `isCategoryFilterConditionSatisfied(with:)` を追加します。こうやって OS ごとにフィルターの条件を付けていきます。これで良さそうですね。

この上で、すべてにマッチするかをここで調べます。`return` の中で `allSatisfy` の `Predicate` を使います。`$0` に対してランドマークを渡せば良いはずです。`allSatisfy` が混ざって見えると分かりにくいですね。致命的ではありませんが。条件（`conditions`）やフィルター名はこのまま `Conditions` のようにしておく方が良いですかね。これで、すべての条件を満たすものを探して評価していきます。

次に、フィルターとピッカーを用意します。`pickerStyle(.inline)` にしていますが、表示する場所が間違っているので、メニューの中に出すのが正しそうです。これをそちらまで移動して、トグルの下にピッカーを配置します。これでピッカーができました。ランドマークリストのメニュー内のピッカーなので、ここだけで良さそうです。

さらに、ナビゲーションタイトルをフィルターの状態に合わせて変えるようにします。これは iOS でやったはずです。`LandmarkList` のバータイトルに相当するところで、フィルターの状態に応じてタイトルを切り替えます。例えば、全件なら「Landmarks」、お気に入りだけなら「Favorite Landmarks」といった形です。`navigationTitle` はボディ内の `List` に対して適用していきます。 この辺の名前ですが、この名前は良くないと思います。ナビゲーションタイトルだと分かりにくく、「何のタイトル？」という感じになってしまいます。リスト、つまりランドマークリストのタイトルだと分かるならまだ良いのですが、少し曖昧ですね。

とりあえず、これはフィルター…違う、`CategoryFilter` でした。これを入れて、リスト、つまりこのリストの中のタイトルでしたね。どの辺に置くかですが、ナビゲーションタイトル…他では「ランドマーク」ではなくて「タイトル」。こんな感じでいきます。

ステップ8では、こういうターゲットでこのメニューがちゃんと動くかを見てみましょう。ステップ9も持ち込んでおきますかね。ランドマークのターゲット、ビルドターゲット、要は iOS の方ですね。そこでちゃんと動くことを確認しようと。なるほど、こんな感じでステップ、セクション4が終わった感じです。なので、動かしてみましょう。

とりあえず実行して、ちゃんとフィルターが動くかどうか。ビルドが通って実行できて、アプリが動いているのかな。このメニューの方ですね。Rivers で、今のところは iOS でのみ有効と言っていましたね。タイトルはどこに出ているんだろう…出ていないのかな。

Lakes を選ぶと、Lakes のものだけになりますね。何とか Lake とか Lake 何とか。Rivers も、Rivers なのに Lakes と表示されていたりしますね。他に Rivers。これは Cathedral Rock とか、何とか River。この辺は川なのでしょう。山っぽいものもあります。Favorites only も一緒に使えます。なかなかすごいですよね。これだけの機能がもうできてしまっているのは、なかなかすごいなという感じがします。

これ、何もなかったときにちゃんと動くのかな。これは良くないですね。良くないけど、これはどういうことだろう。All にして、どっちをクリックしても…消えてないですね。これはバインディングがおかしくなっています。クリックしたときにバインディングが効いていないので、直さないといけない状況のようです。

とりあえずそんなところですが、微妙です。iOS の方も、どっちも確認しておきましょう。でも、どこだろう。今のバインディング。バインディングに悩まされています。今フィルター周りをいじったからですかね。

またビルドエラーになりましたね。ビルドエラーになったところは、ダイアログが出ていませんが、そういうときは一番上のフィルターも確認すると、ここに出てきていますね。ここだ。`CategoryFilter` がスコープにない。`CategoryFilter` はそうだ、iOS または macOS ですね。`CategoryFilter` は綴りが違う…そんなことはないはず。`LandmarkList.swift` の `CategoryFilter`。これが見つからないと言っていますね。

この見つからないのは `CategoryFilter`。何だこれ。何か壊れていますね。`switch` …何だこれ。何かコピーしてしまった感じですね。`favoritesOnly`、`favoriteCondition`。上のはフィルタータイトル。`title: String` が…これ、さっき作ったタイトル。ナビゲーションのコピー。何か消してしまった感じですかね。そうだと思うのですが、それでもエラーです。iOS のビルドエラーで `CategoryFilter` がやっぱりないと言われますね。

ここですか。バーのタイトル、ランドマクリストで。あ、そっか。これは別の OS 側で言われているな。だから、タイトルも同様に iOS と macOS で分ける。これでいいですね。これでビルドが通る。タイトルはここで指定している。`navigationTitle` でしたっけ。`navigationTitle` は `List` が持っていましたね。これも OS で切り替えないといけないから、macOS と iOS ですね。その辺を切り替えたいので、とりあえず `#if os(...)` はコピーしておきました。これで `navigationTitle("Landmarks")` にして、`#endif`。これでビルドが通るはずです。

ビルドが通ったら実行して、実行結果を見ます。あと、星、つまりお気に入りの操作がうまく動かないところも気になるので、今日はそこも直します。とりあえず。

今、シミュレーターが動いています。動くまでの間に何回かお気に入りを…お気に入りは効いてはいるんですけど、ここの反映がされていないという状況です。こちらは押せないですね。もう一方も反応しません。とりあえず iOS のシミュレーターを見ていって、動いたら操作したいですが、ちょっと時間がかかりそうです。PC は MacBook Air を使っているのですが、MacBook Pro の方が快適になるのでしょうけど、結構熱くなるんですよ、MacBook Air。これだけのことをしている程度で。配信は別の PC でやっていて、画面は AirPlay で送っているという感じなのですが、これで結構重くなる。重くなると熱くなる。メモリは 16GB です。

メニューでしたよね。リストですかね。こちらですね。リストの中で Lakes を選ぶと Lakes。この一覧が出てきて、Favorites only にすると、お気に入りの Lakes。なるほどね。分かりやすくて面白いです。項目をタップすると詳細が出てきて、ここを押すと、やっぱり消えなくなっていますね。これでリストからはなくなっています。 iOSでもmacOSでも同じ問題が起こっていることが、とりあえず分かりました。この状況で調べていきます。`Environment` は要りませんが、`ModelData` でプレビューだけはできるようにします。あとはビルドができたら、iOSで実験してみます。

これだけでリンクが直るとは思わないのですが、一応リストに変えてみます。リストに変えて、例えばこの2番目の青いスターを外す……あ、外れた。あれだけで直った。`Environment` を渡すか否かだけで直るのかどうなのか。すごく気まずいですね。どういうことなんでしょう。

macOSでもやってみますけど、`Environment` を渡すだけで更新がされる。`Environment` を渡すと何が起こるんでしょうね。不思議です。これでmacOSにして、macOS用にビルドして挙動を見ます。……消えた。`ModelData` の `Environment` を渡して引き継ぐと、変更が他のバインディングとぶつかってくるのか、ライフサイクルが変わってしまうんですかね。もしかすると、`ModelData` がコピーされていることによってバインディングが古くなる、ということがあるんでしょうか。だとすると、このバインディングを持ち回すという、今回自分がやっているやり方は危なっかしいかもしれません。

とりあえずは、`ModelData` を持ち回して、ビューでもらった `Landmark` を `ModelData` から `firstIndex(where:)` で検索して、見つかったらどうする、見つからなかったらどうする、のように処理した方がいいのかもしれません。そんなときは、`EnvironmentObject` に過度に頼らないで、普通にクラスインスタンスをどこかに（必要ならメインアクター保護で）置いておくだけでいい気もします。そうすると変更が起こらないのか……なんかややこしいですが。

とにかく、ここで `Environment` を普通に置いたパターン、つまり `.environmentObject(modelData)` を付けて、`@EnvironmentObject var modelData` と書いた時点で、これだけで何も他に書いていないにも関わらず、バインディングがおかしくなる、ということになるらしい……あれ、そんなことなかった。できるようになっている。謎です。何か変えましたっけね。変えたとしても、プレビューで `Environment` を渡したかどうかくらいだと思うんですが、こんなところへ影響するはずがないと思うんですよね。これで実行して……あと何か変えましたっけね。変えたような気がしますが。とにかくこうしてみて……あ、大丈夫ですね。なんか幻を見ていたような感じかもしれません。なんのこっちゃという感じですが、これでとりあえずできた感じですかね。

では、実行をもう一回かけて、各OSでちゃんと動くかを見ます。これで一度、いったん終了しますね。で、あとこれもいったん終了……あ、フィルターやってないですね。フィルターで例えば「Rivers」にして、例えば「Turtle Rock」の……大丈夫ですね。これはこっちに入れたりしても大丈夫ですね。なんでだろう、まあいいか。

「Favorites Only」って、やっぱり変わらないと思うんですけどね、「Turtle Rock」。なるほど。だから「Favorites Only」はとりあえずやめて、お気に入りを一個作って、それで「Favorites Only」にして、その後に「Turtle Rock」を……あ、なるほど。「Favorites Only」にしたときにダメになる、ということが分かりました。なんでだろう。とりあえず問題は絞れてきましたね。つまり、「All」のときは問題ないけれど、「Favorites Only」にするとダメ、ということです。「Favorites Only」がダメ。こういうことですね。

「Favorites Only」がダメと言っているときに、`isFavoriteOnly` を `FavoriteButton` に渡していますよね。とりあえず。`FavoriteButton` は `Binding(get:set:)` で、何をしているかというと、ボタンをトグルする形を取っています。トグルするだけで、トグルの状態は `set` に値が渡ってきます。で、その値が `set` に渡ってくると……これでループが発生している？ バインディングがどうなんだろう。ループになっているとしたら、ちょっと嫌な感じがします。

`isFavorite` で、`isFavorite` が変化した段階ですよね。`isFavorite` の変更はここじゃないか。`FavoriteButton` はまあ良いとして、`LandmarkDetail` の一個前、`LandmarkList`。これで、`isFavoriteOnly`（「Favorites Only」のフラグ）が、このステップで変わるはず。この `isFavoriteOnly` はどこだ……たしか `Detail` ではなく `LandmarkList` 側にあって、`Detail` では `Landmark` を受け取って……あ、`FavoriteButton` は……。 Landmark の `isFavorite` についてです。Landmark はバインディングで渡しています。LandmarkDetail にバインディングされている Landmark は `filteredLandmarks` で返されていて、`filteredLandmarks` はここですよね。`isFavorite` だったらこの条件、そうでなければ別の条件、というようにフィルターの条件があります。モデルデータは Environment で渡されていて、その点は問題なさそうです。Environment で渡されたモデルデータから `filteredLandmarks` が作られていて、そこで絞り込みの条件は結局 `isFavorite` だけです。ここが難しいですね。なぜだろう。

アニメーションは関係なさそうです。ツールバーの `showingProfile` も関係ありません。`isFavorite` と `showFavoritesOnly` はここでも使っていますよね。`showFavoritesOnly` のプログラムはちゃんと確認していたはずなので、その点は良いでしょう。もう一度整理すると、`showFavoritesOnly` はプロパティで、ナビゲーションタイトルにも影響し、フィルター条件は `showFavoritesOnly` によって変わります。それはそれとして、`showFavoritesOnly` のトグルメニューにも依存しています。なのに、`showFavoritesOnly` を有効にすると、選択が外せなくなってしまいます。

選択が外せなくなるということは、例えば、`showFavoritesOnly` の挙動から考える必要があります。つまり、`showFavoritesOnly` をどこでどう渡しているのか。そこがポイントになってきます。それを見るには、Landmark と LandmarkDetail がどう関わっているか、`isFavorite` で条件が変わるのかを確認します。星のアイコンが影響を受けていないので、`isFavorite` が状態変化を受けていない、つまり変更が描画に反映されていないと捉えれば良いのかもしれません。どうでしょうね。

この Favorite ボタンをちょっと見てみます。FavoriteButton は iOS と macOS で違うのかと思いましたが、同じでした。ファイル名が紛らわしかっただけですね。

FavoriteButton は `isSet` をバインディングで受け取っています。これが再描画されたときにここで取得できるのか、`onAppear` で `print` してみます。とりあえず再描画のタイミングを見て、実行します。シミュレーターは今は macOS です。最初はボタンが描画されていませんが、例えば詳細を開いたときにボタンが表示されましたよね。おそらく…あ、表示されていますね。その状態で一回押してみます。こうすると、一回しか描画されていないように見えます。FavoriteButton の `isSet` は…押されたこと自体は確かですが、`isSet` が反転したかどうかを知るには、`isSet` はバインディングなので、FavoriteButton を使っているところ、つまり `isSet` と Landmark の `isFavorite` を結びつけている箇所を確認する必要があります。このバインディングがおかしいのではないかということは、なんとなく想像がつきます。 ただ、それがなぜ「Favorites Only」のフラグが立っているときだけなのかが気になります。これを知るには、お気に入りボタンの`isFavorite`が変化したかどうかをチェックしてみたら分かるかもしれません。

これをチェックするには、例えばこの箇所に`onChange`を付けて、`isFavorite`を監視してアクションを実行するのがよさそうです。`onChange(of: isFavorite)`…いや、これではダメでしょうか。`Equatable`な`Binding`が必要かもしれません。`onChange`はdeprecatedでしたかね。`onChange`の`value`にしてみますか。これでもdeprecatedですかね。iOS 14でdeprecatedで、`onChange`のパラメーターは`oldValue`と`newValue`でしたっけ。違うかな。とりあえず`onChange`を仕掛けてみます。

ひとまず`onChange`で変化を拾って…これがdeprecatedで、それ以外だと`onChange`は`of`と`perform`のアクション…これもdeprecatedですね。これか、`value`と`initialValue`。`initialValue`とは…また`oldValue`と`newValue`を受け取る感じみたいです。だから、これを使って`oldValue`と`newValue`を指定して、`print("isFavorite: \(oldValue) -> \(newValue)")`のようにして変化したかどうかを見ていきます。これによってどうなるかですね。

なぜFavoriteのフィルターをかけたときだけダメなのか。ほかは、要はカテゴリー・フィルターと同じ処理をしているはずなのに、そこだけダメというのがとても気になります。

Xcodeと一緒に見たいので、Xcodeを少し小さくして、これで操作していくとログが飛んでくるはずです。例えばこれを選んで、フィルターが分かりやすいように表示を少し調整しておきます。これはあまり関係ないか。ここでボタンを押すと、`true`から`false`になった、そして`false`から`true`になった、という感じですね。

あとは「Favorites Only」。これでフラグを入れると、今`false`から`true`になりました。正確には、処理されたという感じです。で、ここで押すと、変化したことになっていません。もう一回押しても変わらない。でも、リストのほうは動いている。つまり、ほかのバインドが何かおかしいですね。つまり、Favoritesのフラグを付けたときに「Favorites Only」を外すと、ちゃんと動くようになります。こんな感じです。

それだけではなくて、「Mountains」みたいなフラグを立てたときも、ちゃんと動きます。なのに「Favorites Only」だけ動かない。うん、そういう細かい状況になっています。

対象はリストとディテールだけです。では、リストとディテールのコードをもう一回見ます。まず「`onChange`が発動しないことがある」という状況ですね。ここに`onChange`があって、これは`LandmarkDetail`ですよね。`ModelData`が`@Environment`で与えられていて、`landmark`がここに存在しています。これ、`ModelData`はどこで使っているんでしょう。ここも何にも使っていないですね。では、これも切っておきます。`ModelData`の`@Environment`は要らないと。これで直ったりして…まあ、それはさすがにないかな。これで動かしてみて、まずiOSの画面に戻って…。 まずは、何もフィルターをかけていなければ動きます。次にカテゴリーによるフィルターですが、これも欲しい機能で、ちゃんとオン・オフしますよね。ところが、Favorites Only を押したときに、やばい、危ないですね、これが。`onChange` も多分発動していないはずです。フィルターは2個ありますが、2個であること自体はあまり関係ないですよね。ブールの条件式が変わるだけなので、これによって影響するとは考えにくいです。

そう思うと、Favorites Only がオンになったときだと思うのですが、でも、そうはならないか。`isFavoriteOnly` だったときに、干渉するものとして、カテゴリーはディテールではいじれません。一方で、`isFavorite` はディテールではいじれるという要件の差がありましたね。なので、`isFavorite` のランドマークで、バインドしたランドマークを取っているから、もしかしてこの可能性がありますね。そうすると、`isFavorite` の変化を検出させるにはどうしたらいいのでしょうか。

ここで `isFavorite` をディテールにも渡す。ただ、分散するのは嫌ですね。バインディングと分散が嫌だなぁというところがあって、まぁちょっといろいろやってみますか。バインディング。まず、バインディングは `isFavorite` でやってあげて、`isFavorite` を `Landmark` の `isFavorite` ではなく、バインドした `isFavorite` をセットしてあげるようにします。そして、このディテールのところで、`isFavorite` を `Landmark` の `isFavorite` というふうにしてあげて、それで動かしてみましょう。

これで、ビルドエラーはこっちか。ここは、とりあえず const で……いや、定数じゃなくていいですね。モデルデータ、`landmarks[0].isFavorite`、つまり `modelData.landmarks[0].isFavorite`。これでいいですね。これで動かしてみて、`isFavorite` が切り替わるようだったら、バインディングのミスマッチが起きていたということがわかります。

まずは普通に動きます。で、これで Favorites Only にしたときに、この Favorites Only が動かないですね。動かないというか、表示が変わらないですね、という状況か。これではなかったようです。そうすると、バインディングがこれではダメだとすると、`onChange` さえもダメなのかな、これが。例えば、一回ログを消して、このフィルター状況で一回押す、ってやったときには、ログが出てないですね。なので、`Landmark` の `isFavorite` が変わったという認識ができない状況になっています。

バインディングがおかしい。でも情報は変わっているから、バインディングがちゃんと更新されていないという状況になっているのかな、という感じがします。Favorites Only をオンにしたことによって、オフにするとリストから消えちゃう、というところが問題なのかもしれないですね。そうなると、`isFavorite` を個別に渡す必要は必ずしもないのかなという気もしますが、Row がなくなったときにバインディングが失われるのか。失われてしまって、どうしたらいいんでしょうね、これね。 とりあえず、`LandmarkDetail` のバインディングはいったん外して、`isFavorite` のバインディングは元に戻しておきます。ランドマークのバインディングが正しくつながっていれば、`isFavorite` を切り替えたときにリスト側は反映されますが、詳細側は変わらないという状況を再現したい意図です。オン・オフしたときにローカルに状態を持っておくのもおかしい気がするので、ここは何とか `isFavorite` の扱いを直さないといけません。

問題は、`LandmarkList` から `LandmarkDetail` に渡しているランドマークのバインディングが、フィルタで「お気に入りのみ」表示中に `isFavorite` をオフにすると、その行（`LandmarkRow`）がリストから消えてしまう点です。リストから消えると、クリックして遷移してきたこの詳細ビューの「元」がなくなり、ビューが浮いてしまいます。その結果、元のリスト側のバインディングは効いているのに、詳細ビューが持っている側のバインディングは無効になる、という感じがします。

そうなると、「お気に入りのみ」表示中に項目をクリックしたときに、何らかの対策が必要そうです。具体的には、「お気に入りのみ」であっても表示中（選択中）のアイテムだけはフィルタで消さない、という挙動にすれば良さそうです。これは少し難しそうですが、フィルタの動作を調整すればいけるはずです。

たとえば、`@State private var selectedLandmark: Landmark?` のような状態を用意して、選択されていない初期状態は `nil` にしておきます。これを前提に、`filteredLandmarks` を作るところで、1つフィルタ条件を追加します。たとえば `func isSelectedCondition(_ landmark: Landmark) -> Bool` のような形で `Bool` を返す関数を用意し、`selectedLandmark?.id == landmark.id` のときに「選択中」と判定するようにします。これを既存のフィルタ条件リストに `append` して、`if selectedCondition.satisfied(with: landmark)` のように条件を追加で見る、という流れです。これで「選択中の行」は、お気に入りでなくても消えないので、バインディングがおかしくなることは多分なくなるはずです。

次の課題は「選択されたことをどう検出するか」です。つまり、`List` 内で `ForEach` と `NavigationLink` を使って項目を選択したときに、どのランドマークが選ばれたかを `selectedLandmark` に反映させたい、ということです。SwiftUI の `List` には `selection` パラメータがあり、`List(selection: $selection)` の形で選択をバインディングできます。ドキュメントには、選択されたアイテムを保持するために `$selection` に `Set<String>` のような形を使う例もあります。`ForEach` 側にも同様の `selection` があるのかは再確認が必要で、ここは調べ直しになります。`NavigationLink` を使っている場合は `tag` と `selection` を組み合わせるパターンもありますが、いずれにせよ `selectedLandmark` にバインディングできれば、上記のフィルタ調整は機能します。

なお、現在のフィルタ条件の表現はすべて AND（`allSatisfy` 的）で評価している前提なので、「お気に入り」条件と「選択中は常に表示」条件を両立させるには OR が必要です。つまり、フィルタを「お気に入り もしくは 選択中」のようにしたいので、条件の表現を AND だけでなく OR も扱えるように見直す必要があります。やることとしては、フィルタ条件を「`(Landmark) -> Bool` と、その結合方法（AND/OR）を示すオペレーション」を持つ形にする、といった方向性になると思います。 これは、`Bool` と `Bool` を受け取って `Bool` を返す関数を、プレディケートと組みにしたタプル型です。この型を定義して、FilterConditions に入れていきます。ラベル名は何にしましょうか。最初は判定なので、プレディケートでよさそうです。かなり雑な名前になってしまいますが、これでオペレーションも持てるようにしておくと、フィルターを追加するときに両方を扱えるわけですよね。

FilterCondition では、先頭から `&&` と `||` をどう適用するかを考えないといけません。`||` が先に来て、`&&` のときに `||` が `true` なら OK、という感じですね。つまり演算子の優先順位も考慮する必要があります。どうしようかな、とりあえずやってみましょう。かなり雑なコードになってしまいますが、これは AND 条件ということで……と思ったのですが、実はできませんでした。

FilterCondition はこのパターンですよね。プレディケートはランドマークを受け取って `Bool` を返すもの、オペレーションは `Bool` を2つ受け取って `Bool` を返すもの。このタプルの配列である、という前提の中で、オペレーションに `&&` を入れたいのですが、これはランドマークを取って `Bool` を返す関数ではありません。`&&` は関数として書かないとダメ、ということもないはずですが、では何が間違っているのでしょうか。

ランドマークを受け取って `Bool` を返すものと、`@autoclosure` が絡んでしまうのかもしれません。`@autoclosure` の演算子を追加で渡したいので、`Bool` を返す関数として渡します。これで `append`。……これもダメですね。`throws` にするか保持するか、`throws` としてあげると、できました。`&&` 演算で追加できました。

次に、`filterCondition.append` でランドマークに対して何をチェックするかです。これは何でしたっけ、ID チェックですね。これはマストの条件なので「必須」にして、もう1個追加します。演算子の優先順位がうまく扱えていないので、そこは考慮しないといけません。

とにかく `allSatisfy` ではなく、ここは `reduce` にします。`true` から始めて、最初の引数が `partialResult`、次が `condition`（`FilterCondition`）。`partialResult` は `Bool` 型です。`condition.operation(partialResult, condition.predicate(landmark))` の形で畳み込むイメージですね。

`filterConditions` を `reduce(true)` して、`partialResult` と `condition` を受け取り、`condition.operation(partialResult, condition.predicate(landmark))` を返す、という処理にします。`Bool` が返るはずなのですが、挙動が変ですね。`condition.predicate(landmark)` の呼び出しのところで、メンバー名や指定の仕方が間違っている可能性があります。プレディケートとオペレーションのメンバー名は `predicate` と `operation` のはずですが、命名が食い違っていました。

ここは `@autoclosure` を取っているために、そのままでは渡せません。`@autoclosure` を渡すのではなく、通常の関数として扱う必要があります。非常にわかりにくい状態になっていました。 これでOKかな。`Void` を取って `Bool` を返すプレディケートです。ビルドをかけてみると通りませんでした。丸括弧がなく、さらにスローイング関数になっているので対処が必要です。ここで `try!` を使うのは非常に良くないですね。プレディケート内で `throws` なオペレーションがあるので、ちゃんと扱わないといけません。

条件の優先順位も整理します。部分的な結果、というより `isFilterSatisfied` でも同様ですが、セレクティブな条件、つまり選択中のランドマークを最優先にしないといけません。`isFavorite` よりも選択状態の判定を先に上げる必要があります。したがって、`isFilterCondition` における Favorite の条件は、それらより後に評価されるようにします。柔軟性はあまりありませんが、コード上は表現できます。これで、選択されているものを第一優先として、"Favorites only" をオンにするとお気に入りだけが表示されるはずです。

チェックマークを外したときに星が消えないかと思ったのですが、リストから消えました。なるほど、条件が `A && B || C` の形になっていて、短絡評価を考えると、両方が満たさないといけない場面が出てきます。ここは丸括弧が必要ですね。`(A && B) || C` のようにしないと意図と異なる評価になります。このフィルターの仕組みは少し良くない気がしてきました。こんなに複雑なコードにしなくてもよかったという状況です。

そこで、ざくざくと戻していって、`reduce` はやめ、もう一度 `isFilterSatisfied` に戻します。リストは良い、セレクションも良い。条件判定のところで、フィルター条件を評価する前にセレクションの有無を見ます。選択されていれば、それで確定、という流れにします。

フィルターのこの部分で、`isSelected` の判定を入れます。`isSelected(landmark)` のようにして、ランドマークの `id` が `selectedLandmark` の `id` と一致しているか、という条件にします。これくらいなら良いですが、もう少し分かりにくいかもしれません。クロージャの `$0` を使うなら、`$0.id == selectedLandmark?.id` のような形ですね。引数を取る形にして、`isSelected(_ landmark: Landmark) -> Bool` という関数を用意します。これは外に出しておきます。

これでビルドが通ったので動作確認をします。macOS で実行して、選択している状態で "Favorites only" にすると……消えてしまいますね。ダメでした。失敗です。消えたということは選択状態のはずなのに、`selectedLandmark` の反映がされていないように見えます。このあたりを見直します。

リストでは、`filteredLandmarks` が `binding.landmarks` ですよね。ランドマークが選択されたようになるのか、という点を確認するために、`onChange(of: selectedLandmark)` を使って、選択されたランドマークの名前を `print` してみます。`selectedLandmark` は `Landmark?` なので、アンラップが必要です。`??` か `!` が必要ですが、もちろん安全のためにはオプショナルバインディングで扱うのが良いです。

`onChange(of:)` は引数が `Equatable` 準拠である必要があります。`selectedLandmark` 自体はオプショナルですが、中身の `Landmark` が `Equatable` であれば、オプショナルも `Equatable` です。`Landmark` は `Hashable` 化してあるので、`Equatable` にも準拠しています。`onChange(of:)` の定義を見ると、`Equatable` で、初期値やアクションの引数が新旧2つの値を取る形もあります。したがって、この条件は満たせるはずです。 これでビルドが通るということでいいんですかね。どうなんだろう。あ、ダメか。ビルドが失敗して、エラーが出ます。やっぱりオプショナルですもんね。えっと、`??` かな。そして強制アンラップ。`selectedLandmark` を強制アンラップか。ちょっと怖いですが、まずは実験なのでやってみましょう。これでビルドが通って、最初の1回が `onChange` が発動しなければ良いのですが、ああ、ダメだ。壊れてしまいました。`onChange` がそうなっちゃうのか。

そうすると、`nil` を考慮した場合、`onChange` が使えないとすると……SwiftUI。SwiftUI で `onChange` とオプショナル。検索結果にちゃんと出てきますね。オプショナルな State/Binding で、`onChange` ではオプショナルが導入できるって書いてありますけど、これ AI による回答だから大丈夫かな。

`onChange` は、オプショナル……オプショナルと `initial` がいるのかな。`onChange` の……よし、これを見てみますかね。`onChange` が、えっと、`onChange(of: ... )` で、オプショナルなインデックス。あ、これ知ったばかりなのに、ないか。えっと、だから、これで `onChange` をちょっと手に取ってみますか。出てこなくなった。じゃあ、補完候補。`.onChange`。で、`onChange` の……`of`。えっと、`V` か。この辺が、`of: V` で `initial: Bool`、これでアクションは escaping。これは何だろう。どっちが変更するやつですかね。変更というか、古い値と新しい値を検出するやつ。

オプショナルがちょっと出てこないですね。オプショナルは、`onChange(of:)`。これで、`onChange` は `value`。あれ、これが deprecated のやつですよね。それで、`of:initial:`……`onChange` のどっちだ。まだ手でも分からないから入れてみますが、これで `of value` で `V`。`V` は特に何も……えっと、規定されていない。`V` は `Equatable` か。`V` は `Equatable` で、`Binding` は `Equatable` じゃない、っていう感じ。違いますかね。`Binding` ですね。

これをやるとすると、`selectedLandmark` の `wrappedValue` だ。これで大丈夫なんじゃないかな。`selectedLandmark` は普通の `Landmark` のオプショナルでしたね。これで `Landmark` が `Equatable` ですよね。`Equatable` の `private var` の `@State` ですよね。`wrappedValue` ではないことは確かなようで。これは、`Binding` に無理やりすると、何にも変わらない感じがありますかね。

ビルドをかけて……ビルドフェイル。ビルドフェイルの中で、ModelData が見つからない。ModelData、これはユニットを失った感じ？ ModelData はいますよね。これは関係ないエラーですね。ビルドをもう一回かけて……Missing ～。これはダメですね。押してあげてビルドをかけて。これだと、`Binding` したのをラップするという、そういったことをやっていますけど、これだとどうでしょうね。ビルドが終わらないかな。終わらないですね。

`wrappedValue`、`Landmark`。これは、これもダメかな。`Landmark` の `Binding` で、名前が誰でもいないしね。ここは普通の `selectedLandmark` で、これもオプショナルだからダメですよ、というお話になっていて。

ここを何とかするには、`selectedLandmark` の、例えば `id` にしてみましょうか。`id`。これだとオプショナルの `String`……じゃない、`Int` 型。これはハッシュ、というか、`Equatable` で間違いないはずなんですけど、これもダメか。`id ?? 0` とか `0`。これは通りますよね、きっとね。いや、通らないか、今度はね。ビルド中で、結局通らなかったか。fatal error。これは関係ないですね。ビルドのエラーがどうなっているか。ここじゃないのかな。今、ビルド中ですね。ビルド中でビルドフェイル。コンパイラのエラー。ここか。この辺は `Landmark` を……。 とりあえず表示するようにして、これでランドマークのIDでビルドは成功しました。なので、IDが変われば何か反応が得られるだろう、という状況になったはずです。あれで選択するとエラーが出ますが、何も変わりません。例えば、うまくいくかな。一回ちゃんとアプリを落として、実行をかけました。起動したら何かを選択します。そうすると、Executable にログが出ないですね。つまり、`onChange` が反応しなかったということが分かりました。

だから、この辺のリストの記述が間違っている可能性があります。その間違いを突き止めるには、リストの中の `selectedLandmark` と、あと `filteredLandmarks` の扱いを確認します。`filteredLandmarks` はどんな形かというと……これは `Binding<Landmark>` ですね。リストのバインディング、その辺が分かっていないのかもしれません。

`List`、`ForEach`、`selection` のあたりを見ていきます。選択可能なリストの生成として、`List(selection: $selection)` にして、`ForEach` の中で `tag` を付けていますね。`tag(12)`, `tag(20)`, `tag(30)` のようにタグを入れています。タグを入れないとダメかもしれません。この可能性は十分にあり得る、あり得すぎそうな感じがします。

`List` の `ForEach`……これは違いますね。この後かな。`List` の `ForEach`……ここも違いますね。ここも `ForEach` と `selection`。ただ、`selection` 用の値を用意して、値を保持して回しているので、その型に合わせる必要があります。`ForEach` で回すデータの型と、選択したデータを保持する変数の型が一致していないと、正しく動作しません。この前提の上で、`List` と `ForEach`……ここはまだかな。`SelectionValue` を使っただけか。で、オプション（Optional）なんですね。`selection` を指定してから、`tag`（あるいは `SelectionValue` に対応する値）を指定する。そうするだけで、選択可能になると書いてあります。

なので、`ForEach` で回したやつの ID が `\.self`。この ID も何か効いてきそうな気がしますね。とりあえずその辺を理解できたら、`Binding<Landmark>` ですが、これ、`Binding` かな？ そうすると、`selectedLandmark` が `Binding<Landmark>`。こんなふうにして、`Binding<Landmark>` を定義したから、それを使いましょう。`Binding<Landmark>` 型にして、これでできたかな？ そうすると、ここのエラーで、`selectedLandmark` は `Binding` だから `wrappedValue` ですね。`wrappedValue` の `id`。これで実行してみましょう。

型が一致しているとしたら問題ないので、変更が行われてリストにちゃんと残る、ということになると思ったのですが、`wrappedValue` が……だから `selectedLandmark` を使っている他の部分。`selectedLandmark` は、ここの `selection` の他にも、ほかで参照しています。ここが `selectedLandmark` の……ここですね。`wrappedValue` の `id`。これでビルドが通るので、実行してみて、これでちゃんと動くのかな？

またビルドに失敗しました。ビルドエラーの箇所は `ModelData`。これは古いですね。ローカルでの iOS 用ではなく、ここなんですけどね……ビルドが……ここ？ ここじゃないですね。どうですか？ macOS 用のビルドだから、こっちだ。macOS 用のビルドで、ここだ。タイプチェック、コンパイラのタイプチェックがこの辺。`onChange`、この辺ですかね。`wrappedValue`、`selectedLandmark`、`wrappedValue`。`Binding` だから `wrappedValue` でいいと思うんですけど、その値の当てはめの中、ここもですね。これでビルドをかければ、これで OK ですかね。

やることは、リストにちゃんと選択されているものが残るかどうかを確認することですよね。大事です。で、またビルド失敗。えーと、ビルド失敗は macOS で、macOS のビルドの失敗は、ここが……これのタイプチェックがやっぱりこの辺がダメで、これでランドマークの `wrappedValue`。この辺の `wrappedValue` と `onChange` が問題だと思います。 とりあえず、これ抜きでビルドしてみますか。型が合っていればと思ったのですが、まだダメですね。ここが `selectedLandmark`、あ、これがダメだな。これの `wrappedValue`、これでいいのかな。`selectedLandmark` の `wrappedValue`、あ、これはダメか。`Optional` で、`nil` を除外、`nil` を除外……これは関係ないですよね。これではオプショナルのままじゃないや。これは普通にダメですね。デフォルトバリュー……それも違いますよね。すると、`selection` が難しいですね。

`ForEach` で、`selection` が難しいな。`ForEach` で、例えば `id: \.id`、そして `id` というふうにしたときに、`selectedLandmark` というものを `Binding` で持てるのかな。どうなんだろう。えーと、そうはいかないのかな。`String`。とりあえず `String` でビルドをかけて……ビルドをかけると、これはこれでエラーですね。`wrappedValue` が `id` になるので、それをそのまま比較して……それでもダメか。あ、そっか、`@Binding` とかやっていないから、`selectedLandmark` が素直な `id` になっているとして、それで `selectedLandmark` が `String` ですよね。`String` がコンバートできない。`String` から `Int`……あ、そっか、`Int` か。だから `Int` のオプショナルですね。`Int?` にして、これでビルドをかけて……ビルドが通って、デフォルトをかけて、`id` 取れるのかな。

選択で、これを「お気に入りのみ」にしたときに……お、残りましたね。選択を変えると、これで星が消えますね。ちゃんと消えた上に残っていますね。これでできた。うん、あ、いいですね。やっぱりこの Row が消えちゃったから、このバインディングがもう失われて、スターが反映されなくなっちゃった、という状況ができてしまったことが分かったので、これはなかなか難しいですね。どうするんだろう。

フィルターはこれでいいのですが、星をなくした上で他のを選んだときに、もうすぐに消えちゃう。これが気になります。ここまで気にする場合は、もうちょっと、配列で `selection` を持つのか、あとは表示すべき `id` をスナップショットとして取っておくのか。フィルターをいじるまでの間、スナップショットを取っておく。そういったことで、回避できそうな感じがしますかね。

フィルターで、スナップショット。だから、フィルターとアイテム……フィルターとランドマークを、計算型じゃなくて、このフィルターをいじった「その後」ですかね。フィルターをいじったときにボタンを押してあげる。そうすると、フィルターをいじらない限りはリストが変わらない、ということができるようになります。それでもいいですね。フィルターをいじったとき……フィルターをいじったときに忘れないようにしないといけない。それが重大ですが。

フィルタードリストの変更は、リセットしかないかな。依存した場合にそれを更新するためには、やることとしては、フィルターが変更されたかどうか。だから、フィルターをクリックしたかどうか、このメニューをね。フィルターをクリックして変更されたとき、変更されたときに値が変わる。なので、この値を監視して、ランドマークリストを更新してあげるか。フィルターを構造化してフィルターオブジェクトを作って、それを `Hashable` にして、その `Hashable` が変わったときにリストをリセットする。それでいいですね。そうしてみますか。

これをまた次回にしてみますかね。とりあえず、なんとかフィルターが反映できるようになったところで、次はリファクタリングですね。これをやっていく回にします。そんな感じで次回お会いしましょう。では、これで終わりにします。お疲れ様でした。
