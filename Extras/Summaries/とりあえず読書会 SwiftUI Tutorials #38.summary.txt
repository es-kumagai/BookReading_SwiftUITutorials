Transcription & Summarize : とりあえず読書会 SwiftUI Tutorials #38

それでは続編を始めていきましょう。SwiftUIチュートリアルをついに一通り読み終えまして、これでネタは尽きているはずなんですけど、リファクタリングをしていたからですかね、挙動がおかしいと感じるところが1つあります。あとは、それ以外でも今やっている中でだいぶ綺麗にコードが書けたなとは思うんですけど、この辺りでもう少し言い切れるところがあるのかなとか、`#if`ディレクティブ…ディレクティブって言うのかな、Swiftだと。まあ分からないけど、「もしも」という条件分岐の辺りも、マルチプラットフォームだとしょうがないと思うところはあるんですけど、もう少し綺麗で分かりやすい感じにできたらいいのかなと思ったりしています。いろいろ思うところはあるので、せっかくなので、そういったところにも目を向けて、いろいろ考えてみたいなと思います。

はい、じゃあ早速その辺りを見ていこうと思いますが、どれを見ていきますかね。まず不具合ですかね。不具合は、もはや私はそれを見ないとダメですよね、逆にね。不具合を残しておいて、それで完成というのもまあまあいいんですけど、世の中いろんなトレードオフがあるようなのでね。でも、そんなトレードオフを考えたときでも、こういう練習ではきちんとやるのが絶対にいいと自分は思うんでね。やっぱり、知らないでやらないのと、知っていて何かの事情でやれないのとでは、品質が違ってくると思うんですよね。

という感じで、まずはバグを見ていきましょう。最近はテロップも入れるようにしたので、ここから聞くときも、まずは最初の一回なんですよ。「最初の選択が無視されるかも」というところをやっていきたい気がします。じゃあ、そういった形でやっていくとします。

まずこのアプリですよね。まあ、OSの話ですね。選択がおかしい…たぶん、たぶんですね。というわけで、この辺もちゃんと見ないとダメですね。マルチプラットフォームは、全部ざっと動いているかみたいなのを見るのが大変ですよね。まあしょうがないですけど、コードが再利用できているだけ、まあいいとは思うんですけど。

とりあえず実行して、まず最初の1クリックですね。これを見ていきたいなと思うんですけど、このとき、今日はリファクタリングもやろうかなと思います。まあ、ハマると難しい時ありますよね。そんなもんだと思って、元のほうが一番良いですかね。コンパイルエラーとかも、慣れないうちはたくさん出てくると面食らったりすると思うんですけど、慣れてくるとどうでもよくなるじゃないですか。いきなりエラーが100個とか言われても、100個ぐらいのエラーだったら2、3カ所直せば通るかな、みたいな。逆に多いほうが楽というか、そんなのあったりしますよね。

この狭い画面でやるには辛いですよね。なので、Xcodeを小さくするほうがなんか快適な気がするので、これでやってみましょう。

クリックするっていうところだから、リストですよね。ランドマークリスト、ここが問題になっているのだろう、ということが察せます。そうすると、まずはここを狙っていくといいでしょうね。難しいな、意外と。まあ、慣れていないからっていうのもあると思うんですけど。

`LandmarkList` のアップデート、この辺はあんまり関係ないかな。リストがあって、`ForEach` があって、で、ナビゲーションでこれをクリックした時ですよね、おそらくね。なので、選択した時の表示で、ここか。この辺りがどうなっているかっていうのを、まず見たらいいのかな。

ここでブレークポイントを貼って、自動的に処理が続くようにした上で、ここで押されたコードをこのマークにしようかな。このマークにしましょうかね。で、それでランドマークの状況を見て、様子を確認。今の状態で…何もないか。あれ、何もないですね。あ、なってる、なってる。違うかな。やばい。あ、でも出てますね。で、あと、ランドマークで出てないや。なんか間違えましたね。ランドマークが出てくれないところもあるかな。あっという間でしたね。次はね、あっという間で…リロードが来るな。

これで押すとブレークポイントが当たります。当たり前ですけど。あれだ…ブレークポイントはビルドし直さなくても動くの、いいですよね、と思ったけど、あ、プライベートネーム…それを期待している？あ、名前間違えてるのか。Edit Breakpoint で、`landmark`、`landmark`、合ってそうですけどね。`landmark` が違うかな。あ、コンディション、間違えました。コンディションじゃない、アクションですね。なのに、なぜこれが出ているのかがちょっと気になるんですけど、そういうものは…まあいいか。

とにかく一度捨てて。えっと、ランドマークが出ない。出ないことはないですよね。出ないので、何も…何もないんですけど。えっと、`landmark`、`Landmark`、`Landmark`、ですよね。で、これでコンソールに出しますよ。読めなくていいですね。 ランドマークが出てこないのはなぜでしょうか。ランドマーク側で何かが起きているのかもしれませんが、そうではなくてデータ側でどうにかできるのでは、という気もします。

デバッグ用に、`print` を使えるようにしてありました。`ViewBuilder` の中で `print` が使えるのは、以前に仕込んでおいた `ViewBuilder` の拡張のおかげです。デバッグモードに限り、`ViewBuilder` で `Void` を返すものを渡せて、`Void` を渡したときには `nil` にしてくれるように拡張してあります。つまり、`Void` を返す関数を `ViewBuilder` の中に埋め込んでも影響なく使える、というコードを書いてあるので、`print` ができるようになっています。読みづらいかもしれませんが、ここでもデバッグ時だけ有効になるようにしてあります。本当に動くかは分からない、というところですが、とりあえず使っています。

選択をすると、例えば `NavigationLink`、1回目は完全に無視されましたね。もう一回押してみましょう。あ、違うのを選んでしまいました。ダイレクトに遷移しているはずですが、ログは出していませんでした。ハートマークが1個……1個かどうか分からないので、ハートマークで検索をかけると、あれ？ 48個もある？ どこか、ディテールが表示されるかどうかに関係なく、デバッグのログだけ出てしまっているのかもしれません。断言はできないですね。

`NavigationLink` でも同じですね。こういう状況のときは、毎回ログを捨てて確認すればよさそうです。この状態で「Lake McDonald」を選ぶと、12個、12個……0、1番目のハートフラグ……もう、材料が全部出ていますね。これだとあまり意味がありません。要は「クリックされたかどうか」を知りたい、という状況ですから。

なので、「クリックされてディテールが出るか出ないか」を見るために、ディテールに対して `onAppear` を付ければよさそうです。`onAppear` の中で `print` すれば大丈夫ですね。`print` で絵文字を付けて、この後にランドマークだと長すぎるから、`name` でいいですかね。押してあげるとディテールが表示され、そのときランドマークの名前がハートマークと一緒に出る、という形になれば OK です。やってみましょう。ログの名称はデバッグ用のままで構いません。あとで一掃します。

ということで、`NavigationLink` を押します。大丈夫じゃないですね。もう一回押すと、このときにはハートマークが出るかどうかを確認します。うん、1個だけ出ています。それで……あれ、バインディング？ これは何というのが正しいのか分からないのですが、バインディングで `name` を出したはずなんですけど、`name` ってそんなに複雑でしたっけ？ `name` は `String`。あ、そういうことかな。バインディングからランドマークを参照しているので、`Binding` のせいで表記が長くなっています。なので、`wrappedValue` を取ってあげないと、ちょっと長くて困ってしまう感じですね。とはいえ、今回は Lake なので、これで良いでしょう。

つまり、1回目のクリックが完全に無視されている、ということがとりあえず分かりました。では、完全に無視されたと分かったときはどうするか、という話です。これは厳しそうな予感もします。デバッグ出力は、出れば分かるので、このくらいでいいでしょう。

次に、`SelectedLandmarkID` が変わったかどうかを見てみればいいですかね。どこに書くかというと、いちばん上の層に `onChange` を付けます。`onChange` の対象は `SelectedLandmarkID`。そのときに、忘れないように `print` を入れて、例えば「ハートマーク」のようにして、せっかくなので `oldValue` と `newValue` を出すようにします。これでどうなるかを調べたいのですが、その前に余計な感じのログメッセージは消しておきたいと思います。 モデルデータがイニシャライズされたタイミングなどは、`print`を見れば分かりますね。`print`や、`onReceive`で通知を受け取ったときにログを出すのも良いです。こちらは別途アップしておいたところで、これはこれで良しとします。

次に、お気に入りが変化したことをチェックする`onChange`ですが、これも良いですね。`oldValue`と`newValue`が両方ともオプショナルなので、あとは`nil`チェックしておけば回避できます。これでビルドして実行、スタートとなります。

では、クリックしてみます。はい、回りました。`nil`から1006へ。1006はIDですね。この後も、1006から1003へ、といった感じで遷移しています。最初に`nil`だからかな、という気もしますが、いや、関係ないかもしれません。試してみましょう。何をするかというと、この`selectedLandmarkID`の初期値を、例えば1001にしておきます。これで実行。押したときにどうなるか、ですね。今は最初に1006が選ばれている状態です。ディテールには出ていないですが、ここがちょっと面白いところです。例えば、ISPを選ぶと、あ、もう出ましたね。最初に`nil`だから問題が起きていたのかもしれません。

もう一回`nil`に戻しましょう。この状態で実行すると、何も選択されていない状態で始まります。ここでTwin Lakesを選んでも、なぜか無視されます。そうなんだ、としか言えませんが、本当にそういう仕様なのか……。どうしましょう。リストがあって、`selectedLandmarkID`があって、`ForEach`があって、ディテールがあって。そもそも最初のリストですよね。リストのセレクションが、変わったときに動くのか、動かないのか、分からない。

ちょっとAIに聞いてみます。コマンドを打って……出てきました。表示（displaying）がどうこう、`@State`か、`selected`か、なんだこれ。もう一回整理します。`selectedLandmarkID`を`nil`で初期化しているときに、今のコードのように実行し、リストから（`List`かな、`ForEach`か）アイテムを選択しても、最初は`selectedLandmarkID`が選択したものに更新されはするものの、リスト自体は選択状態に一瞬なってから解除されてしまう。その理由を教えてください、と。`selectedLandmarkID`のロジックを見る以外に、リスト側の実装に手を入れると正常動作します、という感じで聞けば、一般的には、当たれば結構いい感じに教えてくれると思います。別のコードで聞くのは初めてだな、そういえば。

多分、読んでくるのかな。答えは、「最初のタップでデータソース（`ForEach`の配列）が差し替わる、あるいは再構成されているため、リストのセレクションが選択状態を維持できずにクリアされてしまう。固有のIDで安定化しておくと、最初の再構成でも選択が残るため、問題が起きにくくなる」というもの。うーん、どうでしょうか。そうなの？ という感じもしますが、とりあえず次を見てみましょう。

リストのデータが初回表示後に差し替わる。リスト内の`ForEach`のデータは`filteredLandmarks`で、その中身が`displayedLandmarks`や`selectedLandmarkID`に依存している。……まだ3回まで出ていたら安心しました。 確かに、`bindingLandmarks`からのフィルターで`displayLandmarkIDs`に依存しています。そこまではいいですね。そして、`displayLandmarkIDs`は`updateLandmarkList`によってあとからセットアップされます。これは`onAppear`と…いや、違いますね。フィルターが変わったときですね。

画面の初回表示時点では、`displayLandmarkIDs`が空のままで初期化され、`filteredLandmarks`も空に近い状態で描画されます。`onAppear`でやっているからということですね。そこで、最初のタップでIDが変更されるタイミングとほぼ同時に、`onAppear`の`updateLandmarkList`によって`displayLandmarkIDs`が更新され、差し替わります。

つまり、`onAppear`を付ける場所が良くないのかもしれません。今はListに対して`onAppear`が付いていますが、もしかするとNavigationのほうに付けるべきかもしれません。フォーカスバグや`onChange`を入れたところです。クリックして確認しようとしたのですが、録画が出てしまってダメでした。自分の予想が外れだとすると、`selectedLandmarkID`が更新されるタイミングとほぼ同時に、`onAppear`の`updateLandmarkList`が実施される、ということになります。`onAppear`で`displayLandmarkIDs`が更新されるのはそうなのですが、`selectedLandmarkID`より前にリストがすでに表示されているじゃないですか。そこが気になっていて、このあと選択しているので、説明と違う動きに見えるんですよね。

ともかく差し替えが起こって、選択が解除される。これは分かります。特にそういった場合のListのselectionは、選択中のIDがその瞬間に表示データの集合に存在するかを厳密に見ます。差し替えの瞬間に存在しない状態が挟まると、選択はクリアされます。選択したときに見るとIDになると思うのですが、この時に変わるのかな。なんか違う気もしますが、分かりません。

とにかく、アニメーションによるselectionの再評価が選択時を不安定にします。アニメーションの設定はデフォルトで、`animation(.default, value: filteredLandmarks)`にしています。`filteredLandmarks`が変化したときのアニメーションですね。

初回のみの条件として、Listのselectionと`NavigationLink`を使っていれば、初期状態から最初の選択を行う瞬間に、スプリットビューのListやDetailの描画処理が同時に走ります。ここに前述のデータ差し替えが重なると、リセットされやすくなります。一方で、最初から`selectedLandmarkID`を選択しに行かないでおくと、初回のデータ差し替えが起きても、選択されるアイテムが表示集合の中に存在するため、状態を維持しやすく、クリアされにくくなります。

一旦アニメーションを切ってみましょう。アニメーションを切るとどうなるか。これで、例えば人類を選ぶ。ああ、どっちもダメですね。アニメーションはまずいいとして、これ以外の根本原因ですね。 ただ、この説明にはまだ納得できていないので、まあいいや、解決策を少し読んでから考えることにします。表示の前にランドマークアイテムを準備しておく、という話ですね。`init`や読み込みのタイミング、それから`task`か。`task`は`onAppear`より前に走ると聞いていますが、`onAppear`とどう違うのでしょう。そういえば、`task`と`onAppear`はどちらが先に動くのでしょうね。確認してみましょう。

確認といっても事実の確認だけですが、`task`をやる前に「task」と表示させて、まずは実行してみます。こうしたときには、`task`が先に動きましたね。説明では`task`がタイミング的に先に動くという話なので、ここはそういう挙動だと分かりました。もっとも、`task`にすること自体にはあまり期待しないほうが良いかもしれません。`task`にしたので、ひとまず確かめておきましょう。全体として挙動は確認できました。

なので、ここは`task`でも`onAppear`でも良いのですが、不必要に`task`を立ち上げるよりは、`onAppear`のほうがタイミングを測りやすい気がするので、元のまま`onAppear`で良いでしょう。あとは「初回だけアニメーションをオフ」というのは違いましたね。

モデルデータについて、少し順番を逆に言ってしまいましたが、`filteredLandmarks`のように初期値を計算済みにしておく話です。モデルデータのライフサイクルには注意が必要です。`EnvironmentObject`になっているので、今回は`onAppear`の時点で有効な値が使えるはずです。

`filteredLandmarks`は、`Binding<[Landmark]>`としてではなく、安定した`Identifiable`の値配列として扱いたいところです。ランドマークのアイデンティティは厳密に保ちたいです。レースバグの可能性もなくはないのかなと思う部分もあって、`Binding`を使っているので少しややこしくなってしまいましたね。

レンダリング時に選択をキャンセルさせたい場合は、最初からIDを入れておく、というのも一つの例としてあります。`firstIndex`を入れておけば、`landmarks`や`filteredLandmarks`の`firstIndex`を使うことで問題は起きにくいでしょう。そういう手は確かにあります。ただし、今回はそれをしたくありません。なぜなら、挙動がおかしい原因を見つけないまま「IDを設定すればいいじゃん」で済ませるのは、あまり気分がよくないからです。もちろん、どうしてもできない場合の回避策としてはありですが。

さてどうしましょうか。リストがとにかく選択解除されてしまいます。リストの選択状態の話ですね。`List`の`selection`自体はちゃんと保たれているにもかかわらず、見た目だけが解除されてしまうのがとても不思議です。なぜでしょう。再描画が走ったとみなされて、キャンセル扱いになっているのかもしれません。

もしリストが更新されたと判定されて選択が解除されてしまうなら、`selectedLandmarkID`が直前の選択IDを維持し続けているのはなぜなのか知りたいです。選択が別レイヤーで管理されている可能性があります。データ側はランドマークIDで状態管理され、UIレイヤーは`List`の`selection`が内部で管理している、という二重構造ですね。`Binding`とはいえ、更新や内容の増減で不安定になるのは、これまでの`Binding`でも悩まされてきたところなので、確かにあり得ます。

`filteredLandmarks`は`Binding<[Landmark]>`で、各ランドマークの`id`はSwiftUIの`id`（`Identifiable`の`ID`）を取っているはずです。`Binding`から`id`を参照すると、このインスタンスに割り当てられている`Binding`のIDが得られる、という理解で良いのでしょうか。だとすると、これが古い可能性もあります。ランドマークが`Binding`になっている都合と、再描画のタイミングとの兼ね合いで、`Binding`が指しているランドマークと実際のランドマークがずれている可能性がありそうです。選択が変わったときに起きるのかもしれません。 そうするとなると、`selectedLandmarkID` もクリックしたときに変えないといけないということですかね。そういうものでもないか……難しいですね。どうしましょうか。

初回に `selectedLandmarkID` を、例えば意図的に何度も更新したらどうなるのか試してみます。`onAppear` のところで `updateLandmarkList` を実行し、その上で `selectedLandmarkID` に `nil` を代入する、というのを意図的にやってみます。そうしてみると、最初は `nil` のままになりますよね。その上でクリックしても変わらない。変わらないとなると、`updateLandmarkList` は `displayingLandmarkID` を `ModelData` の `landmarks` をフィルターした ID に更新する、つまり `ModelData` を更新する処理ということです。`ModelData` ということは、やっぱりプロパティでやらないとダメですね。

ここで `selectedLandmarkID` を更新しても何も変わらなかったということなので、クリックしたときにどういう動きを見せるのか、という状況ですね。`List` の selection が変わっても、その変化がトリガーにはならなかった気がします。いったん selection を外してみましょう。そうすると何も選択できなくなるので、これはメニューに影響する程度で、実際問題としては特に何もないと思います。これで Twin Lake をクリック。これは大丈夫なんですね。なるほど。

そうすると、原因は完全にこれです。selection があるかどうかですね。selection があったときに、この ID が選択中のランドマークの ID と一致しているのですが、もしかしてこのときに `tag` を付けたらどうなるのでしょうか。今は逆にしていますよね。 なので、`List` と `ForEach`、`tag` の付け方をすっかり忘れてしまいましたが、`List` と `ForEach`、`tag`。これはリファレンスを見ないとダメですね。まずはリストを作ってあげて、そうですね、これで `ForEach` と `tag`。リスト内で繰り返すこのタイミングで `ForEach` を使うか、`ForEach` のループ内で `tag` を使う必要はないのか、そのあたりはとりあえずどうでもいいや。まずは `List`、`ForEach`、`tag` の挙動を知りたいです。タップやスワイプ的な操作の話はひとまず置いておきます。

`ForEach` は、`List` の中に入れないとダメかな。`List` と `ForEach`、`tag`。シンプルな方法というか、`ForEach` の中身が `Text` だけなら、これは特に `tag` いらないですね。ほかには、オプショナルの場合でも、`ForEach` の中身が `Text` だけなら別に問題ないですね。

`selection`、`value`、`content`。シンプルな書き方は、`List { ForEach(...) }` で、`id` を付けて、ここで `tag`。つまり、`tag` は中身に付けるってことですか。つまり `ForEach` の中身ですね。やってみますかね。`ForEach` の中身に対して `tag`、そして `ID`、ランドマークの `id`。これでいいのかな。ラベルを入れるのかな。とりあえずビルドをかけてみますか。これで別に問題が解決するとは限らない気がしています。ラベルと value の `id` だとどうでしょうね。こうしたときにクリック……これもダメですね。ここに出ちゃう。ラベルと value の `id`。これもダメですね。

そうすると、`tag` ですね。あとは、`ForEach` で `id` を指定しなかったときにビルドをかけると、選択状態がダメなわけですけど、こうしたときに今押したんですけどダメですね。これもダメか。そうすると、`tag`。ここに `tag` を入れてみましょうか。`.tag`。`tag` もそうなんですが、クリック2回目は大丈夫ですね。`tag` としてランドマークの `ID` というふうにしてあげると、これがどうだろう。最初はやっぱりダメですね。なるほど。

これで、`selectedLandmarkID`。これもあるんですけど、あとは、`@State private var selectedLandmark` として、バインディングをランドマークというふうにして、オプショナルで見るとした上で、こっちでステートか。最初は…いや、変えておきますか。プライベートはちょっと置いといて、`selectedLandmarkID` がオプショナルで、これは `selectedLandmark` の `ID` ですね、というふうにしてあげて。こうしたのは純粋にコードを交換して、持ったまま実況をしたい、というか、それだけですね。

そしたら、`selection` の方を `selectedLandmark` をバインドさせる形にして、それで、`tag` としてランドマーク。こんなふうにするとどうですかね。ビルドをかけて実行をかけて……ちょっと手順を間違えましたね。ランドマークをここにしていって、このランドマークはバインドされていましたよね。確かに。`Section` と `landmarks` を見てもいいのか。`Section` と `landmarks` で、その他は `@Binding` の `landmarks`。

それで `tag` があって、この `tag` をちょっと消してみましょうか。ビルドをかけると、これだとどうだ……これもダメか。`selection` が `selectedLandmark` で、あとは `@Binding` のランドマークの `Hashable`。ここですね。型が `Hashable` じゃないよ、ということですね。 なので、IDが欲しいです。IDが欲しいという前提で何とかしようとすると、`Binding`は普通にランドマークを受け取る、ということにすればいいだろうという判断になります。そしたら、あとはここでタグ。このタグとして`Binding`したのではなくて、これを渡してあげれば、これでいいのかな、という感じでやって、ビルドが通った状態になりましたよね。

これで最初のクリックが……あ、ダメですね。2回目は大丈夫ですね。2回目は大丈夫で、これを「お気に入り」オンオフするのは大丈夫だと思うんですけど、オンオフすると消えちゃう。あ、消えますね。これは、おっと。面白いというか、これをオンにした時点で新しくなったと認識されて、選択が切れているんですかね。これはちょっと面白いですね。要は、この`tag`をやめて、選択しかないか。`tag`をやめるだけに戻してみますかね。`tag`をやめるだけだと一緒かな。今、選べましたね。選べたけど、これ、もう一回実行してみます。これで実行して、最初のクリック……選べた。選べて、あとは「お気に入り」。お気に入りはダメですね。だからつまり、`selectedLandmarkID`が変わっていないですね、これはね。

なので、`selectedLandmarkID`がリストと同一視できたと捉えると、いい感じですね、きっとね。そうすると、コードをとりあえず戻そう。ID、ランドマークの`id`で、`tag`もない状態ですね。ここまででいいかなと。それで少し良くなった。リストがやはり更新されたと見なされたということですね。だから、それを回避しないといけない。IDが変わったとき、または、`selectedIndex`の管理の仕方を変えるというのもあるのかもしれないですけど、それはやっぱり良くないかなと思うので。そうすると、また頭で考えていかないとわからないですかね。どう考えるといいんでしょうね。

`selectedLandmarkID`というのがあって、それで`body`に突入してきて、`updateLandmarkList`というものが`displayLandmarkID`を更新する。`displayLandmarkID`が更新されると、それを使っている`filteredLandmarks`が更新されるんですよね。だから、ここをちょっと見てみてもいいですね。`updateFilteredLandmarks`ですね。同じにして実行してあげる。そうすると、とりあえず3回更新されましたね。これで Twin Lake をクリックすると、もう1回更新されましたね。この後、多分更新されないのかな、というふうな……更新されていないですね。これで他を選んでも更新が。IDが内側にあるかどうか。`nil`がないと見なされる可能性がありますね。リストに`nil`がないと見なされて、`nil`から更新されたとき、選択状態が……。そうすると、更新されたと見なされて中身が変わる。`updateFilteredLandmarks`が走ると、`filteredLandmarks`が更新されてリストが確かに更新されますね。`filteredLandmarks`は`bindingLandmark`、`displayLandmarkID`ですね。だから、`onAppear`で`updateLandmarkList`、`onAppear`とか、実行したときに更新がされる、ということですよね。これをオフにするとリストが出ようがないですかね。なので、これだとどうにもならない。

`filteredLandmarks`が2回更新されているようですけど、ケースの方は`filteredLandmarks`が1回ですよね。ここが2回。`onAppear`で3回、ということですね。要は、`selected`が変わったときに、例えば`update`か。`update`で`displayLandmarkID`ですよね。`displayLandmarkID`。これが`update`でしたっけ。`updateLandmarkList`。そうですね。モデルデータからいろいろやっている。そうですね、難しいですね、これね。

`selected`でリストが変わったと見なされて再描画されてしまう。二度の代入というか、`selectedLandmarkID`が変化したときにリストが更新するしかないですね。`filteredLandmarks`が変わったということになり、それで……これは難しいですね。どうしようかな。

`selectedLandmarkID`。これ、いろいろ`onChange`で見た後に、`selectedLandmarkID`に`newValue`を入れるなんて無意味なことだと思うんですけど、これをちょっとやってみましょう。ダメですね。トリガーしてキャンセルされた。これはそうですよね、って感じですよね。これを`Task`で立ち上げて、時間差でやってみる、みたいな感じにするとどうなるのでしょう。これもダメですね。

そうですね。とにかく、オプショナル化は`updateFilteredLandmarks`……。`filteredLandmarks`の`onChange`。`onChange`か。ここで例えばリスト更新してやるとどうなるんだろう。`updateLandmarkList`。呼び出すとバインディングが壊れますよね。 とりあえず試してみます。どうなるか……これもダメですね。`onChange` を取ってみましたが、あまり意味がない気がします。原因らしきものは掴めたのですが、はっきりとは分からない状況になりました。

とにかく、このリストが新しいものに置き換わったと認識されているようです。その理由は、やはり `filteredLandmarks` が更新されたからだと見てよさそうです。その中に該当する ID が見つからない。`nil` から `nil` ではなくなったとき、そのときだけ `selectedLandmark` が更新されます。`NavigationLink` の反応もそのタイミングだけです。これは困りました。どうにもならない気がしてならないのですが、どうしたらいいでしょう。

では、`filteredLandmarks` を使わない場合はどうなるでしょうか。フィルターを外して、`ModelData` の `landmarks` をそのまま使う形です。バインディングでないとダメそうですが、バインディングにすればよさそうです。これだとどうでしょう。もっとも、そうするとフィルターは効かなくなりますが。

実際に画面を切り替えて、動いたところで選択してみます。あれ、今は押せていません。クリックも効かないようです。操作を間違えていただけでしたが、改めてクリックしてもやはりダメですね。`landmarks` を直接使う方法でもダメとなると、もはや簡単な話ではなさそうです。

テストする上ではどちらがいいのかを考えます。当たってみてもいいかもしれません。2回目のクリックは大丈夫なので、初回だけ何とかできれば全体としては回るのではないか、そんな気がします。

では、最初はとりあえず選択してしまった方がいいのでしょうか。`onAppear` でランドマークリストを更新したら、`selectedLandmarkID` を `filteredLandmarks.first?.id` に設定してあげます。これで実行すると……最初のリストが選ばれていません。ダメでした。初回は選ばれませんでした。

この ID がどうなったのかを確認します。ここで `print` を入れて、`onAppear` のタイミングで ID がどう変わるかを見ます。`nil` が出ています。`updateLandmarkList` の処理で `displayLandmarkID` が更新されたはずなのですが、その時点で `filteredLandmarks` が空っぽなのかもしれません。

では、`Task` を使って `try await` で少し待機を入れてみます。`Task.sleep` を挟んでから設定すれば `nil` にはならないはず……と思ったのですが、やはり `nil` でした。

`filteredLandmarks` の更新周りを見直します。`body` から `filteredLandmarks` を渡していて、これが古い情報を使っているのかもしれません。もし `filteredLandmarks` をローカルに保持しないと、どこかで毎回検索しないといけなくなってしまいますが、試しにローカルに入れない形にしてみます。すると、最初から選ばれましたね。今は、選ぶと次回にも反映される、という状況まで確認できました。 とりあえず動くようにはなりましたね。そうすると、もう一つ考えられるのが、このタスクをやめてもきちんと選択が取れるかどうか、という点です。実行して動作を確認すると、選択はできていて、押すと表示が切り替わります。いいですね。

ここで、`id` をいじらない場合にどうなるかを試しました。これで大丈夫な気がしたのですが、やはりダメでした。そうすると、`selectedLandmarkID` にとりあえず 2 を代入してみましょうか。これで実行……ダメですね。

最初の1件を選択状態にしておくというのは、現在の設計だとあまり好ましくない、というところに行き着いていました。`onAppear` でアップデートしたのが問題なのかな、とも考えました。`onAppear` でアップデートするべきかどうか。`onAppear` でないとすると、その場合はランドマークリストのアップデートが走らないので、`displayingLandmarkID` が更新されません。確かに、`displayingLandmarkID` は最初に更新しておく必要があります。そのせいですね。

となると、`updateLandmarkList` をどこか `body` の中で更新できれば良いのですが、それがかなわない。結局 `onAppear` でやっている処理なので、これだとダメで、リストが最初に出てこなくなってしまいます。なるほど、わかりました。しょうがないので、`selectedLandmarkID` を最初の要素に設定する方針にします。これで良いはずだと思ったのですが、まだダメな気がします。選択状態になっているにもかかわらず、最初の画面が `SelectLandmark` のまま表示されてしまい、別のバグが出ています。これは困りました。

ではどうするか。`updateLandmarkList` を、`selectedLandmarkID` が変更されたときに行う、という手も考えられます。`onAppear` では何もしないようにして、選択のタイミングでリスト更新が走るようにします。しかし、これは無視されてしまい、うまくいきませんでした。

ナビゲーションの最初のページは `SelectLandmark` にする必要がありますが、`selectedLandmarkID` がある場合は詳細を表示したい、という要件です。ここは、`selectedLandmarkID` を表示して様子を見る、という雑なデバッグも試しましたが、起動時は常に 1 になっているだけでダメでした。パラメータの型を渡せない都合もあって、`print` でログを出して様子を見るなどしましたが、押したときもやはりダメです。常に 1 のままですね。

そこで、ランドマークの詳細を表示する構成にします。`if let` を使って、`selectedLandmarkID.flatMap { id in modelData.landmarks.first(where: { $0.id == id }) }` のように `ModelData` から該当のランドマークを取得し、見つかったら `LandmarkDetail` を、なければ `SelectLandmark` を表示するようにしました。これで実行すると、ちゃんと最初から表示されました。ここまでは良さそうです。2回目以降はクリックで大丈夫ですね。Option クリックや Command クリックで選択を外せますが、その後は外れてしまいます。なるほど、`nil` から選んだときに外れてしまうのですね。

つまり、`nil` の状態からリストに戻ったときに選択が外れる、表示が外れてしまう挙動になります。これはちょっと困った感じがします。 とりあえず、余計なコードはもう消しておきます。何も解決しなかった部分ですね。これでいいのですが、ここが最大の難関です。

`List`で`selectedLandmarkID`をどう扱うか、どのイニシャライザーを使うべきかを確認します。`List`のイニシャライザーを見ていくと、`rowContent`、`selection`、`id`を受け取るものがあります。`id`は`Identifiable`ではないデータに対して`KeyPath`で識別子を与えるやつですね。今回は既に`id`は使っているので、そこは放置で良さそうです。

`children`パラメータのあるやつもあります。これは階層的なデータを表示するためのもので、`children`は`KeyPath<Data.Element, Data?>`（データの子要素へのキーパス）という形です。ドキュメント上は`Data`が`RandomAccessCollection`で、`Data.Element`が`Identifiable`だったり、`id`で識別できたりする前提のオーバーロードがあり、`selection`は`Binding<SelectionValue?>`のようにオプショナルを取る形になっています。`SelectionValue`は型パラメータですね。

つまり、`selection`は`nil`が入りうるのが前提になっているイニシャライザーがあるということです。`selectedLandmarkID`が`nil`だったときにどうするか、ここがうまく整理できていません。`nil`から対象を選択状態に遷移させるときの扱いをどう設計するか、という問題です。`onAppear`で値にフォーカスする、みたいなアプローチ（onAppearで値にフォーカスする）を考えたりもしましたが、`selectedLandmarkID`との兼ね合いで手に負えなくなってきました。

オプショナルを許さない形にしてみるのも一案かもしれません。試しに、`nil`ではなく`Int`にして、例えばよくはないですが`1001`を代入しておく、という仮の値で挙動を見ることはできます。ただ、本来はオプショナルが欲しいのですよね。選択無しの状態を表現したいので、`selectedLandmarkID`は`Int?`で、`nil`を正しく扱えるようにしたいところです。 なるほど。リファクタリング以前の問題でバグが取れないですね。そうか。いったんどうするか考えます。で、`List` のセレクションですよね。`ForEach` をもう一回見てみようかな。`List` の中で `ForEach` を使っていますけど、`List` の中でもうそのまま使えないのかな。

`List` で、`else` とランドマーク数…ではなく、ランドマーク配列ですよね。それで `id` ですよね。これから `selection` はどうしますか。これでビルドは通るかな。いや、通らないか。`List` のイニシャライザに戻します。`List` のイニシャライザで、元は `selection` と `id`、それから `ViewBuilder` ですよね。`selection` と `ViewBuilder` で…もうちょっと上かな。少し面倒な感じがありますが、ドキュメントを見たほうがよさそうです。

`List` のイニシャライザで、これこれ。`id`、`selection`、`rowContent`。これを使いたい気がします。うん、OK。じゃあ試しますね。そうして、`List` の最初の引数がデータですよね。フィルター後のランドマーク配列で、それで `id` が `id`、`selection` を渡して、`rowContent` が `content` ですよね。その中で、`content` に来るのは `Binding<Data.Element>`。`Binding<Data.Element>` が `Landmark` ですね。これで `ForEach` は別にいらないってことですよね、つまり。

で、ビルドすると…。実行したとき、これがどうなるかですね。どうなるかな。インデックス…あ、ダメか。一緒ですね。最初の1回は結局一緒か。短くなったからこれでいいやって感じですけど、最初がやっぱり更新が…うーん。あ、いかんかな。`List` ビュー…あ、いや違うな。ないですね。テキスト。この `selection` とランドマークが消えるタイミングでも、逆に言うと `List` が表示されるタイミング…。あ、でも出てますね。大丈夫だ。うん、なるほど。選択が `nil` だったときには、あとは何もならないよ、という感じですね。

それで `List` と `ForEach` か。これから `List` と `ForEach` に戻しますよ。そうしたときに例えば、`EmptyView` は消えちゃうか。もう一回。いや、`EmptyView` は何もしないことが多いから、クリアとかにしますか。これでタグとして `nil` を設定するとどうなりますかね。例えばやってみたい。こうすると無害な…あ、これダメだな。ジェネリック。ジェネリックね。なので、`id` ですよね。だから、まず `Int?`。これで行こう。

で、このときに選ぶ…あー、ダメか。あーダメですね。どうか。そうすると、じゃあここに例えば `Text` とかあって、`ForEach` か。`NavigationLink` として `EmptyView`、ラベルとして `Text` でやって、これにタグとして `nil`、あと `Int` というふうに割り当てると、これはどうなんだろう。1個セルが `nil` 用のができると捉えていいのかどうか。あ、テキスト出ましたね。それで選択すると、今なんか一回落ちた気がするんですよね。何とも見えなかったですけど、一回クリアも何もないや。コマンドで選択解除して…あーダメか。こっちは選べるんですけどね。あ、で、セレクトに影響しないわ。`id`。あ、これ影響しないのね。`Int?` とか。それはダメなんだ。なかなか難しいですね、タグって。`EmptyView` だからダメなのかな。こんなことになるかな。そうじゃないですよね。まあいいか。うん。そうですね。一回 `nil` になっちゃうとダメですね。うん、なるほど。

じゃあそうすると、マルチセレクションで残しておいて、コンテンツとランドマークの変更とかといっても解決ができないという感じですね。これで再現ができるためには、何をするといいんだ。例えばフィルター。フィルターをちょっと変えてみますか。ここ。`filter = filter` みたいなふうに、無理やりフィルターをリセットするということをしてみたときに、`selectedLandmark` が変化して、それで…なんていうのかな。あ、ダメですね。これもダメか。タイミングをずらしてあげるみたいな感じだとどうなるのかな。これでクリック。あ、ダメですね。

で、選んであげたときに、これフィルター解除とか変更するとこうなって、選んだときに解除されるはずよね。これでフィルターを選んだときに、また一回キャンセルされますが、選んだ状態で、`Favorites Only` フィルターにして、これだと選んでいる状態になるんだ。リバース…じゃなくて、`Favorites` 抜きますかね。`Favorites` じゃないよと。今、フィルターがリセットされなかったですね。これもちょっと問題がありそう。 とりあえず、これでお気に入りのみにすると、絞り込まれている状態で選ぶと、これは選べないですね。選んだ状態でお気に入りのみを解除すると、これは大丈夫でしょうか。こうしてお気に入りのみにして、もう一回やると、2番目が選ばれている状態になります。`selectedLandmarkID` は記憶されているということで良さそうですね。

それでフィルターをかけると、フィルターがかかったうえで選択状態になります。また、下の行を選んだ状態でフィルターをかけると、これが選ばれた状態になる、そういった感じでしょうか。

これが内部が `nil` の状態で、それが変化したことによっていろいろ変わり、その結果、一旦描画上の表現がリセットされます。これはおかしいですね。そこがおかしいです。

そうしたときには、最初にフィルターをかけた状態で試してみます。ここで再選択にすればいいですね。フィルターで「Mountains」として、これを選ぶ。最初はダメですね、やっぱり。ということで、もう一つ。お気に入りじゃない状態にして、お気に入りじゃないものを選んでから、お気に入りのみにすると選択が解除されますが、このときに選ぶと、これは大丈夫ですね。`nil` じゃなければ大丈夫、というところまでははっきり見えてきました。

ただし、`nil` だといけないので、`nil` を基準に置く。そうしても、結局は選択を解除してしまうと問題になるので、そこは何とかしないといけません。結局のところ、`nil` のときの扱いを何とかしないといけない、そういった感じですね。なるほど。今日はここまでですかね。

リスト周りを何とかいじれるようにならないと解決できない、こういった感じで良いでしょうか。アップデートしなければ大丈夫だったんでしたっけ。`selectedLandmarkID` か。

もう一つ考えられるのが、`selectedLandmarkID` は今 `@State` で持っていますけど、これを `State` で取るのは、書き換えるからダメなのかな。View で `Binding` してましたっけ。ここか。`selectedLandmarkID`。ここで `selectedLandmarkID` を `nil` にしたんですけど、このイニシャライザーができた、ということですか。そうですね。

あ、そっか。今は `private` が効いていて抜けないのか。押し上げれば、View がどうなる。これで View 側では `Binding` していそうですよね。確か `selectedLandmarkID` って。そうですよね、`Binding` にしちゃってますよね。なので、それを `Binding` にするためには、`Binding(get:set:)` とか、それに対して `.init` とか。`init` の get/set か。get をどこかに書かないといけないから、これはちょっとダメですね。get じゃなければ、もしやと思ったんですけどね。`if` は別に影響しないですもんね。なるほど。ではダメですね。これはダメです。

はい、じゃあ今日はバグが取れずに終わったという感じですが、「なんとかする方法として、やっぱり取れません」ではダメですね。またじっくり次回考えていく感じにしましょう。はい、ではこれで終わりにします。お疲れ様でした。
