Transcription & Summarize : とりあえず読書会 SwiftUI Tutorials #19

それでは、SwiftUI チュートリアル特集に入っていきましょう。だいぶ進んできて面白くなってきたのですが、面白さと一緒に、コードを適当にいじりながら進めていくのが、より楽しいのかなという理由が個人的にはあります。やっぱり映すだけだと、なんとなく面白くないなと感じていたところなので、このやり方は、まったく知らない分野だと難しいところはありますが、多少明るい分野については、いろいろいじりながらやっていくのが良いかもしれないですね。

そんな感じで、引き続きリファクタリングとか、そういうトラブル対応とかもやっていますが、意外とそのあたりは今のところ順調です。全然引っかからないのは面白いですね。ここも一応見どころのひとつではあるはずなので、そこも含めて続き読んでいきましょう。

今日は「Working with UI Controls」で、いよいよプロフィールの編集画面を作るところですね。あと、「an edit mode」みたいな英語の話にも少し触れます。ここで冠詞を使うのか、何も付けないのか、`the` を使うのかなど、いろいろありますよね。ここで「an edit mode」と書くのかどうかは、当たり前と言えば当たり前なのですが、自分の中ではこういうところが難しいです、英語は。普段は調べて、それっぽいことは理解するのですが、結局よくわからない、みたいな。難しいですね、この辺りは。まあ今回はそういう話題ではないので、次に進みましょう。

状況としては、編集ボタンを用意して、`EditMode` を扱っていきます。あれ、編集ボタンは作るんでしたっけ？作った気がしますね。個別のコントロールを編集可能にする、というお話です。その中で、ボタンを置いて、`Environment` データを使った記憶があります。プレビューをちょっと見ておきますか。前回ここに `EditButton` を置きましたね。そうそう、`EditButton` はあらかじめ用意されているので、これを使ってボタンを配置しました。

それから、モデルデータをアップデートして、プロフィールが表示されなくなるまでの間、表示用に維持するプロフィールを持っておく、という方針にしました。このあたりは、前回どこに置くべきかを考えながら、最終的には決めきらなかったのですが、大体この辺だろう、というところまでいった感じです。

次に、ユーザープロファイルデータを `Environment` から読み込みます。`ProfileHost` が `Environment` から渡したデータを使って表示する、という流れですね。そして、編集中の内容は、確定を確認するまで更新を無効にするために、コピーを持っておきます。ここも前回読みました。

条件付きのビューについても、`EditMode` のプレビューを追加しました。今は少し邪魔ではありますが、とにかく `inactive` のときには編集モードの UI は表示だけにして、それ以外のときにはテキストではなく、これから作っていく編集画面を出す、というところまで用意しました。

このとき、`switch` 文を使ったほうがいい、という話を自分がしました。というのも、`inactive` 以外だったときに、まとめて編集画面にしてしまうだけでは、想定する状況が頭の中で整理しきれない、という問題が出てくるからです。`ProfileHost` はここにあると思うのですが、プレビューが大きいですね。`switch` 文にすることで、どういう状況が想定されるのかが明瞭になります。

- `inactive` の場合は、編集モードではないので概要表示用のビューを出す。
- `active` と `transient` の場合は、一時的な編集状態と実際の編集状態なので、編集ビューを出す。
- `nil` は返ってこないと思いますが、もし `nil` だった場合は想定外です。そのときはテキストを出して落とす、という扱いにする。
- さらに、今後 OS のバージョンアップ等で `EditMode` のケースが変わったときに備えて、`default` をどうするか。ここを検討しました。

OS のバージョンアップでどうにもならなくなるのを防ぐためにも、ここでは `fatalError` にしておこう、という話をしました。編集できなくなってしまうけれど、どうするかは要検討、という感じです。アプリの性質によりますが、独自に寄せていくか、編集は最低限できないと困るなら編集ビューを出す方向にしておくのが良いかもしれません。逆に、編集を迂闊にさせたくない場合には、こうやって表示に確定させて、その場をしのいで次のバージョンアップまで待ってもらう、という進め方もあります。

なお、ここで `fatalError` を使うと、この画面を出した瞬間にアプリが落ちます。アプリを更新するまでずっとそうなるので、それはさすがにまずいでしょう、ということで、今回は選び方を工夫しました。

また、`assertionFailure` を `ViewBuilder` の中で使えるようにするための拡張を前回作りました。無理矢理というほどでもありませんが、コード上は問題なく対応できます。ただ、`EmptyView` を返すだけでもよかったかもしれないなと思ったので、そこは直してみます。 例えばここで、サブビューってわけでもいいのかな。エクステンションを追加して、`Void` が返ってきた場合には `EmptyView` を生成することにしましたけど、ここで `nil` という選択肢もありそうですよね。`nil` にしても無視されるんじゃないか、となんとなく思っていて、そういうコードを見たことがあります。これで別にビルドは通るでしょ。`Void` を返す関数を `ViewBuilder` の中で使っているんですけど、これでビルドが通るなら、`EmptyView` と `nil` って何が違うのかな、というのがよくわかっていません。`nil` だった場合、SwiftUI はどう扱うんでしょうね。

とりあえず `EmptyView` を返しておいても問題はなさそう、ということはわかりました。ただ、もしかすると `nil` のほうが最適なのかもしれません。まあ、その辺はどっちがいいんでしょうね。`EmptyView` はちょっと大げさな気もします。`nil` にして、`nil` の具体的な型をどうするかで悩むより、`nil` ではなく `EmptyView` をそのまま返しておくほうがいいのかな、とも思います。そもそもこの方法のほうが素直ではない、という感じもありますからね。これはきっと大丈夫でしょう。このままいったん放置して、続きに進みますね。

ここまでできたので、次はセクション3、プロファイルエディターを定義するところからです。ユーザープロファイルエディターは、プロフィール内の各詳細を変更するためのさまざまなコントロールで構成されています。その中には、例えばタグのようにユーザープロファイルエディターの対象外のものもあります。なので、そうしたものは編集エディターには表示しません。

For consistency（コンシステンシー）についてですが、英語力があればもう少しスムーズに読めるのかもしれませんが、ここでは「一貫性」という意味ですね。プロファイルの一貫性を保つために、エディターでも同じ順番でプロファイルの詳細を表示します。これは大事ですよね。時々ありますが、例えばふるさと納税の金額を計算するアプリやツールで、「確定申告のこの用紙のここに入れてください」と案内しているのに、その番号や色づけ（1番は赤、2番は青、3番は水色、のような）が確定申告書のマス目とわざわざ違っていることがあります。そういう一貫性のなさは本当にもったいないです。ですので、順番を合わせるなどの一貫性は意外と重要です。こうした一貫性の方針は大切ですよね。 とりあえずステップ1として、新しい `ProfileEditor` ビューを作って、ユーザープロファイルのドラフトに対する `Binding` を持つように定義します。最初のコントロールはテキストフィールドで、これは文字列へのバインディングを受け取ります。ユーザーの選んだ表示名（ディスプレイネーム）を編集するためのものです。`TextField` は「ラベル」と「文字列へのバインディング」を指定して作ります。たとえば、`TextField("Display Name", text: $profile.username)` のように、ラベルと文字列のバインディングを指定します。説明を確認しましたが、この理解で問題ありません。

ひとまず該当箇所をコピペして、後でゆっくり整えていこうと思います。`ProfileEditor` は SwiftUI のビューとして作成します。画面が小さくて全部はコピーできませんでしたが、この辺までで十分でしょう。作るにあたっては、Views の中に `ProfileEditor` を置きます。`Profiles` はまだまとめていないので、`ProfileSummary` の近くに置くことにします。

まずはバインディングを作ります。`ProfileEditor` を作って、今コピーした部分を貼り付けてビューを作ってしまいます。バインディングを渡すところでは、プロパティの前に付ける両側の記号は `$` です。デフォルトが書いてあるところでエラーになっていたのは、たしか Environment ではなく `ModelData` 側にデフォルトのプロファイルを持たせていたためだったと思います。`ModelData` の `defaultProfile` を使うように書き換えました。あとは、バインディングでプロファイルをつないでいき、ユーザーネームは `profile.username` を表示する形で問題ありません。

次に、`ProfileHost` の条件付きコンテンツを更新して、`ProfileEditor` を使うようにします。そこにプロファイルのバインディングを渡します。具体的には、`ProfileEditor(profile: $draftProfile)` のように、`ProfileEditor` に対して `draftProfile` のバインディングを渡します。これによって、編集ボタンを押すと `ProfileEditor` が表示されるようになりました。ボタンも動きますね。いい感じです。

次のステップは、ユーザープリファレンス（通知設定）に応じて反応するように UI を整えることです。Landmarks 関連のイベント通知を受け取るかどうかのユーザー設定に合わせて、`Toggle` を追加します。ここでいう「プレファレンス」はユーザー設定のことです。`Toggle` はオン・オフを表現するコントロールで、ブール値を設定するのに向いています。

この画面に `Toggle` を追加するので、該当ページをピン留めしておき、`ProfileEditor` を見直します。追加場所は、先ほどのテキストフィールドの下です。例えば、`Toggle(isOn: $profile.prefersNotifications) { Text("Enable Notifications") }` のように、ブールへのバインディングを渡して配置します。 HStackの下にこのトグルを置くと、編集モードが有効になり、トグルを切り替えられる状態になりました。早速作っていくのはコンポーネント化の良さが出ていていいですね。

次に`Picker`コントロールを配置します。ラベルはHStackに置き、“Seasonal Photo”のようなラベルで、自分の好みのものを選べる感じにします。`Picker`の`selection`には、たとえば`$profile.season`を渡し、`ForEach(Season.allCases)`でシーズンを列挙します。各要素に対しては、`Text(season.rawValue).tag(season)`のように並べていくイメージです。ではやってみましょう。

トグルの下に続けて`Picker`を置いたところ、いろいろエラーが出てきました。まずこの辺を直していきます。`Profile`の`season`は、`spring`/`summer`/`autumn`/`winter`を`enum`で定義していて、`allCases`を使いたいので`CaseIterable`に準拠させる必要があります。以前のチュートリアルではここを`CaseIterable`にしていたはずで、これが重要でした。ピッカーからリストアップするときに、`CaseIterable`で上から順番に値を取れることがポイントです。

それから、`ForEach(Season.allCases)`を使うときに識別子が必要で、`Identifiable`にするか、または`Hashable`にして`id: \.self`を指定する必要があります。今回は`Hashable`で大丈夫そうなので、`ForEach(Season.allCases, id: \.self)`のようにすればよいはずです。

もう一つ、「コンバートできない」系のエラーも出ています。`rawValue`を使っている箇所が原因で、`Season`そのものではなく`Season.rawValue`（文字列など）を扱ってしまっているために、`Binding<Season>`として受け取る`selection`に合わない、という状況です。`selection`には`$profile.season`のように`Season`型のバインディングを渡し、表示用のテキストにだけ`rawValue`を使うようにします。つまり、`Text(season.rawValue).tag(season)`という形が正しいです。

また、ここを直していて気づいたのですが、`rawValue`の使い方がそもそも変でした。`spring`に対して“チューリップ”、`summer`に対して“太陽”というような値を割り当てていましたが、これらは`rawValue`ではありません。季節名そのもの（たとえば“Spring”や“Summer”）が`rawValue`で、チューリップや太陽といったシンボル名や絵文字は別のプロパティ（たとえば`symbolName`や`icon`など）で持つのが適切です。この点をまず修正しました。 文字起こしのテキストを貼り付けてください。こちらで「ですます調」に整え、句読点を付け、明らかな誤変換を修正し、コードはバックティックで装飾します（短いコードはインライン、複数行はコードブロック）。複数人の会話はセリフ形式にせず、内容を踏まえた通常の文章にまとめます。途中から始まっている場合は、最初の不完全な文は無視して次の文から整えます。要約は行いません。

テキストが長い場合は、分割してお送りください（目安: 4000〜6000文字ごと）。分割する場合は、各メッセージの冒頭に「1/3」「2/3」のように順番が分かる印を付けてください。

固有名詞や表記ゆれで「この形で固定したい」ものがあれば、先に指示してください。 整形したい文字起こしテキストを貼り付けてください。ですます調に整え、句読点を補い、誤変換を適切に修正します。コードは内容に応じてバックティックで装飾します（短いものはインラインで表記します）。途中から始まっていても、その次の文から整えます。段落の分け方や記号の扱いに希望があればあわせて教えてください。 テキストが空のようです。整形したい文字起こし本文を貼り付けてください。長い場合は分割して送っていただいても大丈夫です。

いただいたテキストは次の方針で整えます。
- ですます調に統一し、句読点を適切に付与します。
- 誤認識や誤字（例：「G言語」→「C言語」、「万全オキス」→「万全を期す」など）を文脈に沿って修正します。
- コードはバックティックで装飾し、短いコードはインラインで表記します。
- 複数人の会話はセリフ形式にせず、内容を踏まえた通常の文章にまとめます。
- 要約は行いません。途中から始まる場合は、次の文から自然に整えます。

英数字の全角・半角や用語の表記ゆれなど、統一のご希望があれば一緒にお知らせください。 文字起こしのテキストを貼り付けてください。  
こちらで「ですます調」に整え、句読点や誤記を修正し、コードは必要に応じてバックティックで装飾して自然な文章にします。要約はせず、複数人の会話も発話者名を付けずに通常の文章へ整えます。 今回は `rawValue` はやめて、`symbol` というプロパティで表示するようにしたので、ここはシンボルですね。「シンボルを表示するよ」という感じです。これでも大丈夫ですね。こんな感じで、Edit を押すとプレビューが出るかな。これでリストアップされていて、いい感じですね。

最初に冬が選択されているのは、シーズンのバインディングをしているからですね。きっとそうです。ここまでうまくいきました。

最後に `DatePicker` を適用しますよ、と。Editor のセクションの次に、ランドマークの表示に、編集可能なフォームを表現する `DatePicker` を用意しますよ、ということで、これも OK で大丈夫でしょう。インデントがなんか変な気がするけど、ここじゃないね。ここだね。あれ、なんかずれてるね。ここに、全部ずれてるのか。これでいいですね。

押してあげて、`dateRange`……これなのがおかしいって。`dateRange` が見つからない。見つからない。`dateRange` が見つからない。`dateRange` は、ここに今作ったのか。ちょっとコピーしてから見てみましょうね。

`dateRange` って何だろう。上のほうに定義してあったから、同じようなところに置くとして、`dateRange` は `ClosedRange<Date>` で、対象値が、`goalDate` の year に対してマイナス1、つまり1年前。`goalDate` の1年前から、次は year の1年後まで。これを `min ... max` で範囲指定する。で、これで `goalDate` として……これなの？

これで、2025、2024、20…あ、戻される。27、28…あ、戻される。どういうことか。1年前後という形で `goalDate` を選べるようにする、ということにするなら、これは `ProfileEditor` の都合なんですかね。それか、全体のもっと広いレイヤーの制限？ それはないか。選択のときですからね。ここにあってもいいのかな。

`ProfileEditor` の `dateRange`。名前がよくないですよね。`ProfileEditor` に対して `dateRange` と言われても、何の話か分からないじゃないですか。`goalDate` のレンジですよね、これね。ということで、`goalDateRange` に変えないといけないんじゃない？ というふうに。`goalDateRange`。これも際どい気もしなくもないけど、`ProfileEditor` で `goalDateRange`。別の命名のほうがいい気もしますけどね。まあ、でも分かるか。設定…うん、そうね。`goalDate` が何のことを言っているのか、ちょっと分かりにくい気がするんですよね。

例えば、1年後にアプリを開いて、その中で1年より前に期日が設定されていたときに、編集モードではそれをいじらない限り、名前が変えられないってことになりますよね、きっとね。うん、それでいいのかな。アプリの存在意義を理解していないからか、分からないけど、まあ、そこまで深く心配しなくていいか。そういうことにして。

あと気になるところとしては何ですかね。`goalDateRange` が `ProfileEditor` の外で使われることがなさそうな気がするので、`private` にするとか。あとは `ClosedRange<Date>`。これはクローズドでいいのかな。クローズドを求めているのかな。えっと、ここですよね。`DatePicker` の `selection` の中で `ClosedRange` を求めているってことは、これはいいですね。

あと気になるところとして考えられるのは、`ProfileEditor` がそのもののプロパティとして持つんじゃなくて、`Picker` 側で計算するわけにいかないのか、という案。つまり、本当に渡さないといけないんですよね、`goalDateRange` はね。計算できるのかな。親で。いきなりできるよね。できるできる。`DatePicker` を取る前に計算しちゃえばいいんじゃないかなと思ったけど、あまりいいスコープがないですね。このラッパーとか、この上とかだと、なんか微妙。さっきのほうがいいんですかね、とか言いつつ、`private extension` で `ProfileEditor` に対して `var` で定義してあげる。あれでいいでしょう。こっちのほうがいいでしょう。

あと気になるところとしては、別に問題ないかな。`Calendar.current` っていうのを取ってるけど、毎回取っていいのかな。参照で見ているだけで大した問題じゃないと思うんですけどね。`let calendar = Calendar.current` ね。こうしてあげて、ここで2つは `calendar` でいいですよね。これでいいですかね。

あとは、`Calendar.date(byAdding:value:to:)` で、`profile.goalDate`。この辺も問題ないか。もっといい方法ないかな、みたいなことを考えたくもなるけど、大したことじゃないから、まあいいですかね。

これによって、期日のピッカーを使えるようになったよ、ということで OK。あとは、これで終わり…のように見えますね。忘れ物は、`goalDate` の設定です。コピペするだけだと分からなくなりますよね、こういったのね。自分はあまり気にしないんだけどな。`goalDate` なんて入れたっけ？ あ、入ってるね。大丈夫だね。

この `goalDate` で入っているのが、あれか、ラベルなのか、ピッカーか、ここかな。ここか。ピッカーで。この辺、ラベルなのかね、全部ね。そういう作りになってるのか。コピペすると、こういった細かいところが行き届かなくなるのかな。どうなんですかね。自分はこういったのが気が回らないような気がして、やっぱり写経っていうんですか、コードを打っていくほうが学習にはなるんじゃないかなと思うけど、時代錯誤なのかもしれない。

次、セクション4。編集内容の伝播（Propagation）を遅らせる。Propagation ってなんだっけ。伝播、伝達か。遅らせる。あれか、コミットみたいなことをしたいのかな。ユーザーが Edit モードを抜けるまでの間、反映させないようにするために、ドラフトのコピーを使う。編集の間はドラフトをいじって、Edit モードを完了したときのみ反映させるよ、というコードを打っていくらしい。

まず、キャンセルボタンを `ProfileHost` に追加してあげる。`EditButton` が提供する完了ボタンと違って、キャンセルボタンは提供しない。リアルなプロフィールデータを反映させないっていうね、そういったやつですね。それをするために、`editMode?.wrappedValue` の `isEditing` がアクティブのところで、`ProfileHost` の中の `HStack` で、`ProfileHost` のこの中の `HStack` の前に入れてあげる。

ここで、`ModelData` の `profile` がエラーになってますね。これはオプショナルにしたから。`draftProfile` が、`default` プロファイルは `ModelData` の `profile`。`ModelData` の `profile` ってオプショナルのことだって、編集していないときっていうのがあるわけですけど、`draftProfile` が `ProfileSummary` のときに、これは `default` プロファイルを渡していて、`ModelData` の `profile` をドラフトに入れる。ドラフトに入れる。ドラフトに入れるのか。なんでドラフトに入れるんだ、これ。ドラフトに入れて、まだ編集前の状態ですよね。

`draftProfile` はここで、`ProfileEditor` にバインディングしますよね。そうすると、あとここか。`ProfileSummary`…あ、これは違うわ。そうすると、編集途中のものを一回編集キャンセルして、もう一回編集すると、復活するっていう仕様ですか。なんか、動きが微妙な気がする。とにかく、じゃあ `draftProfile` がなかったら、`ModelData` の `default` ですかね。`default` プロファイル。 とりあえず、この辺は素材が悪いですね。とにかく、こうやって`Cancel`ボタンを実装したので、すると、こんなところにキャンセルが出て、本当かな？ `Cancel`を押すと、ドラフトにそれが入った状態で戻ってきて、どこの項目を変えてみますか。ドラフト、これを例えば`Summer`にして、`Cancel`を押して、今、最後、`Snow`になった気がする。`Snow`になりましたね。キャンセルのときには、ドラフトプロファイルはモデルデータのデフォルトプロファイルか。モデルデータはまだ`nil`だから、`nil`だからドラフトプロファイルがデフォルトプロファイルになるのか。ドラフトプロファイルを元に戻すって言っているのか。なるほど。うんうん、どうかな。まあ、いいや。なんか遊べそうなところに……。とりあえず、いいか。こんな感じで、まずちょっと作っていきましょう。これで`Done`・`Cancel`版ができました。自分の`Done`・`Cancel`版の動きは違うのですが、実現するところは同じなんですけど、データのフロー的なところ。まあまあ、自分の考え方だけなので、間違ってないと思うんですけど、このチュートリアルもね、とりあえず作っていこう。

で、`onAppear(perform:)`。これを適用して、データを適用、`onAppear`……何だこれ、`onAppear`かな？ そして、`onDisappear`。あ、そう、なんか改行されているような気がするけど、`onAppear`と`onDisappear`を使ってかな。で、`populate`。`populate`って何でしたっけ？ 「値を埋める、満たす」。エディタが適切かな？ まあ、修正したかな。プロファイルデータをエディタに反映する。そうね、編集したデータを持つエディタですね。あ、忘れてしまった。これがね、自分の語彙力のなさですかね。「満たした、満たす」……ちょっと意味わかんないや。

で、あと、永続プロファイルの更新。ユーザーが`Done`ボタンをタップしたときに、保存するプロファイルをこのプロファイルに更新する感じなんですかね。全然分かりませんでした。適用した際に新しいプロファイルを表示して、永続プロファイルを更新します。 onAppearって、今回表現するようなイメージですかね。で、エピソードに乗せれば古い値が現れる、次にEditModeがアクティブになったときにね。そっかそっか。最初は「自分が復活していない」と言っていたけど、それを防ぐためのコードだったって感じですね。まさしくそういう感じでした。

これを実装していきます。どこが実装されたのか。`ProfileHost` の `onAppear` と `onDisappear` ですね。`ProfileEditor` が表示されるときと非表示になるとき。このあたりでいろいろやる、ということになっていて、`ProfileEditor` はここかな。`onAppear` だったら、`draftProfile` はモデルデータの `profile` か、なければデフォルト。この辺の決着がまだついていなさすぎですよね。そして、`onDisappear` のときにはモデルデータの `profile` に `draftProfile` を設定していく。`draftProfile` を `onDisappear` のときに反映するという手段を取るみたいですね。

これはどうなんでしょうね。つまり、`draftProfile` を常にしっかり管理しておかなければならない。まあまあ当たり前なんですけど。これをした上で、完全に常に書き戻すのか、モデルデータがもう `ProfileEditor` にバインディングされていないのか。`draftProfile` でこれをかませて、反映を適切にやっていこうという発想が大事なところとしてあります。`ProfileEditor` は `Binding` しか持っていないのか。そうすると、なおさらこういった仕組みで反映させていくっていうことにするんですかね。あとは、反映先をまたバインディングするというのもありかなと思うんですけど、それはやりすぎかな。今回の場合は `draftProfile`。`draftProfile` といったら編集中のプロファイルだろうなということは察しがつく感じですかね。ということでOKとして、ここまでで意外と結構やったので、コードを取り回しますか。これで一応編集が終わったらしいので、セットしていきましょう。

どうやってアップデートするか。編集状態が変更されたときに、どうやってビューをアップデートするか。例えば、ユーザーが「プロフィールの編集」後にボタンを押したとき、みたいな感じ。そのときには EditMode を用意して、その上で `TextField` があって、`disabled`。`disabled` は `inactive` だと `TextField` が無効になる。これで `disabled` にはしているけど、これはアップデートではなくて、ステートがチェンジしたときにビューを更新するからですよね。これじゃないのかな。ということは、`editName` があって、`onEditingChanged` だった場合には表示状態を切り替える。`onEditingChanged` というのがあるんだとしたら3番目ですね。そんな話をまだ聞いていないんですけど、自分の用語が違うのかな。これは「編集状態が変更された場合、どのように更新しますか」ですよね。だから、いいのか。これが編集された場合にビューを更新するか。あと、これでいいのか。これで `disabled` は `inactive` かどうかで切り替えていく、ですよね。こっちでいいだろうね。下はないんじゃないかな。わからない、聞いていない。まあでも、大丈夫でした。

はい、じゃあ次。アクセシビリティラベル？`accessibilityLabel` モディファイアを使って、どんなときに追加するか。常にアクセシビリティラベルを全部に付けるわけではないですね。`accessibilityLabel` はユーザーインターフェース要素の意味を、より多くのユーザーに見えるように（伝わるように）するために使うのかな。`Label` モディファイアを持たないときにだけ使う、ということですね。ボイスオーバーのために使いますからね。

次の質問。どうなる？意外か。モーダルとノンモーダル。まあ「ノンモーダル」って書いてありますけど、よく聞くのはモーダルに対してモードレスとも言いますよね。ノンモーダルのことでしょうね。モーダルとノンモーダルの表示はどういうふうに使い分けるかってことですね。ビューをモーダルに表示したときには、ソースビューは EditMode…いや、`destination`（遷移先）のビューの EditMode を持って行くことはないですね。次のノンモーダルビュー。モーダルビューを表示したときには、モーダルビューの `destination` というのは、モーダルに表示されているコンテンツのことですかね、`destination` でね。

ビューはカバーする。ソースビューをカバーして、現在の `NavigationStack` を置き換える。ここが苦手なんです。`NavigationStack`。ナビゲーションスタックはいじらないんじゃないかなと予想するんですけど、ちゃんと `NavigationStack` が分かっていない。ナビゲーションをプッシュしていくやつだと思うんで、それだとしたら上書きしてないですね。上書きというか、更新しないですね。次は、ビューをモーダルに表示したときは、`destination` ビューはソースビューをカバーして、現在の `NavigationStack` をリプレースする。自分の理解がおかしいですね、これね。どれか分からないな。ナビゲーション…。

そうね、どうしようかな。もう一回考えるか。どうなる？違い（difference）。モーダルとノンモーダルの違いの話じゃないのかな？そんなことないと思うんだけど、「違いはなんですか？」ですよね。それで、モーダルの場合はソースビュー…EditMode…`destination` ビューの EditMode をセットする。EditMode は関係ないはずなんで、これは関係ない。違う。テクノロジーは2つですよね。

それで、モーダルビューを表示すると、目的のビューが元のビューを覆い、現在の `NavigationStack` を置き換えます。もしかしてこれかな。モードレス表示っていうのは普通の遷移のことなのかな？で、ビューをモーダルで表示すると、元のビューを覆い隠して、現在のナビゲーションスタックを置き換える。`NavigationStack` を分からないとダメですね。`NavigationStack` に対して表示をしていくという形があって、スタックによってパスの中身が表示されていく。モーダルの場合は普通に現在出ている画面の上を覆う。モードレスって何を言ってるのかなっていう気がするけど、iOS の場合はどういうことなのかな。普通の macOS とか Windows とかだと、モーダルダイアログとモードレスダイアログがあって、モードレスダイアログは表示中でも他の操作ができる。モーダルダイアログは他の操作ができない、という認識だったんですけど、それとは違うっぽい。

`NavigationLink`、これがノンモーダル（モードレス）なのかな？分からないですね。あれ、選べないし…。読むのか、プレゼンテーションのやり方を。ビューをモーダルにプレゼンとするときは、`destination` ビューを `NavigationStack` に追加する…追加する意味かと思ってたけど、「置き換える」というのは独立させるという意味なのかな？こっち？こっちなのか。モーダルで表示すると、通常のフローから抜ける、という意味合いですよね。確かに合いますね。いいのかな。まあ、いいや。なんかイメージがわからなかった。とりあえずこれで理解度チェックはできたということで、まずコードをいじっておいて、また次回はこの「Interfacing with UIKit」を見ていく感じにして、はい、コードをちょっと見ていきました。 ドラフトプロファイルについて、これまでの、特に最近追加したコードを見て思うのは、ドラフトプロファイルが存在しない状況を想定していないということです。常に渡す前提のスタイルを取っているように見えます。そうなると、ここでドラフトプロファイルを指定するのが、少し謎に感じてきます。書き換えてみましょう。

ドラフトプロファイルはステートで構いません。`@State` のドラフトプロファイルが変われば画面表示が更新されます。デフォルトプロファイルが設定されていて、`EditMode` がアクティブなときのキャンセルでは、`ModelData` の `profile` を入れるか、デフォルトプロファイルを入れるか、という仕様ですね。ここは問題ありません。そもそもドラフトプロファイルが存在しないという状況は、今回は想定していません。これで良いと思います。

それで、`ModelData` とドラフトプロファイルがあり、キャンセル時には `ModelData.profile` をリセットする仕様でした。`EditMode` が終わったときには、`ProfileEditor` の `onDisappear` が働きます。`EditMode` に入るときにドラフトプロファイルをここで渡しているのであれば、上での初期化は要りませんよね。最初に `ProfileHost` でドラフトを取ってしまうのか。今表示しているのは `ModelData` の `profile` で、ドラフトプロファイルは使っていません。仮にドラフトプロファイルを使うとしても、`onAppear` のときにドラフトを現在状態で更新してデフォルトを取る、`onDisappear` のときには `ModelData.profile` に書き戻す、そして再度 `onAppear` のときに `ModelData.profile` を使ってドラフトを作り直す、という流れになります。このあたりはキャンセルとの兼ね合いでいろいろやっているのだと思います。戻したときには、ドラフトはデフォルトプロファイルでしょう。ドラフトプロファイルは編集にしか渡していない上に、最初の初期化は意味がない気がします。サマリーでは使っていないので、完全にプロファイル編集の内部に閉じています。であれば、ドラフトはここ（エディタ側）が持てばいいのではないでしょうか。バインディングなんかにせず、です。

ただ、Environment に直接影響を与えるのは良くないのかもしれません。もし良くないのなら、バインディングで `profile` を渡して編集させます。つまり、`profile` を `@Binding` で受け取り、ここで `private var draft: Profile` としてドラフトを持ちます。イニシャライザの中で、受け取った `binding` の `wrappedValue` を `draft` に入れる、という形です。`$` を使った代入をするなら、`@Binding var profile: Profile` に対して、アンダースコア付きのストレージ（`_profile`）に代入する形になりますね。要するに、ここでドラフトプロファイルに、受け取った `profile` の `wrappedValue` を設定して、この中でドラフトをマネージしてしまえばいいのでは、という考えです。

この場合、リストのフィールドで表示するのはドラフトになります。たとえば `draftProfile.username` です。ただし、これは `Binding` ではないので、入力系では `$draftProfile.username` が必要です。`@Bindable` を使うという手も考えましたが、`@Bindable` の `wrappedValue` が必要になり、その前提として型が `@Observable` である必要があります。まずは素直に `@State private var draftProfile: Profile` を用意して、ビュー内で `$draftProfile.username` などにバインドするのが良さそうです。ここでエラーになっているのはそのあたりでしょう。バグレポート云々ではなく、単に自分の使い方が正しくないだけです。`self` を書いても無駄ですし、まだ旧コードで `profile` を使っている箇所が残っているので、`draftProfile` に置き換える必要があります。セレクションも `draftProfile` を対象にするのが正しいです。色が付かないのはローカルだからで、色が付いているのはアセットの参照、だったはずですが、ここは一旦置いておきます。

まずは `goalDate` など、ここは `draftProfile.goalDate` にします。他の箇所も `profile` を `draftProfile` に順次置き換えます。ボタンを押したとき、`EditMode` のオンオフが切り替わるのかどうかは、このコードだけだと分かりにくいです。エディタ側でいろいろやってはいますが、エディタの編集状態はここに何も返していません。なので、ここだけでは無理で、環境値を持たせれば大丈夫だと思います。

`EditMode` に戻って前の画面を見ます。`onAppear`/`onDisappear` で、いまは `ModelData` を代入していますが、`ModelData` の更新はどこでやっているのでしょう。`EditMode` がアクティブだったときのキャンセルボタンの挙動、それから `onAppear` で `ModelData.profile` から `draftProfile` を作っていて、編集モードのときには編集を開けている、という流れです。少し混乱してきたので、もう一度もとの実装を見直します。全体的に `profile` に対してバインディングしていて、ピッカーなどで編集だけを提供する状態です。反映するには、`draftProfile` の内容がどうなるかが重要で、`onDisappear` でドラフトを `ModelData` に書き戻します。`EditMode` はキャンセルのところ以外にも使っています。`inactive` だったらこう、`editing` だったら `onDisappear`、そうでないときは…と、どこで更新しているのか。簡単なコードのはずなので、ここまで悩むものではないと思うのですが、`EditMode` をアクティブにしてキャンセル、トグルで編集状態を切り替えると表示が変わる、という話のはずです。Done を押したときには `EditMode` が非アクティブになり、表示されるものが切り替わります。ちょっと分からなくなってきました。 とりあえず、プロファイルホストではなくプロファイルエディターを見ます。いろいろいじりましたが、一度すべて元に戻しましょう。戻す場所はプロファイルエディターですね。ここで良さそうです。これを下に戻していって、イニシャライズは消して、ドラフトプロファイルも消します。ここまで来た状態で、この状況で少し入れてみます。Edit を押して、例えば Snow を Sun に変えて Done を押すと、Sun に変わりました。変わるのか……あれ、どこかでドラフト……あ、これは良いのかな。ドラフトは disappear。そういうことか。

Cancel ボタンを押したときには、こちらに来ないな。Cancel ボタンを押したときには、どこだ、Cancel ボタン。ここですね。Edit モードで Cancel を押したときには、ドラフトプロファイルを現在のままに置き換える、ということをやってから、そこで置き換わったドラフトプロファイルを引き出す、ということかな。例えば、`print("disappear")` としておいて、あとは、Cancel ボタンを押したときに、そのタイミングで `print` を「引き換え」にして、`failedCancel` というふうにしてあげると、Edit モードに入って Done を押すと……あ、それか。`disappear` ですよね。Edit モードで毎回出しておきますかね。Cancel を押すと、Cancel が走って `disappear` か、ということか。つまり方針としては、要は反映する直前で一度リセットするんですね。なるほど。

ここで、Cancel かどうかを判定できるのか。`EditMode` か。これを掛けて……。一つの方法としては、多分この `EditMode`、いや `EditMode` じゃないか。プロファイルエディターのほうに持っていく、というのが一つあるのではないかなと思います。例えば、`EditMode` が `inactive`、`active` だから、`EditMode` の `Environment` を持っていく。どうするといいんでしょうね。プロファイルエディターに `Environment` を持っていったとして、この辺かな。これは `List` か。`.onChange` で `EditMode`。これでアクション……これはダメなのかな。`.onChange` は、`Equatable` じゃない？ `.onChange` のラップトバリューかな。こういう感じにして、`!`（ビックリマーク、強制アンラップ）でもいいんじゃないかな、ここは。`oldValue` と `newValue` のところで `print`。こちらは広い絵にして、これで `oldValue` と `newValue`。こうしてみると、Edit モードに入って Done を押したときに何も出ないのか。そうなのか。黄色いログが出るかなと思ったけれど出ない。発火されないのか。Cancel も同じか。ここではダメなのか。`Environment` ね。これで `EditMode`……これは変わらないのか。いや、変わらないのか。

そうなると、`Binding` としてドラフトを渡すしかなくなってきますね。もしかして、この `.onChange` を別のほう、`VStack` の終わりあたりに貼って、これが発動するのかを見ます。Edit ボタンで `inactive` から `active` になって、Done を押すと `active` から `inactive`。Edit を押して Cancel も同じで `active` から `inactive`。それで分かりました。つまり、これだと Cancel を検出できません。Done ボタンを自分で作ればまた違いますが、Done/Cancel ボタンは完全にお任せしているので、Cancel したかどうかが分からない。やはり書き戻すのが賢いのかもしれません。考え方を変えたほうがいいのかもしれないですね。動きの感じは分かったので、Done/Cancel などのデバッグコードは抜いて、書き戻しの方針にします。

そうすると、考えられることとしては、ドラフトプロファイルはデフォルトプロファイルを入れているけれど、ここはまず `onAppear` のときにセットします。`onAppear` のときにセットして、出しておかないといけないから、やはりこの辺に持たないといけないのか。そうすると、プロファイルはデフォルトで初期化してもいいのですが、これはどうなのかな。イニシャライザでは決めようがなくて、モデルデータからドラフトプロファイルを取ってくる、という形にします。ドラフトプロファイルを `Binding` で渡していろいろ使ってもらう中で、ドラフトプロファイルの初期値は何にすべきか。デフォルトプロファイル。デフォルトプロファイルで、呼ぶときにこうしてあげて、アプリはいまプロファイルを持っていて……デフォルトプロファイル、プロファイルね。`onAppear` とにかく `onAppear` でドラフトプロファイルを最新のものに更新して、プロファイルエディターをそのまま呼び出します。`onDisappear` のときにプロファイルをドラフトプロファイルに書き換える。これでいいのかな。妥協点を探しているような気もしますが、そうでもないのかな。

`onAppear` でドラフトプロファイルを書き換えて、そのドラフトプロファイルとプロファイルエディターのプロファイルが `Binding` されているわけだから、それが現実対象になる、ですよね。これだけ見ると良さそうに思えます。プロファイルエディターを呼んでバインディングしてやって、`onDisappear` しかないのかな。`onDisappear` のときに変更する。または、`EditMode` が `inactive` になったとき、`active` から `inactive`。どっちもあまり変わりませんね。

ではどうするか。できれば初期化の時点で用意しておきたいのですが、このタイミングでは初期化できません。実際に使うとき、そのときにバインディングできないのか。では強制アンラップするとどうなのか。ダメか。強制アンラップしたものはバインディングとは限らないかもしれないし、相性が悪いですね。ダメです。これはダメ。もちろんプロファイルエディター側でバインディングをオプショナルにして、内部で強制アンラップしてしまう手もありますが、やりすぎ感があります。ここはこれで仕方ないでしょう。

ボタンの Cancel が把握できないとなると、仕方ないですね。Cancel 状態、つまりこの `EditMode` もバインドしてあげる、そういったことをするとまた違うのかな。そうすると、ここにデフォルトを入れておくか、バインドして、バインドしたものを書き換えていってあげる。最初の問題は、ここが最新の状態になっていないことでした。それが終わって、Cancel するのが冗長になる。Cancel の場合には既存の状態で再度書き戻し（ドラフトプロファイルを）、そうでなければ更新されたドラフトプロファイルを代入していく。そうすると、現在の最新状態がドラフトプロファイルに反映している状態ができそうです。できそうで、これでいいのかな。

`onAppear` で、イニシャライザではモデルデータを渡せないから、これでいいのかな。もう少し良い方法があるのでは、とも思います。プロファイルで……オプショナルでもいいのか。オプショナルでドラフトプロファイルが渡されたほうがいいのか。強制アンラップでバインディングができなかったのかな。もう一回試してみます。これで強制アンラップができるでしょう。その上でエラーになった場所があって、ここで強制アンラップできませんでした。 強制アンラップもダメか。そうか、これはバインディングできないんでしたっけ。ダメですね。プロファイルがオプショナルだからかな。プロファイルはデフォルトでいいのか……いや、いいとは限らないですね。あまり良い意味ではない気がします。

動きは分かったので、モデルデータが値を持っていない可能性を考慮して、まだ設定していない状態が分かるようにオプショナルへと改良しました。ただ、この辺がちょっと煩わしいですね。チャンネルがあるときには、モデルデータのプロファイルがデフォルトを反映するようにしていますが、ドラフトプロファイルをオプショナルにするわけにもいきません。なので、ドラフトプロファイルは必須（非オプショナル）という形を取りました。プロファイル周りを表示するときも同じで、ドラフトプロファイルへ代入するときには、プロファイルに値がなければドラフトにデフォルトを入れる、という方針です。

デフォルトプロファイルを一箇所にまとめるのが正解ですかね。たとえば「アクティブ（有効）」「エフェクティブ（効果的/実効）」のようなイメージで、とにかく「プロファイル」として1つ用意しておいて、その値は「モデルデータのプロファイル、もしくはモデルデータのデフォルトプロファイル」という定義にして、以後はそれを使っていく、という形が良さそうです。自分ならそうします。ただ「エフェクティブ」は意味が伝わりづらいですね。名前が良くない気がします。

とりあえず変えていきます。「プロファイルのエフェクティブ」とするより、名前が悪いので「プロファイル」に寄せるか、「アクティブ」も変だし、「有効な」かな……。「メイク」じゃないし。何にしよう。「アクティブ」でもいいのかな。「アクティブプロファイルをドラフトに設定して…」より、「カレント（current）」の方がまだいいかもしれません。「アクティブ」はやっぱり変ですね。「編集中のもの」というニュアンスにも見えてしまいます。「カレント」なら現在の、という意味になります。「プレゼント（present）」でもいいのかな。これでも良い気がします。つまり「現在のプロファイル」。

ドラフトを現在のプロファイルに差し替えた上で、アニメーションで非アクティブに戻します。キャンセルボタンも用意しました。非アクティブのときには現在のプロファイルを表示し、編集のときにはドラフトプロファイルに現在のプロファイルを設定します。`onDisappear` のときには、モデルデータのプロファイルにドラフトプロファイルを入れる、という流れです。「ドラフト」という名前が分かりにくいかもしれませんが、これは好みかもしれません。「リファクタでリネーム」するなら「エディティング（editing）」とかでいいんじゃないかと思いました。「エディティングプロファイル」。これで、編集中のプロファイルを書き出す、現在のプロファイルを編集中のところにコピーする、編集時には編集用のプロファイルを渡す、表示時には現在のプロファイルを表示する、という整理にできます。このあたりもプロファイルの表示が収まりよくなった気がします。キャンセルボタンを押したときには、編集中のプロファイルを現在のプロファイルに戻す、という感じですね。

いわゆる UIKit のときは、編集したデータを適用するか否かをダイアログの OK/キャンセルで判断できましたが、今はその OK が判断できないという状況です。そこでやる方法としては、状態（`State`）にちゃんと持たせる。ここで引っかかっているのは、エディティングプロファイルがデフォルトプロファイルとどう噛み合うかという点です。この値は最初からは用意できません。最初の初期化を遅らせたいのですが、遅らせたところでオプショナルにすると後がやっかいになります。バインディングを使えばいいのかもしれませんが。

理想は、完全に初期化する必要がない段階では無駄なデータを入れずに済ませ、そのうえで選択箇所を1カ所にすることです。そこでバインディングを作ってあげればよい。バインディングのイニシャライザとして、get の中ではエディティングプロファイルを返し、必要なら強制アンラップしたい場面もあるでしょうし、なければデフォルトを入れてあげる、といったバインディングを用意できれば良さそうです。これで良いのではないでしょうか。

コンパイルが通る状態でエディットして、ここでラッシュ（実行）するのか、`onAppear` の前にここで渡してしまうのか、デフォルトを入れてエディティングプロファイルを書き換えるのか。そうすると、完全にバインドを向こうに持っていって何とかしないといけないのか。これでも良いと思ったんですが、先に渡してしまいますもんね。ダメですね。エディティングプロファイルを返すクロージャにしてしまう、というのは絶対にやるべきではない気がします。これでフィールドに…エディットをするとか、これもダメか。ここでデフォルトしてしまうからダメですね。

となると、エディタ側で「強制アンラップのオプショナル」を受け取るか、普通のオプショナルを受け取るかして、その中でバインディングをアンラップして…ということはできません。ここら辺をバインディングでいろいろやっていくとなると数が多いので、あまりやりたくありません。コンパイルが通るだけならいいですが、そうではないとすると、ちゃんとセオリーを知っておいたほうがいい気がします。結局、ここはダミーの値を入れておいて、実際の値に適切なタイミングで置き換えるのが妥当かもしれません。

今エラーになっているのはどうすればいいのか。ファイルの該当箇所をこうして、こういうことか…なるほど。これで良いかという感じにして、`EditMode` の `wrappedValue` が active かどうかを調べるようにします。ここがすごくモヤモヤしますが、これはしょうがないのかな。`EditMode` は何だったかというと、`Binding<EditMode?>` の `editMode` ですね。`wrappedValue` で値を取るので、さらにオプショナルです。ここを楽しようとすると少し複雑になります。

たとえば、`Binding<EditMode?>` に対して `isActive` みたいなプロパティを生やす（拡張する）案もあります。ただ、`wrappedValue` は `EditMode` で、`animation()` 越しに `wrappedValue` を触ることもあり、`Binding<Value>` と `Value` の整理が必要です。あまり良いことはないですね。「`editMode.wrappedValue` と書くのが煩わしいな」と思ったのですが、結局あちこちで必要になるので、妥当なのでしょう。

もう一つの案は、計算型プロパティを用意する方法です。`Environment` に `editMode` がある以上、名前付けも悩ましいですが、たとえば `var currentEditMode: EditMode { get set }` のような計算型プロパティを生やして、getter では `self.editMode?.wrappedValue` を強制アンラップして返し、setter では `self.editMode?.wrappedValue = newValue` にする、といったものです。これで `currentEditMode.isEditing`（あるいは `== .active`）のように書けるインターフェースにできます。ただ、結局 `self` を明示したり `wrappedValue` に触れたり、余計なことが増えます。ここで `self` を書かないといけないですし、最終的には `wrappedValue` に代入する必要があるので、根本的な簡素化にはならないですね。 なんか、結構おいしいことはなかったですね。この辺の`wrappedValue`は消してしまってもいいかなと思ったんですが、一応やっておきますかね。やらない方がいい気もしますけど。

まぁ、こんな感じでシンプルに書けるというのはありますが、ここだけ`self`を付けないといけない、というのは……あ、そうか。エディットモードでアニメーションか。だから、アニメーションも含めてしまえば、逆に機能がリッチになりすぎて困ることもありますよね。アニメーションで`wrappedValue`を入れ替えてやれば、アニメーション付きのエディットモードが出来上がるじゃないですか。その上で、エディットモードに対して直接値を渡してしまう、ということもできますよね。

同じように用意しておいて、中に入れておくかどうかですが……あ、中にしないとダメですね。エディットモードをシャドーイングできないから中に入れた、という感じです。とにかく、後のコードをエディットモードでシンプルに書けるようにしたい、という時にはアリかもしれませんが、これをまた渡してBindingしたい、というような場合にはちょっと困ってくるので、やっぱりあまり“楽なやり方”にはならないかもしれないですね。今回はこのまま残しておこうと思いますけど、最終的には`wrappedValue`に対して操作をかけていった方が、なんだかんだで楽なコードになる気がしてきました。今回遊んでみて、うまくできているとは限らない感じです。あまり良くない例になっているかもしれません。

ただし、この`fatalError`はもう入れる場所がないですね。結局のところここですよね。`fatalError`を入れる場所がなくなったという感じです。この辺に入れてもいいですが、アクセスした時にしか効果を発揮しないので、それはそれであまり意味がないかなという気もします。そうなると`assertion`を入れていく形になるのかな、という感じですが、ここら辺でエディットモードが使えないということはあり得ない気がするので、そこまで頑張らなくてもいいでしょう。頑張るなら、ここで`guard`を使って`editMode`が取れなければ`fatalError`にする、という形ですね。例えば、`guard let editMode = self.editMode else { fatalError("EditMode が利用できません") }`として、Bindingが取れているので、その後にアクセスすればよい、ということになります。ここにも入れておきますか。`guard let editMode = self.editMode else { fatalError("EditMode が利用できません") }`として、`withAnimation { editMode.wrappedValue = ... }`のようにしてあげれば、使ったタイミングでエディットモードが有効でなければ`fatalError`で「エディットモードが使えません」と出てくるので、まだマシです。とはいえ、最初のやり方でも大丈夫だと思うんですけどね。ここでごちゃごちゃできたので。

そもそもこのコードがあまり良くない気がします。実際にこれを公の場で書く時には、いさぎよくエディットモードを消す、この列挙型プロパティはやっぱりやめた、と消してしまった方が有効でしたね。

では、そんな感じで、とりあえずここまでの変更でおかしいところがないかをプレビューで確認して、大丈夫ならここまでにします。プレビューはもうできましたね。エディットをして、例えばウィンターをオータムにして、通知をオフにする。Doneを押すと通知がオフになって、シーズナルモードがオータムに変わりました。もう一度エディットして、これをサマーに変えるけどキャンセルを押すと、オータムのまま。OKですね。

こんな感じで「やるべきではない」コードもできてしまいましたが、とりあえず残しておいてOKという感じにしていきましょう。今日はこれくらいにして、次回はUIKitとの連携、そのあたりに入っていく感じになりそうです。では、これで終わりにします。お疲れ様でした。
