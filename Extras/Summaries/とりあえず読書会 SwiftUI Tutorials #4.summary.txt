Transcription & Summarize : とりあえず読書会 SwiftUI Tutorials #4

では、SwiftUI Tutorials を読み進めていきます。今回はチャプター1のセクション2あたりからです。前回あたりから、せっかくなら SwiftLog 対応もしようとか、リファクタリングもしようとか言いつつ進めているので、今回もそのノリでいきます。最初は UI 周りをいじる感じになりそうで、どうなるかはやってみないとわかりませんが、淡々とユーザーインターフェイスを作りつつ、せっかくなのでコードの話も挟みながら進めたいと思います。

SwiftUI Tutorials のチャプター1「Building Lists and Navigation」のアプリケーションですね。チャプター1は3つの構成になっていて、タイトルは付いているものの、セクション名が一覧でわかりづらいのが少し難しいところです。今日はその中の2つ目、セクション2から進めます。

ここでは Row（行）を表すビューを作っていきます。目指すのは右側にある例のような見た目で、画像があって、テキストがあって、あとはスペーサーがある構成です。これを使ってセルをリスト表示していく、まずはそのための部品を作るセクションになります。

このチュートリアルでは、ビューを用意して、特定のランドマークの詳細（というより行としての概要）を表示する `LandmarkRow` を作ります。`LandmarkRow` はランドマークを表示するためのプロパティを持っていて、指定したランドマークを表示できます。そのあとで、複数の行をリストで表示する話に進みます。一般的な流れですね。

まず、新規に `LandmarkRow` という Swift ファイルを `Views` グループに作成します。そして、その中に `Landmark` のストアドプロパティを追加します。`landmark` を `Landmark` 型で定義する形です。

このとき、プレビューは一旦動かなくなる（エラーになる）はずです。`LandmarkRow` のイニシャライザで `Landmark` のインスタンスが必要になるため、プレビュー側から渡されていない状態だとビルドエラーになるからです。まずはそこまでを確認します。

具体的には、Xcode で `Command+N` から Swift ファイルを新規作成し、ファイル名を `LandmarkRow` にします。ファイルができたら、`struct LandmarkRow: View` の中に `var landmark: Landmark` のようにストアドプロパティを定義します。プレビューはまだ動かないと思いますが、とにかくビルドエラーになることを確認できれば十分です。 まずはここまでOKですね。それで、次としてはプレビューを直すために、プレビューのインスタンスを作っていくことになります。具体的には、プレビュー用の構造体（`PreviewProvider`）の中で、`LandmarkRow` のイニシャライザに渡す `landmark` パラメータとして、`landmarks` 配列の最初の要素を使います。そうするとコンパイルが成功するようになり、まだ細かい部分は作っていませんが、ひとまず `Hello, world` が表示されるようになります。良さそうですね。

一応コードを確認すると、`LandmarkRow` の `landmark` に対して `landmarks[0]` を渡す形です。まずはこれをやっていきます。渡すのは `landmarks` の要素で、`LandmarkRow` に `landmark` を渡すわけですが、今はどうなっていたでしょうか。`LandmarkRow`（タイプの都合でここからはすぐには取れませんが）をプレビューのためにちゃんと作ってあげるしかなさそうです。

はい、現状ではランドマークのデータがグローバルにありません。そこで、バンドルに対して `modelData` メソッドを使ってデータを読み込むスタイルを取っているので、これを使う必要があります。バンドルは `Bundle.main` を使い、リソースはランドマークのデータ、つまり `landmarkData.json` です。これで `landmarks` をインスタンス化できます。そのうちの最初の要素には、さっきはIDでアクセスしていましたが、今回は `first` を使ってアクセスしておきましょう。`landmarkData.json` には1件ずつデータが入っているのは目で見て分かりますし、リソースとしてファイルを入れているのも分かるので、ここで `first` を使っても問題ないでしょう。

これでプレビューを動かすと、まだ `LandmarkRow` の中でランドマークのデータは使っていないので表示は `Hello, world` のままですが、ひとまずプレビューができるところまではうまく動くはずです。何にせよ、JSONからモデルデータを読み出すときに、そのデータがどのバンドルに入っているかは重要なので、バンドルに対してデータを読み込むメソッドを用意しておくほうが、グローバル変数でいろいろやるより良いと個人的には思います。今はこういうコードになっていて、`Hello, world` が出るようになりました。ここまでOKですね。だいぶコードの雰囲気が変わりましたが、まあ良いでしょう。シンプルです。 このチュートリアルのコードのほうがすっきりしているのは確かですが、必ずしもそれだけが問題ではありません。すっきりさは意味的に取ったという側面もあるので、各自のやり方で良いのではないかと思っています。大変であれば、コメントなどで知らせてくださいね。

では、修正して Row のレイアウトを作っていきます。まずは `HStack` に `Text` を置き、`Text` の中身をランドマークの名前が表示されるように直します。チュートリアルで習った方法として、Option クリックまたは Control クリック（右クリックでも可）でメニューを出し、Embed（HStack）を選びます。`Text` の中身はランドマークの `name`（例: `Text(landmark.name)`）にします。

これでプレビューが更新されるはずです……あれ、動かない？ まあ、このパートは今は特に変化がないかもしれません。いずれにせよ、ホットリロードが適用されるようになりましたね。はい、ちゃんちゃんです。

次に、Row を完成させていきます。ランドマークの画像をテキストの前に入れて、最後に `Spacer()` を置きます。画像はリサイズ可能（`resizable()`）にして、縦横比を保ったままサイズを調整し、フレームの幅・高さは 50 にします（例: `.frame(width: 50, height: 50)`）。

ここで注意点があります。ランドマークのイメージが独自の型になっているため、そのままでは SwiftUI 標準の `Image` ではありません。つまり、独自のイメージ型が持つ名前などの情報を使って、SwiftUI の `Image` に変換する必要があります。

やり方のひとつは、前回扱った変換イニシャライザを使う方法です。まず `import SwiftUI` を追加し、`SwiftUI.Image` に対する拡張でイニシャライザを定義します。UIKit ではなく SwiftUI の `Image` を拡張する点に注意してください。名前空間の衝突が紛らわしければ、`extension SwiftUI.Image { ... }` のように明示して構いません。

変換イニシャライザは「変換先」に生やします。今回のような「値を保持する型変換（value-preserving type conversion）」のイニシャライザでは、API Design Guidelines の推奨に従って引数ラベルを省略します。たとえば、`Landmark.Image` のような独自型から名前を取り出して SwiftUI の `Image` を作るなら、`init(_ image: Landmark.Image) { self.init(image.name) }` のように書きます。上では `SwiftUI.Image` とわざわざ名前空間を付けましたが、省略しても問題ありません。

このイニシャライザを用意しておけば、Row 側では単に `Image(landmark.image)` のように書けるようになり、以後は SwiftUI の `Image` として扱えます。こんな感じで使っていけば良いですね。 これでもできるのかと思ったのですが、思ったよりスマートでよかったです。なるほど、確かに、という感じですね。変換イニシャライザのおかげで、ランドマークのイメージをそのまま受け取って、`Image` ビューになってくれて、ちゃんと表示されています。いい感じですね。当たり前ではあるのですが、うっかりしていて、なかなか素晴らしいコードになった気がします。これでチュートリアルのここまでは良さそうです。少し雰囲気が違っていますが、次に進みましょう。セクション3に行きましたね。これで `Row` が完成でしょうか。では次に、`Row` のプレビューをカスタマイズします。まずはプレビューをカスタマイズするのですね。このアプローチは面白いかもしれません。

自動的に認識される `#Preview`。ソースファイルに書いたプレビューマクロを Xcode が認識してくれます。キャンバスにプレビューが表示されます。1つしか表示できないわけではなく、マルチプルプレビュー、つまり複数のプレビューを定義して選ぶことができるとのことです。代わりの方法として、`Group` ビューにまとめて、シングルプレビューで複数バージョンのビューを表示させることもできます。確かに、プレビューを活用するとコードの開発がはかどりますからね。なので、それをやっていくようです。

まずは、2つ目のプレビューを作って、2番目の要素を表示します。そのために、プレビューを追加することで、異なるデータのプレビューを見ることが可能になります。プレビューで `LandmarkRow` をもう1つ追加します。1番目の要素など、このように配列を前提にするなら、インデックスアクセスの方が似合う気がしますね。さっきはハードコードを使ってしまいましたけど。どのマクロをやろうとしているのかというと、プレビューマクロですね。

`landmarks` は両方で使えます。そうすると、これはプレビューマクロの外に置くのがよさそうです。プレビューマクロの外にしたとき、プログラミング上どこからでも使うものではないので、`private` で保護した方が賢いですよね。さらに、`landmarks` という名前だと語弊を招きそうなので、`landmarksForPreview` のような名前にすれば、誤解がない感じになります。

また、`landmarksForPreview` はプレビューでしか使わないことを考えると、リリースビルドには普通入れないですよね。App にプレビューは勝手に入らないのかな。`#Preview` マクロを展開すると、`@available` と `struct` で、`struct` が普通に定義されますね。とはいえ、マクロの動きがリリース時に変わる可能性もあるかもしれないので、そこは分かりません。ほかで変えられるのか、ちょっと見ておきたいですね。前から、プレビューがリリースのときどうなるのか気になっていました。

そうすると、スキームは Xcode の一般設定ではなく、Edit Scheme で、多分ビルド時のコンフィギュレーションを見るのが良さそうです。ビルドコンフィギュレーションを……あれ、これでいいんでしたっけ。Profile と Build だから、あ、いいのか。プレビュー専用みたいなものはなさそうですね。ああ、そうか。そうすると、あ、いいんだ、いいんだ。大丈夫でした。 ビルド時のコンフィギュレーションについて確認します。Run はデバッグですが、ビルドは…あ、これでいいですね。インフォメーションから設定できました。ビルドコンフィギュレーションをリリースにしたときにどうなるか、少し見ておきたいです。

プレビュー用のマークは、一度画面から外さないとダメかもしれません。いったん外して、ビルドしておきます。すると「not built with …」のようなメッセージが出ています。プレビューは最適化を有効にするとダメらしいですね。ということは、この辺の事情も少し見えてきます。とはいえ、よく分からない部分もあります。コードがどうなっているのか気になるのですが、今は分かりませんでした。

とりあえず、リリースビルドへの影響が心配なときは、プレビュー用のコードを全体的に `#if DEBUG … #endif` で囲っておきます。こうしておけば、リリースビルドを汚さずに済むので安心です。

この上で、Landmarks のプレビューの1個目を後で打ちます。プレビューを2つ作って、0番目と1番目ですね。こうしておくとプレビューを切り替えられるようになります。あ、ダメか。あ、そうですね。ここは違うので…。まあ、こうしてプレビューを見ると切り替えられるようになる、という話です。

1つ目が Turtle Rock、もう1つを選ぶと次の Silver Salmon Creek になっていて、切り替えできるので OK ですね。

次に、キャンバスのコントロールです。デフォルトでは、キャンバスのプレビューのタブ名に行番号が表示されます。プレビューは名前を付けることができて、ラベルを自分で設定できます。各プレビューに対して説明的な名前を書くこともできます。ここで `.previewDisplayName("Turtle Rock")` のように書くと、タブ名が Turtle Rock になります。もう1つはサンプルに合わせて Silver Salmon Creek にしました。とにかく分かりやすい名前にしておくと良いですね。今回は中のデータを詳しく知る必要はなさそうなので、個人的には `firstRow`、`secondRow` のような名前でもいいと思いますが、今回はこのままにしておきます。こんな感じでラベルを付けられるようになりました。

ナビゲーションとしては、2つのプレビューを新しいラベルで切り替えられるようになっています。そこまではできました。

次に、異なるバージョンのビューをサイドバイサイドで見たい場合は、`Group` を使って1つのコレクションビューにまとめます。やってみましょう。まずはセカンドビューを取り除いて…いや、取り除かずに2つのバージョンの Row を追加しましょう、という指示でした。`Group` はビューコンテンツをグループ化するコンテナのようなもので、Xcode はこれらのグループのタイトルとビューを、キャンバスのプレビュー上部に並べて表示してくれます。 書きたいコードはこれです。プレビューでは、`Group` で `LandmarkRow` の 0 と 1 を表示します。これをやってみましょう。ちょっとバグる気がしますけどね。

そのときに、最初と次の2つを見ていても悪いことはないと思うので、もう1個追加して `Group` にしましょうか。右クリックで「Embed in Group」があったはず……あ、ありましたね。まあ、このくらいなら自分で書いても早いですけど。Xcode でこの行を複製するショートカットがあった気がするんですが、忘れてしまったのでコピペします。で、0 と 1 ですね。

こんなふうにしてあげると、`Group` のプレビューもできるようになって、単体表示もそうですし、`Group` なら2つをこういうふうに表示できます。いい感じですね。ここまでできました。では次に行きましょう。

プレビューに書いたコードが、Xcode のキャンバスで表示する内容になるのかな、まあそうだろうなという気がします。これでセクション3は終わりですね。では、次はセクション4。

リスト、ランドマークのリストを作っていきましょう。ここはプレビューではなく、実際のアプリのコードです。SwiftUI の `List` タイプを使うと、プラットフォーム固有のリストを表示できます。SwiftUI は iOS、macOS、watchOS、visionOS などいろいろなプラットフォームで使えるので、それぞれのデバイスに合った表示を `List` コンポーネントでしてくれるという話だと思われます。

`List` の要素は、スタティックに子ビューを並べることもできるし、データに基づいてダイナミックに生成することもできます。さらに、それらをミックスすることもできます。では、どんなことを学んでいくのか。とりあえず `LandmarkList` を Views グループに追加して、デフォルトのテキストを `LandmarkRow` のインスタンスのリストに変えていく、まずはスタティックに行く、という流れですね。Xcode Previews では iOS の見た目で見せてくれるはずですが、まあ状況によります。とにかく作ってみましょう。

ここで、先ほどのリファクタリングの影響が少し出ます。まだ `landmark` がないんですよね。どうしようかな。まずはやってみます。

`LandmarkList` を Views グループの中に作って、この `Text` の代わりに `List` を置きます。`List` の中に `LandmarkRow` を入れて、`landmark` を渡さなきゃいけないのに、`landmarks` がないという状況です。今までの流れに合わせて渡していけばよさそうです。たとえば、`@Binding var landmarks` を持たせます。こんなふうに持たせておけば使えますよね。`landmarks[0]` と `landmarks[1]`。とりあえず形としてはできるので、これでいいでしょう。

ただ、これだとプレビューがエラーになります。プレビューでも `landmarks` を与える必要があります。`Bundle.main` からモデルデータを読み込んで、`landmarkData.json` を `ModelData` でパースし、`landmarks` を取り出します。それを `LandmarkList(landmarks: .constant(landmarks))` のように `.constant` で渡します。こうするとプレビューも動きます。さっそく出ましたね。いい感じに表示されるし、ちゃんとデータも出ます。 まずは良しとしましょう。値を渡しすぎているところが少し気になっていますが、いったん置いておきます。やりたいことができたので、次に進みましょう。セクション5のステップ1ですね。ここでは、リストをダイナミックにしてみます。

リストの要素を個別に指定するのではなく、コレクションから直接作っていきます。`List` はコレクションを受け取り、そのデータをもとに各要素用のビューを提供するクロージャーで行（row）を生成できます。つまり、コレクションを渡して、それぞれの要素を変換し、クロージャーを使って表示していく、という形です。

`List` にコレクションを渡すときは、各行をどの ID で識別するかを指定します。たとえば `List(landmarks, id: \.id) { landmark in ... }` のように書いて、各ランドマークを識別できます。導入していた2つのランドマークは削除して、代わりに `List` を書いていきます。`List` のイニシャライザでデータと ID を渡し、どのフィールドを識別子として使うか（例: `id: \.id`）を指定するやり方です。

データを `Identifiable` にする方法は2通りあります。キー・パスでユニークな識別子を指定する方法と、データ型自体を `Identifiable` に準拠させる方法です。ここではまず、コレクションと `id` を指定する方法でやってみました。

次のステップとして、リストの行を自前で設定するために、`rowContent` のクロージャーで `LandmarkRow` を返します。これによって、それぞれの行がランドマークの配列を元に描画されるようになります。ここまででも十分実用的です。

さらに、のちほどリストコードを `Identifiable` で簡潔に書き換えますが、それは後でやるとして、今はここまで実装してみます。`List` のイニシャライザにランドマークの配列を渡し、その後で `id: \.id` を指定して行の区別に使います。その上で、`{ landmark in ... }` のクロージャー内で `LandmarkRow` を1つ作ります。コレクションで全要素が出てきますね。例えば、こういうふうにできていくので、Xcode の iPhone シミュレーターでもちゃんと動きます。UI の強さを感じるところですね。

ここまで書いてきてどうしようか考えています。今のコードのほうが見やすいとは思いますが、`List` のイニシャライザがクロージャーを取っているので、クロージャーに `LandmarkRow` のイニシャライザをそのまま渡してみるのも面白いかなと思いました。ただ、`rowContent` は `@ViewBuilder` が付いたクロージャーで、要素を受け取って `RowContent` を返す必要があります（型としては概ね `(Element) -> RowContent`）。要素を1つ受け取る関数でなければならない点が少し厄介で、イメージしていた「`LandmarkRow` のイニシャライザをそのまま渡す」やり方だと都合が悪いので、やめておきます。今の書き方が綺麗ですし、無理にいじる必要もないでしょう。これでリストはできました。良いですね。

次は `Identifiable` に対応させます。`Landmark.swift` ファイルに行って、`Landmark` を `Identifiable` プロトコルに準拠させます。`Landmark` データは既に `id` プロパティを持っており、`Identifiable` が要求するものを満たしているので、プロトコルに適合させるだけで対応できます。その後、`List` に戻って `id` パラメータを明記しなくても、どのプロパティを使って行を区別するかを自動で推論してくれるようになります。

実際、今 `id` 指定を消してしまうと、`Identifiable` ではないためにランドマークの ID が分からないという扱いになり、`Landmark` が `Identifiable` に準拠していないというエラーになります。ここを準拠させて解決していきます。 ランドマークの型に対して `Identifiable` に適合させます。`Identifiable` の定義を見るとわかりますが、`ID` は任意の `Hashable` な型であればよく、かつそれを計算型プロパティ `id` として読み取りできれば `Identifiable` になります。今回は、作成した `Hashable` な `ID` が読み取り可能になっているので、プロトコルに適合させるだけで `Landmark` 型が `Identifiable` になりました。

これによって、先ほどのランドマークのリストでもエラーが出なくなり、プレビューもちゃんと表示されるようになりました。これで良いですね。そんなところですかね。

余談ですが、`Identifiable` は「その行がそのデータの行である」と判定するための識別子を提供します。つまり、`ID` が同じ行は同じ行だと判断されます。たとえば「タートルロック」の行であれば、同じ `ID` を持つものは同じ「タートルロック」の行と見なされる、という意味合いです。そのため、`Equatable` と一緒に使うコツをコードで見かけることがある気がします。

`Identifiable` が判定しているのは、あくまでアイデンティティ、つまり「同一性」です。これに対して `Equatable` は、そのインスタンスが「同じもの」かどうかではなく、「同じ値」かどうか、すなわち同値性を表現します。両者は似ていそうでいて、実は異なります。

この2つに同時に準拠させたとき、`Identifiable` は `ID` だけで比較します。したがって、他の名前や公園名などがずれていても `ID` が一致していれば同じものと見なされます。それはそれで正しい挙動です。一方、`Equatable` の場合は基本的にすべての値が一致していることが求められます。ここを混同して、`Identifiable` として個体を特定したいだけのときに `Equatable` による全項目一致の判定をしてしまうと、すべての値を比較する必要が出てパフォーマンスが悪くなってしまいます。 ここで独自に実装して、Equatableは何を求めているのかというと、等号（==）のこの関数です。両方に自分の値を取り、真偽値（`Bool`）を返す、これを求めています。何も実装しなくても、全てのプロパティがEquatableであれば、自動的に「全てのプロパティが一致したら等しい」という実装が合成されます。ただ、それだとより重たいので、`static func == (lhs: Landmark, rhs: Landmark) -> Bool` のように、左辺も右辺も`Landmark`で、返り値が`Bool`になる`==`演算子を自前で実装して、軽くしようとすることがあります。

その際、重さを気にするあまり、左辺の`id`と右辺の`id`が一致すればOK、というコードを書いてしまう例を見かけます。しかし、これは同値ではありません。名前などが違っても`id`が一致すればOKになってしまいます。もちろん、それで同値と見なせる場面も多々あるとは思いますが、そうでなくなってしまったとき、例えば`landmarks`に同じ値が入っているか心配になって、`landmarks.first == landmarks.last` のように書いたとします。このとき、`==`が`id`でしか比較しなくなっていると、もし`description`などがずれていても`id`が同じなら等しいと判定されてしまいます。これは意図に反します。

この場合は、そもそもそんな実装はせず、`id`で比較したいのなら `a.id == b.id` と明示的に書けばよいだけの話です。特定の特徴（ここではID）だけで等価を定義するのは、思いがけない動作につながるので避けたほうが良いです。EquatableとIdentifiableの違いは、しっかり認識しておくべきです。

もう1つ、EquatableとHashableの関係も重要です。HashableはEquatableへの準拠を要求します。すでにEquatableになっていれば、Hashableもすぐに書けます。Hashableで大事なのは、ハッシュ値を計算し、ハッシュ値が異なれば値としては絶対に等しくない、ハッシュ値が同じときは等しいかもしれないし違うかもしれない、という性質です。ハッシュ値が一致した場合には、Equatableを使って本当に等しいかを検証します。

自動合成（デリバードコンフォーマンス）を用いると、`hash(into:)`の中で全てのプロパティを`hasher.combine`して、全体として一意になりやすいハッシュ値を作ろうとします。つまり、`id`が同じでも他の値が一致しなければ、普通はハッシュ値が変わります。Swiftでは最終的に`Int`型のハッシュ値が生成されますが、有限の`Int`で全プロパティの組み合わせを表現することはできないので、衝突は理論上発生し得ます（なるべく衝突しないよう設計されていますが）。

ここで大事なルールがあります。Equatableで等しいと判定される2つの値は、必ず同じハッシュ値にならなければなりません。もし`==`を「`id`だけ比較」に独自実装してしまったなら、`hash(into:)`も`id`だけを使って計算する必要があります。具体的には、`hash(into:)`で `hasher.combine(id)` のように、ハッシュもIDに限定するべきです。これを怠ると、ハッシュベースのコレクションで効率が悪くなったり、計算がおかしくなったり、本来等しくないのに等しい（あるいはその逆）と扱われるなどの不整合が生じます。

まとめると、`==`の二項演算子を拡張して独自の等価を定義したくなったときには、`hash(into:)`の実装も必ず対応させなければいけません。特に「IDでだけ軽く比較したいから」という理由で`==`を上書きするのは、思わぬ不具合の原因になるので強く非推奨です。IDで比較したい箇所では、明示的に`id`を比較するコードを書いたほうが安全だと感じています。自分の理解を超えて、もっと良い効果がある場合もあるのかもしれませんが、少なくとも自分としてはこのように考えています。 なので、`Identifiable` は `Identifiable` として、ちゃんとそのオブジェクトの同一性を表します。これで ID を判断します。もちろん、すべてが一致している状態を見たいときには、計算型プロパティで ID を用意すればよいです。`name` と `id` があるなら、`id` は `Int` にしておけば十分です。`Int` 側で特別なことをする必要はありません。工夫の仕方はいろいろありますが、必要なら複数の値を考慮した ID を組み立てて返せばいいだけです。なので、ID は ID としてシンプルに作るのが賢いというか、楽ですね。見通しのよい書き方だと思うので、おすすめです。

とりあえずそんな感じで、今回はシンプルな `Identifiable` を使って、リストを簡単に書けるようにして、チュートリアル的にめでたしめでたし、といったところまでできました。

次はチュートリアルのセクション6、ナビゲーションのセットアップです。リスト内でのディテールへのナビゲーションをしていきます。本格的になってきましたね。リストは行をレンダーしますが、個別の項目をタップしても、まだディテールページには遷移しません。そこで、ナビゲーションの機能をリストに追加します。そのために `NavigationSplitView` というものを使います。初めて聞いた気もしますが、チュートリアルは2回目のはず……まあいいや。これを使ってビューを埋め込んで、ああ、思い出しました。これを使うと iPad などでレイアウトがいい感じに変わるんでしたね。

`NavigationSplitView` を使って、それぞれの行を `NavigationLink` でネストして、遷移先をセットアップしていく、という流れになるらしいです。そのための準備として、ディテールビューを用意します。コンテンツは、以前のチュートリアルで使ったものを流用します。ディテールビューを準備して、メインの `ContentView` もそれに合わせて整えていきます。うん、大丈夫かな。まあいいか、やってみましょう。

ということで、まずは `LandmarkDetail.swift` を作ります。ステップとして、`ContentView` の `body` をまるっとコピーしてくるらしいです。あ、そういえばそうですね。まだアプリ側ではディテール表示のケースを作っていませんでした。 まず、ContentView を LandmarkList で表示するように作ります。次のステップでは、ナビゲーションを作ります。ここまでを順に進めていきましょう。

そのために、まずは LandmarkDetail を用意します。View を新規作成して `LandmarkDetail` とし、`ContentView` の中身をまるっとコピーして貼り付けます。貼り付けただけでは足りない部分があってエラーになりますが、ひとまず LandmarkDetail の中に収めます。

次に、モデルデータ（JSON の landmarks）を用意します。`landmarks` はバインディングで渡す想定なので、プレビューでは `.constant(...)` を使って渡します。例えば、`landmarks` を受け取るビューであれば、プレビュー側で `landmarks: .constant(...)` のように指定すれば大丈夫です。プレビューが出るまで少し待ちます。ビルドが終わっていなかっただけで、ビルドが通ればプレビューは表示されます。

`ContentView` の本体（body）も `LandmarkList` に差し替えます。こちらも `landmarks` のバインディングが必要になるので、同様にバインディングを渡します。少し違和感がある箇所はありますが、`LandmarkList` にバインディングを渡す形で進めます。これでプレビューも表示され、`LandmarkDetail` 側のプレビューも問題なく出ます。細かいところは後で整えれば大丈夫です。

ここまでできたら、次はナビゲーションです。リストとディテールの間にナビゲーションを挟みます。ダイナミックに生成するリスト（`landmarks`）を `NavigationSplitView` に入れます。`LandmarkList` の中で使っている `List` を、`NavigationSplitView` の中に配置し、detail 側にはディテール表示を置きます。`selection` には選択対象として `Landmark` を指定するイメージです。

`NavigationSplitView` は `selection` を受け取り、detail 側にはプレースホルダーを用意しておいて、選択後に実際の詳細ビューに差し替わるような振る舞いになります。iPhone ではプレースホルダーは不要ですが、iPad ではディテールペインで項目を選ぶ前にプレースホルダーが表示されます。挙動の違いは後で確認するとして、まずは `NavigationSplitView` と detail ビューの基本を押さえます。

実装はエディタの「Embed in」を使って、既存のコンテンツを `NavigationSplitView` で包むと手早いです。たとえば、`NavigationSplitView { ... } detail: { Text(...) }` のように書き、`selection` は `Landmark` を選ぶ形で指定します。これでプレビューは大きくは変わりませんが、ビルドは問題なく通ります。`NavigationSplitView` も表示されるので、先に進みます。

次に、ナビゲーションタイトルをモディファイアで指定します。リストに対して `navigationTitle("Landmarks")` を付けます。これは UIKit のときと同じ考え方で、ナビゲーション内の中身にタイトルを設定すると、その画面が表示されたときに適切なタイトルがナビゲーションバーに出ます。`navigationTitle("Landmarks")` を付ければ、良い感じに表示されます。

最後に、リストのクロージャ内で Row を `NavigationLink` で包みます。行き先（destination）に `LandmarkDetail` を、ラベル（label）に `LandmarkRow` を指定します。ラベルという呼び方には少し違和感があるかもしれませんが、見た目として表示したい内容をラベル側に置き、タップされるとディテール側へ遷移する、という形です。ここまで実装します。 まずはリストの中で、`NavigationLink` を使っていきます。リンク先は `LandmarkDetail` で、イニシャライザはランドマーク（`Landmark`）を受け取る形にします。元の動画のコードでは自分で勝手に作って間違っていたので、`LandmarkDetail` が `Landmark` を受け取るように直したほうがいいですね。`LandmarkDetail` 側では `var landmark: Landmark` を受け取ってそれを表示すれば十分です。まだテキストは直接打ち込んでいて使っていませんが、そういう方針で進めます。そうすると、ディテールのビューも `Landmark` を受け取る形になり、コンテンツ用の定数も不要で、パラメータだけでよくなります。

これで `NavigationLink` が作られて、リスト側で受け取った `landmark` をそのまま渡せば OK です。そして `NavigationLink` に対してラベルを指定します。ここで、さっきから出てきているパターンですが、関数呼び出しの丸括弧のあとに波括弧でクロージャを書いて、一つの API 呼び出しになっています。慣れていない人には謎の構文に見えるかもしれませんが、いわゆるトレーリングクロージャの書き方です。クロージャを引数リストの外に出せる構文で、さらに引数リストが空になるときには、その丸括弧自体を省略できます。また、イニシャライザ呼び出しでは `.init` を省略できるというルールもあります。ここまでの省略が重なって、今の見た目になっているわけです。

では、ラベルは何かというと、後ろにクロージャが2つあるときの話です。トレーリングクロージャを2つ使うイメージですね。2つとも外に出せるのですが、この場合は「最初の1個目のクロージャだけ」はラベルを省略でき、2個目以降にはラベルが必要、という言語仕様になっています。`NavigationLink` の定義を見ても、実際にイニシャライザで最初の引数がクロージャになっていて、例えば `NavigationLink { ... } label: { ... }` のように、先頭のクロージャはラベルなし、2つ目には `label:` が必要、という形になります。これはそういう言語のルールなので、1個目にラベルを出すことはできません。

したがって、自分でクロージャを複数取るインターフェースを設計するときには、ラベルなしでも意味が通る（または文脈で分かる）ものを先頭に、ラベルで説明しないと意味が取りにくいものを後ろに持っていく、といった工夫が必要になってきます。最初の1個目はラベルが表に現れないからです。

これで `LandmarkRow` に対して `landmark` を渡し、`NavigationLink` から `LandmarkDetail` にも `landmark` を渡す形ができました。クリックすると、コードに沿ってディテールまで表示され、戻るのも `NavigationStack`（または `NavigationView`）でちゃんと動きます。いいですね。

ここから完成に向けて進めます。補足として、プレビューでナビゲーションができるようにもなったので試してみました。セクション7は「Pass data into child views」ということで、きちんとデータをチャイルドビューに反映させていく話になっていきます。

次に、画像の配置についてです。画像が真ん中に来てしまっていますが、本来は中央ではないはずです。`LandmarkDetailView` を見直します。プレビューを他のコードを見ながら確認したいときには、Xcode のプレビューをピン留めしておくと残ってくれる便利な機能があるのですが、今回は使わなくても大丈夫でした。

`alignment: .leading` を付ける場所を間違えていました。`CircleImage` があるから中央寄せになっているのでは、と思ったのですが、`VStack` の付け方が誤っていました。文字を左揃えにしたかったのに、`VStack(alignment: .leading)` を付ける位置を取り違えていたようです。テキストをまとめているほうの `VStack` に `alignment: .leading` を付けるのが正しく、親側（全体の `VStack`）に付けるのではありません。`VStack(alignment: .leading)` を適切なスタックに付け直したところ、想定どおりに直りました。以前もその形で作っていた気がしますが、どこかで変わってしまっていたようです。直ったので OK です。

今日はこのあたりで終わりにします。次回は、チャイルドビューに対していろいろ反映させていく、このセクション7から見ていく形にしましょう。今日はこれで終わりにします。お疲れ様でした。
