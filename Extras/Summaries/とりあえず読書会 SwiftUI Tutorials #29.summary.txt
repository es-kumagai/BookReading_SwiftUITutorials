Transcription & Summarize : とりあえず読書会 SwiftUI Tutorials #29

では、とりあえず紹介を始めていきます。今日は引き続きリファクタリングですね。Apple Watch用のテンプレートを使って実装を進めていたのですが、個人的にびっくりするような挙動を見かけました。それでいいのかどうかは判断が分かれると思うのですが、そのあたりが少し気になるので、まずはそこを考えつつ、どう進めるのがよいのかを検討します。まだ SwiftUI の常識としてどうやるのが筋か見えていない部分もあるので、そのあたりを模索しながらやっていきたいと思います。

どの部分かというと、watchOS 用にアプリを作っていく流れの中で、モデルデータを `NotificationController`（要はユーザー通知ですよね）で表示されてきた内容を見せる View の中、つまりその View をコントロールするコントローラの中で、デフォルトイニシャライザを使ってモデルデータを生成し、それをモデルデータ内のランドマークと突き合わせていく、というコードになっている点です。

このモデルデータが元々どこにあるかというと、アプリの中では（たしか）Landmarks アプリですよね。この中に定義されています。この状態で、モデルデータをデフォルトイニシャライザでその場生成してしまうと、モデルデータの生成場所がまったく関係なく散在してしまうというか、どこで作られたかの一貫性がなくなります。内部のコードでは普通に JSON から取ってきたデータでランドマークを作っているので最終的には一致するのですが、いきなりこういうところでデフォルトイニシャライザで生成してしまうと、今後バインディングが必要になったりしたときに、どちらのモデルデータを書き換えるのかという問題が出てきます。このあたりは一箇所に統一したほうがいいのではないか、というのが気になっている点です。では、どうやるのがよいのでしょうか。

例えば今回の Landmarks アプリの場合、`NotificationScene` をアプリケーションの中で作っていますよね。そこで `NotificationController` と `category` を渡しているだけの状況なので、ここにコンテキストを渡す、という可能性はありそうです。ただ、単に何かを表示する仕組みが用意されているわけでもないのと、`NotificationController` はこの `NotificationScene` によって作られるのだと思うのですが、そのときに何の情報も渡ってこない、という状況になってしまっているのではないか、というのが気になっています。

そうした前提の上で、まずは通知が来たときのハンドラがちゃんと動いているのかを確認したいです。どうやればよいかというと、単純には `print` で済みますが、`AppDelegate` も用意してみますか。

`AppDelegate` は `final class` で、`AppDelegate` を `NSObject` から継承させますよね。それで、デリゲートを実装します。最初は iOS のつもりで `import UIKit` にして `UIApplicationDelegate` を想定したのですが、「あ、watchOS なので WatchKit か。watchOS 用のデリゲートか」と気づきました。WatchKit のデリゲートですね。なるほど。ひとまずやってみます。

そのときに使うのは `didFinishLaunching` 相当のメソッドで、ここで `print` でログを出す形にします。で、次にデリゲートのアダプターをどう使うかです。少し調べます。SwiftUI で `AppDelegate` を使う場合は `@UIApplicationDelegateAdaptor` ですが、WatchKit にも同じようなアダプターがあればそれを使います。調べると、watchOS には `@WKApplicationDelegateAdaptor` があるようです。アダプターの後にアダプターの型（`AppDelegate.self`）を書く感じですね。つまり、`@WKApplicationDelegateAdaptor(AppDelegate.self) var delegate` のように書けそうです。

これでまず実行してみます。起動したかどうかは、アプリを一度止めればよいのだと思うのですが、まずは走らせてみましょう。さきほど一瞬エラーが出た気がしますが、どうなったかもう一回実行してみます。ビルドに失敗ですね。ビルドに失敗しているのにログが出ていない、という状況ですが、いずれにせよビルド失敗です。

`@UIApplicationDelegateAdaptor` に対して `AppDelegate` を渡している、という iOS 的な書き方になっている可能性が高いので、そこを watchOS 向けに直す必要があるのだと思います。iOS 用ではなく、watchOS 用にしっかり調べ直します。watchOS では `WKExtensionDelegate` を使う形ですよね。デリゲートをやるとメッセージが出る、extension-based なプロセス、リモート通知……といったあたりの文書も参照します。

プロパティラッパーでデリゲートをアダプトするやつについては、使い方として他に何か注意がないかも確認します。たとえば「Integrating with the SwiftUI app lifecycle」のようなドキュメントの中で、`@WKApplicationDelegateAdaptor` の書き方や、どのメソッドが呼ばれるのかといった点を見ておきたいです。`App` の中で `@WKApplicationDelegateAdaptor` を使う、というのが watchOS の正解のはずです。watchOS のデリゲートアダプターはどこにあるのか、引き続き確認していきます。 まずは、ちょっとわからないのですが、デリゲートはいったんやめてみます。もう少し簡単に書いてみましょう。ターゲットのアトリビュートで、`WK`、つまり `WatchKit`。`WatchKit`、`UIKit`じゃないのか、もしかして。あ、`WatchKit`か。で、ビルドをかけて……これもダメか。モジュールの依存関係、Landmarks for iOS。あとは `watchOS` と `iOS` で両方ビルドすることになるから、これじゃダメなんですね。`watchOS` 限定の機能という形で実装してあげないといけない、というのを忘れていました。`#endif`。だからエラーが出たのは、純粋に Apple Watch 用のビルドではないところでエラーになっていた、という感じですかね。これならビルドは通るでしょう。まだダメか。ビルド失敗で、`WatchKit` のモジュール依存関係。ここも `WatchKit` を条件に入れないといけない、と。こんな感じですかね。これでビルドをかけて……さすがにビルドは通りますよね。よし。

次にやることは実行です。実行してみて、まず起動がどうか。あと、デリゲートで認識されて `print` されるかどうか。まずはされると思うんですけどね。これで起動しましたね。いったんログを消して、ホームに戻って、これを落とします。これで投げ込んでも別になんともならない気がしますが、一応やっておきますか。通知のテストのやつを送ってあげて……。あれ、投げる先を間違えた。こっちですね。これを送ってあげて、通知が出て、ビューが表示されたよ、という段階になったときに、いろいろログが出ていますが、受信しただけですよね。受信しただけ、ということは、この時には Landmarks アプリはすでに動いていると捉えていいんですかね。アプリが動いているだけ、と。アプリが動いているイコール Landmarks アプリが動いている、という理解でいいんですかね。

まあまあ、それで仮に良いとして、デリゲートが動いて……。あと、これをアプリを一回止めてですね、バシッとしっかり止めて、その上でチェック。これを投げてみます。そうすると通知が出て、アプリは起動したことになるんですかね、という感じです。この時には、受信の後……受信だけか。あ、そうか、受信だけか。これが動いていない状況。動いていないというか、メソッドが呼ばれていない状況か。なるほど。悩ましいですね。これをもう一回動かすと、普通に起動したところからになると思うんですよね、まずは。あ、違う。ログが見れなかっただけだ、今の。あ、そうですね。ログが見れなかっただけか。なるほど。ログが見えないとなると、Apple Watch のログっていうのをシミュレーターから見られるのでしたっけ。 デバッグの中にコンソールみたいなのがあるのかな。システムログか。えーと、システムログで見られるのかな。まあまあ、どこかで開いているのかな。うん、なるほど。アプリがね…。

あとは、Xcode の中の、ウィンドウの…いや、ウィンドウじゃないか。えーと、デバッグじゃないか。「View Debugging」…これは何だろう。エラー系とレンダリングのパッケージなんですかね。ウィンドウですかね。`Window > Devices and Simulators`。この中のシミュレーターで今動いているのが、えーと、watchOS のシミュレーター。Apple Watch の 11 ですよね。これの、リリースどっちか。42、46…46 かな。あ、でもこれもログが見られないのか。別に。

まあ、えーと、システムログ。ターミナルでシステムログを見よう、と一応書いてあります。iOS シミュレーター…。えーと、ほか。iOS シミュレーターのログを見ると、あとは iOS シミュレーターのバージョンのシステムログ。えーと、マーベリックス。うん。`/var/log/system.log` でいいんですかね。ちょっと見てみますか。えーと、`/var/log/system.log`。これの下の方ですかね。この下の方で、えーと、20:19 とか 20:15、13:21…。うん、入ってなさそうですね。ここじゃない気がします。

そうすると、あとあり得るところは、ライブラリのログの中に iOS シミュレーターというのがあるらしいので、じゃあそれをちょっと見てみますか。えーと、ライブラリのログ。あー、ログ、見ますね。一応ね。えーと、この中にシミュレーター…どれだ。ログの中に `CoreSimulator` かな。この中に ID が…シミュレーターごとのログだと。見てみますか。これ自体は特に何もないと。そうすると、シミュレーターの ID。例えば、Pro Watch のだと `EDD...C13`。えーと、`EDD...C13`。これですね。この中にログがあるんですかね。これを開いて、その中に `system.log.gz` で保存されている。`gz` は 10 月 9 日、10 時、0 時 5 分、プラス 9 時間というところかな。これの可能性もありますけど、`gzip` 圧縮。まあいいか。なんか一時に圧縮するんですかね。`gzip`、`gzip`。まあ、いきなり開いても絶対出ないですよね。これね、0、0、0 ですね。これバイナリファイルですよね。だからこれを、`gunzip` かな、コマンド。`system.log.0.gz`。これを展開してあげようと思ったけど、えーと、…`cp` で `system.log.0.gz` を、 とりあえずTempにコピーしてみますか。で、Tempのフォルダの中にコピーしたものを、ダブルクリックで開くと展開されます。そこで、その中身がどうなっているのかを見る…どこだったかな。あったけど、システムログ的にリスタートしたと予想されるならば、どこから開発の過程がわからないですね。iOSかwatchOSのログが見られました。まあ、そのあたりは調べてみてもいいのかもしれませんが、ちょっと別の手段で見てみますかね。ログが見られたほうが楽だと思うんですけど、あまりそればかり調べても、面白くないですし配信向きでもない気がします。

出てこないので、中身が見つからないかなと思って、もう一つだけやっておきますか。ログというか、Xcodeの「Devices and Simulators」でiPhoneのほうですね。これはペアリングされているiPhoneだから、いくつになるんだ。起動しているシミュレーターを見ればいいんですかね。この中で覚えているのが、`SE` の iOS 16。`SE` ですね。だから `SE` の iOS 16、ここですね。どこにもターミナルとかコンソールとか出てこないですね。昔は出ていたような気がするんだけど、今は出ていないのか。じゃあしょうがないな。コンソール、コンソール…シミュレーターの項目。`Copy Log` はないか。`Clear Console`。バックグラウンドのワークフロー…なんかいろいろありそうな雰囲気は感じますけど、今のところは読めないですからね。

じゃあこれでデバッグできたけど、あとは大事なところとして…あ、そうか。コメント…じゃない、イニシャライザー。`ModelData`。`ModelData` がインスタンス化されるタイミングがいつなのかなというのが気になったので、これも `print`。これも雲マークでいいですかね。`print("☁️ Model initialize")`。こんな感じで。これで一回ビルドすると、普通はすぐわかるでしょう。実行して、どこで呼ばれるのかな…あ、さっきかな、という感じで動くと思うんですけど。これで `ModelData` が作られて起動しましたよね。

それで、Xcodeのコンソールだとログがたくさん出て見づらくなっちゃうから、普通のコンソールを出しておきますか。ターミナル…じゃなくてConsole.app、こちらコンソール。普通のコンソールで、これでiPhoneとApple Watchが出てきました。これでいいんじゃないでしょうか。これで「開始」ってやると、Apple Watchのログがちゃんと取れないんじゃないかな。もう一回起動してみますか。Xcodeでもう一回ログを取っていこう。こうすると、ターミナルのほう…こっちに出てくるかなと思ったけど、出ないか。iPhoneはiPhoneのほうと、こっちのほうと、PCのほう、全部ログを取っておきますか。

この上で、こっちはいっぱいログが流れていくと思うんですけど、一つの手がかりとして、Apple Watchとかやると両方が絞られてくるのかな。絞られるのはいいとして、この2つのデバイスがあって、iPhone側のログがいろいろ出ていますね。出ているけど、特に大きな問題はないか。これでじゃあ、投げ込めばどっちかに出てくるかもしれないですね。一旦フォームに戻して、さっきの通知（Notification）の投げ込みを行ってみましょう。こんな感じで。そうしたときにログとしては、iPhone側のログは…どんなものだったかな。うーん、反応がない感じがなんとなくしますね。あとは、こっちのPC、MacBookのほうはというと、これも特に何もないですかね。Apple Watchも別に出てないですね。どうかな。これで出てくれるつもりだったんですけど、出ないか。手当たり次第やるしかないか。まあ、これは渡しておきましょう。 とりあえず、通知が来たときにメッセージを処理して、モデルデータを再度更新しています。これを何とか渡したいのですが、渡す手段がもしかしてないのかなと思い始めました。そうなると、ちょっとヤバいですね。これ、どうするんでしょう。

`NotificationController` に対して、この中でモデルデータを作るという手はあります。まあ、それで良いなら良いのですが、本当にそれで良いのかなとも思います。`NotificationController` のデータはどうやって渡すんでしょうね。要は、`WKUserNotificationHostingController` に情報を渡したい、という話です。まずはこの `WKUserNotificationHostingController` について少し見てみます。

「App と Scene の機能追加まとめ」。Scene としていろいろできたのと、`DocumentGroup`、`Settings`、`WKNotificationScene`。定義されたカテゴリのリモート通知から、通知が受信した際に表示されるシーン。表示されるシーンか。ああ、なるほど。表示される。ここに落とせばいいんじゃない？というのをちょっと思いました。これ、例えばできるのかな？

でも、コントローラーがクラスなのがちょっと気になります。ここでコントローラーはクラスですね。だから、シーンは別にアプリ側で定義しますが、このシーンは自動的に生成されて起動してくれるだけなので、ここにデータを渡せないのかな？渡せるのかな？渡せなさそうだな、という感じで見ています。とにかくシーンがありますね、`WKNotificationScene`。ここに情報を渡していきたい、というところです。ごまかして渡すならできると思うのですが。

`WKNotificationScene` は、あとはシーンのイニシャライザーがあるくらいで、普通のシーンです。シーンとして、こういう普通のシーンですよね。で、その後、シーンの中で `Scene` に準拠していますね。`Scene` に準拠しているか、`MyScene` として `scenePhase`。シーンってなんだ？これはどれだ？自分で定義して作って使う感じですか。`MyScene` は `MyView` を表示するような、そんなふうになっているという状況で、それとは全然別だと思うのですが、`WKNotificationScene` は構造体です。 インスタンス化しているので当然そうだと思うのですが、そうすると、この定義を一応たどってみます。これでシーンがあって、これは普通のシーンを継承している感じですね。シーン自体には Environment などを渡せると思うのですが、今回の場合はちょっとそうもいかないですかね。普通はどう渡すんでしょうね。

要は、モデルデータってこれなわけです。アプリの中の最初のステップとして用意されているモデルデータです。これと話が食い違っては困るので、普通はこんな変なところでモデルデータがイニシャライズされるという状態で渡す、というのはやらないのかなという感じです。

あとはコンテンツですね。ひとつ気になるのは、コンテンツとして何が渡ってくるかという点です。通知コンテンツ（`UNNotificationContent`）で、この方は `userInfo` を持っていますね。コンテンツは `userInfo` を持っている。ただ、そのコンテンツは実際に NotificationController が呼ばれるまでは分からないということですね。だから、ここに意図的に情報を入れていくということは、シーンの中で何か特別なものが用意されていない限りはできない、ということになります。

使えるのは、デフォルトのストアや `@AppStorage`、シーン、そして通知コンテンツあたりでしょうか。デフォルトのストレージ、あとは継続のシステムオーバーレイ、状態復元用とかウィンドウマネージャ、ツールバー、Environment……。Environment はちょっとそそられますけど、使っていいのかな。ちょっとやってみましょうか。Environment でモデルデータを渡せればそれだけで終わるんですけど、どうなんでしょう。こんな勝手なことをやっていいのかな。例えばコントローラーのほうに、Environment のほうを持たせてね。こんなことができるのかが全然わからない。

この中で `self.modelData` にして `modelData` ってやるでしょ。これで持たせたところで、`didReceive` のところで `modelData` を表示してあげて、これでクラッシュするかどうかでまず一つわかりますよね。やってみますか。クラッシュするかどうかは実行して、シミュレーターが動いてアプリが動いた状況で、これを一回フォームに持たせてあげて戻れば動くはず、ということですよね。そうしたときにどうなるか。面白いですね。

面白いけど、なぜかこうやってもね……どうなんでしょうね。出たときにも出るのがですね……えーと、どうなのか。落ちてる。落ちてますね。ダメですね。オブジェクトが渡されてこない。`EnvironmentObject` だとダメですね。そうか。渡してくれればいいのにね。そうじゃないとすると、伝達はどうするんだろう。これはもう、何度か試してみても落ちてますよね。何回も選んでね。だから、これで `ObservableObject` のモデルデータが取れなかったって言ってるので、これはダメと。

そうすると、NotificationController をセットするときに、NotificationController のインスタンスを持たせられればよかったのですが、ダメですね。メタタイプを渡しているだけですからね。メタタイプを渡しているだけでは情報が共有できない。インスタンスを共有できないんですね。インスタンスを渡すスタイルだったら、ここの NotificationController 情報としてインスタンスを取るんだったらよかったんですけどね。それもダメとなると、Environment はダメでした。 というところで、ChatGPT に聞くしかないのかな、という気がしています。これが `WKNotificationScene` で、ChatGPT 的にはこれで良しなのかな。みんなは当たり前のように情報源を統一して運用できているのか、どうなのかを確認してみましょう。

とりあえず、Swift で通知を受け取ったときに表示される Notification Controller の話です。これですね、Notification Controller。これのインスタンスでいいのかな。インスタンスに任意の情報を渡す方法を教えてください、という感じでやってみます。少し曖昧な質問ではありますが、まあ良いでしょう。

任意の情報を渡す方法はいくつかある、という話になりそうです。1つ目は、クラスが自動的に生成されて `didReceive` が実行される流れの中で、表示したい情報をすべて送ってしまう方法です。基本的にはサーバー側からペイロードで渡す想定ですね。

ただ、今回はランドマークの画像はローカルから取りたい都合があり、ID だけを渡して、その ID からモデルデータを検索し、見つかったランドマークの画像データを表示する、という方針にしたいのです。画像データを Base64 などでエンコードして通知と一緒に送れば問題はないと思いますが、そうではない方法をやりたい気がしています。

ここでは Notification Controller でモデルを定義していて、ビューの中でそのモデルを使い、`didReceive` で例えば `NotificationModel.from(notification:)` のようにしてモデル化する流れを考えています。この流れでは、システムが自動生成して呼び出す都合上、任意のイニシャライザは用意できません。

そこで、`UserDefaults` などに情報を保存して両方で共有する、という手もあります。`UNNotification` を使う場合は、ペイロードの `userInfo` 経由で渡す方法が推奨で、`didReceive` 内でそれを取り出します。`userInfo` は `UNNotificationRequest` の `content.userInfo` に入っており、`content` や `trigger` と一緒にリクエストに設定されます。

今回は APNs のペイロードをファイルで投げ込んで試しているので、その JSON に埋め込んでおく、ということになりますかね。あとは OS 側と iOS 側の通信まわりですが、通信についてはひとまず置いておきます。

端末側でいろいろやる、というのは OK ですし、ほかには `UserDefaults`（`App Group`）の利用もあります。なるほど、情報を `UserDefaults` などに入れておく、ファイルではなく共有コンテナ（App Group）に置く。それならいけますね。もちろんファイルで運用しても良いと言えば良いのですが。

`userInfo` として渡せば十分で、SwiftUI のバインディングのようなことは必要ない、という理解で良さそうです。結局は `userInfo` を起点に `didReceive` 内で取り出し、必要ならローカルのモデルやストレージ（`UserDefaults` や App Group）を引いて画像や詳細データを解決する、という流れになります。ユーザーインフォですね。 とりあえず、まずは `UserDefaults` ですね。あとは、限定的ではありますが、`NotificationCenter` や `EnvironmentObject` でもできそうです。

`Environment` はどういうときに使えるかというと、`SwiftUI` の `View` を起こせば使えるはずです。一方で、`NotificationCenter` は、アプリが生きていれば使える可能性がありそうだという予感があります。

ただし、通知受信時に新規作成される `Controller` の特性上、アプリ実行中のデータ共有には向いていないのかもしれません。もともとそういう用途には向いていない、ということですね。全体の構成を見れば、なんとなく雰囲気はわかります。

いずれにせよ、共有するモデルをオブジェクトとして持っておき、通知の `View` の中では `EnvironmentObject` としてその共有モデルを渡します。そして、`Controller` の中でその `SharedModel` をインスタンス化しています。ここは、`Singleton` を使えば同様のことはできると思います。

このようにして、通知用の `View` で `EnvironmentObject` に `SharedModel` を渡していく、という形になります。 ただ、最初に作ってしまっているところが個人的には気になっているので、これは何とかしたいなという発想ですよね、今のところは。だから、`Environment` はちょっと違うかな。それと、`UserInfo` か `App Group` か `NotificationCenter` ということになるのか。あとは、アプリケーションのインスタンスが取れれば、またどっちが出てくるのかなというのがあって、それを可能にするなら、まずはアプリケーションのインスタンスを取ってみよう、ですね。

ここで取れるかな。iOS なら `UIApplication`、watchOS なら `WKExtension` かな。アプリケーションを取るには、受け側の直下にいろいろ書いてみますか。アプリケーション系、`WKExtension`、ありますね。`WKExtension` の中に `shared` がいますね。とりあえずね。`shared` がいると `delegate` が取れるという、おいしい情報があるわけなんですけど、じゃあデリゲートに行こうかな、そうしたら。

とりあえず、`shared` でアプリケーションが取れることは大丈夫だと思うんですけど、確認してみますか。まずはこれで、アプリケーションがどんなインスタンスかというのを調べて、その上でいろいろやっていく。ここまで来て、一回アプリを置いて、その後、この APNs から投げてあげましょうね。これで投げてあげると通知が出て、いろいろ動いたよという状況の中で、ログを見ると動いたからまずいんですけど、レシーバとして `WKExtension`。とりあえずインスタンスは当たり前ですけどね。

そうしたら、もう一つ考え得る方法としては、デリゲートですね。これ、`WKExtensionDelegate`。これを別のファイルにちゃんと作っておこうかな。LandmarkApp のところから、LandmarkAppDelegate にします。これで watchOS だけに入れておくという形を取って、ここに作っちゃったけど、ここじゃなくて、watchOS 用のアプリケーションのところに持っていって、それでこの AppDelegate のところに対して、AppDelegate、これを持っていきますが、`final class LandmarkAppDelegate`。これが `NSObject` を継承しつつ、かつ `WKExtensionDelegate` に準拠する。準拠する、ですね。

`import` は何だ、WatchKit なのかな、と。こうしてあげて、まずここまででいいかとすると、このデリゲートは要らなくなって、それで WatchKit の `import`、これは必要なのかな。`SwiftUI` が入っていれば大丈夫かな、とだけしてみました。これで LandmarkAppDelegate が取れますね。大丈夫ですね。これでデリゲートが走りますよね。デリゲートが走ったということで、デリゲートが取れるということになっていて、この状態でモデルデータがこっちに移っちゃって大丈夫なんですかね。ライフサイクル的に。ライフサイクル的に痛い目を見てるんで、ちょっと心配なんですけど、やってみよう。

SwiftUI か。これで全部いきましたね。これでモデルデータが `@State` としてデリゲートになって、ここがいいのか分からない。とにかく、これでやってあげると、このモデルデータというものはデリゲートの中ですよね。この中にモデルデータがあるわけですが、これは “inaccessible due to 'private' protection level”。プライベートにしちゃってるね、`@State` が。`@State` じゃダメですね。`@State` はローカル、プライベートってこのチュートリアルで習ったわけですけど、ローカルにしたらどうなんだろうね。`@State` をリプレースしちゃっていいのかな。とにかく通るようになった。 まずはアプリを動かしてみます。これでちゃんと動くかどうか。実行してみたところ、「スコープにない」というエラーが出ました。これは、もしかするとこのファイルのせいかもしれません。iOS は別にいらないので、こうですかね。これでビルドをかけると……ビルドが失敗？ まだダメですね。さっきからエラーがちゃんと出なくなっているので、どこにどんなふうに出ているのかはビルドのログを見ることになります。

「デリゲートがスコープ内にない」と言っています。watchOS 用に作ってしまったので、iOS にはないですね。なので、これを共通化します。`LandmarkAppDelegate` を共通に持っていって、`LandmarkApp` も全体に入っていますよね。`LandmarkApp` を持ってきました。共通の下のほうから持ってきました。`LandmarkAppDelegate` も同様に共通に持ってきて、watchOS と iOS の両方で使えるようにした上で、`@StateObject` としてモデルデータを持たせます。

このデリゲートの実装は、まず extension でいけるか試します。`LandmarkAppDelegate` に対して `WKApplicationDelegate` を extension で適用します。大丈夫そうですね。ここまで大丈夫だったら、`#if os(watchOS)` … `#endif` のようにしてあげると、これで watchOS 用のデリゲートができるでしょう。同じ要領で、iOS のときには `UIApplicationDelegate` としてあげれば良さそうです。これで `LandmarkAppDelegate` は共通で使えます。ただ、そこを共通化したからといって、ここの実装が分からないとダメですけどね。

ところで、プロパティラッパーって、型エイリアスは使えるんですかね。ちょっと試したくなりました。たとえば、iOS では `typealias ApplicationDelegateAdaptor = UIApplicationDelegateAdaptor` のように作っておき、watchOS では `typealias ApplicationDelegateAdaptor = WKApplicationDelegateAdaptor` とします。ターゲットは iOS にしましょう。今は iOS にして、こちらでは `UIApplicationDelegateAdaptor`。アダプタはここにありますね。これで、プロパティラッパーとして `ApplicationDelegateAdaptor` を使えれば、この `#if` ディレクティブもいらなくなります。いけますね。ビルドが通りました。今は iOS のターゲットです。これでビルドが通ってくれれば、うまくいったということでしょう。

さらにこれがうまくいった後に、お気に入りを保存できれば、デリゲートの中に `@StateObject` を置いておくということが許されていることも、おおむね間違いなさそうだと分かります。公式の情報じゃないので本当かは分かりませんが、そういうことが分かるじゃないですか。テストだったというのも、おおむね想定どおりで、いけそうですね。 では、これで今度実行してみます。実行できたのか…これですかね、この画面は。画面を描くデバイスのサイズはどこでしたっけね。サイズ、サイズ…いろいろなコマンドがいくつか出てくると思うんですが、コマンド1、2、3、4…これでいいや。面白いな、シミュレーターでこんなのが出てくるんだ。今はしなくていいです。

という感じで、実は動かしたからか…動かした記憶はないけど、まあこれで。あ、実はクリックしたのか。意外と多いな。マップに最低限の情報くらいは使わせますか。それでもう一回、こっちを動かしてみて、リプレイしていいかな。これで、iOS用のアプリが、こっちか、こっちかもしれないですね。画面的にはこれくらいのサイズでいいですかね。今ちょっと起動待ちですが、これを移動してくれて、ネットワークをいじれたら、これで情報共有はバッチリいけそうだな。情報一元化、バッチリいけそうだなという予感がします。うまくいくといいですけどね。

でもまあ、アプリ側で、スペースはプライベートで、「スペース」と言われているのがちょっとあって、それは引っかかっているんですけど、とりあえずここまでは動いていますね。例えばこの辺をタップすると動きますよね。で、お気に入りに入りますね。レイク・マクドナルド。これをお気に入りのリストにすると…レイク・マクドナルド、動いてくれていますね。いいですね。

そうすると、ここまでできたら話は結構簡単で、`AppDelegate` と `Application`、というか、`Application` ですね。いわゆる用語どおりダイレクトに取れると思いますが、どちらのOS用のものでも、特別に用意しなかったら今回は `Delegate` と `Application` の2つです。`Application` のところは、やはり `Delegate` がいいですね。

この `Delegate` の中で、例えば `watchOS`。`Application` のパターンも少し違いますね。では、ひとまず `watchOS` だけにしておきますか。この辺で `watchOS` 用のコードを書くにあたって、エクステンションで…`watchOS` にしておきますかね。`watchOS` のエクステンションで、`WKExtension` を拡張します。で、この中で何を持たせるかというと、`var delegate`。この `delegate` を `LandmarkAppDelegate`。これを先にやらずに進めてみましょうか。

これなしでいくと、例えば…ここで何かあるんでしたっけ。何と言ったか、コントローラー。コントローラー…`NotificationController`、あれですね。これをいじるときに、`Environment` がダメだったので、そうすると、この中で…これはモデルデータをインスタンス化している方ですね。ここで新たに作るんじゃなくて、`delegate` を持っています。 `UIApplication`は`shared`で共有されています。これの`delegate`を取りたいのですが、型が`UIApplicationDelegate?`（オプショナル）になっているので、ここからいきなり何かを取り出すことはできません。そこで、`UIApplication`に対して`delegate`を`UIApplicationDelegate?`として扱う…という方向で考えましたが、ここで`delegate`や`self`、`super`…あれ、`super`のオブジェクトを忘れていました。`delegate`に`super`の`delegate`があるかと思ったのですが、`UIApplication`ですね。`NSObject`自体は`delegate`を持っていません。`UIApplication`の`delegate`を見てみると、`UIApplication`の`super`は`NSObject`ですね。`self`を`delegate`にする…そんなことできましたっけ。さっきのやり方だと、継承しないとダメですね。

プロジェクトのInfoで、アプリケーションのインスタンスに関する設定を探しました。オブジェクト側だと、アプリケーションのインスタンスがどれか…書いてないですね。では、追加すればいいのかな。クラスを指定できるはずです。この辺で新たにキーを追加して、プリンシパルクラス（`NSPrincipalClass`）。プリンシパルクラスはどっちが正しいんでしょうね。ちょっとやってみますか。何にすればいいんだ…`UIApplication`とかにして、とりあえず動かしたときにエラーで落ちてくれれば効いているということになるかと思ったのですが、その前にビルドエラーになりました。

`self`の`delegate`…これはやってもダメですよね。これはやるわけにいかないので、今は別の工夫をしています。実行してアプリを落としてみて、動作してくれれば分かるのですが、今はビルドがエラーで落ちました。アプリケーションを持っていけたかどうか、この辺りがまだややこしいです。少し動かして、`delegate`はイニシャライザーで作るだけにしておいて、まずアプリを落とす。実行がかかって動いて、ここでアプリがもう落ちていると嬉しいのですが、戻れば何とかなっているかな。ログが見えるなら良いのですが、また強制終了させられました。これで分かったかね…プリンシパルクラスはダメか。イニシャライザーが走ってしまいましたね。

別の方法としては、若干美しいやり方があって、共通インターフェースで全部狙えれば良かったのですが、プリンシパルクラスが効かないのかもしれません。iOSの方でやってみましょうか、プリンシパルクラスね。さっきの書き方にするとアプリが落ちると思います。プリンシパルクラスとして`UIApplication`…いや、何にするべきなんでしょうね。これで実行すると、多分iOSの方が落ちるはずなんですよね。本当はiOSの方を動かせばよかったですが…。では、起動ターゲットをiOSにしてみますか。 とりあえず iOS にしてビルドをかけて実行してみます。そうすると、基本的には落ちると言っていますけど、もちろん今のターゲットに切り替えて実行します。これで実行してシミュレーターに行くと、アプリが起動しましたね。どこに行っちゃうのか……プリンシパルクラスですよね。

プリンシパルクラスは Build Settings（ビルド設定）ではなかったですね。`Info.plist` でいいんだと思うんですけど、プリンシパルクラス（`NSPrincipalClass`）、アプリケーション……どうですか。プリンシパルクラス、入っていない。All 表示にしても、プリンシパルクラスだから……。とにかく iOS のほうに入っていましたね。プリンシパルクラス、これは例えば有効なのが本来だと思うんですけど、どうなのかな。プリンシパルクラスが見つからないと言われて落ちてくれるのが普通なんですけど、どっちか……あ、動いちゃいますね。あれ、おかしいな。

プリンシパルクラス、コンプリケーション・プリンシパルクラスってなんだろう。あとは、ここ、プリンシパルクラスを今作りましたけど、Info。この `Info.plist` の中で今出ましたよね、本来はプリンシパルクラスが。プリンシパルクラス、これですね。で、消してみましょうか。プリンシパルクラスを消しました。で、Build Settings に戻るといなくなる。面白いですね。昔はこんな感じじゃなかったのに、いつの間にか `Info.plist` と Build Settings が一緒になっている感があります。

で、プリンシパルクラスはどう使うのかな。プリンシパルクラス……調べるといろいろ出てくると思うんですけど、「iOS プリンシパルクラス」で検索すると、多分「プリンシパルクラスを返します」と。これなんですけど、プリンシパルクラスを返します。 そんなメソッドがあるのか、誰が持っているんだろう、と思ったのですが、プリンシパルクラスはバンドルが持っているのですね。今回は使わない気がしますけれど、プリンシパルクラスは基本で、最初のクラスだと。プリンシパルクラスのメソッドを知りたいわけではないので、ここでは `UIApplication` を継承したカスタムのアプリケーションクラスを使う、という話になります。

カスタムのアプリケーションクラスを `UIApplication` を継承して持たせて、それで「どういう方法」ではなく、`UIApplication`（メインアプリケーション）を使っているのか、という理解です。なるほど、これで UI のメインがあるので、あれ（エントリポイント）を使って、いろいろ勝手に起動するのですね。プリンシパルクラスを直接扱う感じではなくなった、ということでしょうか。

それと、`userInfo` については、これを使った方法を書いていなかったのですが、さきほどの設定のようなところからできます。プリンシパルクラスは、直接使うというより、Objective-C や UIKit の文脈で扱う話ですね。そうすると、ここにプリンシパルクラスが書いてありそうです。「プリンシパルクラスを削除する」と。大胆な説明ですね。無条件で消していいものではないので、そこは注意が必要です。Scene Configuration も同じではないかな、と思います。

AppDelegate のインスタンス化（カバレッジ）や delegate がエントリポイントになっているから、`Application` 型（`UIApplication` など）を活用しましょう。今は無理やり新たに作ったアプリケーションデリゲートの中で何とかしようとしていたのですが、ここで型を明記しないと、普通の `UIApplicationDelegate` という共通インターフェースしか取れなくなってしまいます。そうではなくて、発火させる先を、たとえばアプリケーション側に寄せます。

watchOS で `WK...` を使いたいという話もあるのですが、それは少しやりにくいです。発火すべきは `LandmarksApp` 側ですね。`LandmarksApp` に `static var` を用意してあげて、デリゲートは `self` のデリゲートではなく、`WKExtension.shared().delegate`（iOS なら `UIApplication.shared.delegate`）を参照します。このデリゲートは、さきほど作った `LandmarksAppDelegate` 型にオプショナルでキャストできるようにします。名前は「ランドマークス」でしたね。リネームして `LandmarksAppDelegate` にします。ファイル名やコメントも合わせて変えておきます。`LandmarksAppDelegate` に対する拡張を用意してもいいですね。

つまり、shared は `WKExtension` か（iOS の場合は `UIApplication`）。`UIApplicationDelegateAdaptor` と同じように、`typealias` で iOS では `Application = UIApplication`、watchOS では `Application = WKExtension` といった形にしておくと扱いやすいです。拡張先は `LandmarksApp` に対して、デリゲートとして `LandmarksAppDelegate` を使います。アプリケーション側に特に実装が不要なら、不要なときはそのままで構いません。こうしておけば、デリゲートが適切な型で接続できる状態が作れます。

あとはデリゲートなので、`LandmarksApp` の中でデリゲートをちゃんと持たせていますよね。そこを考えると、ここは強制アンラップにして、オプショナルを外してしまうのでもよさそうです。これでいいのか、言語仕様的にどっちがよいかは迷いますが、とりあえずこれでいきます。`LandmarksApp` のデリゲートを参照すれば、ダイレクトに安全なものが手に入る、という約束ができました。そうしたら、`LandmarksApp` のモデルデータを取得するときに、`LandmarksAppDelegate` の `modelData` を指定できるようになります。これでちゃんと動いてくれれば OK です。

アプリケーション内でメインに使うデータもそうですし、通知で渡ってくるときに使うデータも、両方ともデリゲートの中に入っているモデルデータを使います。これならソースは一箇所にまとまります。このためにアプリケーション側を使ったほうがよい、という話だったのですね。これで OS ごとの差異を吸収した上で、ここで吸収したほうを使う、という形にします。

これでビルドが通りますよね……あ、通らなかった。どこだ、通らないの。ビルド中に「non-function type 'UIApplication' を呼び出すことはできません」みたいなエラーが出ています。watchOS 側でも `UIApplication` や `WKExtension` 周りで同様のエラーがありそうです。ビルド設定（OS ごとの条件分岐）をもう一度見直します。問題の箇所はここですね。ここは `UIApplication` と言いましたね。もう一回ちゃんと試してみます。OS ごとのビルド条件の中で、関数ではない `UIApplication` を呼び出してしまっている箇所がもう一つあります。ここは `UIApplication.shared` を呼ぶようにしてみます。 まず、`WKExtension` の `shared` とデリゲートの話をしていました。`WKExtension` はデリゲートを持っていますよね。ここで一度ビルドをかけてみたところ、missing return（リターンが足りない）というエラーが出たので、とりあえずリターンを書くことにしました。ビルドをかけると失敗し、失敗箇所が2箇所あり、なんとなくデリゲート周りが怪しそうです。いったんクリーンビルドを試します。ログなどでエラー箇所が出てくれると助かるのですが、今のところ出ていないのでビルドは失敗のままです。

コンソールは動いているようです。いったん停止して、iOS のほうをビルドしてみます。こちらがまずビルドできるかどうかを確認します。ビルドすると、iOS のほうもエラーが出ています。今度はエラーがちゃんと出ていますね。「Non-function type 'UIApplication' value is not callable」という内容です。これはプロパティを関数のように呼んでしまっている、つまり `UIApplication.shared` を `UIApplication.shared()` のように呼んでしまっているケースですね。`shared` はプロパティなので、ただのプロパティアクセスにすべきです。これで良いはずですが、まだ使われていない箇所があったりして、エラーが残っています。ビルドをかけると、まだ「`UIApplication` の non-function」といったエラーが出ます。`UIApplication` の `shared` はプロパティですから、ここはコントロールできますよね。

`application.shared`、`UIApplication`、そして `delegate`。良いと思うのですが、ビルドをかけたとき、エラーはどこか。`non-function type` のところです。同じ名前がかぶっているのがダメなのかと思い、仮に `delegate1` のように名前を変えて様子を見ます。ビルドをかけると、以前とは違う箇所でエラーが出ます。`static var` で計算型プロパティ（computed property）として `shared` を扱っていること、`UIApplication.shared` はプロパティであることなどを確認します。`class var`（プラスバー）で `UIApplication` に対して書くのは問題なさそうに見えます。

`UIApplication` の `shared` を真面目に書き直してみます。`UIApplication.shared` の `delegate` から `AppDelegate`（ここでは `LandmarksAppDelegate` を想定）を取りたいわけです。ビルドをかけると失敗します。エラーが表示されないときもありますが、クリーンしてからもう一度やると、エラー表示が少し変わりました。「Unavailable: `UIApplication` は watchOS では使えません」という内容になりました。つまり iOS の中ではビルドできていましたが、watchOS のビルドでは `UIApplication` が使えないため失敗していたということです。watchOS のターゲットをビルドしていたのですね。

では、watchOS に切り替えたときの話に移ります。watchOS 側では `WKExtension` を使います。`WKExtension.shared()` はメソッドであり、`UIApplication.shared` はプロパティです。この差異が原因で、どちらに寄せてもビルドが通らない状況になっていた可能性があります。そうなると、共通で利用するために何らかのラッパーを定義するしかない、という判断になりそうです。

考えられる方法としては、無理に共通化しようとせず、`shared` をシンプルに取得する道を用意することです。具体的には、`LandmarksApp` に対して `shared` を生やし、watchOS の中では `WKExtension.shared()` を返し、iOS のほうでは `UIApplication.shared` を返すようにします。例えば次のようなイメージです。

- watchOS: `LandmarksApp.shared` が `WKExtension.shared()` を返す
- iOS: `LandmarksApp.shared` が `UIApplication.shared` を返す

こうしておけば、`LandmarksApp.shared` の差異でプラットフォーム差を吸収できます。あとはこれを使って、デリゲートは `LandmarksApp` から自分自身の `shared` の `delegate` を取り、そのデリゲートを `LandmarksAppDelegate` にキャストして扱います。これでコンパイルは通ります。今は watchOS 側で通ったので、このままテストできます。

デリゲートから取るようにしたので、ビルドして実行します。起動してホームに戻し、ここから APNs を投げると、通知が出てほしかったのですが出ませんでした。Xcode 側で落ちています。`shared.delegate` を触ったところで落ちていますね。デリゲートの型が違っていました。`LandmarksAppDelegate` と書くべきところを間違えていました。さらに、watchOS で取りたかったのは `WKExtensionDelegate` であって、`WKApplicationDelegate` ではありません。取りたかったのは、えーと、何でしたっけ。 これですね。`LandmarksAppDelegate`…あ、合っていますね。`delegate` が取れなかったですね。これはどうかと思いました。そうすると落ちそうですね。ここでブレークポイントを設定して、どうなるか。もう一回いきます。

`delegate` が取れていない、作られていない可能性を考えると、このやり方は全然ダメでしたね。ブレークしたと思うので進めます。止まっていますね。`self` は `LandmarksApp` です。`LandmarksApp` は構造体として存在していますよね。これに対してモデルがイニシャライズされています。あ、これは最初に起動したときですね。

ここで `po` で `shared` とか言いましたが、`shared` ではないですね。`self` は関係ないですね。あ、一応 `self` を出しました。 普通に self の型を出そうと思ったのですが、出てこないですね。デバッグの表示を待っても出てきません。困りますが……あ、出てきました。

LLDB で `po LandmarksApp.shared` を実行すると、インスタンスは取れました。取れたものにワーニングが出ていて、Application 〜 といった名前が表示されていますが、これはクラスですよね、たぶん。続けて、`po type(of: LandmarksApp.shared)` のようにして型を取りたかったのですが、実行できていないようです。`type(of:)` とここに書いてあったものの、"type fallback to Swift AST context …" のようなワーニングが出ているだけですね。うまく出ていません。

どうしましょうか。もう一度 `po` を試して、`LandmarksApp.shared` がもう一度出てくれるか確認します。もし出てこないなら、この箇所に `print` をいくつか仕込んで様子を見ます。一旦、3つくらい出力しましょう。まずは `shared` のインスタンスがどうなっているか、次に `delegate` がどんな形か、さらに `WKApplicationDelegate` についても見てみます。

`WKApplicationDelegate` と `LandmarksAppDelegate` ですね。嫌な予感はするのですが、`LandmarksAppDelegate` がここに見当たりません。拡張（extension）のドキュメントも出てこなかったようです。`shared` に対する `delegate`、ここは良さそうです。`type(of:)` でその型を実際に見たいので、`shared.delegate` も出しましょう。この3つが出て、ここでブレイクしてくれれば基本的に大丈夫です。一応、データの元として `shared.delegate` は Optional かもしれません。これは良いですね。実際に実行して、`delegate` がどんなものになっているか見ていきます。

おかしいな、`delegate` はちゃんと取れると思っているのですが、ラップされていると困りますね。あ、そうか。通知を投げないとダメですね。通知を投げないということは、まだ `delegate` を参照していないからです。そうそう、これは良い。なので通知を投げて、その時点でブレイクするようにしておきます。これで `WKApplicationDelegate` が入っていますね。`WKApplicationDelegate` は入った。さらに上を見ると、Optional な Extension Delegate のアドレスが入っています。WatchKit の Extension Delegate のようなものがあるということでしょうか。`WKExtensionDelegate` というのがありますね。これは何だろう、メソッドのライフサイクルが実際には Extension 側で動作するという話ですが、今回は関係ないですね。

そうすると、Extension Delegate のアドレスが入っていて、それになっているから取れないのかどうか……。これはちょっと困りました。取れてくれれば良かったのですが、`delegate` が直接は取れないのかもしれません。

`delegate` が取れないとなると、もう一つ考えられる共有パターンとして、シングルトンがあります。シングルトンでも良いのですが、どうでしょう。`delegate`、`Application.shared` はちゃんと取れていますよね。この `delegate` にアダプターが入っているのでしょうか。もしかして `ApplicationDelegateAdaptor`（`@UIApplicationDelegateAdaptor` や `@WKApplicationDelegateAdaptor`）のことかもしれません。関係ないかな……。`ApplicationDelegateAdaptor` はどんなプロパティなのでしょう。`DelegateType` として型を持っていて、`wrappedValue` が `DelegateType`。つまりラップして `delegate` を保持していると思われます。`DelegateType` はアダプターで、`ObservedObject` のラッパーや `projectedValue`、イニシャライザー、`DelegateType` が `Observable` だったとき…などがあり、`Sendable` でもある。ひとまずここまでです。どうにも `delegate` が取れません。困ったという感じです。

本当はモデルデータを共通で `delegate` に入れておいて、それを使いたかったという簡単な話なのですが、`delegate` が取れないなら、モデルデータの共通化として考えられるのは、普通に `static var` でしょうか。`static var` でもいけますね。これを使っておけば、`ModelData.shared` のようにしても良さそうです。`ModelData.shared` として、どうしますかね。

`delegate` が取れないとなると、以前に iOS でできたような、`delegate` を持たせて principal class（Info.plist の Principal Class）をいろいろいじるやり方を試した記憶がありますが、もしできないなら仕方ありません。そうすると、例えばモデルデータをシングルトンにする、というのが一つ考えられる方法なので、それを試します。

`ModelData` の中に `@State`……いや、`@State` が `static` につくのかという問題もあります。`shared = ModelData()` のようにしてビルドをかけるとして、ビルドは通るでしょうか。通らない。ここは練習が必要ですね。モデルデータをどう扱うかです。これを `@MainActor` から扱うようにする方法が一つと、`shared` じゃない方法が一つ。闇雲に `@MainActor` で縛るのもどうかと思うので、アプリケーション、つまり `LandmarksApp` のところに `ModelData` を `static var` で持たせる、というのはどうでしょう。これだけだとビルドは失敗しますが、`LandmarksApp` 自体を `@MainActor` で保護しておけばビルドは通りますね。こうしておくと `@MainActor` が効いてくれるはずですが、本当に効いているのかどうかはまだわかりません。取ってくれて良いのか、判断がつかないところです。 とりあえずこれで、macOS のほうの通知のコントロール、ここだけ持っていってみましょうか。`LandmarksApp` の中に `ModelData` を用意したので、これを使ってあげれば、ちゃんと画像を取ってきてくれるだろう、というところまではできました。これは大丈夫でしょうね。テストっぽいことは何もしていないんで。普通に情報を持ってこれるので、ちゃんと画像が表示されるという状況になってくれるはずです。いいですね。ここは良かったです。

次は iOS ですね、問題は。iOS はプロダクトを iOS に変えて、それで `ContentView` はそのままですかね。アプリケーションの `LandmarksApp` の中で、確か `Environment` でこうやって渡しているわけですよ。デリゲートの `ModelData`。これを `self.modelData` に変えてあげて、`static` メンバーをちゃんと `Environment` で渡せるんだったら、これでとにかく情報の一元化はできたということにはなります。でも、そんなことは気にしなくていいのかな。通知が終わって、閉じたらもう終わりですからね。なので、その瞬間のスナップショットを持っていればいい、という発想で考えれば、いきなりデフォルトイニシャライザでインスタンス化するというのも、ないと言えばないですが、それならシングルトンがいい気がしますね。

例えば `FileManager` みたいなものは、必ずどこからでも `shared` で呼び出すことによって、同じインスタンスを使います。状態が変わることもないんですけど、そういう感じのアプローチです。素直に作るならそっちですよね。

Chilkoot Trail、これ要りますかね。これのお気に入りを外して、外れた感じがしますね。それで戻ってあげて、リストのほうを見ると 2 つだけ。あとは例えば Twin Lake、これをお気に入りに入れて、それで戻ってあげると、Twin Lake もお気に入りに入りました。なので、`static` プロパティであっても大丈夫ということが、とりあえず動いている限りの現状を見る限りでは、わかりました。

この状態で、これをオフにしてあげて、投げ込んであげたときの通知も、同じ `static` からの情報を見ているので、どっちが出ているのか。あれだけでいいのか。あれだけしか…ホストが付いているからかな？ 違うか。これはデバッグのモードが違うからかな？ シミュレーターが動いているんで、どうなっているわけではないですよね。これでもう一回投げてみましょうか。これで投げてあげて、「できた」とタップすると、終わってきましたね。画像が出ているし、OK。`Dismiss` を押すと、これをもう一回投げて、そしてこの辺を押すとアプリに戻る。このときのデータソースは全部一緒のはず…おそらく。

`ModelData` が…もう一回これを消して、アプリを終わって、動かしてみましょうかね。これで実行をかける。こうして動かして…いや、動いてくれればそれでいいんですけど、いいんですけども、なんとなくどこか微妙なんですよね。これでいいのかな？ そういうふうに言われても、ちょっとリアルのように本当に気にしないでインスタンスを立ち上げてあげればいいのか、わからないです。 今、モデルのイニシャライズが2回走ってしまっているのは、余計な処理が残っているせいで、結果的に2回イニシャライズしてしまっている状況ですね。そこで、オフにして投げるだけの形にすると、これで出てきます。この時点ではイニシャライズの回数は増えていません。ここが満タンで、上がここまで、という状況で、受信の挙動も含めてこれで良さそうです。

こうするとコードがずいぶん簡単になります。というか、今回置き場所をデリゲートにしたかったのですが、最終的にはアプリケーションに置く形になりました。であれば、このステートの `static var` 自体もアプリケーションに持たせたほうがよいですよね。`static var` に置くのは違和感もありますが、プライベートにできますし、理屈としては筋は通ります。こうすればエクステンションも要らなくなりますし、結局デリゲートも今回は触らなかったので不要になります。つまり、このあたりのデリゲート周りは一切消せます。消してしまいましょう。ここまで来ると、あとはビルドが通るかどうかですね。

デリゲートがもう要らない、という話です。ビルドすると、「モデルデータにアクセスできない」、つまりプライベートにしているせいでアクセス不能というエラーになります。`ModelData`（ランドマーク用のモデルデータ）をプライベートにするのは結局できなかった、ということですね。そこから渡せるなら良いのですが、そもそも `static var` である必要も薄れてきます。ここは `NotificationController` に渡したいという要求があるのですが、`NotificationController` 側が勝手にイニシャライズされてしまう以上、何かを直接渡すことはできません。イニシャライザもプロトコルで規定されたものを使ってインスタンス化されるはずなので、特別な引数を渡すのは難しそうです。

プロトコルに準拠した型があって、メタタイプからイニシャライザを呼んで…という流れを考えると、やはりステートは `static var` で持たせるのが妥当なのか、本当にこれでいいのか、という迷いはあります。まあ、大丈夫だとは思うのですが、少し気になります。ステートを管理するためのマネージャのようなものを1つ作って、グローバルにアクセス可能なデータとして置く、というのでもよいでしょう。とりあえずアプリケーションはグローバルに1個のインスタンスしかありません。アプリケーションの世界ではここは絶対的で、必ず1個です。なので、ここに置くほうが手っ取り早い。ということで、当面はここに置いた、という整理で良いと思います。データは1箇所に置きました、ということにしましょう。

ただし、グローバルに置いてしまうと、`Environment` で渡す必要がなくなります。どこからでもこのモデルデータにアクセスできてしまうわけで、それはそれで良くない持ち方です。いろいろなところにブレが出てしまう（言い過ぎかもしれませんが、少なくとも一部ではブレを感じます）。だからこそ、本当は `NotificationController` に渡したい。だとすると、通知表示用の情報は Assets カタログなどにきちんと入れておけ、という話に尽きる気もします。画像などですね。あるいは、画像だけはIDから取れるようなデータを持っておいて、画像は差し替えない前提なら、ファイルと独立してインスタンスを作ってもそこまで気にはならないでしょう。バンドル内で、画像のID（ファイル名）を元に画像を探してくるようなコードにしておけばよいわけです。つまり、Assets カタログで、ランドマークのIDから画像を引っ張ってこさせるのではなく、ランドマーク画像のID＝ファイル名自体を渡してあげる、というアプローチもあります。初期に話したように Base64 で埋め込む、という手もありますが、情報量が増えると面倒なので、やはりバンドルから取るほうが良いと思います。

いずれにしても、`NotificationController` との連携が難しいのが非常に厄介です、という感想です。今回のチュートリアルとしては、このあたりまでで十分でしょう。チュートリアル自体がこういった課題を与えているわけではありませんが、ひとまずはこの方針でいきます。

今日はこのくらいにしておこうと思いますが、もう一つやっておきたいことがあります。チュートリアルを操作しながら進めていると、iOS側を見るとわかりやすいのですが、プロフィールボタンを Landmarks のトップ（複雑な画面のほう）に表示して使っていました。これはタブバー構成だったので、どちらにも欲しいボタンでした。勝手に配置したこのプロフィール表示ボタンは iOS ではうまく動いていましたが、Apple Watch の場合、インターフェースはシンプルに、使用最小限のものにしないと使い勝手が悪くなります。そのため、Apple Watch ではリストだけの画面をチュートリアルで作っていたのですが、このときにユーザープロファイルが表示されてしまっています。これを表示しないようにしたいのです。`#if os(...)` のような条件コンパイルで排除する方法もありますし、別途スムーズなフラグを用意して切り替える方法もあります。いくつかやり方があるので、サクッとできそうではありますが、これは次回に回しましょう。次回、これをやってサクッと解決するならそれで良いですし、複雑になるようなら1時間使ってじっくり見ていく、という感じにします。

では、これで終わりにします。お疲れ様でした。
