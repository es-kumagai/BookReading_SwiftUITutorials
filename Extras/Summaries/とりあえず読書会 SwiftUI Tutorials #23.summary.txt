Transcription & Summarize : とりあえず読書会 SwiftUI Tutorials #23

では、とりあえず特集を始めていきます。なぜかチュートリアルと呼んでいますが、今回は、前回の配信が出先からで、30分くらいで切れていることに気づかず、そのまま進めてしまって全然話にならなかった件の続きです。あのときは、チュートリアルのコードをいろいろリファクタリングしていたら思うように動かなくなり、その原因を探って直す、ということをやっていました。配信中に原因は見つけて修正もできたのですが、アーカイブとしてはまとまっておらず、改めて残すことができなかったんですよね。

原因自体は分かったものの、なぜそうなるのかという根本のところが理解しきれていない、というのが現状です。そこを今日は追ってみます。1〜2時間で片付くのかは正直あやしいですが、とりあえずやってみて、途中で「これは無理だね」となるかもしれないし、うまく見つかるかもしれない、そんな感じで進めようと思います。

問題になっているのは、今扱っている「Interfacing with UIKit（UIキットとの連携）」のセクション（たぶんセクション3あたり）です。UIKit と SwiftUI を連携させつつ、一方は `UIPageViewController` を使います。つまり、UIKit が提供している `UIPageViewController` を SwiftUI で活用しよう、という文脈ですね。そのために `UIViewControllerRepresentable` を使って、そこでいろいろやっていく中で、ページングに `UIPageViewController` を使うための `Coordinator` を用意して、デリゲートを呼び出してもらう補助クラスを作っています。そして `makeCoordinator` で `self` を渡しているのですが、ここが一番の問題でした。

この辺までは動いていたのですが、いざ状態（State）を連携しようと、SwiftUI の View の State をトラッキングして、`currentPage` を `UIPageViewController` と SwiftUI 側のページビューの間でしっかり同期しようとしたときに、`currentPage` の値がズレる、という問題が起こりました。そこで原因は何かを探っていった、というのが（前回の）幻の展開です。最終的にそれは達成できた、つまり原因は突き止めて修正できたのですが、今日は改めてそこを見ていきます。

いろいろコードを直したので、まずは問題が再現できるところまで戻さないといけません。今「引数が間違っている」と言っていますが、これは試しに入れていたものなので良いです。ビルドが通ればいいのですが、その前にコードの前提を軽く確認します。

`makeCoordinator` で `self` を渡しています。この `self` は何かというと、`UIViewControllerRepresentable` に準拠した `PageViewController`（SwiftUI と UIKit をつなぐ元になる View）です。この View では `makeCoordinator` と `makeUIViewController` を実装して `UIPageViewController` を作り、さらに `updateUIViewController` でページビューコントローラを更新しています。これは、バインディングされている値が変更されたり、View が更新されたときに呼び出されます。

このとき、`self`（自分自身）は `currentPage` を持っています。そして `context` で渡ってくる `coordinator` にも `parent` として `self` を渡してあります。つまりどちらも `currentPage` を持っていて、同じバインディングにぶら下がっているはずなので、両方同じ値を返すだろう、と思っていたのですが、そこがズレていたのが問題でした。

具体的には、`context.coordinator` が持っている `pageViewController(for:)` というメソッドに `currentPage` を渡せば、そのページのコントローラを返してくれる、という作りにしていました。ただ、`currentPage` は `coordinator` が持っている `parent` が持つプロパティです。つまり外から与えなくても `coordinator` から普通に参照できますよね。そこで、`context.coordinator` に `currentPageViewController` のようなメソッドを用意して、`parent.currentPage` から導くのが自然だろう、としていたのですが、これが間違いでした、という話です。

本来であれば、`currentPage` は `PageViewController` の `currentPage` と一致しているべきで、両方の情報から正しい `currentPage` に対応するビューコントローラを導けるはずなのに、実際には食い違ってダメだった、ということです。どこでズレるのかを見ていきましょう。実行しなくてもプレビューで十分ですね。

ページをスライドさせると、`updateUIViewController` 内での `self` は2ページ目になっているのに、`context.coordinator.parent` のほうは1ページ目のまま、という状態になります。さらにもう1ページ進めると、`self` は3ページ目になるのに、`context.coordinator.parent` はまだ1ページ目のまま。つまり、1個ズレているというより、最初の値をずっと保持してしまっているような挙動です。これが問題の本質です。

この前段として、SwiftUI 側の `PageView` は `@State` な `currentPage` を持っていて、これを `Binding` で `PageViewController` に渡しています。`PageViewController` のイニシャライザでそのバインディングを受け取り、`currentPage` のプロパティとして保持しています。ライフサイクル的には、`UIViewControllerRepresentable` の流れで、最初に `makeCoordinator` が呼ばれ、その中で `Coordinator` に `self` を渡します。`Coordinator` のイニシャライザは `parent`（`PageViewController`）を受け取る形になっていて、`parent` に `self` を設定する、というイメージですね。引数ラベルを省略するのは分かりづらいので、`parent:` と明示したほうが誤解がない、という気もしますが、それはさておき、とにかく `Coordinator` に `self` を渡している状況です。

にもかかわらず、後段の `updateUIViewController` が呼ばれたとき、`context.coordinator.parent.currentPage` と `self.currentPage` が一致しない。どちらも同じ `Binding` のはずで、元のソースは一つ上位の View にあるわけです。ここが非常に問題です。

この現象は有名なバグか、少なくともよく知られた話ではないかなと思ったのですが、周りの iOS エンジニアに聞いても、いまいち反応がもらえなかったりします。これくらいの規模感で問題が出るなら、みんな当たり前に回避している気もするのですが、私はピンと来ていません。とにかく、同じバインディングを持っているはずなのに狂っている。なぜこうなるのか、今日はこれを特定したいのですが、どう特定するのがいいでしょうか。ひとまず、`Binding` 自体がどんな形なのかをもう一度見直すのが良さそうです。（幻の回でも一度見ました。）

`@frozen`、`@propertyWrapper`、`@dynamicMemberLookup` が付いた `public struct Binding` ですね。`@frozen` は「バイナリ互換を壊すような変更はしませんよ」という宣言です。`@dynamicMemberLookup` は、メンバ名を動的に解決してアクセスできる仕組みです。今回の場合、`value` に割り当てられた先のメソッドやプロパティがコンパイル時には分からないので、`@dynamicMemberLookup` を使って動的にアクセスしている、という理解で良いはずです。

`Binding` 自体は `struct`（値型）なので、ヒープではなくスタックに載るデータで、情報自体はコピーされます。バインド先は当然どこかに実体があるはずですが、そのあたりがどう振る舞うのかが気になります。

それから `Transaction`。`Binding` には `transaction` という情報がぶら下がっていて、「バインドした値が変わったときに View をどう更新するか」というメタ情報を保持しています。ドキュメントでは、`Transaction` に対してカスタムキー（`TransactionKey`）を定義して、`defaultValue` を持たせ、`associatedValue` でキーに対する値の表現を与え、`extension Transaction { var myCustomValue: Bool ... }` のようにしてカスタムのトランザクション値を拡張できる、といった話が書かれています。コンパイラは `defaultValue` の型から値の型を推論してくれます。利用側はキーそのものを直接使うのではなく、カスタム・トランザクション値のキーパスを使い、変更の適用には `withTransaction` を使う、とあります。

この値を `myView` の中や、その descendant（子孫）で利用できる、という説明が続いていて、descendant は「減らす」ではなく「子孫」という意味ですね。この辺をもう少しちゃんと翻訳にかけて確認しよう、というところまで見ました。

さて、話を戻すと、今のコードではプレビューで再現できます。`PageView` のほうを選んで更新をかけ、`PageView` の `body` で `PageViewController` を使い、`currentPage` に対して `PageView` が持っている `pages` を渡している構造です。`PageViewController` 側では、さきほどの `updateUIViewController` の中で、`self.currentPage` と、`context.coordinator.parent.currentPage` の値が異なってしまいます。本来は同じ `Binding` のはずなのに、`coordinator` 側は最初の値を保持したまま、という挙動です。

ちなみに、途中でエラーとして「Only applies to file scope（ファイルスコープでのみ有効）」のような非推奨（deprecation）警告が出ていましたが、これは試しにいじった名残りで、変なリファクタリングをしたせいかもしれません。一度中間生成物が消えてしまっていたようなので、改めてビルドし直してプレビューしています。

まとめると、ライフサイクル的には最初に `makeCoordinator` が呼ばれ、そこで `Coordinator` に `self` を渡します。その後 `updateUIViewController` が呼ばれた際に、`context.coordinator.parent.currentPage` と `self.currentPage` が一致しない、という現象が起きています。同じバインディングを共有しているはずなのにズレる。この根本的な理由を、ドキュメント（`Binding` や `Transaction`）を読み解きながら突き止めたい、というのが今日の狙いです。最後に、先ほどのドキュメントの続きは、もう少し翻訳にかけて確認していきます。 では、これで終わりにします。翻訳ソフトがアップデートを求めているので、アップデートをかけてみます。アップデート展開中でインストール中です。これで、きっと出てくるはずです。

そのC++から値を利用するには、`myView` には何もない気がするけれど、descendant（子孫）ってそういう意味なんだ、という理解で合っていそうです。とにかく、`transaction` モディファイアを使って値を使うことができる、ということらしいです。`myView` の `transaction` としてトランザクションを受け取り、その中でトランザクションの `MyCustomView` を設定していくイメージですね。スラッシュで書いてあるのは `View` のトランザクションのことです。

どこが間違えるかな、という懸念はありますね。間違える可能性はあります。ただ、`transaction` モディファイアを使えば、トランザクションの値を利用できるとのことです。`myView` の `transaction` でトランザクションを受け取り、その中で `myCustomView` のためのトランザクションをいじる、という形です。これはブール値ですね。これで、トランザクションのアニメーションとして、デフォルトの `.repeatCount(3)` みたいなことを設定してあげる、という話です。スコープがよくわからなかったのですが、今はわかりました。

どうなんだろう、`TransactionKey`。とりあえず、そういうトランザクションキーでアクセスできるサブスクリプトを `Transaction` は備えている、ということで、これに尽きるみたいです。一応エクステンションがありますが、トランザクションの中で、`BehaviorToWindow` は「プログラム的に dismiss する」、つまり `DismissWindowAction` を使ったときのトランザクションというのをインタラクティブに表現する、みたいな感じです。そういうことですね。`DismissTransaction`、`DismissBehavior`、`isDismissActive`、`dismissActive` という形でいろいろやっているっぽい。そういったのがデフォルト拡張で、`DismissBehavior` というのが用意されているらしいです。

`DismissBehavior`、そうなんだ、これは使ったことがないです。ちょっと調べてみますか。`DismissBehavior`。これはエミュレーター……いや、これはマークアップでいいか。あ、違う。Xcodeで検索しちゃった。今、すごくシームレスに調べられたんだけど、サファリのつもりでやっちゃった。

`DismissBehavior`。このキーワードであればいいかな。これで `DismissBehavior`。これは `dismiss` の動きを紹介するブログですね。これじゃないですね。`DismissBehavior` は Apple の公式がいいかな。`DismissBehavior`。こっちのほうがいい気がします。

これで、`DismissBehavior` として、どのようにウィンドウが dismiss されるか、というのを `DismissWindowAction` と組み合わせることで設定する、ということですね。何の意味かわからずに言ってしまったけど、せっかくなので続けます。これに設定する項目があって、`dismissWindow` というのがあり、`DismissBehavior`、`destructive`、`dismissWindow(id:)`、`accessory`……まあ、だいたい似た意味合いだと思うんですけど。

AUXって聞いたのは大学の頃で、Prolog というプログラミング言語を授業で習ったときです。やたらと `aux` という名前を付けて、一時的な補助的な述語を定義しているのを見て、「aux って言葉はなんかごまかしっぽいな」と思いながら、それはそれで良かったなと思った記憶があります。まあ、どうでもいい話ですね。

とにかく、ウィンドウのこういった使い方の用途を説明しているけど、やっぱり `dismissWindow` を取っておいて、`DismissWindowAction`、`DismissBehavior`……うーん、まだちょっとよくわかっていません。`DismissBehavior` というものがどういうものかは決まっているんだと思います。用途は一応書いてあって、`DismissWindowAction` でわかるのかな。ウィンドウ、そして particular scene。particular は部分的、ではなくて特定の、ですね。だから、特定のシーンに紐づけられたウィンドウを dismiss するときのアクション、`dismissWindow` の Environment ですね。これでいろいろやっているけれど、この辺は…。 とりあえず今は必要なさそうなので、まずはこれでいいかなと思います。そういったものもあると覚えておけば、そのうち役に立つでしょう。

他にもトランザクションの中に、`isContinuous` というのがありますね。`Transaction` が「継続的」かどうかを示すブール値で、アクションのシーケンスから発生したトランザクションなのか、というニュアンスっぽいのですが、正直まだよくわかっていません。とりあえず値が取れたら「継続的なアクションが生成されている（`true`）」、`false` ならそうではない、という理解です。ここでいう継続的なアクションは、スライダーのトラッキングや、押下中の操作、スクロール、`Stepper` などを想定しているのだと思います。なんとなくわかるような、まだ腑に落ちないような感じです。

トランザクションの中には、`position` とか、`scrollTarget` のようなものもあるみたいです。ほかにもいろいろ書いてあって、書き込み（プロパティや挙動）がいろいろありますね。今見ているのはトランザクションですが、実際に見ているのは `Binding` ですね。`Binding` の中のトランザクションを見ると、意外といろんなステータスがあるのですね。これを元に何か細かく制御しているのかな、と想像はするものの、具体的なイメージはまだつきません。`addAnimation`、`completion`、`animation`、`disablesAnimations` とか、いろいろあります。`taps` や `velocity`（ベロシティ）といった話題も出てきます。とりあえずそんな感じで、トランザクションにはいろいろあるという理解です。

ではもう一度、`Binding` のドキュメントに戻りましょう。この `Binding` の中で、トランザクション以外にあるのがイニシャライザですね。`get` と `set` を受け取るやつです。例えば、`get: @escaping @isolated(any) @Sendable () -> Value` を返す `@Sendable` なゲッターと、`set: @escaping @isolated(any) @Sendable (Value) -> Void` のように、値を受け取ってセットするセッターです。要は `get`/`set` ですね。これへのアクセスが外から許可されているなら、同一性の判定（同じものかどうか）みたいなことも、場合によっては見られそうだなと感じます。Concurrency 周りもだいたいそんな雰囲気です。

あとは、定数バリューとして `Binding.constant(_:)` という静的関数があります。`Binding` に対して固定された値を渡してあげる便利なやつですね。`wrappedValue` は、普通にバインドされている値を取得するものです。`projectedValue` は、`Binding` そのものを返します。だから、`Binding` として渡すときには、ドル記号付き（例えば `$value`）で渡す、という仕組みですね。`projectedValue` で初期化することもできるのか、なるほど。こちらのほうがきれいに書ける場面もありそうです。ここでどう書くのがいいかは、後で試してみましょう。

さらに、サブスクリプトで初期化（というか取得）して、ダイナミックメンバーに対してキーパスでアクセスできます。具体的には `WritableKeyPath` で値にアクセスし、`Binding` を返します。要は、このバインドしている `Value` に対して任意の戻り値の型を取れるサブスクリプトがあり、それをキーパスで指定して `Binding<Subject>` として取得できる、ということですね。そうか、こうすればいいのか。`Binding` からどうやって別の `Binding` を取るのだろうと思っていたのですが、キーパスを普通にサブスクリプトで渡せば取れるのですね。ダイナミックメンバーといっているのは `@dynamicMemberLookup` のことなので、つまりドットで取れる、という話です。なるほど。 つまり、バインディングされた値に対してドットでアクセスすると、プロパティ名を書くことでバインディング先の値を取得できる、という仕様ですね。これはかっこいいですし、よくできています。いわゆる「ダイナミックメンバールックアップ」（`@dynamicMemberLookup`）的な使い方で、プロパティに限られるのだと思いますが、実装としてはとてもスマートです。実際の使い道がどれくらいあるかはわかりませんが、プロキシ的な書き味が好きな人には刺さりそうです。

次に、`Binding` の条件付き準拠についてです。`Value` が `Sendable` なら `Binding` 自体も `Sendable` になりますし、`Value` が `Identifiable` なら `Binding` も `Identifiable` になります。便利機能ですね。

さらに、`Value` がコレクション系のプロトコルに準拠している場合の扱いです。`Value` が `MutableCollection` であれば、`Binding` は `Sequence` として扱える、という話があって、「コレクションとしては扱えないのか」と一瞬思いましたが、ちゃんと `Collection` 版もありますね。`IndexingIterator` や `SubSequence` の話も出てきます。なぜ段階的に分けて書かれているのかは少し不思議ですが、要はコレクション系の `Binding` はそのまま `for-in` で回せる、と読めます。さらに、`BidirectionalCollection` や `RandomAccessCollection` にも条件付きで対応していて、該当する型を入れれば効率よくバインドが動く、というわけです。これは設計上重要な特徴ですね。

規定の実装としては、`Transaction` や `Animation` に関するデフォルト実装があるようです。

それから、`DynamicProperty`（ダイナミックプロパティ）について。`DynamicProperty` プロトコルは、View の外側から更新されうる「保存型プロパティ」のためのインターフェース、という説明になっています。`View` が `body` を再計算する前に値を与えられる、という趣旨ですね。ドキュメントの表記で「`View/body-swift.property`」のようなスラッシュ区切りの書き方が出てきますが、これはドキュメント内でシンボルを指すための記法です。`View` の `body` プロパティを指しています。

`DynamicProperty` には `update()` というメソッドがあり、SwiftUI が `View` の `body` をレンダリング（再計算）する前に呼び出してくれるようです。`update()` 自体は自動的に実装されていて、内部の保持している値（underlying value）を適切に更新するためのもの、という理解でよさそうです。このあたりは興味深いですね。`onChange` などを調べる中でも、同様の文脈でこの話が出てきます。

「`body` プロパティの実装（`View/body-swift.property`）」という言葉は、いろいろなところで出てくるので、意味合いとしては「`View` の `body` を指すドキュメント上の表記」と捉えておけばよいと思います。今日はひとまずこのくらいにしておきます。 とりあえず外してはいなさそうですしね。コメントでそればかり出てきても仕方ないので、このあたりは一旦よしとします。では、とりあえずボディのことということにして、`View` の `body` の描画前にアップデートが呼ばれるというのは非常に興味深いんですけど、本当かな。自分の会社がそういう実装をしているのかな。

`DynamicProperty`。とにかく、その `DynamicProperty` に、あと、バインディングがそうなっているのか。だから描画前に何かできるっぽいですね。できるっぽいです。

それで、`Binding` にはほかにも、実装の中でイニシャライザとして、`Binding<V>` の値がオプショナルだったときに、オプショナルではない `Binding` も受け入れるよ、という意味のものがあります。なるほど。つまり、需要側がオプショナルを要求しているときには、わざわざオプショナルのプロパティを作らなくてもいいということですね。まあ、実際の使い道は限られるかもしれませんけど。

あと、失敗可能イニシャライザとしても動作するらしいです。`Binding` の値がオプショナルだったときには、その値が `nil` であったらバインドせずに `nil` を返す、というやつですね。ああ、そうなのか。これも役立つことはありますよね。

それから、`Binding<V>` で、値が `AnyHashable` であって、`V` が `Hashable` であるとき。なるほど。イニシャライザで、値が `AnyHashable`、`V` が `Hashable` のときに、`AnyHashable` をバインディングしている変数には `Hashable` のものを何でも入れられるためのインターフェースになっているわけですね。汎用化という意味で、なかなか上手な工夫だと思います。こういうのは面白いですね。言語側で簡単にやってくれても面白そうですけど、さすがにそこまでのルールはないから、自分で作る感じですね。

だいたいバインドの話は分かってきました。そこで問題に戻りますが、HPコントローラーにバインディングとして持っているもの。これは1個前のところで、HPUがHPコントローラーを生成するときに、このペットをバインディングという形でここに渡していますよね。渡ってきたバインディングを代入する。この代入のときに、アンダースコアでもいいんですけど、アンダースコア（`_`）はプロパティラッパーを考慮したストレージそのものになるので、これでもいいんですけど、イニシャライザが用意されているなら、それでバインディング。バインディングのラベルがいきますね。

バインディングのイニシャライザをもう一回確認します。イニシャライザはここです。`projectedValue`。`projectedValue` を使えばこれでコンパイルできそうかなと思ったんですが、`Binding` の `projectedValue` が `Binding` の値だから良さそう、と思ったのは自分の勘違いだったかもしれません。もう一回見ます。これで、バインディングを他のバインディングから生成する。`projectedValue` としてバインディングを受け取り、その値をそのまま渡して自分自身の `Binding` を使っていますよね。つまり、あそこの代入と結局同じか。もらっているのが `Binding` の値ですもんね。

普通に `currentPageNumber` にして、ここでアンダースコア（`_`）。これはバインディングなので、バインディングだけで `wrappedValue` はダメですよね。これもダメか。なので、アンダースコアでしたね。全然いい感じにならなかった。これでは何にもならないか。やはりアンダースコアでしたね。

とにかく、ページビューコントローラーが `currentPageNumber` のバインディングで受け取って、`currentPageNumber` に設定して、`updateUIViewController` が呼ばれたときに、このバインディングと、親（`parent`）の `currentPageNumber` のバインディング。この二つが食い違うというのは、ここから探せるかな。バインディングはいろいろあるよというのと、トランザクションとかも書かれていたけど、結局は構造体でしょう。構造体だと同じ値かどうかを見るのが難しいですね。 とりあえず、`Binding` をそのまま `print` するとどうなるのでしょうか。こちらをバインディングとするなら、このあたりですね。あ、勝手にやってくれました。自動で展開されたものを広げてまず見てみると、この二つですね。まだ狭いですが、それはしょうがないです。

`weak self` と `context`、この二つに注目します。つまり、上と下の二つです。これを見ていくと、バインディングは `pageNumber` で、トランザクションは `SwiftUI.Transaction`、ロケーションは `SwiftUI.LocationBox`、`SwiftUI.Binding`、`Landmarks.PageNumber` というのがあるらしい、という見え方です。`Unknown context 0x1DA48478` が出ていて、ここでロケーション、バリューは `page`。上と下、どちらも同じですね。

次に、ページを動かすとどうなるかを見ます。このときの下の出力では、`Binding` の `pageNumber` で、ここまでは同じです。ロケーションも同じ、`Unknown context` も同じです。バリューの `page` だけがずれていますね。これだけでは分かりません。

さらに分かるようにするには、トランザクション…トランザクションに `get` や `set` のようなものがあるとよいのですが、そういった API は公開されていない感じがします。`.` で `get` とかはありませんよね。誰か別にあるわけでもなく、`get` や `set` は見当たりません。

アンダースコアを使うとどうなるでしょうか。`_` を付けて `.` 経由で `transaction` とかを辿ると、プレビューのホストやルートのホストに関係しそうなものが出てきて、KeyPath の扱いにそろう感じですね。`transaction` や `update` などいろいろあって、`Transaction` はさっき見たようにいろいろなプロパティを持っているみたいです。これによってトランザクションが規定されている、ということだと思います。

`Animation` は何を持っているのでしょう。`Base` と `Mirror` と `debugDescription`、`Publisher`…分かりませんでした。とりあえず、まあいいか、というところです。

そうすると、ここでは手がかりがあまりありません。`_` はここで呼べないですからね。では `debugPrint` にしてみますか、一応。`debugPrint`。これでもう少し細かい情報が出てきてくれたらうれしいな、という期待を込めて、プレビューでもうスライドさせてしまいましょう。どうなるかというと、普通に文字列で出てきただけで、さっきと一緒ですね。ページがずれるだけです。`_value`、ちょっと `_value` が気になります。

`_value` というのを `Binding` が持っています。`Binding` が持っているけれど、これは `Binding` そのものではないですね。バインディングされた値そのものではなく、`Binding` に対して `wrappedValue` があり、その中に入っているだけなのかなという感じです。`update()` が呼ばれて初めて更新されるのかな、という推測もできます。

たとえば、ここで `context` の `Coordinator` の `parent`、`Coordinator` 以下の `parent.currentPageNumber` のアンダースコア…ここでは取れないですよね、`private` ですし。多分違いますね。`Binding` を持っていればいいから、`currentPageNumber` が `update()`…これ呼べますか？ いえ、`update()` はダメですね。イミュータブルな値に対しては呼べません。`currentPageNumber` はイミュータブル、`parent` の `Binding` ですね。これに対して `update()` しても…なるほど、`let` として認識されてしまいます。だから、これをそのまま呼びたいのですが、これではダメです。

では、可能性があるとすると、たとえばここでいきなり自分自身に対してやってみます。アンダースコア…これもダメですね。`mutating` なので、呼ぶ側がミュータブルである必要があります。自分自身をミュータブルにすればいいのか。こうするとパスは通るのか。なるほど。これで呼ばれるのかな。`mutating func`。さすがにこれだとプロトコル要求を満たしていない、という話ですね。

では `pageNumber` をこうやって持たせる…これは通るのかな。あ、これでいいんですね。なるほど。ではこんなふうにして、ボックスとして持たせます。これを `Binding` で更新するにはどうすればいいのでしょう。`update`…`update` かな。さっきの `DynamicProperty` の `update()` を試してみましょうか。`DynamicProperty` にして…。

ないのかな。本当かな。`func update()`。これをクリックで `print`。そして「update」というメッセージを… とりあえず出すようにします。`update` を呼ぶことにして、この中で `currentPageNumber` に対してアップデートができるはずですよね。ここは大丈夫、プラスなので問題ありません。

それから、上のほうで「`box = box[...]`」のように書くのではなく、`Box` は `Box` 型ですよ、という前提にしておきます。その上でイニシャライズするコードはダメだったので、その代わりに `self.box = Box(currentPageNumber: currentPageNumber)` のように、バインディングだから `currentPageNumber` を渡す、という形にします。

続いて、エラーが出ているあたりを直します。`box.currentPageNumber` に統一して、他の参照もすべて `box.currentPageNumber` にします。ここも、そこも、もう一箇所も `box.currentPageNumber` に置き換えます。これでオペレーターも通って、`update` もかかって、ここが出てくる、という流れですね。

今のところは、トランザクションを作って、バインディングで `location` とか、その辺が全部 `value` として 1 の状態になっています。これを動かすとどうなるか。ページ 1 と 2 と 1……この辺は変わっていないですね。とりあえずそれでいいのですが、やはり変わらない、つまりバインディングがズレる、という話になります。ここで `update` をかけたい、というわけです。

`Context` の `coordinator` の `parent` の `box`、これに対しては `update` できますし、`update` 自体はちゃんと発動します。`DynamicProperty` 面白いですね。初めて知ったのですが、これで `update` をかけました。ではこれを更新したときにどうなるか。あー、ページ 1 か。変わらない。`update` をかけてもダメでした。となると、ソースが全然違う、ということが言えるのかもしれません。3 ページに行って、もう一回回すと 1 ページ目に戻る。`update` が呼ばれるのは最高ですが、2 回呼ばれているのは何でしょう。

この `DynamicProperty` が 2 回呼ばれているということは、`box` の参照を見れば、別インスタンスにコピーされているかどうかが分かるのではないでしょうか。つまり、`box` インスタンスのアドレスを見たいわけです。そこで、ここでは `UnsafeBitCast` を使って `box` を `Int` にキャストしてアドレス相当を出します。`UnsafeBitCast(self.box, to: Int.self)` のようにして、同じように別の箇所でも `box` をコピーして貼っておきます。`context.coordinator.parent.box` も同様に出力して比較します。初めに作った `box` が何かも見ておきたいので、`print("InitialBox", UnsafeBitCast(self.box, to: Int.self))` のように出力します。

出力の体裁は 16 進数にしたいので、文字列のフォーマットをいじります。`UnsafeBitCast` を入れたのは 3 箇所ですね。これと、ここと、ここ。文字列の組み立てを直して、`Int` 型で扱います（`Int` 型か？違うかも、と思いつつも、まずは `Int` で進めます）。ダブルクォーテーションが消えていたりと崩れているところを直しつつ、16 進数で出力するように揃えます。

それから、`makeCoordinator` で `box` がそのまま渡っていくはずなので、何回作られたかも知りたいです。このあたりに `nonisolated(unsafe) var boxCount = 0` を置いてカウントするようにします。これで挙動がよく分かるはずです。 ここで `boxCount += 1` として、`initialBox` の `boxCount` を増やすようにしました。こうしておけば、何回目の `initialBox` が表示されているのかが分かりますし、その上で `updateUIViewController` が呼ばれたときに、そのボックスがどうなっているかも見られるかもしれません。

もう一度描画させたいのですが、いったん再開を押すと、あ、もう動いていますね。ではもう一回実行します。最初の時点で `initialBox` が 4。4というのは、以前の状態が残っているのでしょうか。`TAE5B0` というボックスが作られていて、ボックスが割り当てられています。`update` 側のバインディングは `self` と同じで、`context` と `self` で同じボックスを使っています。ということは、同じボックスに違う値が入るはずはないので、やはり同じということですね。ひとまずここは問題なさそうです。

それから、`update` が2回動いているのは何でしょう。1回だと思っていたのですが、もう一つ動いています。H が 1 と 1 で、もう一つも H が 1 と 1。`updateBox` が2回動いていますね。次の `update` ではアドレスが違っていて、`TAE5B...`。これが最後にイニシャライズされた方です。前のものは切り替えたときの残りかもしれません。もう一回切り替えれば分かるかな。`...5B0` が最初に出て、別のものが表示されるはず。動かしてみると…どうでしょう。いったん捨てればいいのかな。今はもう出ていませんね。ここで一回捨ててから動かすと、最初が `...5B0` です。これで解決していそうです。次に `A30` が新しく作られているので、さっきのは古いやつがたまたま出てきていただけでしょう。この後に出てきた方だけを追えばよくて、ボックスが同じということは完全に同じはず、つまりバインドも同じ…と言い切るのは言い過ぎかもしれませんが、少なくとも同じインスタンスが複製ではなく参照として `context` まで到達している、ということは分かった気がします。

その中でバインドされた値は、今は 1 ページ分の情報ということですね。もう一回動かせば、ちゃんと捨てられることが分かると思います。ではさくっと動かします。`initialBox` の後、次のボックスを作りました。`9140`、そして `9140`。お、ズレました。これで良さそうです。ボックスのアドレスがズレたということは、ソースが違うということです。`...140` が最初の方で、それに対してもう一つ、`context` に入っている方が `A30`。今作ったのが `A30`。新しいのはこちらですね。つまり、新しいビューが再描画されて、そのビューと関連付いたバインディングを持つ `context`（正確に言うと、今は自分自身のビューです）に、この中で作られたものが渡ってきて、再描画されている、という流れです。`context` に関しては、`makeCoordinator` が呼ばれるのは一番最初だけのはずです。

`Coordinator` が作られたところもログを出しておきたいので、`print("Making Coordinator")` のように出力するようにします。リアルタイムっぽく動いているように見えましたが、そんなことはないでしょう。ではもう一度動かします。

`initialBox`。今表示されているのは古い方ですね。この辺まで進めて、ここからが新しい方だと思います。`makeCoordinator` が走って、`update` がかかり、`510` というボックスに切り替わっています。`context` にも現在のビューにも対応付けられている状態です。ここでスクロールすると、`510` が `context` の方だけになる、という感じですね。 ここです。ここを見てください。510だったやつがスクロールすることによって、ページナンバーが2にセットされました。2にセットされたときに、イニシャルボックスが `0x1F0` で作り直されて、これがバインディングとして機能しています。`self` のほうは `0x1F0` に変わっていて、通常のバインディングが更新されました。

この更新はどこでやったのでしょうか。`update` の中で代入していましたよね。どこだったかな……ああ、デリゲート。デリゲートのどこでしたっけ。代入したのか。ここです、ここでした。これはページコントローラーの `didFinishAnimating` か。アニメーションが終わった段階で、`parent` のボックスの `currentPageNumber` にページナンバーを設定しています。

こういった状況になっていて、これは誰が持っているのでしょう。ページビューコントローラーか。ページビューコントローラーだけではないですよね。コンテキストが持っている気がします。コーディネーターです。コーディネーターが持っています。コーディネーター（デリゲート）に対して `update` が呼ばれたときに、ここで呼ばれてくるコーディネーターは新しいコーディネーターですね。そのコーディネーターにボックスの `currentPageNumber` をセットする。一方で、こちらでは `parent` に対して設定しているので、少しこんがらがりますね。とにかく、そのようにしていた値が `0x1F0` に反映されました。

だから、ここでどのコンテキストが発動したかも見ればいいのです。後でそれをやるとして、とにかくここを見ると、コンテキストのほうは 510 という古い値が残っています。残っているページが更新されないままです。なるほど。ただ、コンテキストが古いというのは、`makeCoordinator` は2回目は出ていないですよね。1回目のこの `makeCoordinator`（コンテキストとかコーディネーター）。コーディネーターをたくさん作ったときに `self` を入れてしまっているので、その `self` がもう消滅してしまっている、そんな感じ。つまり、それは更新対象にならない、ということなのでしょうね。だから、バインディングが更新されない、ということなのかな。

ここで `setPageNumber`。この中で `String`、`unsafeBitCast`、これでコンテキストの `parent` のボックスに対して `UInt(self)`、それで `UInt16`、これでいいですね。こうすると、セットした値がどっちなのか見えますよね。ページコントローラーとかさっき捨てたから、スクロールした後で、イニシャルボックスで 960 というのができて、その 960。960 が新しいほうで、`0x020` がたぶん古いほうなのでしょう。

イニシャルボックスもそうですが、`setPageNumber` はまたこれだ。そうか、`currentPageNumber` に `0x020` を入れると、バインディングされたんだ。そうなのか。古いほうにページナンバーを代入して、そのとき代入したページが `setPageNumber(2)` ですよね。でも `0x020` のほうの `_value` は 1 なんだ。つまり、バインド先が新しいビューにも入れ替わっているということなんだ。

新しいビューに入れ替わっているかどうかを調べる方法は、構造体なので普通は見えないですよね。構造体、スタック領域……スタック領域だと思っている。スタックのアドレスを知るにはどうしましょうかね。とにかく、バインドが持っているその先、そのアドレスが変わっていることが分かれば、明らかに違う値ですよね。変わっていなければ同じ。変わっていなければ、バインディング先が差し替わっていない、ということになると思います。

そうすると言えることとしては、ボックスに対して、そのボックスが何を持っているか。バインディングを持っていますよね。だからボックス型に対して何かできるように、能力を与えてあげればいいのかな。ボックス型に対して、バインディングが `var` で、プロパティラッパーが `var` だと、アドレスが取れるじゃないですか。だから、例えば関数 `dumpBinding` みたいなものを作ってあげて、この中でどうしようかな。バインディングの `parentPageNumber`、これを取りたいわけですよ。`binding.parentPageNumber` を関数で取れるようにする。

例えば、`dumpPageNumber` という関数を、引数に `UnsafePointer<PageNumber>` を取るようにして、これでポインタで取れれば、`&pageNumber` のアドレスを渡せば、アドレスが出てくると思うんですよね。これに渡せれば良いという状況になってくるので、`dumpPageNumber` に対して `&pageNumber`。これでいけるのか、`pageNumber`。これはダメですよね、きっと。プロパティラッパーを `&` で渡すと、`UnsafePointer`。これを `dump` するときに、バインディングをそのまま表示したら、これはバインディングアドレス（さっき表示したボックスに対するバインディング）になります。まず、バインディングそのものが差し替わるかどうかを見ていきますか。バインディングそのものが変わる可能性がありますよね。 文字起こしテキストがまだ届いていません。整形する元のテキストを貼り付けてください。

受け取り次第、次の方針で自然な文章に整えます。

- ですます調に統一し、句読点を適切に入れます（要約はしません）
- 誤認識の表記を正します（例: 「G言語」→「C言語」、「万全オキス」→「万全を期す」など）
- コードはバックティックで装飾し、短いものはインライン、長いものはコードブロックで表記します
- 複数人の会話でも発話者名は出さず、内容を踏まえた通常の文章にまとめます
- 途中から始まる不完全な文は無視し、次の文から整えます

追加の希望があれば、併せてお知らせください（例: タイムスタンプの扱い、口癖・ノイズの削除の程度、専門用語の表記ゆれルールなど）。 文字起こしのテキストを貼り付けてください。いただいた内容を、要約せずに「ですます調」で読みやすく整え、誤変換（例:「G言語」→「C言語」や「万全オキス」→「万全を期す」など）を適切に修正します。コードに該当する部分は必要に応じてバックティックで装飾します。動画の一部分でもそのままで大丈夫です。 文字起こしのテキストを貼り付けてください。

いただいた内容を、ですます調で読みやすく整え、誤変換を修正し、コードは必要に応じてバックティックで装飾します。文の途中から始まっている場合は次の文から整え、会話形式は地の文に統合します。要約は行いません。 文字起こしのテキストが見当たりませんでした。整形する元のテキストを貼り付けてください。長い場合は分割で送っていただいて大丈夫です（目安として1回あたり5,000〜8,000文字程度）。

対応内容

- 「です・ます調」で自然な日本語に整えます。要約はしません。
- 誤変換（例: G言語→C言語、万全オキス→万全を期す）を適切に修正します。
- コードはバックティックで装飾します。短いものはインラインで表記します。
- 複数人の会話は発話者を区別せず、内容を踏まえた通常の文に統合します。
- テキストの冒頭が中途半端でも、続く文から自然に整えます。与えられていない内容は追加しません。

表記の希望（例: 用語の統一、英数字の全半角など）があれば、合わせてお知らせください。 ダンプバインディングという機能を追加したおかげで、これを文字列として使えそうです。戻り値を `String` にし、内部の入れ子の関数も `String` を返すようにして、出力は `print` ではなく `return` にしました。絵文字の出力は不要になりそうです。こうしておいて、該当箇所は `return` で返すようにします。

これでダンプできるようになったので、あとはバインディングを出力している箇所を調整します。ボックスのアドレスを取っている処理のついでに、もう一つ、あとでダンプとして `self` の `Box` に対して `dump_binding` を呼ぶようにします。こうしておくと、バインディングの実際の値がポインタで得られ、実体がある場所までポインタでたどれるようになります。そういう意図でまず進めていきます。

`self` の前に挿し込むのはここかな、という箇所があって、ダンプが必要なのはここことここだけだったはずです。ほかはあれだけでしょうか。ページナンバーの処理のついでの箇所は、`self` ではなく `parent` を使うべきでした。上のほうで並べて書いたところに1か所間違いがありました。つまり、ダンプはコンテキストのコーディネータの `parent` の `Box` に対して行います。

これでどう動いているかをまずちらっと確認します。`parent_number` では、ダンプの中で `0x840` が使われています。イニシャルな `Box` のときには `0x570` で、その後のダンプも `0x570`。もう一方は古そうで、バインディングが `0x850`。ダンプっぽい動きです。ここでは `0x840` が古そうで、ダンプの `0x570` が新しそうに見えます。もう一回やってみると、キャプチャの値が変わるかもしれません。先に `parent` のほうを見ると、`0xF60` と `0x840`。イニシャルでは `0xF60` で、確かに `0xF60` ですね。`0x840` は何だったかというと、ここです。`page_number` が `0x840`。`0x840` はまた全然違う値になっています。つまり、バインディングはどんどん作り直されていくということです。

ただ、見たいのはこれではなく、バインディングそのもの、すなわちバインディングのポインタが指している実体です。これをさらにプロパティとして取り出したいのですが、どうするのがよいでしょうか。これは `page_number` ですが、`let x` のようにして扱いたいイメージです。バインディングの構成はどうなっていたでしょうか。バインディングのプロパティは、ほとんどがトランザクションとラップドバリュー、それからプロジェクテッドバリューでした。これは計算で得られる値の可能性があります。とにかく、ラップドバリュー。プロジェクテッドバリューもあるかもしれません。バインディングの値は、計算によって求まる型かもしれません。 わかったことの一つとして、バインディング自体がここで完結しています。これ自体がトランザクションとラップドバリュー、今回のページナンバーを持っているので、この型のサイズだと考えられます。やってみましょう。

これはプロパティに入っている `Binding` なので、ポインターの `PageNumber` の `pointee` ですね。`pointee` が指す値をトランザクションのページナンバーにキャストする形を取るわけですが、この箇所が問題のようです。ここはそのままで構いません。

`unsafeBitCast` でキャストしましたが、よくないエラーが出ます。サイズが違うということですね。クラッシュするのは良くないので、あり得るとすると、もう一つのプロパティ、`Binding<PageNumber>` のほうで試してみます。これで落ちなければ…。サイズはいくつか調べてみるしかなさそうです。`print` で `MemoryLayout` を使ってサイズを出してみます。ログのために残しておきます。これでいいかな。実行すると、どこかにサイズが出力されるはずです。24 らしいですね。`PageNumber` だけだといくつだろう？ 8 ですね。ページナンバーは 8 でしょ。

では、トランザクションは…？ プロトコルがトランザクションで、`Binding` のトランザクションはラップドバリューだけですよね。`public var transaction` を持っていますけど、このトランザクションを設定するときに、イニシャライザーで `value` と `transaction` を取っていますよね。それでやっているけど、先ほどの 40 もないですね。`Binding<PageNumber>` が 24 しかないということは、24 の中に入っている、つまり値はヒープに入っている可能性のほうが高いと思います。

トランザクションはプロトコルだと言いましたが、このプロトコル自体はただのプロトコルです。いろいろ書いてあって、内部で何かを持っているとしても、`Binding` でも 16、あとは 8 バイト、8 バイト。`Binding<PageNumber>` も 8 バイトかな。だから、8 バイト、8 バイト、8 バイトの 3 つで 24 ですよね。では、それでやってみますか。トランザクションとかページナンバーとか細かいことは抜きにして、`UInt64` を 3 つで 24 バイトにそろえます。`UInt64`、もう 1 個 `UInt64`。こんなふうにして書き換えれば、これはこれで落ちないと思うんですよ。24 バイトなんでね。…あれ、落ちた？ 8 バイトと 1 バイトになってしまっていますね。16、`UInt64`、そうですよね。ここだ。すごい勘違いをしていました。`UInt64` に直します。これで落ちなくなりました。

落ちなくなったので、この `x` に入っている値を、とりあえず `print(String(x[0], radix: 16))` という形で連続で出してあげます。次に `x[1]`、もう 1 個、ここかな。で、`x[0]` と `x[1]` と `x[2]`。このようにしてあげれば、 とりあえず、アドレスっぽいものが出てきてくれるかなということで、1回削除してスワイプしてあげると、イニシャライズのところ、ページナンバーの古い方がこれで見られますね。6、0、0、6、0、0、0、0、0、0、0、4。読み方、読み方、1、2、3、4、6、7、8。頭の0をカットすることがあるのか。頭の0をカットすることがあるのか。これはちょっと困りますね。どうするといいんだ。ラッピングとか、何かをかますとか、これはないですね。そうすると、頭に全部振っていきますか。

これとこれと、あ、間違えた。`String` のラディックス、こことここと、ここに対して、"0" + `String(..., radix: 16)` って、これに対してサフィックス2ですか。何か違うか。あ、違う違う。こっちがプレフィックス1桁だよな。押してあげたら、いらないわけにして、もう1回スワイプしてあげると古いやつ。古い情報が、これだ。000E001、何か来たやつだよな。

えっと、サフィックス。サフィックスってのを後ろから2つ…いや、2つじゃダメですね。そうだよね。えっと、16ビット…16ビットじゃない、32ビットだから、あ、来たか。えっと、あ、そうか。全然違うこと書いた。えっと、でも、00E001、何か出たような。えっと、何でだろう。まずここを解決しますか。頭に0詰めをして、数字が必ずある状態で、もう1個数字を足して、それで…。だから0にも出てくるんですよね。だから6も出てると思うんですけど。1、2、3、4、5、6、7個。7個出ている。7個出ている。ナンバーで7個出ている。7個も出るか。

えっと、`String` に対してサフィックス…丸括弧が何か足りてないですね。あ、足りてないね。全然違った。だからこれか、この `String` の前に足すところですね。足すところと、あ、全部そう。この足すところ。ここで丸括弧を1個入れて、で、それで、あとはこの先で、サフィックスの前に、8桁のね、サフィックスを取って、それで終わりだ。これでいいな。そうすると、何個も…えっと、1、2、3、4、5、6出てますね。

で、それで終わりだと。えっと、16進数だから、1バイトは2桁、32ビットは4バイトなので、16進表記では8桁です。で、これで4つ、4つ…うん、とね、終わりだとね。はい。で、これで頭が0なのもありがたいですね。その後、0CDED001というふうになっていったりとかして、これが、えっと、6を1回捨てました。6を1回捨てて、さっそく動かしたときに、まず最初の方で、ページナンバー下、古い方。ここは、0000CD88BED001というね、3ページ目なのか、勝手に思ったけど、3になりましたね。うん、ページ番号の3。これは要するに予想通りなんですけど、この可能性があるということですね。

で、それで、これ見てもしょうがないね。とにかく…あ、いや、しょうがなくないや。とにかく、このテキストで選べるページナンバー。この中身、これがリフレッシュされているということですよね。うん。なので、バインディングの差し替えも伴っているけど、それに伴って、その中の実際のバインディングが新しいビューに変わっている可能性が、なんかありますね。実際のビューも、比べてみれば何かアドレス出てくるのかな。それも確かめられるかな。ビューがあって、ビューがあって、確かめるにはコーディネーター。アップデートのところで十分か。アップデートのところで、自分自身ですよね、ビューっていうのはね。`self` のことだ。`self` が、あ、でも `self` もコピーされちゃいますからね。`self` がコピーされてしまうから、`self` 自体のアドレスを取っても、ちょっと意味ないですね。うん。

だから、やっぱり指し先が、バインディングでの指し先。あと、指し先がビューの可能性があるのかな。でも、ビューのアドレスが入る可能性っていうのは、なんか低い気がするんですよね、なんとなくね。あと、ビューのアドレスを取るのは、ちょっとやっぱりですね、mutating関数を入れる隙がないので、それはダメですね。ダメか分からないけど、基本はそこまで考えなくていいから。とにかく、ビューのレンダリングの都合で、やっぱりバインディング先が変わっちゃうっていうことが、一番の大きな問題みたいなね。おそらくというか、それは間違いないですかね。 なので、古い方のビューを何とか更新させれば、いわゆるさっきのアップデートがうまい形で発動してくれるのかな、と思いました。すると、そうか、バインディングで書き換えるところを見たじゃないですか。実際にページの、ペアレントページナンバーを書き換えるところです。あそこで、そうそう、`setPageNumber`。ここを見たときには、`setPageNumber` は古い方に対して発動していた、というのがありましたよね。

ここだ、ここだ、ここだ。古いやつじゃないや。これ自体も新しく出たんだけど、これが `001` に対して `3` を代入した、という感じですね。これに対して `3` を代入すると、バインディング先のビューは更新されるのに、自分自身は変わらないのか？ そこも気になりますね。

バインディングして、ペアレントの Box の `parentPageNumber`。こうしたときに `print` で、例えば `parent.box.parentPageNumber` を出力するとします。これを見て、今は1ページ目の表示なので `1` になっているのかな。えーと、もう一回サクッとやってみましょう。これで `print`、あ、出た、`2`。あ、ここは更新されるんだ。`001` に対してね。`001` に対して、ここは `1` なのに、コンテキストの中は `1` なのに、このアドレスにページナンバーを代入したのに、新しい方（ここではないですが）に代入したのは…あ、ここか、ここね。いいんだ、`001` というやつに代入した。アドレスも合っていましたね。

だから、代入した先は古いバインディングなのに、更新された先は新しい方、ということになります。あれはコントローラー、あとは `finishAnimating` で代入して、これでこのローカルの中では古い方がまだ呼ばれて、アニメーションが終わったのですね。この中では古い方に対して更新がかけられて、それで更新もちゃんとペアレントの Box から取れるにもかかわらず、次に行ったときには、もう `2` の方、新しい方ですね。新しい方からしか新しいページが取れなくて、代入したときに使ったはずのバインディング、ここからは古い方しか取れない。代入したのもローカルのコンテキストではないけど、行き過ぎた側ですよね。コーディネーターのペアレント…そうだね。しかし、よくわからない。本来おかしいな。とにかく古い、古い。なんでだ。

バインディング、このバインディングの先のアドレスですよね。というか、ポインティが指している中身がアドレスだったと仮定して…とにかく、これでコンテキストのアップデートは `1` で、`pageNumber`。`pageNumber` のバインディングを表示したのがこれ。だから、下と同じ感じでやってみますか。上の方だね。この辺でペアレント側を参照しますが、これをコピペして、さっきのアットマークのところ。ここで「代入前の `pageNumber`」と「`pageNumber` をセットした後」。この2つに対してアットマークを添えて出力してあげて、それでコーディネーター…この辺はコーディネーターとかないので、全部なしで。コーディネーターが自分だからペアレントまで、という形ですね。それで、代入し終わった後のバインディングがどうなっているのか、これを見てあげればいいんだ、と。

これで実行します。このときにバインディングがどう変わっているかを見ればいいかなと思ったけど、ここに残っているコンテキストのコーディネーターはいらない。これとこれね。ここで3つあったのか。3つあった。上の3つを消したっけ？ ペアレント Box、ペアレントコーディネーター、ペアレント Box、ペアレント Box、ペアレント Box…消した。大丈夫そうですね。これでいいです。

ロゴを消して、スワイプを1回したときに、アットマークの辺り。この辺りでバインディングの値が…これだこれ。あった。この「アットマーク1個の前」と「1個の後」と「2個の前」。この2つでページ番号を更新しているわけですけど、バインディング先にはちゃんと反映されたにもかかわらず、バインディングの変数自体は両方 `1` のままですね。これが原因ですね。なるほど。だから古い方でもちろん新しい方には影響を与えるのですが、ただし、これ（古い方）の内部的な情報は更新されないままになっているので、次に古い方が握ってしまったコンテキストの方は `1` のまま、ということが起きているのね。

たぶん、現在のページ番号はここで出力しているのに、あとはちゃんと `2` が取れるのはちょっと違和感はありますけど、これは連絡を取っているのがちゃんと反映先の方をデータとして取っている。しかし先に行くと、アクセス先が古い…古いじゃないね。いや、わからないな。何だろう、この `value` の…。とにかくこの `value` がデフォルトなのかな、これ。デフォルトの可能性もありますね。だとすれば、リンクが途切れたときにデフォルトを返している、という可能性はあるといえば…でもデフォルトの `Transaction` か。うん、そうだね。何だろうね、これね。わからないね。とにかく `value` が古いということはわかった気がする。古い方、`001` の方は最終的な値が `1`、ページも `1`、そんなふうになっているので、「エンドはページ `1` ですよ」ということなのかな、という気がします。そういう理解でいいのかな。

バインドして、こんな気はするけど、バインディングでバインド先がいなくなったとき、このときにどうなるか見ればいいのかな。バインディングのことを念のためもう一回ね、おさらいしておこうと思ったときの `Transaction` と `wrappedValue` と、`wrappedValue` からですね、あともう1個、`projectedValue` か。はいはい。うん。この辺があるぐらいで、デフォルト値は別に持っていないですけどね。この辺はどう解釈すればいいんだろう。まあ。 バインディングでバインドが切れたときにどうなるのかが気になったので、Xcode Playgroundsで試してみます。バインディングを使うために、まずは `import SwiftUI` を入れます。

次に、`struct X` を用意して、`@State private var value: Int = 0` のようにプロパティを作り、`init(value:)` で `value` を設定する形にします。さらに、`struct Y` を用意して、`@Binding var value: Int` を持たせます。イニシャライザで `X` を受け取り、`value` に何を渡すかを考えます。`Binding<Int>` から `Int` に直接アクセスできるか、あるいは `Int` から `Binding<Int>` にできるのか、という点で少し詰まります。`@Binding` には `Int` そのものではなく `Binding<Int>` を渡す必要があるので、本来は `x.$value` のようにプロジェクテッド値を渡す必要がありますね。

値を確認するために、`print` 文で `value` を表示する関数を用意します。`description` にしようかとも思いましたが、ひとまず `dump()` のような関数名にして、`value` を出力するだけにします。

スコープを2つ作って挙動を観察します。`let y: Y` を確定初期化する前に `x` を作って `dump()` を呼び、`x` が解放される（リリースされる）タイミングで、`Y` 側のバインディングがどうなるかを見たいわけです。`x` が本当に解放されるかどうかを確かめるために、`deinit` で `print("deinit X")` するようにもしてみます。型を `Copyable` にしてみたり、`borrowing` や `consuming` を試したりもしましたが、コンパイラの不具合っぽくて `Exclusive Access` の違反（Exclusive Violation）が出てしまい、状況は変わりませんでした。`borrowing init` なんてものは存在しないはずですし、これはちょっとバグっぽいですね。デイニシャライザ（デストラクタ）は確認できませんでしたが、通常どおり解放はされるはずです。

この状態で実行すると、表示は 0 になりました。初期値を 3 にすると 3 と表示されます。つまり、`value` が 3 で、`@Binding var value: Int` で受けているときの表示は期待どおりです。では、初期値はなくてもよいのでは、ということで `value: Int` を初期化せずにおいてみると、実行結果は 10 になりました。

次に、`dump()` する前、つまり `x` が消滅する前に `x.value = 20` を代入してみます。すると表示は 10 のままでした。これは良さそうに見えます。さらに、`x` が消滅しないように `let` を `var` にしてスコープの外に出すなどして生存させてみても、表示はやはり 10 のままです。

ここで、`X` の自身の状態（`self`）を書き換えるようにしてみます。`$value` に対して更新をかける形を試したいのですが、`let` にしているため変更できません。`var` に直し、外から更新を呼ぶようにしてみます。たとえば、`mutating func update(_ value: inout Int)` のような関数を `Y` 側に用意して、`set value` のあとに `Y` の `update` で `value = 20` を試します。しかしこれは「ミューテーティングな `Binding`」に絡む問題でうまくいきません。`@Binding` 側をミューテーブルにする必要はなく、`Y` に `mutating func update(...)` を用意してそこで `value` を更新する、という方針に変えても、実行結果は 10 のまま変わりません。

このあたりは、SwiftUI の機能（`@State` と `@Binding` の連携）に依存してバインディングが機能している部分があって、Playground 単体では完全には再現されていないのかもしれません。`State` の定義をたどると、`wrappedValue` と `projectedValue`（`$value`）を持つプロパティラッパーで、`init(wrappedValue:)` や `init(initialValue:)` があり、拡張もいくつかあります。`@State` 自体は単なるプロパティラッパーとして見えますが、実際の更新・伝播は SwiftUI ランタイムの管理下で働く部分があるはずです。

最終的に、`Y` の `dump()` は単に `value` を表示しているだけなので、ここまでの実行結果は「`Y` が保持しているのは 10 のまま」という挙動になっています。 これで X にもバインディングすることになるのかな。X の値は…25 にしようか。こうしたときに、でも初期値は 10 だったような気がするんですが、初期値 10 ですよね。うん。あれ、なんか `underlying value location` って見覚えがありますね。`Location` にいるってのがありますね。

とりあえず、X が値で…えっと、X がどこかというと `KeyPath`、あ、ここですね。X の値が `nil` で、Y に対して X で…えっと、こうした値がどの位置を向くか…あ、これか。バインディングで、SwiftUI で、値が 10 になっている。そこに代入したよね、ということですね。うん。

`Location` をボックスとして見ると、Swift の `Int` 型で、`ConstantLocation` になっています。`ConstantLocation`、バインディングを渡したときかな。このときに X の値が 10 で、その 10 は `Int` 型に入っているはずですよね。`Int` 型で入っていて、その X のバインディングをもらっている。X はもう一回見るけど、`@State` って `Value` ですよね。これが `ConstantLocation` になっているのがよくわからないけど、ああ、もう `constant` になっちゃったのか。あの辺はわからないな。うーん。そうか。まあ `constant` だったら、どんなに代入しても `constant` のままでしょうからね。これでいいと思います。うん。

これを SwiftUI でやろうとするとできるのかな。えっと、できるのかな。えっと、ここですよね。ここで拝借して、PDF コントローラーがあるという、そういった中で、バインディングが…うーんと、例えば、例えば何もないかな。とにかくバインディングに対して、`@State` を消滅させたいんですよね。とにかくやりたいことはそれです。だから、やるとすると、PDF コントローラーの 1 個前かな。PDF はどこだ。PDF はここだ。PDF の中で、例えば `@State` を変えただけか。これを消滅させたいんですよ、とにかく。だから、PDF を発揮するというか、親ビューがあって、バインディングをして、バインディングした後にオプションになるかどうか想像できるんですけど、でもオプションになるかどうかは…えっと、オプショナル、消滅させるわけにはいかない気がする。まあ、ちょっとやってみましょうか。

タスクステータスじゃなくて、これを、えっと、ページナンバーをオプショナルにしてあげて、そうするとこの辺で指示を効かす？これはいいのか？この辺は別に…。えっと、ここでね、指示を効かすわけですけど、`currentPageNumber` に対して、えっと、オプショナル。だから `wrappedValue` を触るには、ここでバインディングは自分で作らないといけないかな。バインディングを作ってあげて、オプショナルはどうかということで、やっていかないといけないかな？どうするか…。まあやってみますか。

`Binding` をイニシャライザで作って、丸カッコで、それで `set` として…えっと、イニシャライザで `get` として…えっと、あ、そうか。オプショナル、いい。大丈夫。えっと、`currentPageNumber` の `wrappedValue`。それで、`set` に対して、`currentPageNumber` に対して…なら 0 かな。なら 0 で。大丈夫です。 この辺がステートに `MoveNext` を持っていないと言っていますね。`currentPageNumber` がステートで、このステートの `wrappedValue` かな。それの Next はこれでいいですね。`currentPageNumber` は `currentPageNumber` に一手を入れる、つまり `wrappedValue` を 1 増やす、これでいいですね。

あとは、ここが強制アンラップができていないですね。強制アンラップで `wrappedValue` を使うようにして、代入も強制アンラップした `wrappedValue` に対して入れる。これで `currentPageNumber` を表示するのも `wrappedValue` でいけます。これでいいですね。

こうしてあげたときに、プレビューは動かないのかな…大丈夫ですね。これで動かしているという状況になっていますよね。その先は別に変わっていないので、これでページ番号が…ページ番号が 1 のままカウントになっていた。これではダメか。`Optional` とかダメなのかな。なんか作り直したりする？ いや、わからないな。まあでもダメですね、とにかくね。ああ、そうか。`Optional` をやめて、どこまで戻る？ これで。`Step` にデフォルトバリューが面白かったですね、なんかね。まあ、当たり前なのかな。うん。これで…あ、これは動かせて動けますよね。うん。だから自分のバインドの使い方が間違っていたと思うんですけど、バインドって難しいですね。あれだけで終わっちゃうんだ。`Optional` にしただけでね。`Optional` にしない中でバインド…まあ、これでいいからいいか。

これを自分でバインド作ったらどうなるんだろう。まあ、やってみる。あ、違うのかな。バインド…バインディングか。1、2、3、いけますね。ってなると、`Optional` が問題だったのかな。`Optional` がなんか問題だったのかな。そうかもしれない。うん。そういうことにするか。わからないけど、まあいいや。これで。よし。はい。え、どうしようか。なるほど。これ消しちゃったんですよね。パレットページの…あ、`Step`。いや、`Step` をね、まるっと差し替えたいんですよ。でもこれ構造上不安なのでね。`Step` はね、差し替えられないっていう、差し替えられないという問題があるので、あれじゃないか。そうか、バインド先がなくなったときっていう状況だと思ったんですよね、これがね。だからこのバインドがなくなった場合というのを再現…なんか、だけど、`View` で持っちゃっている以上はね、バインディングがうまくできないですよね。あ、なくすのがね。

あともう一個思いましたけど、さっきの `Y` を、例えばこの中でやってみるってものかな。これをね、ステートをなくせないんですよね、そうするとね。でもまあ、例えば `Y` として、`Y` 型。イニシャライザーとして `y = Y(x: self)` ですよね。`self` だと、ストアドプロパティを効かせていないですよ…あ、効かせていないですね、確かにね。これは許されないので、`Optional` で返しました。で、これで `y` を作って、それでこの `y` がちゃんとバインディングが動くかどうかって感じ。

これ、ファンクションテストをやって、このテストの中で、`value` に対して Int 型をもらって、それで `y` の `value` に Int 型をもらって、それで `y` の `value` が…`y` の、えっと、Int 型の…こうかな。自信が一気になくなった。あと `print` がなんかいらない？ `x` が `self` が自分だから、これ `value` ですね。`value`。うん。`print` の色が付いていないのは何？ えっと、大丈夫ですよね、ちょっとね。だからこれで、`x` のほうのテストを呼んであげれば、まあ、反映しているかどうかの話ね。`x` のテスト。で、`value` に対して 100 ぐらい与えてあげたときに、さあ、最後の出力はどうなるでしょう、というのを今見てみました。 x が 100、y が 10。これ、面白い結果が出たのではないでしょうか。x が 100 で、y が 10。y のバインディングは x 自身を渡して作っているのですが、この状況で x の値、つまり状態は 100 に変わったのに、y のバインディング側の状態は 10 のままです。これは再現できました。なぜそうなるのかは少し難しいのですが、上のほうのテストではどんなに書いても変更が反映されなかったのに、こちらのやり方にするとちゃんと反映しましたね。

もしこのやり方にしていなかったとすると、y に値を書いて `print` しているだけなので、すでにやっているのと同じことになります。いったん、そのときのコードのコピーを持ってきて、y に代入したところ、つまり y に代入したこの部分を見直します。そして、x の内側から代入できるようにする。いや、y の内側でもどちらでもよさそうですが、試してみます。

`set_value` を用意して、引数の型は `i32` にします。そして、メソッド内で `self.value = value` としてあげれば、内側から書いたのと同じになります。ここで y に代入するときには `set_value(200)` のように呼べばよいはずです。あれ、これはセットできましたっけ。y はバインディングだから大丈夫なのかな。とにかく、型注釈を付けたほうの結果を見ると、このやり方ではやっぱり反映されていないですね。なるほど、原因はまだわかりませんが、別のやり方にするとできました。

もう少しうまく再現できないか試します。x があって、y があって、これをバラバラにしたい、という要求だけなのですが、y を初期化して、y に代入して……これでバラバラになっていますかね。今回の例だと、x と y がスコープの外側にあって、y を初期化するときに x を代入しています。テストでは y の `value` を代入しているのですが、y は反映されていないのに x だけ反映されている、という状況です。同じバインディング、というか、ただバインディングしただけなのに、なぜこうなるのでしょう。

バインディングはどうなっているのか。値を取ってきて、借用はするのだけれど、スナップショットを持っているのでしょうか。そうかもしれません。よくわかりませんが、スナップショットを取って、最後に書き戻す、いわゆるコピーイン／コピーアウトのようなものなのかもしれません。ここで x も見てみればよいのか……見ていますね。x にはもうすでに反映されていました。こちら側では x にも反映されていました。y に書きましたよね。y はバインディングです。ボローイング（借用）などの細かいことはいったん置いておきましょう。念のため実行し直しておきます。上は 10 のままで、x の状態のほうにはちゃんと反映された、という状況です。

この関数を抜けた後も見てみたいですね。テストの後に `print` で x の `value` と y の `value` を出力して、どうなったのか確認します。実行がまたおかしくなりましたが、まずは動きます。出ました。x の `value` が 10 として出力されました。そういうもの、ということなのでしょうか。評価や表示のタイミングの問題かもしれません。

だとすると、内側の状態をここで表示できればよいのかもしれません。そこで、x に対して関数 `print_x` のようなものを用意して、その中で `print_value` を呼ぶようにします。これで内側の状態が表示できるはずです。 丸括弧の中に入れてみますね。`print(x)` は別に出ちゃうんだ。だからここに入れるんじゃなくて、次に出しますよ。`print(x)`。これは `x` が出るでしょ。中に出るかな。10のままか。10のままですね。

こっちが100かと言ったのはどこか…。今増やしたのが `print(x)`、ここか。次の次、次の次…10か。これか。この10は何だ。これは `x` の値。ここに `prefix(2)` を付けて、この中で…これはいいですよね。全部10。10、10はどこから出たんだっけ。10のままだ。

この100は中身そのものが…ここの、何ですかね。これはね、中身そのもので、ここで `value` を `y` にしている。ここ間違ってんじゃん。ここ間違ってる。`x` が `self` の `value` だ。間違えた。100になってないでしょ、きっと。10のままでしたね。あ、そっか、代入に失敗した。あ、なんだ、進展したかと思ったけどダメでしたね。

こうすると、SwiftUI がよしなにやってくれているってことですかね。何かね、あれかもしれない。さっき見つけたアップデート…なんだっけ。アップデートを、Binding か、持ってるやつ。Binding が持っている…アップデート。何だろう。Binding があって、Bindable インスタンスがあって、コレクションがあって、Binding で…あれなんだっけ。さっき遊びで使いましたよね。番号で確かリターンするんだけど。あれ、これ、`updateUIViewController` の中に…`DynamicProperty` だ。`DynamicProperty` あたりで頑張ってくれるのかな。その可能性もあるんですかね。Binding が確か `DynamicProperty` を持っているのかな。これでアップデートするツイートに何か来ているのかな。そのカスタマイズ機能を持ってるのかな。

Extension でこうやって持って、それで `update` メソッドでしょ。`update` メソッドどうして実装するんだろうね。`update` メソッドは既定の実装を `DynamicProperty` の Extension で持っているか。それだけじゃ何でもないんですけどね。なんでだろうね。

とにかく、さっき「更新できた気がした」のは間違いで、全然入れ替えにしようとしてもダメでしたね。これで `View` になるとまた違うのかな。`View` にしてみましょうか。Extension…`body`…あそこか。`View` にして、`body` で使う更新…あそこか。まあいいか。

とりあえず `body`、その `View` で `EmptyView` というふうにして、これで今までのコードが動くけど、こんなこと動かしても何の意味もない気がするんですが、やってみます。…全部10のままですね。変わってないですね。

えーと、Binding で、`y` も `View` にしたらいいのかな。やってみますか。`View` にして、また雑な `body` を用意して、これで `EmptyView` ね。用意してあげて、これでやると…。これでも変わんないかな。変わってないですね。全部10のままですね。

そうか。だからバインドしてあげて、バインドした値を `body` で変えるとどうなるんだろうね。`task`…。`EmptyView` じゃしょうがないか。`EmptyView` じゃしょうがないから、`Text` にしておきますか。念のため一応 `Text` を用意して、`EmptyView` っていろいろ省かれますよね。だからこれでどうだろう。`Text` はまずこれだけ。これで動かしたときにどうなるか。これはどうにもならないと思うんですけど、全部ですね。こうなって、それで `y` の Binding で `body` の中で、えーと、タスクとして…タスクじゃないか、`onAppear`。`onAppear`。`onAppear` もしてないですね。`body` が呼ばれてないのか。`body` が呼ばれたからといって、Binding がどうとか、そういった問題じゃない気がするしね。わかんないな。うん。こんがらがってきた。

これを `View` で表示させてあげたときに、Binding が効果を出すのは、普通に使うだけですよね。Binding をね。読んで書いて、っていうそれだけ。これをボタンとかでね、やって、`body` の中…どうするのね。例えば、`task`、`task`、`onAppear`。`onAppear` は表示しないとね、なんとも言えないですけど、`onAppear` で `value = 770` みたいなね。こんなふうにしてあげて。このままだとどうにもならないですが、これを `View` でやるには、Playground で `View` を表示するときってどうするんでしたっけ。 プレイグラウンドでビューを使う場合は、`PlaygroundSupport` をインポートし、`PlaygroundPage.current.setLiveView(...)` でプレイグラウンドページにライブビューを載せます。なるほど、ではここでそれを発動させてあげます。`x` と `y` があるので、ビュー側にも `y` が欲しいですね。`x` に対して関数 `f` を渡してあげる、という形にします。

まずはライブビューを作らずにやってみます。これでやると全部 `10` になりそうですね。そうですね。

次にライブビューでやってみます。ついでに `Spacer` が表示されるようにもしてみます。この中で `value`…あ、これはダメだったかな。いや、大丈夫か。`y.value` と、`x.value` ももう少し表示しておきますか、ここに。こんなふうにして、その上でプレイグラウンドを準備します。

プレイグラウンドでは `import PlaygroundSupport` を書いて、`PlaygroundPage.current.setLiveView(...)` としてライブビューを載せます。`PlaygroundSupport` で `struct PlaygroundView` を用意して、`PlaygroundPage.current.setLiveView(PlaygroundView(...))`、これで良さそうです。セットするライブビューに `x` をバリューとして、例えば `3` くらい渡します。これでできたかな。

動かしてみると…どうでしょう。今、プレイグラウンドがコンティニュー状態なので、結果はどこに出ているのかな。結果エリアには出ていないですね。コンソールでもない。ライブビューはどこに行った？ 画面が狭くて拡大もできないな。`x` が…サイズがダメなのか。では、`frame` でサイズを `400` くらいにしてみます。これで十分かな。

「777」と表示され、ここがビューで変わったということですよね。とはいえ、別に出力されているものは…先に動かしてみようか。これを先にやって、その後に `try await Task.sleep` で、`seconds` を 10 秒くらい。10 秒じゃダメかな。これでプレイグラウンドを動かして、動かした時に「777」となって、結果…というかコンソールですよね。

ここまでで、ライブビューのインスタンスを取りたいですね。これを作るときに `x` が来るんですけど、その `x` を作るときにビューも作って、それをライブビューに載せます。その後で最後に、ビューの値がどうなっているかを見たい。ビューのプライベートにしただけ…つまり、ビューの `x` のステート変数ですよね。`value` が、ビューの `x` がどうなっているのか。`value` が要りますよね。`print(value)` と、ビューの `y` の `y` がどうなるかというのを本当にどうなのか見たいので、これをそのままにして…これにしましょうか。こうしてあげて、これでどうなるか。今の値が欲しいので、こことここにスペースを入れて。これでライブビューが走って、走ってから `print` が走ると思うんですけど、そのときに `value` はいくつになっているか、というのを見たい。

「3」で表示が終わりました。`3` は確か初期化したときの値ですね。なるほど。描画は確かにライブビューでは「777」になったにもかかわらず、その後アクセスできていると思うんですが、その後のアクセスによると、普通に値が初期に戻っている、というところからすると、なんとなく分かる気がします。`body` の中でステートのインスタンスというものが有効になっていて、`body` の中だけでステートがちゃんと使われ、`body` が終わるとステートが抜けちゃうのかな、そんな気がします。ステートが破棄されて、普通のイニシャライズ状態のものに戻る、みたいな印象です。だから `body` が表示されているという前提の中だけでステートが生きている、というのは当たり前といえば当たり前ですが、そういう感じかもしれないですね。

もう一つ試してみます。今は `print` した後、ライブビューは終わっています。これを踏まえると、例えばさっきの `onAppear` でやりましたが、これを `Task` でやってあげて、`Task` の中で `try await Task.sleep` を 2 秒くらい。これで待ってあげる。`Task` は throwing な関数なので `try await` が付きますが、特に問題はありません。 こうしてあげると、最初に3が見えて、その後777に変わって、所定の出力がされる、という動きになると思います。これで、その後もう一度、対象のビューに対して Live View を上げてみると、また3から始まりますか、という話になります。1回目は3で始まって777になり、出力がされて、その後、Live View が新たに更新されるはずです。

ここでも念のため `print` を入れておきますか。少し待たせるという意味で、Playground のカレントページで `PlaygroundSupport.currentPage.needsIndefiniteExecution = true` にすれば見えるのかなと思いました。期待としては、1回目が3から始まり777になって `print` が出て、もう1回ビューが3から始まる、という流れです。しかし、動かずに終わってしまいました。もうビューが終わったということなのでしょうか。

試しに、ここで新しい `x` の値として5などを作ったら、もう1回ビューが更新されるのかなと思いましたが、どうでしょう。`setLiveView` が1から始まり777になり、10秒ほど待ってからもう1個が動くはずですが、やはり Live View は発火しません。そういう仕様なのかは分かりませんが、ひとまずそういうものだとしておきます。

`setLiveView` 以外に何か、リセットのようなものはあるのでしょうか。`setLiveView` はありますが、この辺は特に Live View 特有のものはなさそうです。Live View はオプショナルで、`public var`、`finishExecution()`、`needsIndefiniteExecution` などですね。あまり触ってこなかったので分かりません。ともかく、2回目は動かなかった、ということで、ここは分からずじまいです。

では、この辺はいったん関係ないので置いておきます。普通のビューの話に戻します。外側から `value` を例えば100にしたときに、3が出るのか100が出るのかが気になります。これは外からは影響を与えられない感じがしますね。`initializer` で3を入れているので、`initializer` 由来の値が使われます。`body` の中、あるいはアップデートのタイミングで `setValue` してみますか。ビューに対して `setValue` で100を入れると、100が割り込んでいくのかな、と思ったのですが、見た目はそのままで777のままです。外からはいじれないようです。

一応、ビューの `y` にも `setValue` を入れておきましょう。これで100の影響がどうなるか見ますが、やはり777のままで、外からはいじれません。つまり、SwiftUI のライフサイクルに完全に依存して動いているので、そこから離脱してしまうと駄目なのだと思います。UIKit のライフサイクルと SwiftUI のライフサイクルを重ねたとき、`body` の中で生存している間にはちゃんとエフェクトがかかりますが、そうでないと反映しません。コンテキストの中に残っている古いバインディングがそのままだと駄目、ということになりそうです。

それを踏まえると、一番簡単な話は、コンテキストにバインディングを持たせてはならない、ということですね。それを助長する可能性のある、`ref` を渡すという行為は、結構重大なことをしていそうです。`currentPageNumber` で、つまりここです。PageViewController がバインディングを持っているにもかかわらず、持っていること自体はよくあることではありますが、理由があります。その中でコンテキストを回していきますが、`Box` はいらないですね。 なので、この`Box`は消してしまい、アップデートも要りません。そもそもボックス自体が不要ですね。この`Box`を消して、何を持たせるんでしたっけ？えっと、`Binding`のカレントページナンバーだけを持たせる、でしたね。これは外に出しておいて、ボックスは不要にします。とにかくそんな方針でいきます。

それから、ボックスを初期化するのではなく、カレントページナンバーを初期化する、でしたよね。カレントページナンバーです。これで、このあたりの初期値に関する`print`も要りません。削除します。`boxCount`も不要です。

`UIHostingController`などでも同様ですが、バインディングを確保してあげればよいのかもしれませんが、毎回そんなこともしていられないですからね。このとき、`content`内で自分自身のカレントページナンバーを使う分には問題ありません。ここは大丈夫です。`Coordinator`は自分で作っているだけですから。

`Coordinator`のこれは関係ないです。`update`系のデバッグももう不要ですね。コントローラを出すとき、つまり`updateUIViewController`のところでは、カレントページを待っていますよね。なので、`updateUIViewController`では自分のカレントページナンバーを使って、見つからないなら…という感じで扱えばよいです。これは良いですね。

`updateUIViewController`では、ここをちゃんと自分のカレントページを渡してあげます。`context`ではなく、自分の状態を使います。これでOKです。その後に残るエラーはデバッグ系だけですね。`print`はもう不要なので削除します。何か残っていたら、カレントページナンバーに代入してあげれば、これで有効なカレントページナンバーになります。もっとも、ここで「有効」と言い切るのは難しい面もあります。

`UIPageViewController`の`didFinish`（正確には`pageViewController(_:didFinishAnimating:previousViewControllers:transitionCompleted:)`）では、どちらが何を持っているかを意識する必要があります。これは`UIPageViewControllerDelegate`側の話ですね。さっきの、`context`にぶら下げていたものは、あれは`UIPageViewControllerDataSource`側でしたっけ。そうそう、合っています。データソースは生き続けている気がしますが、デリゲートではなく、もうこちら、つまり`UIViewControllerRepresentable`のほうに渡ってくる`Context`に依存するのはダメということです。そこがシンプルな判断基準になります。

つまり、`Context`が過剰なのです。`self`を持たせてはいけませんし、`Binding`ごと抱え込むような設計も避けるべきです。必ず、最低限のものだけを持たせ、余計な情報を持たせないようにしたほうがよいです。ビューから操作できるものはビューで扱う、という前提に立つと、`Coordinator`の設計が間違っていた、という結論になります。`Coordinator`の中で`parent`を絶対に持ってはいけません。受け取るだけなら良いのですが、それでも本当に欲しいのは`pages`です。必要なのは`pages`。

そうしてあげると、できること／できないことがはっきりしてきます。まずイニシャライザの中では、`pages`に対しては自分自身が持っている`pages`を完全に渡してあげれば良い。これで良しとします。一方で、できなくなるのは、この辺ですね。`parent`のカレントページナンバーに代入する部分。これはどうするか。あれ、ここは少し困りました。`Context`…ではなく、`Coordinator`でした。長い間言い間違えていましたね。`Coordinator`が`pages`だけを持つなら、`Binding`を持たないといけない場面が出てきます。結局、`Binding`を持たせてはいけない、という話では済まないのかもしれません。だから`self`（`parent`）を渡していたのか、なるほど。つまり、「注意して使え」という話に落ち着く、ということです。

`Binding`で何か良い方法はないかな、と考えると、`Binding`を更新する必要がある以上、寿命が保証された`Binding`を渡さざるを得ません。ここが大元の原因ですよね。`parent`の`UIPageViewController`を使って、`parent`を辿ってページコントローラを取得しようとすると、古い`parent`しか取れず、ダメでした。ここは設計を見直して、`Coordinator`には本当に必要な最小限、たとえば`pages`と必要な`Binding`だけを持たせ、`Context`や`parent`を安易に強参照しない、という方針で整理するのが良いと思います。 この`parentPageController`を`updateUIViewController`…いえ、`makeUIViewController`ですね。`makeUIViewController`と`updateUIViewController`はUIKit側の世界観なので、ここで`parentPageNumber`を渡さずに`parentPageController`を取ろうとすると、大間違いになってしまいます。そういう状況になるので、この問題では`parentPageNumber`を持つ必要があります。

要はバインディングです。ただし方針としては、データソースやデリゲートからいじるもの以外は読ませたくない、存在させたくないという状況ですよね。とりあえず、`parentPageController`のほうで`parentPageNumber`自体を持たせないといけないことが判明した以上、まだ危険性が伴います。どうすればいいのでしょうか。やりたいのは`parentPageNumber`への代入です。

ページコントローラでアニメーションが終わったタイミング、つまり`pageViewController(_:didFinishAnimating:previousViewControllers:transitionCompleted:)`で代入したいのですが、そのときにページコントローラへアクセスする術がない、ないという状況があるかもしれません。`Coordinator`で、例えば…そうですね、`Coordinator`だとここですね。バインディングを持たせないといけないことが判明したので、`fileprivate`で…。 とりあえず、`fileprivate var` か、`@Binding` なのかな、というところから始めます。`currentPageNumber` を `@Binding` で持たせて、`currentPageNumber` を参照する……この辺の表記が間違っていましたね。イニシャライザと `currentPageNumber` の関係も整理します。`fileprivate var` にはできないのか？ と試すと、「`currentPageNumber` が必要ですよ」と言われます。`@Binding` の後だけアクセスコントロールを付けてもダメです。

そこで、ページと一緒に `currentPageNumber` を持たせ、`currentPageNumber` のバインディングを取るようにして、`self.pageNumber`（ページ番号）に代入していきます。まずは渡すところから直して、`pages` の中で先に `currentPageNumber` を取り出し、それを入れてあげる。こうしてあげると、ビルドは通るわけですね。今回は `currentPageController` は使っていませんが、コーディネーターのほうで対応しています。`fileprivate` とかも大丈夫です。

`currentPageNumber`、これはバインディングじゃないですか。このバインディングに対して、外から直接入れてもダメでしたよね。だからといって、このバインディング自体を差し替えたいわけではない。とにかく、例えばアクションで、`func updateBinding` のような謎のメソッドを用意して、`pageNumber`、そして `currentPageNumber`、`@Binding currentPageNumber` を受け取って、押し込んであげる。その上で、バインディングの時に、自分の中の `currentPageNumber` を新しい `currentPageNumber` に置き換える、つまりバインドを差し替えるという、すごい苦肉の策の作業をします。

これで、`context.coordinator.updateBinding(...)` を呼んで、自分自身（例えば `self`）を渡して、`currentPageNumber` を更新します。ひどいなこれ……と思いつつも、こういうことをやっているわけです。ただ、これで自分自身はちゃんと一度差し替えができました。うん、原因はわかった。とにかく、バインディングが古いものを持ち続けてしまうから効かなくなった、ということが分かりました。コーディネーターのバインディングを、死んじゃったタイミングでちゃんと更新してあげれば、View をちゃんと動かすことができる、ということですね。なるほど、と。

これまでの良い解決策、良いトラブル防止策、何か思いついた人はいますかね。どうだろう。外側からアクセスするインターフェースを定義する、という方法が1つあると思うんですけれど、`context` に対してどうするといいのか……いや、ダメか。それもダメかな。外側から来るから、やっぱり。今のところ、これがマシな策ですかね。バインディングを直してあげる。そうすれば辻褄は確実に合うので大丈夫ですよ、というやり方です。

本当は、あれが勝手に発動してくれればいいんですけどね。そういうわけにもいかないのかな。例えば、バインディングが変わるわけですよね。バインディングが変わるということは、`context` でも渡ってこないとダメか。`context` が渡ってこないとダメだから……あ、そっか。そうですね。初めて `context` を知れるのはこのタイミングです。やっぱり `update` のタイミング、ここで初めて知れるので、差し替えるためにはここしかないですね。これですかね。はい、まあいいや。

とりあえずこんな感じで、原因は分かりました。ライフサイクルの話ですね。デリゲートで、ちゃんとコーディネーターに対して直接的に働きかけてきたときには使えるけど、UI のアップデート時には、もうコーディネーターのバインディングが古くなっちゃっている。そういった前提をちゃんと意識しないとダメ、ということです。`self` を持たせるのが問題だと思っていましたが、それだけじゃないですね。バインディングを持たせるのも問題です。生々しいですね。みんなこれよく言っていますね。すごい。

まあいいや。とりあえずこんなハマりどころがありました、ということで OK ですね。はい、じゃあ今日はこれで終わりにしましょう。お疲れさまでした。