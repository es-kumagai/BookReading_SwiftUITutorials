Transcription & Summarize : とりあえず読書会 SwiftUI Tutorials #6

はい、ではとりあえずご紹介します。今日も SwiftUI チュートリアルを読み進めていきましょう。今のところ順調で、いろいろコードを書き換えつつ、Swift 6 対応も一緒に進めています。だんだん本格的になってきて、出来上がっていくのが面白いですね。

今日は、この中の第1章「Handling User Input」についてです。いよいよユーザーの入力に対して反応していく部分を書いていきます。これまで状態（State）をなんとなく使っていましたが、今後は使いどころを意識して選んでいく必要がありそうだ、という趣旨の作業ですね。前回はダウンロードまでやったので、その続きからです。

まず「お気に入りのランドマークをマークする」から進めます。リストを拡張して、気に入ったランドマークをすぐ見られるようにする、という流れです。そのために、次の作業を行います。
- Landmark 構造体にプロパティを1つ追加して、初期状態として「お気に入り」をデータから読み込む。
- ランドマークの行（LandmarkRow）に、お気に入りの印（星）を表示する。

まずは Xcode で、以前のチュートリアルの続きのプロジェクトを開きます。ランドマークを一覧表示するプロジェクトですね。そして、Landmark 構造体に `isFavorite` というプロパティを追加します。リソースの中にあるランドマークデータ（JSON）には、すでに `isFavorite` というキーが含まれているので、この名前で `Bool` 型のプロパティを用意しておけば、その値がそのまま読み込まれます。該当ファイルを探すときは、`Command + Shift + O` で「Open Quickly」を開き、例えば `Landmark` や `landmarkData` といったキーワードで絞り込むと見つけやすいです。候補の中で一致率が高いものを選べばOKです。

Landmark 構造体に `isFavorite` を追加するとき、以前に `imageName` の名前を変えた関係で `CodingKeys` を明示的に定義している場合は、`CodingKeys` にも `isFavorite` を追加するのを忘れないようにします。ここを忘れると「Landmark が `Decodable` に準拠していない」といったビルドエラーになります。`Codable` のカスタム実装（`init(from:)` と `encode(to:)`）で対処する方法もありますが、今回は `CodingKeys` を更新するほうが単純で、漏れがあればエラーで気づけるのでこの方法でいきます。

次に、`LandmarkRow` を開いて、`Spacer()` の後に「お気に入りなら星を表示する」という条件付き表示を追加します。具体的には、`if landmark.isFavorite { Image(systemName: "star.fill") }` のように書きます。これでお気に入りのランドマークには星が表示されます。プレビューで確認すると、例えば Turtle Rock に星が出ていれば成功です。表示されない場合は、プロパティ名のタイプミスなどを疑ってみてください。

ここで、`Image(systemName: "star.fill")` を直接書くのではなく、たとえば `StarImage` という小さなビューを用意して、その中で星を描画するようにしておく方法もあります。こうしておくと、文字列リテラル（`"star.fill"`）を毎回思い出したり、打ち間違えたりする心配が減りますし、見た目の共通化もしやすくなります。さらに、`foregroundStyle(.yellow)` を適用すると、星を黄色にできます。イメージはベクター形式なので、カラーの変更は簡単です。スターアイコンは `landmark.isFavorite` が `true` のときにだけ表示される想定です。

では次のセクション、Filter と List のカスタマイズです。すべてのランドマークを表示するか、「お気に入りのみ」を表示するかを切り替えられるようにします。そのために、`LandmarkList` に少しだけ状態（State）を追加します。State は時間とともに変化する値（あるいは値の集合）で、ビューの挙動・コンテンツ・レイアウトに影響します。これを `@State` 属性でビューに追加します。

`LandmarkList` を開き、`@State` なプロパティ `favoritesOnly` を追加します。初期値は `false` にします。例えば、`@State private var favoritesOnly = false` のような形です。State プロパティは、そのビューとその子ビューに特有の情報を保持するために使います。可視性は必ずしも `private` でなくても動作しますが、合理的に `private` にしておくのがよいでしょう。これでステートの準備ができました。 文字起こしのテキストをご提示ください。いただいた内容を次の方針で読みやすく整えます。

- ですます調に統一し、句読点や文の区切りを自然に整えます。
- 要約はしません。内容は削らず、生かします。
- 誤変換（例：「G言語」→「C言語」、「万全オキス」→「万全を期す」など）は適切に修正します。
- コードはバックティックで装飾します。短いコードはインラインで、必要な場合のみコードブロックを用います。
- 複数人の会話が含まれていても、発話者名は付けず、内容を踏まえた通常の文章に整えます。
- 冒頭が文の途中から始まっていても、その文は無視し、次の文から整えます。

テキストが長い場合は、分割して送っていただいても大丈夫です。どの部分からでも対応します。 ということで次に進みます。まずは `false`、いいですね。次に、ビューの構造を変更していくらしいです。プロパティの追加や編集を行い、キャンバスごとのリフレッシュを使って、ビューの状態を自動で更新していくプロパティを追加していきます。キャンバスがビジブル（表示）でなければ、エディタからキャンバスを表示してください。プレビューを出したいということですね。プレビューの出し方は問題なさそうなので、次に行きましょう。

次は、ランドマークのフィルタードバージョンのプロパティ、つまり `filteredLandmarks` の話です。これは `computed`（計算型プロパティ）として定義します。ここに書いてあるように、`filteredLandmarks` は「お気に入りのみを表示するかどうか」を示す `showFavoritesOnly` と、各ランドマークの `isFavorite` を使ってフィルタリングします。

条件としては、たとえば `!showFavoritesOnly || landmark.isFavorite` のようになります。丸括弧は付けても良いのですが、なくても良さそうです。ただ、この条件は少し読みにくいと感じるかもしれません。自分は複雑な条件式を読むのが得意ではないので、「`!showFavoritesOnly`（お気に入りのみではない＝すべてを表示）」または「`landmark.isFavorite`（そのランドマークがお気に入り）」という意味を毎回頭の中で展開しなければならず、やや煩雑だと感じます。すべてを表示する場合と、お気に入りだけを表示する場合を考慮して、もう少し読みやすく書きたいところです。

`filteredLandmarks` という名前については、どんなフィルターがかかっているかが名前からは分からないという懸念もあります。しかし、ここでは `showFavoritesOnly` に基づくフィルタリングしか行わないとはいえ、将来的に条件が増える可能性を考えると、「いろいろな条件を総合的に適用して得られたランドマーク群」という意味で、`filteredLandmarks` は悪くない命名だと解釈しています。

このようなときには、さきほどのような論理演算をうまく組み合わせて1行で書く方法も普通に有効ですし、もう一つの手として、式を分けてまず `showFavoritesOnly` かどうかを調べ、その結果に応じて処理を分岐させる書き方も個人的にはありだと思います。たとえば、`showFavoritesOnly` が `true` のときは「お気に入りのみ」を、そうでなければ「すべて」を返す、といった形です。ここはクロージャを使って `isFavorite` が `true` のランドマークを抽出する形にするのですが、すみません、具体的なコードはちょっと失念しました。 ランドマークをフィルタリングします。`filtered` な配列を用意して、`landmarks` に対してフィルターをかける形で実装できます。これで良さそうですね。

具体的には、フィルターを適用する際に「お気に入りのみ」の場合は、ランドマークのうち `isFavorite` のものだけに限定します。逆に「お気に入りのみ」ではない場合は、無条件で全てを対象にします。こういう書き方も一つの手です。

それから、配列に対して使うメソッド名は `filter` で良かったですね。少しど忘れしていましたが、`filter` で問題ありません。ということで、これで `filteredLandmarks` ができました。少しコードは長くなりましたが、構造としては分かりやすい気がします。この状態でプレビューで動作を確認してみましょう。

次に、ステップ5として、リスト表示には `filteredLandmarks` を使うようにします。さらに、`showFavoritesOnly` の初期値を false から true に変えて、この動きを見てみましょう。今は false なので全件表示ですが、true にするとお気に入りだけに限定されるはずです。実際に true にすると、プレビューが更新されて、お気に入りのものだけになりましたね。

仮に `@State` などがなかったとしても、今回は手動で代入しているので挙動の確認という意味ではどちらでも大丈夫です。この点は、また後で確かめられるタイミングでやりましょう。 まずは、とにかく `showFavoritesOnly` をもう一度 `false` に戻したうえで、次のステップに進みましょうか。表示をトグルするためのコントロールを追加します。ユーザー操作用のコントロールをリストフィルターの上に追加し、`Favorites only` の値を切り替えられるようにします。

これを行うために、`Binding` を `Toggle` コントロールに設定します。`Binding` はミュータブルな値への参照として動作し、ユーザーがこのトグルをオン・オフに切り替えると、コントロールはバインディングした値を使って状態を更新します。つまり、ユーザー操作に応じて（accordingly）、それに従って更新していくということです。なので、まずはこの `Favorites only` というトグルスイッチを作っていこう、という流れになります。

ネストした `ForEach` グループを作って、`filteredLandmarks` を行（row）として配置していくグループと、`ForEach` を作っていきます。今までは `List` の中で一気にやっていましたが、今回はリストのアイテムの前にトグルを入れたいからですよね。`ForEach` で `filteredLandmarks` を回して、リスト用の行を作っていく、ということをやります。なので、`List` の中でこれまで `filteredLandmarks` を直接使っていたのを、ここで分けて扱えばよさそうです。

この中で `ForEach` のパラメータとして `filteredLandmarks` を渡します。これはすでに `Identifiable` で表現されているので、`id` の明記を忘れずに、このままそれぞれに対して `NavigationLink` を貼っていく、という実装にします。これでプレビューはちゃんと動いているのかな……はい、動いていそうですね。ここまでOKです。

次は、static と dynamic なビューの話です。`List` の static view（今回はトグル）と dynamic view を組み合わせて使うために、親のグループにまとめ、dynamic なグループを結合するのに `ForEach` 型を使います。データは `List` に直接渡すのではなく、`ForEach` に渡す方法を取るらしいです。

その後、`Toggle` ビューを `List` の最初の要素として配置します。それを `Favorites only` にバインディングしていきます。`$` プレフィックスを使うことで、その変数をバインディングとして渡せます。または、その `@State` のプロパティのいずれかにバインディングすることもできます。`$` プレフィックスで「`@State` へのバインディングにアクセスする」と書いてあった（たぶん Bind のことかな？）のですが、ここは少しよく分かりませんでした。「プロパティのいずれか」というのがどのプロパティを指しているのか、ちょっとよく分からなかったです。

とりあえず、今回は `@State` にバインディングさせていくので、`Toggle` をリストの最初に追加して、そのテキストを「Favorites only」にする、という感じですね。 ForEach の前ですね。ここで `Toggle`。`@Binding` だから、`Toggle` は…あれなんだっけ。ちょっと見ますか。`isOn` でしたね。`isOn` として、`$showFavoritesOnly`。で、この `Toggle` のラベルのテキストとしては "Favorites Only" ですね。あんなふうにするとできたりする、と。

これで、静的な行と動的な行が存在している、ということになります。一緒にスクロールしてくるのかな？ そうですよね。今スクロールすると、こうやって "FAVORITES ONLY" が消えちゃうじゃないですか。ここまで読んでいたけど、やっぱり Favorites のほうがいいなと思ったときに戻るのって、なんか面倒じゃないですかね。上の「お気に入りに限定する」ボタンがあったのを忘れちゃうこともありますし。そう考えると、これはリストの外に置いたほうがいいんじゃないのかなと個人的には思うんですけど、どうですかね。ちょっと変なところに行き過ぎては…これだとね。こうすると、ほら、スクロールさせても残るので、すぐ使いたいときに使えるじゃないですか。というのは、ちょっとやりたい気がするんだけど、でも不格好だな、これ。

えーっと、これはどうすればいいんだろう。マージンとか変えちゃえばいいのかな。マージンというか、パディングか。パディングとして、例えば 10 とか…あれ、10 から 100 だとか言わないですよね。うん。パディングの、例えば…パディングの、えーと、`Edge.Set` か。`EdgeInsets` じゃなくて、`Edge.Set` のほうを使って。いや、`EdgeInsets` じゃない。えーっと、`Edge.Set` はどう使うんだ？ これか、`Edge.Set`。で、これで…ちょっとわからないや。えーっと、`bottom`…`bottom` じゃない、`leading`、`leading`。例えば 500 とか。これで合ってる？ 合ってないか。なんか、ちょっと使い方知らないから、わからないや。

えーっと、定義を見ればいいですね。`padding` で、えーっと、`Edge.Set` ですよね。で、`Edge.Set` だから `OptionSet` で、この `OptionSet` は `RawValue` があって、`top`、`leading`…。あー、そういうことか。はいはい、なるほど。で、これで `Edge.Set` を指定した後に、`length` か。あー、なるほど。これが `leading` と、えーっと、また `trailing` かな。`trailing` にして、それぞれをね、20 ぐらいとかにすると。で、ちょっと動きましたよね。まあ、これぐらいでいいですかね。ここだとね。こんな感じにすれば、ずっと…いいのかと言ってやるから。まあ、これでどうでしょうかね。今はこんなの、パディングをやるタイミングじゃないかもしれないですが、まあ、ちょっと私はこれでいってみましょう。

それで、Improves Filtering。アニメーション。`animation` モディファイアを使って、`filteredLandmarks` の値が変わったときにアニメーションを始めるようにしてみようと言っています。ここが、リストに対してですね。リストに対してアニメーションで、デフォルトのアニメーションで、値が `filteredLandmarks`（配列）が変わったとき、ですか。これをちょっとやりますか。今のところ、こうやって切り替えると一瞬で変わる、という状態の中で、リストに対して `animation(.default, value: filteredLandmarks)`。こんな感じで、`filteredLandmarks` が変化するとデフォルトのアニメーションをしてくれる、という意味ですかね。定義としては、`value` が変更をモニターする値でしたね。実際にこんな感じで、特定の値が与えられたときにアニメーションする。

で、これで早速、切り替えると、こう…スライドする感じで動きますね。これ、今表示してくれているやつ。で、ライブプレビューで、それをね、トグルを切り替えて…あー、そういう意味か。そうだ、さっきのね、テスト用にするようにしたんだ。 ここは一旦 `false` に戻しておきましょう。そのうえで、プレビューで実際に動かして、挙動を確認してみましょう。OK ですね。では次に進みます。

今度は Observation、ストレージ周りのオブザベーションの話です。これを使っていきます。準備として、まずは読み進めていきましょう。プロパティを直接参照しているときに、その更新が伝播する仕組みのようです。`@Observable` 属性を付けたモデルデータを作っていくことになるので、まずはそれを用意します。

モデルデータのファイルでは、アプリのバンドルからリソースを読み込む形になりますが、ここでは `@Observable` に加えて `ModelData` を定義します。おそらく、この `ModelData` 型では、どのメソッドをオーバーライドさせないべきかをきちんと考えないと、オブジェクト指向の機構が正しく動かないはずです。そういった点を特に考えないのであれば、`final class` にしておくのが妥当でしょう。ということで、まずは `final class ModelData` にしておきます。

そのうえで、`landmarks` の配列を `ModelData` の中に移動します。場所によっては不都合が出るかもしれませんが、今回はこの構成で進めます。元の Tips があるので、それも確認しておきました。ちなみに、`Command + Option + 角括弧（[ または ]）` を押すことで、行を上下に動かせます。これは確かに便利ですね。今回は動かす必要はありませんが、必要なときに使うとよさそうです。面白いですね。

では、この中でプロパティを定義します。`var landmarks`、つまり `var landmarks: [Landmark]` のようにしておきます。今までは `load` メソッドで読み込んで初期化していましたが、今回は `Bundle.main` からリソースを取得して読み込みます。具体的には、`Bundle.main` の `forResource` で `"landmarkData"` を見つけて、`withExtension: "json"` を指定し、その JSON をデコードして `landmarks` に代入します。これで読み込みは OK で、`ModelData` クラスの準備ができました。これに伴って、不要になるコードもいろいろ出てきそうな雰囲気があります。 まずは先に進んでみます。気になるのは、`landmarks` が `var` になっている点です。これは外からいろいろ書き換えられてしまいます。書き換え可能でよい場合もありますが、今回のコードはイニシャライザがデフォルトイニシャライザだけになっていて、この中で `landmarks` を書き換えさせているということは、基本的に `landmarks` を外から自由にアクセスさせる意図に見えます。とはいえ、そのまま `var` にしておくのはあまりよろしくない気がします。ここは `private(set) var` にして、`landmarks` は外から書き換えさせないようにしておくのが、今のところは良さそうです。

次に、`ModelData` オブジェクトを使っていきます。`ModelData` オブジェクトをビューに連結させるにあたっては、ビューがアプリのデータストアを使うように改良していく必要があります。ということで、まずは Environment を使って `ModelData` を扱う手法を取ります。

`LandmarkList` に対して Environment プロパティを追加します。`@EnvironmentObject`（EnvironmentObject プロパティラッパー）を使うと、現在のビューから `ModelData` を読み込めます。また、`environment` モディファイアでデータオブジェクトを Environment として渡せます。

ここまで読んでいて、自分の中での意識付けがまだ弱いのですが、`EnvironmentObject` という概念がありますよね。これまではあまり意識せずに使っていた気がするので、今回はちゃんと考えておくと良さそうです。とにかく `LandmarkList` に、まず `ModelData` を Environment オブジェクトとして提供する方法からやってみましょう。

プレビューは最初の入口になります。今はランドマークを普通の引数として渡してしまっているので良し悪しがわかりにくいのですが、まずはチュートリアルに沿って、ここで `environment` モディファイアに `ModelData` をパラメータとして渡します。つまり、プレビュー側で `LandmarkList` に対して `.environmentObject(ModelData())` を付ける感じですね。これで OK です。

ちょっと気になるのは、ここでパラメータの書き方をどうするかですが、今回のプロパティは `ModelData` ですし、どちらの書き方でも大差ないと思います。好みの問題ですかね。

このように `LandmarkList` に対して `ModelData` を Environment で渡すようにしたので、これまで個別に渡していたデータは不要になります。`LandmarkList` も引数を取らない形にできます。そのうえで、プレビューで `.environmentObject(ModelData())` を付けます。

もしまだ引数を取ろうとしてエラーになっているなら、`ModelData` と `landmark` を受け取るイニシャライザやプロパティがコードに残っているのが原因です。`landmark` はもう不要なので消します。ランドマークの配列は `ModelData` の `landmarks`（`modelData.landmarks`）を使います。 モデルデータのランドマークを使います。そんな感じで進めましょう。ほかは、ランドマークリストのほうですね。まだエラーが出ています。モデルデータを参照しようとしていますが、引数で渡すやり方だとダメそうです。たまたま書けてしまっただけ、という状態だったのかもしれません。

ここはエンバイロメント（`@EnvironmentObject` と `.environmentObject`）を使ってモデルデータを渡します。これを付与するとエラーが消えて、プレビューも動き始めます。どちらが良いという話ではなく、「必ず動作すること」が重要なので、この方針でいきます。

ほかのコードにもエラーが出ているので直していきます。まずは `ContentView` です。エンバイロメントを与えないと `ContentView` は落ちるので、ひとまずはランドマークリスト側のプレビューだけが動くことを確認してから次に進みます。ちゃんとエンバイロメントを引いていますね。良さそうです。下の色が付いている箇所（エラー箇所）もすでに直っているのでOKです。

次に、モデルデータのランドマーク配列を使って、フィルタリングされたランドマーク（`filteredLandmarks`）を計算するところを進めます。ランドマークリスト側では、`filteredLandmarks` をモデルデータから取るようにしてあります。こちらも問題なさそうです。

ステップ3として、`LandmarkDetail` を更新し、モデルデータオブジェクトで動くようにします。これもエンバイロメントでやっていきます。具体的には、`LandmarkDetail` でモデルデータのランドマーク配列をプレビューに渡す、という形になります。これまではグローバルにランドマーク配列を置いていましたが、今後はモデルデータから取得しないといけない、という話です。今回はそこまで深く考慮しなくても大丈夫そうなので、次に進みます。

`LandmarkRow` についても同様に対応します。次のステップとして、`ContentView` にモデルオブジェクトをエンバイロメントで追加します。これでサブビュー側は大丈夫になります。必要なところ以外ではモディファイアを付けるだけで済みます。逆に、サブビューがモデルオブジェクトを要求しているのに、エンバイロメントで渡していないとプレビューは失敗し、エラーになります。

では `ContentView` を直していきます。ここではエンバイロメントを使うことで、`ContentView` の中で明示的にランドマーク配列を持たなくてよくなります。エンバイロメントを `ContentView` に渡すようにし、そこでモデルデータを参照します。これで `ContentView` の上位でランドマーク配列をわざわざ作らなくても済みます。プレビューの前に一度ビルドをかけて、エラーが出ないか確認します。

`ContentView` はアプリケーション側、つまり `LandmarksApp` から使われます。ここでは個別にランドマーク配列を持たせる必要はありません。`ContentView` に対してモデルデータを明示的に渡す必要もなく、エンバイロメントにモデルデータを注入すれば十分です。これでコンパイルが通るようになったので、プレビューでも確認していきます。問題なく動いていると良いですね。確かにエンバイロメントを使うのは悪くないやり方です。

アプリケーションインスタンスでモデルオブジェクトを作成し、エンバイロメントに渡します。エミュレーターや実機で動作する際の `LandmarksApp` でこれを指定します。狙いはアプリ側でモデルデータを一元管理することです。アプリでは `@StateObject private var modelData = ModelData()` のようにモデルデータを作り、`ContentView` に対して `.environmentObject(modelData)` を付けます。`ContentView` の中では特にモデルデータを引数で渡す必要はありません。プレビューのときは `ContentView().environmentObject(ModelData())` のように渡しておけば大丈夫です。

以上で一通りできました。 ビュー内でモデルオブジェクトを初期化する際には、ビューの中でプロパティを初期化するのと同じ要領、つまり `@State private` のような形で進めていくと良いです。`SwiftUI` の初期化はビューのライフタイムの中で一回だけ行われます。アプリケーション全体でただ一つのインスタンスにしたいものは、`LandmarksApp` の中で唯一のインスタンスとして一度だけ初期化する、という考え方になります。

`LandmarkList` に戻って挙動を確認してみましょう。無事に動きましたね。できました。

この流れで、お気に入りボタンを作っていく話に進みたいのですが、これは次回に回します。その前に、`Environment`（`@EnvironmentObject`）を付けたことで不要になったコードがいくつか出てきているはずなので、調整していきます。

`CircleImage` は `Landmark` の `image` を取っていて、ここは問題ありません。`ContentView` はすでに直してあり、特に状態は持っていません。ランドマークが表示されていることも確認できています。

ランドマーク情報を使っているビューについては、`Landmark` を引数で受け取るのではなく、`Environment` に載せたときにどう変わるかを考える必要がありますが、とりあえず今回はやってみましょう。`Landmark` ではなく `ModelData`（`@EnvironmentObject var modelData: ModelData`）で良いかもしれませんね。`@EnvironmentObject` を使って `modelData` 経由でさまざまなランドマークにアクセスするのはもちろん可能です。ただ、近いところにあるランドマークへアクセスするだけなら、引数で `Landmark` を直接受け取るほうが楽な場合もあります。

「モデルデータにするか」と話していましたが、`ModelData` ではなく、ここでは単純にパラメータで受け取れば良さそうです。`ModelData` の注入は一箇所で行うことになるので、その点は大丈夫ですね。これをバインディング（`Binding`）にするかどうかは、編集を伴うかどうかで決まります。今回は編集していないのでその必要はありません。値が書き換わるかどうかが大事ですが、今はそこまでは考えません。`Detail` は大きい（重い）ですね。

`LandmarkList` はすでに書き換えてあり、`@EnvironmentObject` 方式が採用されています。`LandmarkRow` はランドマーク1件ずつに対してのビューなので、ここでは `Environment` は特に要らなさそうです。更新の扱いについては今後考えていけば大丈夫でしょう。`MapView` は座標を渡すだけなので特に影響はありません。`StarImage` も影響はないですね。`LandmarksApp` は今やった通りで問題ありません。

ということで、今イメージできる範囲では一通りうまくいっているので、このまま次へ進む準備はできた、という感じがします。次はセクション6で、お気に入りボタンをそれぞれのランドマークに付けていく作業を進めることになりそうです。

今日はこれで終わりにします。お疲れさまでした。
