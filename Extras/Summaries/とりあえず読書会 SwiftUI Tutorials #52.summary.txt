Transcription & Summarize : とりあえず読書会 SwiftUI Tutorials #52

はい。では、とりあえず読書会を始めていきましょう。どういった、いわゆるビュー・ツリーのようなUIを見直しておりまして、ここでいったんリファクタリングのチェックみたいなことをします。リファクタリングはコードをきれいに整えることですが、どこをきれいにできるのか、という点は、だいぶできているような気がするので、その辺りを見ていきますね。

この辺りに直すところがないかを見ていきます。見てみると、ここですね。この部分は iOS ですね。なので、プレビューを動かしつつ進めていきましょう。このコードを眺めていきます。あれ、なんかプレビューでビルドエラーが出ていますね。先にビルドエラーを直さないとよろしくなさそうです。なんだろう、でもエラーを書いていましたっけね。まあ、ビルドすればわかるので、ゆっくりやっていきます。エラーはビルドの中のコードを見ればわかるんですけど……。とにかくビルドしてほしいですね。では、OKですね。プレビューはきっと動くでしょう。

その間に、これを見ていきます。ページという型があって、親ページがページ番号をプロパティとして持っています。ページ番号は前回も言いましたが、内容は純粋なIntの値しか持っていないので、Intで作ってもよいわけです。しかし、ここであえてページ番号を型として定義することによって、「ページ番号なのかインデックス番号なのか」を混同しないように注意しています。特にSwiftのプログラミングでは、一般的にインデックスは0から始まります。実際、`UIPageControl`がそうですよね。簡単にやろうと思えばページ番号も0から始めればいいのですが、人間は1ページから始めるものです。なので今回は、1ページから始まるページ番号を使いたかったので、そういう設計にしました。これを作った最初の段階で、インデックスとページ番号を混同しがちになったので、こんな感じで作ったのだと思います。実は大したことではないんですけどね。

ということで、リファクタリングがすでに終わっている状態で、このページ番号というのが存在しています。イニシャライザは、何らかのシーケンスとして渡されたページを`pages`に配列で保存する、という形にしています。これは悪くないですね。配列にして順番を保持したい、というのは確実にあります。1個目の要素が1ページ、2個目の要素が2ページ目、という感じでやっているので、配列が適切ですよね。これでうまくいくので良いのですが、他に、ページの配列を必ず1ページ以上持つようにする、という手もあるかもしれません。

このページはどうやって使っているのでしょう。探すのが大変になってしまいました。ええと、これで、このページのイニシャライザを呼んでいるところはないのか。こちらはあるけど、とても良くて……見つからないですね。ページの初期化はどうしているのかな。メインコンテンツは`LandmarkApp`の中の、そのコンテンツですが、`ModelData`ですかね。`ModelData`はページを別に持っていないですね。そうすると`ContentView`ですかね。`ContentView`はいろいろ持ってはいるものの、その中にはないか。その中で`CategoryHome`、`LandmarkList`……ページは`CategoryHome`ですかね。そしてその中で、ページを作っている`PageView`で、`Page`が使われていますね。

`PageView`は、SwiftUIベースでpublicなジェネリックの`struct`として定義しており、そのようなコンテナを引数として受け取ります。 FeatureCardですね。私はこれを作っていて、このFeatureCardは`FeatureCard`の配列になっています。`featuredLandmarks`で作った配列を`PageView`に渡し、その中で`PageViewController`に`Binding`を渡す、という構成です。バインディングで`landmarks`を扱う形ですね。こうなっているので、「必ずページは1個以上ある」ことを型で保証しようと考えたのですが、そこまで厳密に保証しようとすると`landmarks`まで非空を貫いてしまいます。`landmarks`が配列である以上、「必ず1個はある」という制約がかえって邪魔になる可能性があります。

そうなると、プレコンディションで縛るのが良いのか、という話になります。ただ、ひとつ気づいた点として、ページコントローラ、つまり`PageViewController`が`PageView`に`FeatureCard`を渡しているのですが、これがゼロだったときは落ちますよね。いわゆるプレコンディションフェイラー（`precondition`違反）です。つまり、本来はゼロ個を渡してはいけないのに、今のコードではチェックしていません。これは良くないので、チェックを入れるべきです。

`FeatureCard`側で「ゼロ個以上」を保証するというのも悪くはないのですが、結局ここが「1個以上」になっていたら同じように落ちます。これを仮にオプショナルにして、1個以上得られなかったら`nil`で返す、というのも変です。`nil`を返せばいいだけの話ではありますが、`FeatureCard`には触らない方針にするなら、触るべき場所は`PageView`の呼び出し側になります。つまり、`PageView`に渡す`featureCards`が空なら、そもそも`PageView`を表示しない、というのが良さそうです。

では、`featureCards`がまったく無かったときにどうするか。バックグラウンドの該当箇所を見ていくと、`FeatureCard`のリストがあって……最終的に`PageView`でスワイプできるやつを出しているわけです。ここがゼロだと「どうするの？」という話になってしまいます。`PageView`は1個以上を前提にしていますから、「タブもロックもない状態」になったときにどう扱うか、という話になります。`PageView`側でいろいろ頑張るよりは、UI自体を表示させないのが良さそうです。

具体的には、例えば`let featureCards = ...`と作っておいて、`featureCards.isEmpty`をチェックします。`featureCards.isEmpty`ではない場合に限って`PageView`を表示する、つまり`if !featureCards.isEmpty { PageView(...) }`という形にします。こうしておけば、空のときは`PageView`を表示しないので落ちません。`UIPageViewController`や`UIPageControl`周りで落ちる可能性を潰せます。

仮にこれが空だったとすると、この条件分岐で`PageView`は表示されなくなります。これで問題ありません。加えて、`featureCards`というラベル自体がUI上に必要かどうかも考えられます。どこで使っているかを見ると、リストで、`Landmark`がカテゴリになっているリストのタイトル（おそらく`navigationTitle`）に`FeatureCards`と付けている感じでしょうか。`navigationTitle`はそのビューに書いてあるので、カードがあろうとなかろうとタイトルが「FeatureCards」なのは少し不自然かもしれません。必要であれば、`featureCards`が無いときは別のタイトルに変える、というのも考えられます。 いまは `hasFeatureCards` と書いていましたが、このあたりはややこしいので、変数名はシンプルに `hasFeatureCards` にしておきます。これでルールを明確にし、`hasFeatureCards` を読めば「こういう挙動をする」という判断がしやすくなります。中の処理をどうするかを細かく考えなくても、「`FeatureCards` を持っているかどうか」を基準にすれば、ここは普通に `if hasFeatureCards { ... }` で良いですよね。

まとめると、単純に `hasFeatureCards` がある（true）ならページBを表示する、という形にします。`FeatureCards` を使って横方向のスクロール表示をするのと合わせて、タイトルも楽に切り替えられると思ったので、いまはその形で作ってみました。`hasFeatureCards` なら `FeatureCards` を表示し、そうでなければ、たとえば普通に `Landmarks` にする、という分岐です。仮に `FeatureCards` が何もないとき（`hasFeatureCards` が false のとき）は、タイトルが `Landmarks` に変わり、一覧のようにグループ分けして表示されます。違和感も少なく、これで良さそうです。

このようにしておくと、不必要なエラーが起きにくくなり、リファクタリングができたと言えます。プリコンディションを張ったからには、その前提条件を満たさない実行パスを作ってはいけない、というのが理想論のはずなので、その理想に基づいて今は調整した、という感じですね。最初から必ずやる必要はありませんが、個人的にはこういう前提の整理は入れがちです。

構成としては、`body` があって、`ZStack` に `PageViewController` と `PageControl` を重ね、そこでおしまい、という単純な作りです。背景があり、その上に重ねる部分がある、という感じなので、さらに細かく分けなくても大丈夫そうです。分けても良いのですが、今回はこのくらいで十分でしょう。

`pageCount` を 18 倍したものを `PageControl` に渡しています。これは単純な計算で、ページ数に応じた幅を出しているだけですね。少し分かりにくいので、何をしているかが明らかなように、たとえば `pageControlWidth` のようなプロパティ名にしておくと良いでしょう。`pageControlWidth` は `Double` にしておき、表示側の幅指定は `CGFloat` に渡します。`CGFloat` と `Double` は暗黙に相互変換できるという、Swift における珍しい型変換の特例があるので、そのまま渡して問題ありません。ここは幅指定の箇所で `CGFloat` が要求されますが、`Double` からでも普通に渡せます。OK ですね。 別に寄せなくていいんですけど、これは個人の好みですね。一般に Swift では浮動小数点を `Float` と `Double` で扱うので、`Double` に寄せている、というわけです。こうすることで、「PageControl の幅は PageControl の幅ですよ」という感じで、意図が明確になります。ではそれは何なのかというと、最初に `pages.count` が1以上であることが分かるので OK、という判断ですね。この辺は少しごちゃごちゃしていますが、これで大丈夫な気がします。

ではプレビュー。プレビューは普通に大丈夫ですね。ここは `FeatureCard` を作っています。`FeatureCard`、`Landmark`、`ModelData`、`Binding<Landmark>` といった構成でした。テストのために、わざわざ `ModelData` に共通化する必要はないですね。見覚えはありますし、`ModelData` から作れるので一気に作ってもいいのですが、`ModelData` の中で `FeatureCard` を扱うのは少し長い形になるので、やめておきます。これでいいと思います。

では、`PageView` ができたので、次に `PageViewController` のリファクタリングにいきましょう。`PageViewController` は `UIViewControllerRepresentable` に準拠していて、`pages` を `let` で持ち、`Binding` で現在ページを受け取っています。言語仕様的には `private(set)` が欲しそうなので、本当にそうかは分からない人向けに TODO を付けておく、という形にしています。

`pageNumber` があって、イニシャライザでは `pages` を受け取ります。ここでは配列で受けますが、汎用化するなら `init<P: Sequence>(pages: P) where P.Element == Page` のように `Sequence` でも受けられるようにします。`currentPageNumber` は `Binding` として受けます。そのうえで、`self.init(pages: Array(pages), currentPageNumber: currentPageNumber)` のように配列版に委譲する形ですね。先ほどは `PageControl` と `PageView` のインターフェースが不揃いだったため、`Binding<Int>` の `currentPageNumber` を適切に渡せていませんでしたが、ここを修正しました。さらに、`Sequence` を渡し忘れていたので、`Sequence` も渡せるようにした、ということです。

次に `precondition` があります。`PageViewController` にページを渡しますが、このときもページ数は必ず1個以上であるべきです。これはイニシャライザ内で使った `precondition` によって約束されているので、ページ数は絶対に1個以上になります。つまり、`PageViewController` は必ず1個以上のページを伴って呼ばれるため、この `precondition` がエラーになることはありません。これは OK です。`pages` を持ち、`currentPageNumber` に `Binding` を入れてあって、問題ありません。

`makeCoordinator()` ではコーディネーターを作り、オーナーとして `self` を渡します。ここでも `precondition` を置いて、`pageNumberRange` が `currentPageNumber` を含んでいなければ「想定しているページがない」ということになります。これは最初に渡した `currentPageNumber` の整合性を確認するものです。ここで落ちて気づかせるパターンですね。基本的には、ここで必ず存在するページを渡す設計になっています。今までちゃんとそうなっていたと思います。確かデフォルトで `1` になっていて、この「1ページ」は、ページ数が1以上である以上は必ず存在しますよね。 なので、「大丈夫」という発想ですね。ページを切り替えたときには、存在するページの中から切り替えていくので、それも大丈夫でしょうということです。とはいえ、`makeCoordinator` は最初の1回だけなので、なおさら先ほど見たやり方で大丈夫ですね。

とにかく、作ったときにページが変なところを指しているとよろしくないので、開発段階でいきなり見つかるように `precondition` で落としています。最初のページも一気に `precondition` でよいでしょう。コーディネーターを作るついでに、ダメなら落とす、という方針です。ここはOKですね。

ここを厳格に落とすか、もう少し寛容にするか、どっちがよいでしょうね。こういう場合は微妙かなと感じますが、まあ好みの問題です。

次に、`makeUIViewController` でこのテキストを取り、ここでは `UIViewController` を生成して、`dataSource` と `delegate` をコーディネーターにしています。ここは問題ありません。

それから、`updateUIViewController` は更新のたびに毎回呼ばれるやつですね。このときにコーディネーターのオーナーをセットし、バインディングを最新の状態に更新します。カレントページコントローラ、つまり現在のページに対応するコントローラが見つかるかどうかを調べ、見つからなければエラーで落とします。普通はあり得ません。ページ範囲内でスワイプしている中で、これ用のコントローラがないというのはあり得ないので、ここは完全にロジックエラー、つまりプログラマーのミスです。見つかったら、`UIPageViewController` にそのコントローラをセットして終わりです。

ガードの順番は、どちらかというと一番最初にバインディングを更新するのが安全ですね。これでいいと思います。

`UIPageViewController` を extension して、ページコントローラはこの `typealias` でよいですね。ところで、ページコントローラはどこで使っていましたっけ？ ここか。ここでページコントローラ……。これは `private` でいいのかなと思ったのですが、`private` だとダメですね。こちらが `private` なので、公開範囲を調整してあげる必要があります。

ページ番号は他でも使うので、`private` というより `fileprivate` だと思ったのですが、すでに `fileprivate` でした。ここは大丈夫ですね。ここが `fileprivate` なので、エラーは出なくなりました。

アクセスコントロールは、この程度なら外から触られても問題ないかもしれませんが、外で使わないのであれば最初から見えなくしておくほうが賢いでしょう。ということで、`fileprivate` にしてみました。

あとはコーディネーターは、`NSObject`, `UIPageViewControllerDataSource`, `UIPageViewControllerDelegate` に適合した `final class` で、`@MainActor` で保護しています。オーナーは `fileprivate var`、コントローラも `fileprivate`、イニシャライザも `fileprivate` にしておきます。いいですね。これでオーナーを入れて、ページコントローラにはページ番号だけセットしてあげて、OK です。 この辺も大丈夫ですね。では、ページコントローラーのデリゲートですが、どっちだったかというと、ViewController のコアで話していたところですね。ここでは `pageNumber(for:)`、ページコントローラーに対するページ番号を返す関数を使っています。このページコントローラーが何ページを管理しているかを `pageNumber(for:)`（自作の関数）で調べ、ページが取れなかった場合は、その値は無効なので、対応するページコントローラーは返せません。ということで、`nil` を返しています。

ページ番号が得られた場合、それがスタートページ番号だったなら、後ろへスクロールするために `lastPageNumber` を持ったページコントローラーを返します。それ以外は `previousPageNumber` ですね。previous を越えちゃうとどうなるのか、普通に越えていくのか、という話ですが、アニメーションが終わったとき（`didFinishAnimating`）、`transitionCompleted` が `true` なら終了です。そうではなかった場合には、ページビューコントローラーの `viewControllers?.first` を参照します。

この `viewControllers` は配列をオプショナルで返すので、空配列と `nil` の違いが分かりづらくて困りますよね。こういう API を自分で作るときには、配列そのものをオプショナルにはしないほうが良いと思います。今回は仕様上そうなっているので、取れなかったり最初の要素がなかったり、つまり `nil` だったり空配列だったりしたときは `return` する、という扱いにしています。

一方、現在表示中のビューコントローラーが取れた場合は、それが「アニメーションが終わって自分が表示されている状態」だと判断できます。そこで、それを `viewControllers?.first` として取り出し、そのビジブルなビューコントローラーからページ番号を取得します。ここでページ番号が取れないのは完全にプログラマーのミスなので、`fatalError()` にしています。そうでなければ `currentPageNumber` を更新します。これは `pageViewController(_:didFinishAnimating:previousViewControllers:transitionCompleted:)` の中で行っていて、アニメーションが終わったときに現在のページを更新する、という流れです。これによって描画の切り替えが正しく行われるので重要です。OK ですね。

次に、Coordinator のプライベート extension で、`startPageNumber` は `pageControllers` の `startIndex`、`fromIndex` ですね。ここで注意ですが、`pageControllers` の `startIndex` は配列なら 0 です。つまり 0 から始まるインデックスです。ページ番号が 1 始まりの設計だった場合、`startIndex` をそのまま渡すと 2 ページ目になってしまいます。これは間違いです。コードは合っているのですが、ドキュメントとしての説明が少し紛らわしかったですね。`fromIndex` は 0、`controllers` の `endIndex` は `count`。おそらくこんな感じで良いでしょう。

こうすると、ページコントローラーの配列は必ずインデックス 0 から始まらないといけない、という制約が出てきます。まあ、これは配列であれば自然な制約なので良いでしょう。逆にインデックスでアクセスするときには注意が必要ですね。ともあれ、`startPageNumber` と `endPageNumber` はこれで良さそうです。

`lastPageNumber` は `pageNumber` とほぼ同じですが、`endPageNumber` と混同しないようにするのがプログラミングではよくある話です。`last` は「一番最後の値」を指し、`end` は「その次を指すマーカー」です。ここを混同すると他の人に誤解を与えるので、時々見かける「最後の要素を end と表現する」のは避けたいところです。スタートに対する end は「終端（次）」であり、そこに到達したらループを抜ける、というのが今どきの一般的な考え方です。ここはちゃんと区別できていますね。エンドの 1 個前がラスト。厳密には「ラストの次がエンド」と言ったほうが筋が良い気もしますが、今回の `Int` 型インデックスでは成り立っているので、これで問題ありません。

`pageNumberRange` は `start` から `end` までで、`end` は含まない、というのが大事な点です。これで OK です。

`indexFromPageNumber` も、ここが気になって見ましたが、ちゃんとできています。`pageNumber(fromIndex:)` と対応していて、`startIndex` からのオフセットで計算しています。これで整合性が取れています。 さっきの件だけ不安になってきました。ここですね、`fromIndex`。`pageNumberFromIndex` はここか。`distance` を使っていますね。ということは、さっきの理解は合っていました。`pageNumberFromIndex` で、`startIndex` から始まるインデックスだった場合には、ちゃんとこれが 0 になってくれるので、逆にさっき書き直したのは間違いでした。リファクタリングでバグを生む、というやつですね。

`pageControllers` の……どっちが違う？ いや、合っていますね。これの `firstIndex`、`startIndex`。そうですね。これで `endPageNumber` が `endIndex` ですね。これを見てみると、この `pageNumberFromIndex` のところで、`startIndex` が渡ってくるので、`pageControllers` の `distance(from: startIndex, to: startIndex)` は 0 になります。ページ番号は 1 ページから始まり、そこにプラス 0 という形になるので OK です。

一方で、`endIndex` のときには、`distance(from: startIndex, to: endIndex)` がカウント（要素数）になって、`startIndex` に足されることで、最終ページ番号を示します。これで良いです。

次に、`pageNumber(for pageController)`。これはページ番号を返しますが、`pageController` は……そう、キャストの話です。`pageController` は `UIViewController`。これはコード上の型が、引数は `UIViewController` を取っていたんですよね、確か。ここでは、このプログラムの中においては、ページコントローラーを `UIViewController` として扱っています。UIKit の文化の中ではそういう扱いがちなので、ページコントローラーは普通はページコントローラーなんだけど、受け取りは `UIViewController`、という前提がこのフレームワークの上では成り立つ気がします。

それを活用して、ビューコントローラーは `UIViewController` にしてラップする、という形を取っています。ただし、問答無用でページコントローラーにキャストしてしまうと、戻ったときにいきなり落ちるのは嫌なので、今回は「ページが取れなかった」という意味で `nil` を返す、という手法を取っています。型が合っていた場合には、`pageNumber(for:)` でちゃんとページコントローラーを取得するほうを、コンパイラにやらせる、という発想ですね。人間がやるのは相当大変なので、そこはコンパイラに任せるために `pageNumber(for:)` を作った、ということです。

次、`pageController(for pageNumber)`。ページ番号からページコントローラーを取るやつも似た作りです。`indexFromPageNumber` でコントローラーのインデックスを取り、そのインデックスが `pageControllers` の中に入っているかを調べます。なければ、インデックスが指す場所が無効なので「ページコントローラーは得られませんでした」ということになります。取れた場合には、`pageControllers` からそのインデックスを指定して返すだけ。大丈夫ですね。流れもいいです。

それから、`currentPageController` はページコントローラーを返しますが、`currentPageNumber` をそこから探して取り出します。`currentPageNumber` がない場合はない、つまりオプショナルになります。そうしたときにどう影響するのかというと……ここですね。「制御するコントローラーが見つかりません」。普通はある、という前提で、`currentPageController` を作っているのは誰か。そこが問題ですね。 一つ以上存在する必要があると言っているのは、ここですね。ページコントローラーについてです。ページコントロール（`PageViewController`）は誰が持っているのかというと、オーナーが`currentPageNumber`を持っていて、ページビューコントローラーはこれを参照します。ページビューコントローラーは、この…そう、ページビューコントローラーが持っています。

そうすると、さっきのエラーについても、今やった取り付けのような検索から辿っていけば出てきます。これが予期しないページコントローラーを指しているかというと、コーディネーター（`Coordinator`）のレベルでも同じところですね。コーディネーターの`pageNumber(for:)`から、ここをちょっと拝借して、必要なところだけ選んで使えばよいでしょう。

そのうえで、`pageNumber(for:)`や`visibleController`（あ、`visibleViewController`のことですね）についても確認します。ここは良いですね、`visibleViewController`。あるいはどこだったか…そうそう、ここです。`currentPageView`や`currentPageController`。ここが該当箇所で、ここだけが影響しています。

ページビューコントローラーは「ページは必ず1ページ以上存在する」という前提を活かしているので、この中でカレントのページコントローラーが見つからない、ということは、ページビューコントローラーが正しくコントロールしている限りありえません。なので、ここはもうダイレクトで大丈夫です。ダイレクトで良いのですが、`currentViewController`のセットアップをしたところは、例えば`guard let controller = pageController(for: owner.currentPageNumber) else { /* 見つからない場合の処理 */ }`のようにして、見つからなければ「見つかりません」と出すついでに、`currentPageNumber(for:)`を共通化します。これで、該当箇所同士が取り違えないようにできます。この規模感なら、オーナーの`currentPageNumber`だけでも良いのですが、取り違えは避けたいので、こうしておくのが安全です。ページが取れた場合には、そのコントローラーを返す、という形にします。これで大丈夫ですね。良い感じがします。

こうしておけば、絶対に取れる前提なので、`currentPageController`を呼び出す側では何も特別な対処をしなくて良い、という整理になります。ここもリファクタリングしたのでOKです。

ここまで行ったので、プロファイルエディターの方に置いておきます。プロファイルエディター（iOS版）ですね。ここは直でViewがいるかな。動かしつつ、リファクタできそうなところを見ていきます。

また出てきましたが、バインディングは利用上はこれでやっていますが、言語仕様上は`private(set)`を付けた方が良いのではないか、という点です。Setterは自分の中に閉じておくものですね。これでOKです。なくてもいいのですが、付けておくと安心です。

その後、この辺りの見通しが少し悪いですね。パッと見たときに`List`があって、その中で`Section`があって、`Text`があって…と並んでしまうと、何を作っているのか分かりにくくなります。なので分離します。`private extension`で`ProfileEditor`がありますね。ここに切り出して作っていけば良さそうです。

その前に、これを見ておきます。`goalDateRange`。これですね。`goalDateRange`は`Calendar.current`で、`date(byAdding:)`を使ってマイナス1年、つまり1年前から1年後までを`goalDateRange`として返していますね。`goalDateRange`って何だろう…あ、これか。多少冗長ではありますが、これはこれでOKです。

`goalDateRange`のゲッター…ん？あ、こっちですね。`DatePicker`で`profile.goalDate`を使っていて、`in: goalDateRange`で範囲を指定して表示しています。これですね。`goalDateRange`を使って表示、という流れです。 じゃあ、そうしたら、デートレンジはこれで良いのかな。カレンダーの計算は、`Calendar.date(byAdding: .year, value: -1, to: ...)` のようにして、前年や翌年を求めれば十分ですね。`previousYear`、`nextYear` みたいな呼び方ができると分かりやすいとは思いますが、そこまではしなくても良さそうです。

やるとしたら、ここで計算型プロパティを使って、最小日付と最大日付を用意します。とはいえ、別に複雑な計算は必要ありません。`minDate` は1年前、`maxDate` は1年後としておけば、その範囲で制限できます。`calendar` は `Calendar` を使う形で良いですね。これで十分だと思います。

あとは、この辺です。`Text("Username")` と `TextField` で構成される行、つまり「ユーザーネームの行」を部品化します。たとえば `userNameRow` のようなビューを作って、それをこのあたり、レンジの定義の下あたりに置くのが良さそうです。`private` も使えていますし、プロパティとしてまとめましょう。

その前に、`@ViewBuilder` を付けて、`var userNameRow: some View` を定義します。さっきコピーしたレイアウトをそのまま貼り付ければOKです。

同じ要領で、`@ViewBuilder` で `notificationsRow` や `enableNotificationsRow` も `some View` を返す形で作ります。ちょっと具体的すぎるかなとも思いましたが、まあ良いでしょう。さらに、`seasonalRow` も `@ViewBuilder` で `some View` を返すように用意していきます。こうして行単位で部品化しておくと見通しが良くなります。 まずは、これを組み合わせて作ります。`ViewBuilder` のパワー、そして `some View` です。たとえば、`UserNameRow`、次にこれは通知ですよね、`EnableNotificationsView`。`Enable` を作りましょう、というのが、ひとまずここです。`EnableNotificationsView`、`EnableNotificationsRow` を用意して、`EnableNotificationsView` の Row はこんなふうに定義してあげます。同様にここは `SeasonalPhotosRow`。`SeasonalPhotosRow` はこれですよ、というふうに定義してここに入れてあげます。同様に、これは `GoalDateRow` ですね。押さえておいて、`GoalDateRow` はこれですよ、というふうにすれば OK です。

これでできました。`body` を見れば、`List` があって、リストのアイテムが `UserNameRow`、`EnableNotificationsRow`、`SeasonalPhotosRow`、`GoalDateRow` の順で並んでいることが分かります。つまり、ここを見れば、「たとえば `EnableNotificationsRow` って何だろう？」と思ったときに、`prefersNotifications` をバインディングして `Toggle` で描画している Row ですよ、ということがすぐ分かります。分からないところだけを見ていけばよいわけですね。

さらに、「`GoalDateRow` って何だろう？」となったときには、ここから飛んでもいいですが、とにかく `GoalDateRow` の定義を見れば、最後の Row がどんな作りになっているのかだけに注目できて楽ですよね。という感じで OK です。

では、やったコードに無駄がないか見ます。`HStack` で `Text`、`Spacer` と `TextField`。この辺は大丈夫ですね。`EnableNotificationsRow` も `Toggle` で、バインドしてテキスト表示できています。`SeasonalPhotosRow` はバインディングして、`ForEach` で `Season.allCases`。`Season` は `CaseIterable` なので `allCases` が使えますよね。`Season`、シンボルはないですね。なので、`allCases` によって「ここが `allCases` から選べるよ」という話です。それで、`Text` でシンボルを出して OK です。`GoalDateRow` は `DatePicker` を出してバインディングして、このレンジ内で選択させます。`displayedComponents` は `.date` にする、いいですね。さっと読めて分かりやすいですよね。「`DatePicker` は何なの？」というときには、「`GoalDateRow` ですよ」と書いてあるので分かりやすいです。

ではこれで、`ProfileEditor` はリファクタリング、もう大丈夫でしょう。ということで、次に `ProfileHost` を見ていきましょう。`ProfileHost` は、えーと、エラーが何個か出ているので、ビルドを掛け直しましたが、まあ、掛け直しつつ見ていきますかね。`Environment` で `modelData`、うん、エラーは大丈夫ですよね。`EditMode` で、今回はこれで終わりにしますよね。`EditMode` はちょっと面倒でしたけど、まあまあでも、ちょっとやりそうになっていたので OK です。

それと、`@State` は `private` で保持しなさいってチュートリアルで言っていたので、これはいいですよね。`editingProfile` は `Binding` で返して、`editingProfile`……これ、もしかして `Profile` も `private` でいけるんじゃない？あ、無理かな。大丈夫ですよね、きっと。だとですね、うん。`presentProfile` これも `private` で良さそうですよね。ということは、つまりエクステンションですね。外に出しておいた方がいろいろと観察しやすくなるんじゃないかなと個人的には思うので、`private extension` でプロファイル保存、こうでしたよね。こうしてあげて、この中で、さっき `private` にした `editingProfile`、あとどれだけじゃないんですよね、`presentProfile` も多分そうで、`editing` も多分そうで、`body` は違いますね。あれ、ここまでかな？ まずはこうしてあげて、余計なものを見せない状態にして、ボディに専念する形にします。これでOKですね。移動していったものを先に見ます。編集中のプロファイルと、確定済み（コミット済み）のプロファイルのどちらを目指すかを決めます。もし確定済みがあるならそれを、そうでなければ現行のプロファイルという感じでOKです。セットする場合には、確定済みのプロファイルを置き換えていきます。いいですね。コードの書き方も悪くないのですが、言語仕様の都合でこういう書き方になりますね。`get` と `set` を並べた方が美しいかなと思うので、こうなったときには `get` と `set` を並べて書くのが良い気がします。

この規模感であれば、`newProfile` などと明示しなくても、「現在のプロファイルは必須です」と書いてあげた方がパッと見て分かりやすいです。なんかまた色が出ていますが、これを見ると大丈夫ですね。プライベートがよくないのかと思いましたが、特に問題なさそうです。これで `presentProfile` は `get` と `set`、普通の `fn` とプロパティの `get` と `set` という扱いで良いでしょう。モデルデータのプロファイルに `presentProfile` は直接影響を及ぼしていく、という感じです。つまりこの `presentProfile` は編集中ではなく、コミットした最終的なプロファイルで、これはモデルデータに保管するということですね。

それから設定は `get` と `set`、これはいいですね。セットも nonmutating ですかね。`EditMode` は `@Environment` でしょう。ここはそういうUIです。

あとは Body。ここも長いですね。少し分けたい気がします。`HStack` の `isEditing`、`Cancel`、それから `Spacer` と `EditButton`、ボタンですね。ここを空白を消しつつ、Buttons みたいなエリアにしておきます。`Buttons` というエリア名にしましょう。これを extension のところに移します。`private extension` にまとめるなら、個々に `private` は要らないですね。あ、でも `EditingProfile` を外で使っているのに `private` でいいんだっけ……まあ、ひとまずこれでいいでしょう。これを貼ってあげて、OKです。

それと、作るべきは Batches。`CompletedBatches` と `RecentBatches` のエリアです。`var` の前に `@ViewBuilder` を付けて、`var completedBatchesArea: some View`、さらに `@ViewBuilder` で `var recentBatchesArea: some View`。こんな感じでいきます。これで全部ですね、おそらく。

こうしたあとで、`isEditing` だったら `ProfileEditor`。`false` だったら別の SomeView エリア。さらに `onAppear` のときに `pendingProfile` が新たに `var` である場合は、それを新しいプロファイルとして `presentProfile` に代入します。`pending` は反映したので無くなります。ここは悪くないですね。つまり、ボディは Buttons エリアとコンテンツエリアが垂直方向に並ぶ、ということが表現できています。OKです。これで大丈夫な気がします。

では次。3. Profile Summary。これだけ見て今日は終わりにします。`ProfileSummary` は `View` で、なるほど、編集用ではないプロファイル表示部分ですね。モデル→ビューで、プロフィールは読み取り専用で、よくできていますね。ここももうすでに作ってあります。`ScrollView` は `ProfileView` と `CompletedBatchesView` と `RecentBatchesView`。さっきやろうとしていたリファクタリングと同じ感じです。

ダメではないのですが、`some View` と書いているので `Group` で括っています。ここは `ViewBuilder` を使えば `Group` をわざわざ作らなくて済むので、インデントが1つ節約できます。UIでは見た目（コードの見た目も含む）が重要なので、`Group` を作るより `ViewBuilder` を使った方が賢い感じがしますね。ここも同様です。`VStack` をそのまま直で書いてもいいのですが、書き換えが面倒なので、`some View`（不透明な型）で `VStack` を返す形にしておくのが良いでしょう。

リファクタリングは一通り終わったので、次回は `ViewBuilder` などを引き続き扱いつつ、アニメーションなど、この下のあたりを見ていってリファクタリングを進めていく、そんな感じにしましょう。はい、ではこれで終わりにします。お疲れさまでした。
