Transcription & Summarize : とりあえず読書会 SwiftUI Tutorials #15

はい、では今日も「とりあえず読書会」を始めていきましょう。チュートリアルを見ながら、いろいろとコードを書き換えつつ進めています。チュートリアル通りに書くだけだとあまり考えずに進んでしまって身につきにくいところがあるので、少し大げさに言うとリファクタリングしながら進めています。その分、コードの見通しや理解度が随分変わってくる印象があります。進みは遅くなりますが、速度より理解度アップの方が大事だろうということで、この調子でやっていきましょう。

今日は「Animating Views & Transitions」の中の「Composing Complex Interfaces」を見ていきます。チャプター4、いよいよカテゴリビューを完成させようというところですね。ここから見ていきます。

まずは、カテゴリホームページにフィーチャー画像を加える、つまり `CategoryHome` に手を入れていくところです。`CategoryHome` の `body` を更新し、カテゴリ情報をロータイプのインスタンスに渡していきます。具体的には、`ForEach` で `CategoryRow` を生成していきます。

プレビューはひとまず置いておいて、`CategoryHome` の `body` で `ForEach` の中身を `Edit` ではなく `CategoryRow` に置き換えます。`CategoryRow` に渡すべき値は `category` と `landmarks` です。このとき、`ForEach` でちょっとしたキーを使います。`ModelData` 側では `landmarks` を持っていて、さらにカテゴリごとにまとめた辞書（たとえば `categories` のようなもの）を持っている想定です。辞書のキーは `Category`、値はそのカテゴリに属する `Landmark` の配列、といった構造ですね。

`ForEach` で辞書の `keys` を使って各カテゴリを走査し、各キー（つまり `Category`）に対して `CategoryRow` を作ります。その際、表示順を整えるためにキーを並び替えます。元のチュートリアルでは `rawValue` で並び替えることが多いですが、ここでは `rawValue` ではなく `name` で比較して並び替えるのが自然だと考えました。

そこで、`Sequence` に対して、要素が `Category` のときに使える `sortedByName` のようなメソッドを用意すると、見通しが良くなります。たとえば、`sorted(by:)` を内部で使って、`lhs.name` と `rhs.name` を比較する形です。最初は間違えて `Landmark` 向けに拡張してしまいましたが、並び替えたいのは辞書のキー（`Category`）なので、拡張先は `Category` でしたね。`Dictionary<Key, Value>.Keys` は `Collection` かつ `Sequence` で、要素型がキー（ここでは `Category`）なので、その前提が合います。

このようにして `keys` に対して `sortedByName` を適用し、各カテゴリごとに `CategoryRow` に `category` と、それに対応する `landmarks` を渡していきます。`Category` 側に `name` がある前提で進めますが、もし `name` が `rawValue` のラッパーなら、`name` は `rawValue` を返す計算型プロパティにしておくと、コードの意図がはっきりしてよいと思います。

同様に、必要であれば `Landmark` 側でもカテゴリ名での並び替え（たとえば `sortedByCategoryName`）ができると便利かもしれません。ここは用途が少し違うので、必要になったら拡張していく形にします。 とりあえずどうなるかは分からないのですが、同じあたりに置いておきます。エクステンションのシーケンスとしてのランドマークですね。スタートと同じですが、`func sorted(by:)` で `categoryName` を使って並び替えます。こんなふうにして、戻り値はランドマークです。並び替えとしては、関数はもうできています。`sorted` を使って、レフトハンドサイドとライトハンドサイド（`lhs` と `rhs`）で比較し、返すのはブール値ですね。用意するほどでもなかったかもしれません。`lhs` のカテゴリー名と `rhs` のカテゴリー名を比較することで、ランドマークもいきなり並び替えが可能になります。

ここでは、カテゴリーを取得するときにメタデータの `categories` を参照しますが、名前がけっこう変ですね。自分がつけたのかな……。これは絶対に違いますね。ランドマークをカテゴリーごとにグルーピングするので、素直に「グループ化」を使えばよさそうです。このタイミングで名前を変えてしまいましょう。少し長い名前になってしまいますが、`landmarksGroupedByCategory` が候補かな……。`grouped` で合っているか、`byCategory` で合っているかを確認します。

元データについては、GPT に聞いてみます。変数名を相談する感じですね。コードはコピペしてきたので、聞くところも画面に映しながらやります。ちょうど GPT のアップデート中が終わったので、これで画面を見せつつ進めます。Xcode との連携でもよかったのですが、コピペしてきたのでこのままいきます。

このプロパティの名前が適切かを聞いてみます。「名前は適切ですか。冗長のようにも言えます」といった感じで質問します。どうなるでしょうか。結果としては、説明的すぎるらしいです。API デザインの観点ではやや冗長とのこと。ランドマークであり、カテゴリーという情報があるので、「カテゴリーごとのランドマークの集まり」というのは推測可能だそうです。だから `grouped` や `byCategory` をすべて明示する必要は必ずしもない。一方で、`landmarksByCategory` のようにするとシンプルでよいとのこと。なるほど、確かにそうですね。`landmarksByCategory` か。`grouped` と書かなくても「カテゴリーごとのランドマーク」であることは伝わります。

「カテゴリー」という言葉は意味が広いのに、ちゃんと意図を汲んで提案を出してきたのはすごいですね。よく分かっているなと思いました。 とりあえず、名前は「ランドマークスバイカテゴリー」が良さそうということで、これに統一していきます。ランドマークスバイカテゴリーという名前にしておけば、モデルデータの中でも分かりやすいと思います。

気になっているのは、ランドマークスバイカテゴリー内の `keys` です。汎用的な `Dictionary` を使っているので仕方ないとはいえ、`keys` だと意味が伝わりにくいですね。普通にプログラムを書くなら `keys` のままでもよいのですが、今回はもう少し丁寧にしたいので、次のどちらかにしたいです。

- この `Dictionary` に対して同名のプロパティを与える
- もしくは独自の型を作って整理する

`Dictionary` がどういう型なのかというと、プロトコル（例えば `Collection`）に適合して振る舞いが定義されるわけですが、APIデザインガイドライン的にも、Swift の思想的にも同じ機能を複数の手段で提供するのはあまり推奨されていません。それでも今回 `keys` は分かりにくいので、もう少し語義の明確なプロパティ名にしたいです。

そこで、ランドマークスバイカテゴリーの形を先に明示しておくと自分が楽になります。例えば、`typealias` で「`LandmarksByCategory` は `LandmarkCategory` をキーにした辞書」という形を定義しておきます。その上で `extension LandmarksByCategory` に `var categories` を生やし、`keys` 相当をより意味の通る名前で提供します。

`var categories: some Sequence<LandmarkCategory>` のようにしておけば、返り値が配列でなくてもよく、`Collection` として扱えるので大丈夫です。実装してみると、返り値の型に関するエラーが出ましたが、`Element` が `LandmarkCategory` になるように整えれば問題ありません。配列になってしまっていた部分を修正しました。アクセス自体はサブスクリプトで行えばよいので、辞書としての使い勝手は保てます。

これで `CategoryRow` に渡すときも、`categories` の方が見た目と意味が良いです。省略引数のインターフェースを使って、`ModelData` の `landmarksByCategory.categories` をそのまま渡せます。途中、`init` していないという警告が出ていたのでそこも修正しました。括弧の位置のエラー（トップレベルに中括弧が出ていると言われるやつ）も直しました。これで `CategoryRow` にもちゃんと渡せています。

並び替えについては、最初は「名前順に並べる」という `sortedByName` を用意して、カテゴリー名順で並べ替えようとしていましたが、カテゴリー名で並べ替えてもあまり意味がないのでやめました。辞書側で無理に並べ替える必要はなく、`LandmarksByCategory` 型として返すだけにしておきます。

使う側では、リストの手前で一度 `let landmarksByCategory = ...` のように取得しておいて、`landmarksByCategory.categories` を必要ならその場で名前順にすると良いでしょう。`sortedByName` を用意しておいたおかげで、呼び出しはうるさくありません。これにより、`landmarksByCategory.categories` から取り出したものをループで回すだけで済みます。同じ出所（`landmarksByCategory`）から取っているので、ここでは強制アンラップでも問題ないと判断しました。

ビルドに関しては、使っていなかったコントローラを外し、不要な参照を整理したところ、ビルドは通りました。プレビューも動いています。たまたま横スクロールが入ってしまうかどうかは分かりませんが、ひとまずは大丈夫そうです。ここまでで一通り整いました。 続いて、Featured ランドマークをビューのトップに追加します。追加の情報はランドマークデータから取得するので、`isFeatured` プロパティを加えます。モデルデータ、つまりランドマークの型に `var isFeatured: Bool` を追加し、`CodingKeys` にも `case isFeatured` を同様に追加します。データ自体はすでに ModelData.json に入っています。

次に、ModelData に `featuredLandmarks` を用意します。`var featuredLandmarks: [Landmark] { landmarks.filter { $0.isFeatured } }` のように `isFeatured` が true のものだけをフィルターします。命名は `featuredLandmarks` に統一しておくと分かりやすいです。

続いて、CategoryHome の List の先頭に、モデルデータの Featured ランドマークのイメージを表示します。モデルデータ全体で隠蔽している感じがあるので、ビュー側にも `featuredLandmarks` を用意して、内部で `modelData.featuredLandmarks` を参照する形にしておくと扱いやすいです。そのうえで、最初のランドマークを取り出す際は、`if let` で `featuredLandmarks.first` を安全に取り、取得できた場合に `Image(...)` を作成して `.resizable()` などの修飾を加える、という流れにします。こうしておくと、Featured ランドマークが1件もなかった場合にはトップの画像が出ないだけの挙動になり、ないならないで問題ない、という形にできます。

ここで「必ず最初の Featured ランドマークが存在しなければならない」という前提があるなら、このコードは適切ではありませんが、今回はそうではない想定とします。もし常に存在することを保証する設計なら、`fatalError` で落とす対応もできますが、JSON から取ってきている都合上、Featured が1件もない状況もあり得るので、アプリを落とすのは避けたいところです。今回は、存在しない場合はトップ画像を出さない方針にしておきます。 とりあえずこれが出てきました。このビューをインタラクティブなカルーセルに入れて、後から対応するかもしれません。フィーチャーされたランドマークを、角を丸めてクリップしたプレビューで表示する、といったことを言っていますよね。先ほどは雑に訳しすぎたので、きちんと直しておきます。要するに「インタラクティブなカルーセルに後で変換する。現時点では注目のランドマークのひとつを強調表示し、トリミング（クリップ）したプレビューとして表示する」という意味です。雑でしたが、大体は合っていましたかね。

次に、ランドマークのプレビューの両端のインセットを0にして、コンテンツがディスプレイの端まで広がるようにします。`listRowInsets(EdgeInsets())` を使う、というのがまず一つらしいです。これで表示が伸びましたね。`listRowInsets` を `EdgeInsets()` にして、こちらも同様に `listRowInsets` を設定して、全体的に伸ばしていきます。いいですね。中途半端な余白が消えて、いい感じにスクロールできそうな雰囲気が出てきました。

次はセクション5、ナビゲーションを定義していきます。カテゴリのランドマークが表示されるビューの中から、ユーザーがアプリの各セクションへ辿り着けるようにします。ナビゲーション API とプレゼンテーション API を使って、`CategoryHome`、詳細ビュー、お気に入りリストを含む `TabView` から操作可能にしていく、という理解でよさそうです。

進め方としては、まず `CategoryRow` で既存の `CategoryItem` を `NavigationLink` でラップします。このとき、`CategoryItem` に対応するランドマークを `LandmarkDetail` で表示するようにします。ここまで先にやってしまいましょう。`CategoryRow` の中で、`body` はこの部分です。中身は `ScrollView` になっていて、各ランドマークを `NavigationLink` にし、ラベルは `CategoryItem`、リンク先は `LandmarkDetail` にします。

ここで「ランドマークはバインディングか？」という点を確認します。あとで値が書き換わる（例えば `isFavorite` が切り替わる）ことを想定するなら、`@Binding` にしたいところです。ただ、`CategoryRow` では並び替えた `landmarks` を使っているので、そのままだとバインディングを取りにくいかもしれません。環境オブジェクトなどを使えば対応できそうですが、現状のままだと扱いづらい気もしてきました。

`LandmarkDetail` に戻って確認します。ここまでの「アニメーション」あたりには登場していなかったですよね。もう一つ前の「パスを書いていこう」というところでも、まだ出てこなかったはずです。この辺は一通り大丈夫そうです。 UI Essentials の Handling User Input のあたりで多分出てくる話だと思います。Landmark のボタン、つまり favorite ボタンは LandmarkDetail で使われていて、ModelData に対して Environment でアクセスし、`landmarkIndex` があって、`landmark` が `var` として用意されています。Detail では地図（Map）が表示されていて、`Divider` が入り、`Description` などが続きます。お気に入りボタン（favorite ボタン）をどうしていたかを確認したところ、LandmarkDetail でボタンを配置して、`landmark` をバインディングしています。つまり、ModelData をバインディングしているわけですね。なるほど、こういう作り方にするのが推奨なのでしょうか。そんな気もします。

ただ、バインディングをあまり持ち回りたくないなと思って作っていました。バインディング、というか ModelData をいろいろなところから直に見ると、差し替えが効かなくなるというか、実質的にシングルトンみたいな扱いになってしまいます。Environment だから良いのかなとも思う一方で、その辺りが少し気になっていました。バインディングをたくさん使っていった都合で、今回の自分の実装がサンプルと全然違ってしまっています。特に `NavigationLink` を張るところですね。ここは何とかしていかないといけません。

favorite の状態をバインドするとなると、やはり `landmark` 自体をバインドしないといけません。ModelData から `landmarks` を取ってきて、`ForEach(landmarks)` のところでバインディングしているはずです。バインディングした状態で読むと、`CategoryRow` はどうなるのか。`CategoryRow` は `landmarks` をカテゴリーで分けていますが、ここもバインディングしたものを返す形にしてどんどん渡していく、という手はあります。ただ、それだと Environment の意味があまりない気もします。

コードをもう一度見直します。Landmark を Detail に渡して、`LandmarkDetail` 側で favorite ボタンを描画しています。このときにすでに `landmarkIndex` を求めていて、`landmarkIndex` は ModelData から探しています。バインディングでやる場合は確かにそうですね。Environment からの参照です。どうしようかな。`@Bindable`（バインダブル）でやれるか実験したのですが、initial value が unavailable だったり、計算プロパティには適用できなかったりしてダメそうでした。

そこで、`isFavorite` を ModelData を介して更新する方法を考えます。バインディングを持ち回しまくらなくても済むように、ModelData の中にアクション的なメソッドを用意します。例えば `setFavorite` です。`setFavorite` は `isFavorite: Bool` と `to landmark: Landmark` を受け取り、成功したかどうかを返すようにします。失敗しない想定ではありますが、念のため `Void?` を返すことにして、`@discardableResult` を付けます。中では `guard let index = landmarks.firstIndex(where: { $0.id == landmark.id }) else { return nil }` としてインデックスを探し、見つかったら `landmarks[index].isFavorite = isFavorite` にします。これで `landmarks` の直接変更をある程度カプセル化できます（`Hikes` も同様に保護したい気はしますが、そこは一旦置いておきます）。

この方針にすると、`CategoryRow` などはバインディングを必ずしも要求しなくなります。しかし `FavoriteButton` 側は `@Binding var isSet: Bool` を受け取る想定なので、ここでは計算バインディングを用意します。`Binding(get: { landmark.isFavorite }, set: { value in modelData.setFavorite(value, to: landmark) })` のようにして、`get` は `landmark.isFavorite` を返し、`set` は ModelData の `setFavorite` を呼ぶ形です。そのために `@EnvironmentObject var modelData: ModelData` を持ってくる必要があります。

ここで注意として、`Landmark` は `struct` で作っています。値型なので、ただのコピーを通しているだけだと変更が反映されませんでした。これがボタンの変更がうまく UI に反映されなかった理由ですね。だからこそバインディングが必要です。EnvironmentObject のオブジェクトが変わればビューは更新されるはずなので、渡されてきたものをそのまま信じて、計算バインディング経由で更新すれば大丈夫なはずです。自信はあまりないですが、試してみます。

`FavoriteButton` 側では `isSet` と `isFavorite` の名前や大文字小文字を間違えないようにします。`isSet` の `get` は `landmark.isFavorite`、`set` は `modelData.setFavorite(value, to: landmark)` です。`modelData` が見つからないというエラーが出たら、`@EnvironmentObject` を宣言していないのが原因です。`get`/`set` のシグネチャの不一致や、`Bool` の型の取り扱い（「Pointer から Bool に変換できない」など）でエラーになる場合は、クロージャの引数型が `Bool` になっているか、返しているのがオプショナルになっていないか、といった点を見直します。`Binding` は `get: () -> Value` と `set: (Value) -> Void` なので、`get` は純粋に `Bool` を返し、`set` は `Bool` を受け取って `Void` を返す形に合わせます。

まとめると、EnvironmentObject（ModelData）を活かしつつ、`FavoriteButton` には計算バインディングで `isSet` を渡す方式にしてみます。これならバインディングを深く持ち回る必要が減り、同時に `struct` の値更新が UI に反映されない問題も回避できるはずです。エラーが出る場合は、`@EnvironmentObject` の有無、`Binding` の `get`/`set` の型、`Bool` と `Bool?` の不一致、プロパティ名（`isFavorite` と `isSet`）のタイポを重点的に確認します。 「isFavorite」の関係ですね。ここは OK でしょう。`get` と `set`、ここが間違っているらしい。`get` と `set` で、`init` は何になる？ `init(get:set:)` で、`get` と `set` の関係を作るんですよね。プール…ではなく `Bool` が入ってくる（入れられる）わけです。ここで `isFavorite` にして、渡されてきた値を使えばいい。そう思ったのですが、違いました。

`init(get:set:)` の `get` は `Bool` を返し、`set` は `Bool` を受け取って `Void` を返します。これで `Bool` が入れられる、という形です。`Void?` みたいなオプショナルは要りません。今回は失敗しないように進めます。

ただ、まだ `Binding` の `get` が見つからないと言われます。`init` を入れておきますか…とやっていて、`Binding` が多すぎるのも気になります。`init` で `get` を取るのかどうか、どうしようもないかと試しているところですね。`init` と `Binding` をちゃんと書いて、あとは `isFavorite` を設定してあげれば大丈夫なのかな、という方針です。

ビルドエラーはどうなったかな。まだありますね。プレビュー側で `Binding` が効かなくなっているので、モデルデータの `landmarks` を使う感じで直します。このままビルドエラーを潰していきます。

これで `Binding` のランドマークは、モデルデータからインデックスで取れます。ランドマークリストも `binding` していましたが、インデックスでランドマークを取り出したものを使って、星（Star）のボタンまわりでいろいろやっているところです。ここはもうランドマークを直接使う形にして良い、ということですね。`set`、というか、もう `Binding` ではなくするので、`landmark` を直接使う、という形にすれば OK ですかね。エラーはなくなりました。エラーがなくなったなら動くのかな、という肝心なところです。

いろいろ無理やり直してきた感があるので、動くかどうかは自信がないです。実際に Category…フォーム（多分 `Category` 系のビュー）からプレビューカードを取ってみたらどうか。Category 側の中から出して、`isFavorite` で見たいからランドマークのアプリ…ではなく、`ContentView` で確認しましょう。`ContentView` はまだリストが出てくる状況なので、これで「Silver Salmon」をクリックして、お気に入り（星）を押す。…入っていない。入っていないですね。ダメです。トグルもオフにできない。失敗しましたね。ダメか。ここはカテゴリービューは一度無視しておいて、頑張って原因を追います。

まず `ContentView` は `Environment` とモデルデータが分かっている状態で、ランドマークリストですよね。モデルデータ…まだ `Environment` 周りがよく分かっていないのですが、プレビューでこうしたらどうなるかな、とビルドしたらエラー。これは適当に書きすぎて、まだ作り切れていないからですね。直せば良さそうです。

そうすると、トグルしたときに `Binding` されていないといけなくて、かつ `Binding` の更新が反映されないといけない。星の `Binding` がどう動いているのかを見るのが早そうです。トグル自体は関係ないですね。

`LandmarkDetail` の中に `FavoriteButton` があるはずで、ここで `Binding` していますよね。この状態で `modelData` の `isFavorite` をどう扱っているか。`isFavorite` の setter…つまり `set` のところに情報を差し込めば良いのかな。ここら辺で `print` を追記して、デバッグしてみましょう。たとえばインデックス、`landmarkIndex` の `isFavorite`、新しくセットする `isFavorite` がどういう関係になっているかを、プレビューで一緒に見ます。

これで、手順どおりにできているのに動かないのか、自分のコードがチュートリアルと違っているのか、切り分けます。星を押したときに `false, false` と出る。期待と違いますね。つまり、`false` を `false` に書き換えてしまっている。ここで、`isFavorite`、新しい値が渡ってくるはずの `isFavorite` が正しく来ていない、という状況のようです。 なので、これで「Silver Salmon Creek」の星が増えました。できましたね。戻ると、入っていますね。よかった、できた。これで「St. Mary Lake」とかも星を外すと星が外れて、それで戻ってあげると「St. Mary Lake」もちゃんと星が外れています。

同じようにフェイバリットオンリーにして、例えば「Chilkoot Trail」、これにしますか。これの星を外してあげるとちゃんと外れるかな……外れない。うーん、ここまたバグが残っちゃいましたね。バグが再発しちゃいましたね。戻るとちゃんといなくなっているんですよね。これが前にもあったバグ――バグなのかな、勘違いなのかな。この前は、`@Bindable` を使うと描画されなかった、というのをちゃんと読みました。ランドマークのインデックスを使って、`@Bindable` を使うと、フェイバリットオンリーをオンにした状態で、ディテールビューからフェイバリットボタンを押しても、モデルデータは変化するが描画が変化しない、これがまた出てきてしまって。これまではバインディングを直接渡すことによって、その問題を回避していた、という話だったんですけど、今回はバインディングをやめちゃったので、LandmarkDetail のところでバインディングしていない状態で、ここで渡ってきて……ランドマーク別に何の差異もないはずじゃないですか。にもかかわらず、このフェイバリットボタンで状態を変えたのに、星が――フェイバリットオンリーをオンにしているかどうか、これによって――この挙動が何なんだろう、というのがありますね。

どうしますかね、これ。解決しないといけない問題だと思うんですけど、とりあえず先に進んでいって、一番最後に問題解決でもいいのかな。「とりあえず動くでしょう」なのか。回避策としては、トランジション、というかナビゲーションで移動する前にフェイバリットをオフにするとか、何かそういったことをすればいいのかなって気もするけど……でも何でしょうね、`false` とかちゃんとやっていたし、ID は一緒なのに。描画がこのオンオフで変わらないっていうのは、元のリストが何か悪さしているんですかね。そこはちょっとわからないんですよ。

とりあえず、どうしよう。このままいけばいいのかな。もう一回だけやっていこうかなと思うんですけど。プレビューが動かないな……動いてるか。これをオンにするとダメなんですよ。これで一旦ね、押しても `false` になっているはず。もう一回押すと、`false` から `false`、`false` から `false`、`false` から `false` か。もう一回押すと `false` から `false`。ここの描画が変わっていないから、こっちは押したから `false` が分かっているけど、リストの方はもうすでに `false` になっているので、ここが連動していない感じですね。連動していないってことは、結局 `landmark.isFavorite`、ここが変わらないのかな。ここが変化してくれないと困るのか。モデルデータからちょっと取ってみましょうか。モデルデータ、モデルデータの `getFavorite`。

とりあえずモデルデータの……ここじゃないや。モデルデータの定義の中で、この中で `getFavorite` を今用意した。そうね、それがあるわけで。`get` かな？ なんか `get` ってあまりしない気がするんだけど、Swift ではしないと思うから、`favorite(of landmark)`。こんな感じですよね、きっとね。ランドマークから取って、これで `Bool` を返すよ、というふうにして。この中で、`Bool` だけどランドマークがない場合がありますよね。ない場合どうしますかね。そういう時には `nil` が妥当ですよね、本来ね。だから `Bool` のオプショナルにして、`var index = landmarks.firstIndex(of: landmark)` にしてあげて、そうじゃなかったら `return nil` ですよね。まずはね。その後は……3つあるんで、絶対に。 ランドマークのインデックスを使って `isFavorite` を参照するようにすれば、`favorite` がモデルから正しく取れる状態を作れます。そうすると、モデルデータの `get` に対しても同様に参照できます。

モデルデータのランドマーク…ではなく、`favorite` の綴りが違っていました。名前を変えておきたいところですが、今は名前を変えられないので、ひとまず `favorite` をオフにします。先ほどのランドマークのモデルはここにあり、モデルデータの関数も `favorite` ですね。これらを踏まえた上で、`Binding` の `favorite` をランドマークに結びます。今回はランドマークは必ず存在する前提です。

これでどうなるかというと、両方ともモデルデータを見ているので連携するはずですが、SwiftUI を分かっていないと少し分かりにくいかもしれません。実際に押してみると、星が消えました。`true/false` が切り替わって、戻ると表示も更新されています。アプリで星を一度オフにして、もう一度オンにしても、状態はちゃんと生きていますね。という感じで、無事にできました。

要するに、モデルデータから直接操作していく、あるいはモデルデータに対してバインディングしていく、という方針で OK です。つまり、`Binding(get:set:)` を使うということです。今はこう書きましたが、リファクタして、`@EnvironmentObject` の `modelData` を使い、`modelData` の中の `landmarks` にアクセスします。たとえば値を直接いじるのが良くない場面では、`Binding` を使って `get` と `set` を用意する、というやり方になります。 とりあえず `let` でやってみましょう。モデルデータ、こういう `ModelData` をこうしてあげて……これでやっぱり、うーん。モデルデータの `landmarks`、どれだったっけ。`modelData.landmarks` の `0`、これはダメか。今はバインド可能な状態になっていないからですね。`private(set)` にしているから、これを `var` にしてあげると……でも、これでもコンパイルが通らないんでしたっけ。

`modelData` のバインディングで、`landmarks` ですよね。`first!` はダメだし、`first` もダメですよね。あれ、できなかったっけ。`Binding<Landmark>` を直接渡そうとすると、結局必要なのは `Binding<Bool>`、つまり `isFavorite` のバインディングですね。そうするとバインディングはできますが、配列から要素を特定しないとしょうがないので、ここでインデックスを取らないといけないのか、という話になります。

これは `ModelData` でインデックスを取ってあげるのがよさそうです。さっきインデックス取ってましたっけ。`FavoriteButton` に `Binding<Bool>` を渡す流れだから、どこかで取ってたはずですが、取ってないのか。まあ、メソッドで何とでもなるので、それでいきましょう。

`ModelData` からバインディングを取りたい。ええと、バインディング、`bind`、`Binding`……アイテムを取っていかないといけない。`first` ではなく、`firstIndex` ですね。`first(where:)` じゃない、`firstIndex` を取っちゃってもいい。`landmark` のバインドを作りたいんですが、SwiftUI でこういう書き方をするのかはちょっと自信がない。

例えば、`Landmark` ではなく、`ModelData` 側にバインディングを返すメソッドを用意するのがよさそうです。`extension` で、`ModelData` に対して `bind(to landmark: Landmark)` のようなものを用意して、`Binding<Landmark?>` を返す、みたいな形です。そして返すものとしては自分自身のデータに対するバインディングなので、`Binding` の `wrappedValue` を使う形になります。`wrappedValue` だと値が変わるだけですよね、という理解で、`@Bindable` が使えるかどうかも検討します。例えば `@Bindable var self` 的なことができるのか。プロパティラッパーの `@Bindable`、`ObservableObject`（もしくは `@Observable`）と自分自身の関係、だからここは `wrappedValue` をどう扱うかという話です。

最終的には、`self.landmarks` の中の該当要素のインデックスにアクセスすることになります。つまり、`guard let index = landmarks.firstIndex(of: landmark)`（または `firstIndex(where: { $0.id == landmark.id })`）のようにインデックスを求めて、そのインデックスを使って `self.landmarks[index]` に対するバインディング（例えば `$modelData.landmarks[index].isFavorite`）を返す、という形にしたい、ということです。 リターンにいるとインデックスが取れるけど、ここは自分の`landmarks`にしたい。これは`wrappedValue`も維持しちゃおうかな。こうしたときに、`self`…でもだめか。挙動か。あまり格好良くないですね、`self`だとね、`wrappedValue`。

だから、これを`wrappedValue`にしてあって、このまま`wrappedValue`で`landmarks`のインデックスを取って、`wrappedValue`で`landmarks`として、ここでインデックス…これじゃだめなのかな。`landmarks`のインデックスは、`landmarks`の`Landmark`から`Binding<Landmark>`に変換できない。`Landmark`からね。で、これがここか。だから、えーと、Writable KeyPathを…ああ、そうですね。こうしてあげると、バインドしたものが取れる、という動きに変わるので、ここだけ`Landmark`のディテールの中で、`isFavorite`に渡すときに、この中ではごちゃごちゃやらずに、`Favorite`の中で`ModelData`に対して`bind(to:)`で`Landmark`…これで`isFavorite`だといいのかな。

`bind`が…違うか。`bind(to:)`は、今`Binding`に帰着したからいけないんだ。これを`ModelData`にして、それで`Bindable`を`self`にしてあげて、回せますよね。これで`Landmark`に`bind(to:)`…これは効果だめなのかな。`isFavorite`、`Binding`…いや、でも大丈夫ですよね。効果なんだ。えーと、あー、落ちちゃった。はいはいはい。今、絶対やります。ということで、びっくりマーク（`!`）を付けて、これで`isFavorite`に対して呼び出した。これで動くのかな。うーん、まあ、やってみましょう。理屈としては動くと思うんですけど。

シルバーサーモンをクリックして、とりあえず`favorite`にしましょうか。`favorite`できましたよね。一応オフにしようか。大丈夫ですね。もう一回オフ、できますね。大丈夫。これで戻るでしょ。で、シルバーサーモンをクリックすると`favorite`になった。これでオンにして、例えばセントマリーレイク、これをオフにする。うん、オフになりましたね。ログ出なかったかな。ログはどうだ。もう一回押してみましょう。出てないね、ログ。もう一回…あ、どこか消した。あ、消したからだ。セットを呼んでいないからですね。

当たり前ですが、大事なところとしては、ちゃんとしたデータソースからバインドしたものを取ってくれるということです。ちゃんとやらないとダメ、ということですね。本当に当たり前ですけど。なるほど。まあ、できたんじゃないでしょうか。これで、いろんなところが良くなったポイントがいくつかあります。まずは…もう何もないか。`ModelData`。この辺のコメントもいらないですね。そうすると、「なぜできるのか」だったっていうのは、はっきりとはもう分からないですけど、だいたい今日いろいろ試したことで、もう二度とこういったことはないでしょう、という感じで。OKですね。

で、これで`ModelData`…ここですね、`ModelData`の中に入れたいかな。こんな感じで。これで、バインドできるようにした。`Landmark`を指定してバインドする。で、何もなければ`nil`が入る、という状況にして。この`wrappedValue`の前が今はやや変ですよね。なので、`ModelData`…前にしようか、`self`にしようか。`self`なのかな。えーと、`ModelData`でいいか。`self`をシャドーイングできたら最高だったんですけど、残念ながらそれはできなかったので、まあよしとしましょう。

でも、これ面白いですね。自分自身をそのまま`Bindable`に渡してあげることで、これで「お気に入り」だけですね。これをお気に入りから取ってあげる。そうすると、これで…うん、タートルロックだけ。OKですね。`isFavorite`が増えたような気がするけど、まあ大丈夫かな。実際にはあり得ないですよね。はい、完璧ですね。コードもいい感じにスリムになった気がします。もう一回、ビルドもスムーズになるかな。

で、これで`isFavorite`…これは古いコードですね。なので、やるところから入ったほうが早いですね。で、この中の…これ。この中の、さらに、どこにいた？ Categoryでデータを出したか。このインデックス、こんな感じですよね。はい、一応読み解けました。 リンクを設定して、`LandmarkDetail` への `NavigationLink` を入れます。`CategoryItem` 自体をラベルとして使う形です。`destination` は `LandmarkDetail` のプレビューにしておきます。

プレビューはピン留めして、次のステップの変更がどう影響するかを見られるようにします。`CategoryRow` をピン留めしたくない気もしますが、ひとまずピン留めしておきます。`CategoryRow` を選んで、Command+Shift を使ってピン留めします。

ステップ2として、`CategoryItem` の Appearance を調整します。定義に移動して、`Image` は `renderingMode(.original)` に、`Text` 側は `foregroundStyle(.primary)` にします。グレーになっていた文字が黒くなりました。`renderingMode` は見た目が変わらないようにも見えますが、`template` にすると色が変わるので、効果は出ていることが確認できます。とりあえずここは `original` で進めます。

次に、アプリのメインである `ContentView` を調整して、`TabView` を作ります。作成した `CategoryHome` と、既存の `LandmarkList` のあいだをユーザーが選択できるようにします。タブとして `Featured` と `List` を用意するイメージです。

自分は拡張で書きたいので、`ContentView` に対して次のように用意します。まずタブ用の列挙を作ります。`enum Tab { case featured, list }`。次に状態を追加します。`@State private var selection: Tab = .featured` のように、デフォルトは `featured` にします。

そのうえで、`TabView(selection: $selection)` を使い、`CategoryHome` と `LandmarkList` を並べ、それぞれに `tag` を付けます。`tabItem` のラベルは、`Featured` にはシステムイメージの `star`、`List` には `list.bullet` を指定します。例えば、`Label("Featured", systemImage: "star")` と `Label("List", systemImage: "list.bullet")` です。こうしておくと、ユーザーインターフェースでの選択が `selection` に反映されます。

プレビューで動作を確認し、タブ間でナビゲーションが正しく機能していることを確かめればOKです。`LandmarkList` のほうも `tabItem` で `Label("List", systemImage: "list.bullet")` を設定しておきます。 リストを作って、`Label` で `systemImage` を使う形にしました。見た目のイメージとしてはこれで良さそうです。ただ、波括弧が付いていて、どこかがマッチしていないというエラーになっていました。`Label` 周りの指定や `List` の構造をもう一度確認して、`Image(systemName:)` とラベルの組み合わせが正しいかを見直します。

次にタグの扱いですが、`tag` は何を取るのかというと `Hashable` ですね。なるほど、だから結局ハッシュ可能である必要があるわけです。たまたま同じハッシュになったらどうなる、という心配はあるかもしれませんが、とりあえず `Hashable` に準拠していれば大丈夫です。

星マーク（お気に入り）を付けたり外したりできるようにして、画面を戻ったときの状態も確認しました。押下状態で別の操作を行ったときの挙動も試して、戻ったときにどう見えるかをチェックしています。

`print` がまだ残っているかどうかも確認しました。`print(isFavorite)` を書いて、`onChange` で old と new を受け取る形（例: `onChange(of: isFavorite) { oldValue, newValue in ... }`）にしていたはずですが、これはプレビュー上の問題かもしれません。

`LandmarkDetail` で `landmarks[0]` を見て、`ModelData` をプレビューで参照できるように、`Environment` に `ModelData` を渡しました。具体的にはプレビューに `.environmentObject(ModelData())` を付けて、`@EnvironmentObject` が解決されるようにしたところ、プレビューも正しく動くようになりました。作業中にプレビューが動かなくなるのは「あるある」ですね。

リスト周りはこれで良さそうです。次に命名の話です。「`CategoryForm` って何？」という違和感があります。`LandmarkList` は意味が明確ですが、`CategoryForm` は意図が伝わりにくいです。これは「Featured」のことですよね。フォームというよりは「Featured」を表したいのであれば、`FeaturedView` のようにするのが自然に思えます。ただ、`Featured` だけではない構成かもしれないし、タブアイテムで `Featured` を選ぶなら `FeaturedView` というのが妥当そうではあります。`LandmarkList` との整合性も考えつつ、`Featured`、`Landmarks`、`take`（これは何だったか）など、いろいろと候補を見直しましたが、パッとしないときに無理に変えるのも良くないので、今回は一旦 `CategoryForm` のままにしておきます。やや微妙な名前な気はしますが、後でまた見直しましょう。

チェック項目も一通り確認しました（Understanding Check）。どのビューがルートかという点では、`LandmarksApp` のエントリに `ContentView` を置いているので問題ありません。`ContentView` がこのアプリの他のコードからどう使われるか、という観点でも整合しています。ビューのシンタックス、モディファイア、命名規約については、やや基準的なものから外れていないか再点検が必要ですね。ランドマーク関連のビューをナビゲーション階層でちゃんとつないでいるかについては、上位に `NavigationLink` を置いて、ディテールに遷移する実装を確認しました。`NavigationLink` のコードは、ディテール（例: `LandmarkDetail(...)`）とラベルの組み合わせで書く形（例: `NavigationLink(destination: LandmarkDetail(...)) { Label(...) }`）が正しいので、これは OK です。

今日はここまでにします。次回は「Working with UI Controls」に進みます。お疲れさまでした。
