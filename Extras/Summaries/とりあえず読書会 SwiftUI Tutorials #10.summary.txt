Transcription & Summarize : とりあえず読書会 SwiftUI Tutorials #10

ということで、紹介を始めていきましょう。SwiftUI チュートリアルの第2章の動画かな、と思います。バックグラウンドの上に、パスで作った細長い形状を回転させながら繰り返し描画することで、バッジを作っていこうという流れです。そんな感じのセクションですね。その中でいろいろとリファクタリングもしつつ進めています。Swift のバージョン対応のことも頭に置きながらやっているのですが、意外と引っかからないものですね。まあ、そういうものなのかもしれません。とりあえず読み進めながらやっていきましょう。

今日はセクション4で、バッジのフォアグラウンドとバックグラウンドのパーツを組み合わせて、バッジを作っていくという内容です。バッジデザインは、山のような形（いわゆるシンボル）を回転させて複数回繰り返す、という構成に従います。ここで出てくる「follows」は「〜に従う」という意味ですね。プログラムでいう関数の call（呼び出し）を連想しがちですが、ここではそうではありません。

新しい型を定義しよう、という話も出てきます。ここでの「leverage」は「活用する」の意味ですね。各ビューに同じ調整を適用した複数の `MountainShape`（山の形）を用意して、それらをまとめて扱えるような型を作る、という意図です。つまり、マウンテンのパラメータを受け取ってレンダリングしてくれる型を用意するわけです。回転用の構造体を用意して、`ForEach` ビューを活用して同じ調整を繰り返し適用します。`ForEach` 自体がビューだという感覚には最初は慣れないかもしれませんが、確かにビューですね。

まずは `BadgeView` を作り、その中で `BadgeBackground` を用意します。その上に、`ZStack` でバッジのシンボルを重ねます。ここに回転させたシンボルをいくつか配置していくのでしょう。たとえば、回転させたバッジシンボルを `angle: Angle(degrees: 0)` から始めて、`ForEach` で複数回並べる、といった構成です。これでバッジシンボルの描画ができそうです。なるほど、という感じですね。

次に、バッジのサイズを調整します。`BadgeSymbol` を `GeometryReader` でラップして、サイズに応じたレイアウト調整を行います。少し進行が遅くなってきましたが、まずはここまで実装してしまいましょう。`GeometryReader` の部分は必要に応じてコピーして使い、`body` の `ZStack` に `BadgeBackground` と、今コピーしたシンボル側のコードを配置していきます。 なので、まずバッジビューを作りましょう。ビューの構造としては、`ZStack`で組み立てる形にします。ここで、`Badge`という`UIView`…ではなくSwiftUIのビューとしてのバッジを用意して、いったんビューを戻しておきます。

`Badge`の中身は`ZStack`でしたよね。`ZStack`の中に`BadgeBackground`（バッジの背景）を置きます。今回、この`BadgeBackground`はリファクタして、内部で`GeometryReader`を呼ぶのではなく、外側で`GeometryReader`を使ってサイズを取得し、そのサイズを渡す方針にします。

つまり、`ZStack`の中で`GeometryReader`を使って、`BadgeSymbol`のプロパティに必要なサイズを渡す、という流れです。`BadgeSymbol`をサイズ調整するために`GeometryReader`を使っていこう、という話でした。コピーしてあったものをベースに、`Badge`として組み直していきます。

ここで気になったのが、`BadgeBackground`側の`bounds`にも`GeometryReader`が必要になる点です。これでサイズが変わってしまうのかどうか。`BadgeBackground`に対しても`GeometryReader`でサイズを渡していくとして、どうなるのかをまず試してみましょう。`geometry.size`をそのまま`bounds`に入れてあげて、`geometry.size`を使うようにします。

この場合、2箇所でサイズを取ることになります。外側で取得した`GeometryReader`と、もう1つ別の`GeometryReader`を使ったときにどうなるのか、正直あまり考えたことがなかったので、挙動を確認しておきたいです。曖昧なままだと怖いので、`GeometryReader`を2つ置いた場合のサイズを`print`で見てみます。

`print`はこの位置だと呼べないので、`.task { ... }`の中で`print("1:", geometry.size)`のように出力します。もう1つ、シンボル側でも`.task { print("2:", geometry.size) }`としてサイズを確認します。こういう初歩的なところ、意外とやっていませんでしたね。

まずビルドエラーが出ました。当たり前といえば当たり前ですが、原因を直します。`RotatedBadgeSymbol`のつもりの箇所が「`RotatePatchSymbol`」のように間違った名前になっていたので、リファクタのRenameで`RotatedBadgeSymbol`に統一します。その上で、`GeometryReader`を外に出すリファクタに合わせて、`RotatedBadgeSymbol`のイニシャライザが`bounds`を受け取るようになっている前提で、`angle`の前に`bounds: geometry.size`を渡すように修正します。

それから、`FillStyle`については、`BadgeSymbol`側で元から当てる（デフォルトを使う）形にしていたので、そのままにします。これでビルドは通るはずで、プレビューも動くはずです。

プレビューで知りたいのはサイズです。`GeometryReader`がそれぞれどんなサイズを取得しているのかを確認します。外側と同じサイズが得られているように見えますが、念のため`Text`を入れてレイアウトの影響を試します。はっきりとは分かりませんが、今のところイメージ通りに動いているようです。実際の環境では違う可能性もありますが、ひとまずこの方向で進めます。 まずは、`GeometryReader` で `ZStack` の中身のサイズが取得できるので、それを使ってバッジのバックグラウンドに対してジオメトリーのサイズを渡しつつ、`BadgeSymbol` にもジオメトリーのサイズを適用できます。そういった状況ができていると言って問題ないでしょう。実際、問題なさそうですね。いい感じにコードが進みました。良いですね。

ここで、`BadgeSymbol` も `GeometryReader` を使っていますが、`BadgeSymbol` を計算型プロパティで作るのと、型として作るのとでは、どういう判断基準になるのでしょうか。計算型プロパティを使えば同じインスタンス変数を共有できるので、作りやすさの面で利点があります。今回の場合はどうでしょう。`BadgeSymbol` を計算型プロパティで作るのであれば、`BadgeBackground` なども同じようにして良いはずです。どちらでも良い、という感覚でいいのか。それとも、型に切り出す意義をもう少し細かく考えるべきなのか。型にすると明確にはなりますよね。型を定義しない場合は基本的にそのスコープの中だけで完結しますから、再利用しないということになるでしょう。また、インスタンスを作るたびにその分のメモリを確保することにもなります。とはいえ、今回の量なら大したサイズではないと思います。位置に影響するところも含めて、そのあたりを考えれば良さそうです。

要は、「`BadgeSymbol` にしたい」という意図があるので、それで良いのかどうか。今まで型を分けてきた側面もあるので、試してみましょう。

`BadgeSymbol` があって、これをコピーして配色を調整し、`SymbolView` を用意します。ただし、この `SymbolView` はバッジの中でしか使わない気がするので、ここに定義していきます。例えば、`extension Badge { ... }` の中に `private struct SymbolView` を定義します。バッジの中に含まれていれば `SymbolView` で良いでしょう。そこで、`let bounds: CGSize` を持たせます。その上で、`View` を適用して `body` を実装し、`RotatedBadgeSymbol` を使います。これはサイズではなく `bounds` ですよね。これを適用してあげます。これで `SymbolView` ができました。

次に、`GeometryReader` の中で `SymbolView` を使い、`bounds` としてジオメトリーのサイズ（`geometry.size`）を渡します。ここまで変わらないことを確認したので、これをやった以上、もはや `BadgeSymbol` は不要で、`SymbolView` に置き換えられます。

このときに `scaleEffect` とかも適用できるのかな、という点ですが、`offset` か、`RotatedBadgeSymbol` の適用タイミングの都合か、といったところですね。いずれにせよ、バッジのバックグラウンドとシンボルのバックグラウンド、という感じで構成できています。`scaleEffect` はこの計算式で成り立っていて、4分の1、そして `position` はジオメトリーのサイズを元に定義されています。この辺はとりあえず良さそうです。

`ZStack` と `GeometryReader` の関係も、バッジの中で完結しているので問題ないでしょう。バッジのバックグラウンド、というか、ここはもう `BadgeBackground` で良いですよね。`extension` はここに置いていますが、これは単体で使うものではないはずです。ファイルを分けるべきかは悩ましいところで、ファイルを分けると `private` にできなくなってしまいます。アクセスコントロールの観点と、外のファイルに混ざって複雑になるという観点のどちらを取るかですが、この場合は複雑さより `private` を優先するのが良さそうだと感じます。

ということで、この辺をざっくりとプレビューまで通す感じですね。`Badge` に対して、`BadgeSymbol` と同じように `BadgeBackground` も用意します。今持ってきたばかりなので、ちゃんと動きます。これでプレビューとして、`Badge` と `BadgeBackground` を用意し、こんなふうにするとちゃんと切り替えられますよね。`Badge` と `BadgeBackground`。普通は `Badge` が最初に見たいところでしたね。 なので、まずはバッジを先に進めます。これで良いですね。ここで一度落ち着いたところで、同じように少しリファクタリングをしていきます。

まず、バッジに対してプライベートエクステンションでシンボルを作っています。これはバッジだからバックグラウンドで扱うものです。そうすると、あとはパラメータですね。これを移していくと、バッジのバックグラウンド用のファイルは不要になって、残りはパラメータだけになります。パラメータはどこに置いたかというと、`HexagonParameters` ですね。`HexagonParameters` も気になる点はありますが、まずそれは置いておきます。

ファイルが見つからないときは、`Command` + `Shift` + `O` で「Parameters」を選べば探せます。パラメータはルートに置いておくことにして、`HexagonParameters` のファイルの中にあります。今回については、これも `private` で良さそうです。`HexagonParameters` にエクステンションしていく想定なので、そうでないといけない、という感じですね。なので、これもまた細かいところはまとめていく方向にして、バッジのこの中に置いておきます。ファイルの下のほう、プレビューの前くらいに置いておきましょう。

それで、まずシェイプに行く前に、バッジのバックグラウンドの `HexagonParameters` に対して、`Segment` を作るというのをプライベートでやっておきます。`private` にしすぎかもしれない気もしてきましたが、もし不都合が出たら考え直しましょう。今回は、バッジのバックグラウンドの `HexagonParameters` の下あたりに、パラメータの `Segment` を置いておきます。

ただ、これを `Segment` で書くとどうなるか……ダメですね。これだと循環参照になってしまいます。ここにたどり着きますよね。やはりダメで、`typealias` がそれ自身になってしまっています。では `Self` で書けば良いのかというと、`Self` もダメだとわかっていたパターンですね。ここはこういう感じで入るように直した上で、エラーは解消。プレビューも動くはずです。これで動けそうですね。大丈夫です。良いと思います。

そうすると、もうひとつ気になるのが、描画まわりでいろいろ定義したパターンが見えてきたことです。今回のようにいろいろ定義したときには便利ではあるのですが、バックグラウンドがあって、シンボルがまだ描画されていません。`HexagonParameters` はこのままで良いとして、シンボルが描かれていないので、そこもやっておきます。プレビューで確認できるようにして、終了時点の見え方を確認します。

このプレビューはバックグラウンドの前側に、やっぱりシンボルのプレビューを置きます。その中で `GeometryReader` が必要になります。ここがバッジのシンボルで、`bounds` として `GeometryReader` の `size` を使います。こんな感じでプレビューが3つ並ぶようにして……良いですね。ここまで問題ありません。

あと、`CoreGraphics` を `import` しなくて良いのかは少し気になりましたが、要らないならそれで良しとします。まずは不要になったパラメータ用のファイルを削除しておきましょう。これで整理できました。

続いて、さきほど作ったバッジをもう一度見直します。シンボルをもう一回見ておきましょう。シンボルの中に `RotatedBadgeSymbols` があります。これを `RotatedSymbols` にするかどうか、という問題ですね。`RotatedSymbols` にしておきます。中でしか使わないはずなので `private` にします。そして、バッジのほうに持っていきます。こうやっていくとファイルが少し長くなってしまうのが気になりますが、この辺りは標準ライブラリではなく、アプリ内の要素をまとめているだけなので、今回はこれで良いでしょう。必ずしも1つ1つを別ファイルに分ける必要はありません。

シンボルは `RotatedSymbols` にして、名前も変えることにします。`GeometryReader` 周りもOKですね。なので、`RotatedSymbols` にリネームしたシンボルとして使い、それをエクステンション側に寄せます。さらに、この `struct` 自体の定義を、`private extension` のところまで持っていく、という整理にします。

このあたりの `HexagonParameters`、`BadgeBackground`、`Symbols` はこのファイル内にまとめます。`RotatedBadgeSymbols` を `RotatedSymbols` に変更し、`private` にした、というのが今回のポイントです。バッジ用の `RotatedSymbols` として使い、プレビューの位置も調整します。ここはかなりこだわりですが、バックグラウンドの前に持っていきます。大丈夫ですね。本当はシンボルの後ろにしたかったので、これで良しとします。すると、プレビューとして `RotatedSymbols` も出てきて、回転した感じが確認できます。ここまでで良いと思います。 ローテーティッドシンボルも不要になったので、これも削除します。こんなふうにして整理します。

まだ気になる点があります。`RotatedSymbol`の中で`BadgeSymbol`を使っていましたよね。`BadgeSymbol`は別の場所に定義されていて、しかも内部でしか使わないはずなので、同じように移動します。いくつかの段階に分けて移動しました。まず`BadgeSymbol`の定義をここまで移動します。`Badge`の中で`RotatedSymbol`を呼び出すので、その定義の次に置くようにします。

`BadgeSymbol`は`Badge`の中に入ったので、名前は`Symbol`で十分通じるでしょう、ということで`Symbol`にリネームします。その上で、横に並べて配置します。さっきの`BadgeSymbol`の横に、誤っていた`Badge`と`BadgeSymbol`の並びを直し、プレビューが邪魔なので一旦消します。それから`RotatedSymbol`も移動します。`RotatedSymbol`も`Badge`の`Symbol`に依存しているので、こちらも一緒に持っていきます。

`Badge`の`Symbol`を持ってくるときには、`BadgeBackground`あたりと並べるのが良さそうです。丸い部分をまとめて、`makePath`あたりまでを一括で持ってきます。`private extension`になっているので問題ありません。型を`Badge.Symbol`というふうに、名前空間で表現するようにします。ついでに、この後に空行を入れておきます（細かいことですが）。これで、プレビューを移すだけで良くなります。

プレビューについては、`BadgeSymbol`なので、`Badge`の`Symbol`の次、`RotatedSymbol`の下あたりに置きたいかなと思います。順番はどちらでも良いので、とにかく配置します。ラベルは“Symbol”として、`BadgeSymbol`は`Badge.Symbol`に変更します。これでビルドが通りますね。

不要になった`BadgeSymbol`のファイルは削除します。良いですね。プレビューを確認して問題ないことが確認できれば、かなりいじりましたが、問題なさそうです。`BadgeBackground`も正しく表示されているし、“シンボル”といえばこれ、`RotatedSymbol`といえばこの見た目、`Symbol`といえばこの見た目、という対応関係も大丈夫です。ここまで順調なので、もう一度チュートリアルに戻りましょう。

現状は、`Badge`のシンボルとして、`RotatedSymbol`が1個だけ描かれている状態です。次は、`BadgeSymbol`のサイズを背景のサイズ（ジオメトリ）に合わせて調整してフィッティングする、というところからですね。さっきやったところですし、その方針で進めます。

次に、ポイントを追加して、シンボルのコピーを回転させます。セグメントごとに360度の回転を割り当て、太陽のようなパターンを繰り返して作る、という内容です。8回の繰り返しで360度を一周させるようなので、長いのでコードはコピーして対応します。これは上のほう、シンボルの定義側（`Symbol`型）の回転に関わる箇所ですね。

この中で、`Badge`のプレビューも出しておきます。名前変更に合わせて、`RotatedBadgeSymbol`ではなく、今は`RotatedSymbol`を使います。角度は360度を8で割る計算になっています。また、`bounds`を渡す必要があるので、`bounds`はこのように設定します。加えて、`FillStyle`も同様に指定して、`Symbol`に適用します。これで描画がずれていないかどうかを確認します。うん、少しずれているかもしれませんね。 とりあえず描けました。ズレていたらしょうがないですが、これでどうしようかなというところです。ズレた原因はいろいろ考えられるので困っていますね。まずは、レンジのインデックスが`Int`型であると期待している以上、`Double`に変換する形からいきましょうね。あとは、角度の計算を回転シンボルの中でやるのか、それとも外でやるのか、くらいですかね。

角度は、ここでキャストもできるのか。まあ、`Angle.degrees`ですね。これはコピーしてペーストでいいか。こういうふうに、内側と外側で役割を分けてあげれば、読み出しがシンプルになって把握しやすくなりますよ、というくらいで、ここはお好みで大丈夫です。これくらいシンプルになると、もう1行で書けますし、余計な`360.0`とかがなくても大丈夫だよ、というところです。

インデックスが`w`なのは、カプセルを計算するときに`w`に変換すれば大丈夫でしょう。360度を割って……いや、分けるか。まあいいか。この辺は、どこかに式をまとめるより、ぱっと見たときに意味が分かりやすいリテラルを使っていくほうがよいと思います。360度の`degrees`だから、ですよね。

それで、`Int`を8で割ることによって、0.125みたいな、1を8等分して……要は、0から――あ、これはダメだ。円周率πで角度を決めていくやつでしたっけ、確か。まあいいや。とりあえずこんなふうにして、角度がズレているのが非常に気になりますけど、まずコードとしてはこんな感じです。

続行を結構入れるのが好きなんですけど、今回は続けたときにこうして……。で、透明度は0.5でしょ。この辺のパラメータがマジックナンバーになっているのが非常に気になるところです。例えば、シンボル数として、`body`でしょ。この`body`の`opacity`というのがあるんだけど、これはまあいいでしょう。これもちょっとね、面白いことができたらいいのかなという気がします。アングルを生成するイテレーターみたいなのを作って……まあ、それは無茶な話かな。そんなに強い動機もないし。

例えば、`body`の中で360度回していくから、要素数……何だろう。イテレーターを作る必要はないかな。これは無理やりになっちゃいますからね。ここは一旦`ForEach`で走りましょう。

じゃあ、これでコードが一通り書けた気がするので、ちょっとプレビューが怪しいですが、いきますか。あ、`scaledToFit`だって。これ忘れてる。`ForEach`ビューで……あとは、`ZStack`に`scaledToFit`。どれの`body`かというと、バッジの`body`。ここですかね。あ、これでいいじゃない。よかった。全然違うね。逆になっていたのが気になってたけど、これで良しです。

`body`の`ZStack`に`scaledToFit`、これは理屈上間違ってなさそうですね。で、`GeometryReader`が入ってきて、ちょっとイテレーターが回っていってますが、これはしょうがないレベルですかね。`geometry.size`を使いまくっていて、何も悪いことはしていないんですけど、これを一般に、今のコードでは`bounds`と呼んでいるところを踏まえると、`bounds`に縛られちゃうってのもありますよね。名前はね、`geometry.size`。そうすると最初の時点で、この時点で`bounds`に縛られていて、4分の3……うん、まあいいか。これはいいですね。大丈夫かな。

掛け算は入れ替えても大丈夫という性質がありますよね。どうしようかな。これは人によるんでしょうけど、メリハリをつけてるのかな、掛け算と割り算でね。まあそういった意図もあるかもしれないですけど、その辺はどっちでも大丈夫かな。そんなこだわりではないということですかね。はい、これでOKかな。

4分の1とか、この辺のマジックナンバーが気になるなら、これを外から渡すか……外からか。バックグラウンドとシンボルのね、この一番上だから外からで正しいですね。 次のステップに行く前に、追加した新しいファイルをすべてバッジグループに入れましょう。バッジ系のコンポーネントをグループ化します。自分は今、バッジ系を1つのファイルにまとめました。バッジ系は1つのコントロールとして扱い、この中で外から使えるものはバッジだけにします。その内部で細かいバックグラウンドなどを使う、という構成です。これは悪くないと思いますので、このまま進めます。はい。では、先ほどの整理は不要になったということで、ここでいったん終わりです。

ここからはクイズです。読み取り問題として、シェイプの型とポジション、アプリケーションの構造の中でのシェイプビューの型と位置を識別します。外側からは自動的に読み取れるようにして、動的にポジションを描画したり、横に並ぶビューに合わせて調整したり、バッジに数字を付けたりするケースを想定しています。リユースする際には、アプリ内で異なる表示にも対応できるようにします。サイト側でも適切な表現になるよう、動的に色分けします。下からイエロー、オレンジ、レッドという並びのパターンです。これは1番目の選択肢ですね。レッドスタックなので、順番にパターンになっていくはずで、きっと1番目です。例が強烈ですが、大丈夫でしょう。バックグラウンドでしょう、いや、これですね。では、`Submit`。正解でした。

次の問題です。どんなシェイプが描画されるか、というものです。難しいですね。X が 20、Y が 0 に移動して、そこから X はそのままキープされたまま Y が 200 へ移動します。あのパスは上からでした。 その後、このパスを描いて、`fill` でグラデーションを塗ります。グリーンからブルーへ。`startPoint` は x が 0.5、y が 0、`endPoint` は x が 0.5 のままで y が 1。ということは、緑から青へのグラデーションは垂直方向に描かれるはずですよね。合っているのかな、と少し自信がなくなってきました。

いきなり三角形と言われると混乱するので、`move` でもう一度見ておきます。`(20, 0)` にムーブして、その後 `line` で `(20, 200)`、次に `(220, 200)`、さらに `(120, 0)`。これを結ぶので四角形になりますね。正方形ではなく、平行四辺形です。

ビューとトランジションについても触れておきます。移動のチェーンのような感じで、ビューのアニメーション（跳ねたりする動き）と、トランジション（例えば、矢印が下に回り込むような見せ方）があります。こういったものは `SwiftUI` を使うことで、ビューの変更アニメーションを付けられます。さらに、ドキュメントには「エフェクトが発生する場所に関係なく、ビューやビューの状態の変更を個別にアニメーション化できる」と書かれているのですが、正直まだ意味を掴みきれていません。英語のニュアンスがわからず、うまく読み取れていないところがあります。とにかく「個別にアニメーション化できる」という話題だ、というくらいの理解にとどまっています。

今日はシンボルが、個人的にはいい感じに整えられたかなと思っています。エフェクト周りは、まあしょうがない部分もあります（ネガティブな意味ではないです）。それで、バッジをこうやって、例えば「8回回すよ」というパラメータも、必要に応じて外側から渡して、回転回数を制御できるようにします。もっとも、バッジからしか使わないので、`FillStyle` みたいなものはパブリックにしなくても、バッジ側で適切に制御して、今回で言えば正しい紫色を指定してくれる、という感じですね。

それから `opacity` も、場合によっては明示しておきます。`opacity` は `Double` で扱って、変な値を与えないようにしておきます。その上で、プレビューのところで「不透明度で挙動を見ようか」といったことを考えるのが自然ですよね。これで良いと思います。シンボル数ももう少し調整できました。回転も指定したいところですが、`360` などいろいろあるので、その辺の加減はお好みで。`padding = -60` といった指定も、今回は外側から渡せるようにしておきます。`padding` は `CGFloat` のインターフェースにしておくのが重要で、初期値は `Double` リテラルで指定していても型としては `CGFloat` に寄せます。さっき一瞬おかしな挙動が出たのですが、反映タイミングの問題かもしれません。`-60` にしても期待通りでなかったりしましたが、まあ今回は良しとします。とにかく、外から変更できるようにしておくのがポイントです。

こういった名前の付け方も見直しました。今回はイニシャライザーなので、プロパティと同じ名前の引数をそのまま使うのがデザインガイドライン的に適切です。省略できるものは後ろの方に置く、という価値観で並べれば大丈夫でしょう。シンボルは一通り手を入れたので、この辺はもう大丈夫だと思います。いわゆるマジックナンバーも、名前を付ければ問題ないですし、名前を付けるほうが読みやすいです。

あとは `makeTopPortionPath` と `makeBottomPortionPath` のほかに、もう1個関数が並ぶと気持ちよさそうだなと思ったので、パスの隙間を移動させるだけの処理に名前を付けることにしました。`makeSpacingPath` にしましょう。`makeSpacingPath` の引数はパスの `inout` で、`Path` を受け取って編集する形にします。さっきコピーした処理を持ってきて、コンパイルエラーが出ないようにシグネチャを合わせて、用語や構造が崩れないようにしました。これで「バッジのパスはトップ部分とスペーシング部分とボトム部分で構成されている」と読めるようになり、可読性が上がりました。

そのほかのコードも、そこまで悪くないと思います。各種パラメータ（例えばスケールなど）も読みやすいですし、割り算を含む計算式も妥当です。パスを作って、最後にグラデーションで塗っていく、という流れも問題ありません。`make*Path` 系はさっき見直したとおりです。

こんな感じで、いろいろ整いました。今日はここまでにします。次回は、アニメーションとトランジションの辺りを見ていくことにしましょう。お疲れ様でした。
