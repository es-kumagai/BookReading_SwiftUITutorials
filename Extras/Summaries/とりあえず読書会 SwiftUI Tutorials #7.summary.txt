Transcription & Summarize : とりあえず読書会 SwiftUI Tutorials #7

はい、では今日も「とりあえず読書会」を始めます。読み進めがだいぶ進んできて、実際にコードがいろいろ書けるようになってくると、自分が勝手に今やっている SwiftLog 対応とぶつかるところがいろいろ出てくるような感じになってきて、それはそれで面白いなという感じです。そういった点が有意義だなと思いつつやっておりますが、そのあたりも楽しみにしながら、どうやって SwiftLog に対応しつつ SwiftUI アプリを組み立てていくか、という感じで遊んでいってみましょう。

今日はお気に入り機能ですね。これをいよいよ作っていくという感じになってきて、まずはお気に入りボタンをそれぞれのランドマークに対してつないでいきます。ランドマークアプリでは、お気に入りのフィルタリングはできています。今のところは JSON から渡される「お気に入りかどうか」の情報を基にしてリスト内でフィルタリングをかけている状況です。ただし、お気に入りのランドマークの状態はまだ固定のまま、つまり JSON 側に固定値として載っているだけで、アプリ上から変更はできません。実際に JSON コードに `isFavorite` がハードコードされているわけではないにせよ、アプリから変更できない状態である、という意味合いですね。

そこで、ユーザーが「お気に入りを追加したり、解除したり」できるように、`FavoriteButton` を `LandmarkDetail` ビューに追加していきましょう。再利用可能なお気に入りボタン、つまりリユーザブルな `FavoriteButton` を作っていきます。この「再利用」というパターンは大事ですよね。やろうと思えばできそうなのに、意外と再利用すべきところでできていない、というのはよく見かけます。まずは、再利用とは何かをイメージしつつ、それを意識してコードを書いていくしかないかなという気がします。というわけで今回は、`FavoriteButton` を「再利用」を目的に作っていきます。

まず `FavoriteButton` を作って、その後に `isSet` をバインディングで扱えるようにします。これは現在の状態を示すインジケータの役目も果たします。`Preview` では暫定的に定数のバインディング（たとえば `.constant(true)`）を渡して動作確認をします。あくまでサンプルとして定数を使うだけで、本質的に定数である必要はありません。

バインディングプロパティはプロパティラッパーの `@Binding` ですね。これは、永続するデータ（モデル）のプロパティの読み書きと、それを表示・変更するビュー側を連携させるための仕組みです。これによって、ビューからモデル側の状態を直接いじるのではなく、双方向に値がつながる形で変更を伝えていくことができます。そんな感じで、まずは `FavoriteButton` を `isSet` というプロパティをもとに作っていきます。

ここまでの流れとしては、新たに SwiftUI のビューを作り、その中でボタンを用意します。プロパティとしては `@Binding var isSet: Bool` を持たせます。この `isSet` が `FavoriteButton` と外側の状態をつなぐ役割を果たします。`FavoriteButton` のプレビューでは、このバインディングを渡さないといけないので、とりあえず `isSet` に対して定数のバインディングを渡しています、という状況ですね。まずはここまでにしておきましょう。

実装に戻って、ボタンを作ります。`Button` に `action` を持たせ、ブール値の `isSet` をトグルするようにします（たとえば `isSet.toggle()`）。こうして変更が状態に反映されるようにします。ボタンのラベルとして提供したタイトル文字列は、SwiftUI の表示では非表示にでき、たとえば `.labelStyle(.iconOnly)` を使うとアイコンのみが UI に表示されます。ただし、そのタイトル文字列は VoiceOver などのアクセシビリティ機能が読み上げるために使われます。VoiceOver は、画面上の要素を音声で案内する機能で、どのボタンが選択されているかなどを音声で伝える際に、このテキストが用いられます。ここは重要なポイントだと思います。 今回は、ボタンを `isSet` でトグルする形をとって、トグルするコードは `Label` を使います。システムイメージとしては、`isSet` だったら `star.fill`、そうじゃなければ `star` を使います。ラベルスタイルはアイコンだけにしておき、`foregroundStyle` で色を変えます。「ああ、ここで色を変えるのか。前回は少し外側で色付けしていたのがダメでしたね。」という気づきもありましたが、ダメなら直せばいいだけなので大したことではありません。とりあえずこの辺を作っていきましょう。

まずはボタンを用意します。`body` に `Button` を置いていきます。ボタンの中で、最初はラベルから書いていく想定です。SwiftUI で少し迷うのは、最初のブロックがいわゆるラベルなのか、それともアクションなのかが、イニシャライザによって違うところです。ここは少しわずらわしいと感じることがあります。ともあれ、`isSet.toggle()` するようにして、ラベルとしては `Label("Favorite", systemImage: isSet ? "star.fill" : "star")` とします。

これだけだと、右のプレビューにラベル文字も出てしまうので、`labelStyle(.iconOnly)` にしてアイコンだけを表示します。ここで色を付けます。前回は外側で色付けしていましたが、今回はここでやります。

前回作ったのは `Star` でしたね。同じように再利用をイメージして `StarImage` というビューを作り、そこで黄色を設定したのですが、これだと全然再利用できる感じになっていません。`systemName` が `star.fill` 固定ですし、`StarImage` をうまく使い回せていません。どうしようかというところですが、最適解が見えないうちは、無理にまとめても良いとは限らないので、とりあえずこのまま進めます。

押したときには、`Label("Favorite", systemImage: isSet ? "star.fill" : "star")` を使って、`isSet` のときに星のイメージが変わるようにします。ラベルは `labelStyle(.iconOnly)`。色は状況によって変わるはずなので、`foregroundStyle(isSet ? .yellow : .gray)` としておきます。これでできた、ということでしょう。`isSet`、`Favorite`、`foregroundStyle`、`FavoriteButton`、`Label` を使う感じですね。

それから、例えば `StarImage` がありますよね。`StarImage` を作るときに、`Image` ってラベルみたいなのを付けられないのかな？ えーと、なんて言うんでしたっけ。 さっきの音声で操作するやつは、VoiceOverですね。VoiceOver にはアクセシビリティのラベル、つまり `accessibilityLabel` があります。これを付けてあげれば、かなりいけるのではないかと思います。もう一度チュートリアルを見ますが、この中の「ラベル」というのは VoiceOver で使われるものですよね。参考にしてくれるラベルだということなので、VoiceOver で調べてみると、対応方法の話が出てきました。

VoiceOver の仕様として、フォアグラウンドにイメージがあって、テキストがあって、という感じで扱われます。タップするとイメージの名前が読み上げられるといった説明があるのですが、これだけだと自分の期待とは少し違うかもしれません。対応しないと無言になってしまうことがある、といったことも書いてあります。ここで、「ラベルにイメージを含む場合の VoiceOver」や「ボタンのラベル」などの記述を見ましたが、求めているものと完全には一致しません。やはり VoiceOver の API をもう少し知りたいところです。

「VoiceOver の基本」を読めばいけそうです。アクセシビリティの話ですね。イメージ（`Image(systemName: ...)`）に対して `accessibilityLabel` を付けないと、画像のリソース名がそのまま読み上げられてしまいます。これは重要なポイントですね。さっきはボタンの中でラベルを使っていましたが、イメージの場合も同様に `accessibilityLabel` を指定すればよさそうです。

あとはボタンの種類などで、`accessibilityAddTraits(.isButton)` のようにトレイトを追加するかどうかですが、細かいところは今回は無理にやらなくてもよいかなと思います。`accessibilityAddTraits(.isButton)` を付ければよいのか、という確認はしつつ、まずは `accessibilityLabel` からやってみます。とりあえず概ねイメージは掴めたので、正しくできているかは置いておいて試してみます。

前回作った `StarImage` をせっかくなので再利用したい気持ちがあります。再利用が罠になる可能性はありますが、「星を表示する」というパターン自体は変わらないので、これをボタンとして使い、ラベルを付けてあげればよいのではないかと思います。`star.fill` を使うかどうかは `isFavorite`（あるいは `isSet`）のようなブール値でオン・オフが決まり、オン・オフに応じてイメージ名と色が変わる、という点は明確です。

今回はどこまで汎用化するかにもよりますが、`StarImage` としては、オン・オフだけを外から与えて有効状態を切り替えられれば十分かもしれません。色を自由に指定できるようにするより、ブールで制御したほうが融通は利かない代わりに、このアプリケーションでは使いやすくなる気がします。

プロパティの宣言は、例えば `@State` でいいのか、`private var` にするのか、`let` ではだめなのか、まだ少し判断がついていません。`Binding` は双方向ですよね。このあたりはまだ完全には把握できていないので、まずは動かなくてもいいや、という気分で進めてみます。 まずは普通のプロパティにしてみます。今回は `isActive` にしましょう。`Bool` を持たせて、この `Bool` に応じて星や色などを変えていくスタイルにします。

次に `Image` のシステム名ですが、`body` 内でいろいろやってもよいものの、計算型プロパティにするのが良さそうです。拡張（`extension`）にしてもよいですが、内部でしか使わないので `private extension` にしておきます。この中で `var systemImageName: String` を用意し、値は `isActive` かどうかで分岐します。アクティブなら `star.fill`、そうでなければ `star` といった感じです。

さらに色も用意します。`foregroundStyle` に渡すカラーとして `Color` 型のプロパティを作り、`isActive` のときは `Color.yellow`、そうでないときは `Color.gray` を返すようにします。これで既定の色を決めたうえで、`Image(systemName: systemImageName)` に `foregroundStyle(color)` を適用します。

アクセシビリティラベルも付けたいところですが、この `StarImage` が何のためのイメージなのかが曖昧なので、ここではいったんアクセシビリティは考慮せず、必要なら外側で対応することにします。

とりあえずこれで形になりました。`StarImage` の `isActive` を `true` にすると黄色の星が出るはずです。両方見比べたほうがよいので、`Group` にして `StarImage(true)` と `StarImage(false)` を並べて表示してみます。

ところが、`Landmark` でエラーになりました。他の箇所でもエラーになっているので、まずはそちらを直します。`StarImage` がアクティブかどうかは、たとえば `isFavorite` で判断できる条件なので、`isActive` は `true` にしておきます。`false` のときにグレーの白抜きの星を出すべきかどうかはまだ仕様がはっきりしていませんが、とりあえずこれで表示はできました。`false` ならグレーの白抜きの星、という感じです。

ここまでできたら、さきほどの箇所に戻る前に、`isSet` かどうかで `true/false` を指定するのもよいのですが、この `StarImage` は2パターンだけなので、切り替えをもう少し簡単にしましょう。拡張に限らずどこでもよいのですが、`static let active` と `static let inactive` を用意し、それぞれ `StarImage(isActive: true)` と `StarImage(isActive: false)` をあらかじめ作っておきます。こうしておくと `StarImage` を簡単に初期化できます。今回のように2パターンに意味がある場合は、これでよさそうです。

そして `isSet` の状況によって切り替えようと思いましたが、これはブール型ですね。わざわざ別のものを作らなくても、そのまま出せばよいことに今気づきました。 ここでラベルとして…何でしたっけ、スターイメージ。作らなくてよさそうです。いつアクティブか、いつセットか、これでいいですよね。本当に。ラベルはいらなくて、それでバランスしてもいらなくて…。あ、そうだ、VoiceOver の対応ですね。ここにボタンがあるので、このボタンに付ければいいはずです。きっとね。アクセシビリティのラベルとして、`Toggle Favorite`。多分これで大丈夫です。とにかく、アクセシビリティのためのラベルが `Toggle Favorite` で、表示としては、黄色で塗った星か、グレーで白抜きの星かを、`isSet` によって切り替える、という形でできている気がします。では、これでいってみましょう。

プロジェクトを進めていくために、フォルダの階層を作る方法がある、という話でしたね。タイトルイメージ…ではなくおそらく `CircleImage` と `MapView`、それから `FavoriteButton` を、ヘルパー的なグループに入れてあげる、ということらしいです。そして、`LandmarkView` は Landmarks グループに入れてあげる。今どうなっていましたっけ…ええと、Views の中に Landmarks と Helpers を作ってあげる、ということですね。あ、「Helpers」という名前か。なるほど。

とりあえず、Views の中にフォルダを作ります。今は「グループ」ではなく「フォルダ」と言いますね。これで Landmarks と…あ、そうか。こう作ってしまったけれど、選択して増やしていけばいいですね。あと、ちょっとランドマーク系を移しますか。ランドマーク系と、`CircleImage` と `ContentView`…あ、`ContentView` は違いますね。`CircleImage` と `FavoriteButton`、`MapView`。スターイメージでもそうですかね。これらをフォルダに入れる形にします。

それから、これは Helpers…というより、名前はどうしましょうね。「ヘルパー」とは言わない気もしますし、ライブラリではよく「Controls」を見ますよね。では「Controls」でいいんじゃないでしょうか。コントロールにしてみます。うん、こんな感じで。フォルダ分けはソフトウェアの動作に影響しないので、これで良いでしょう。ではフォルダ分けはとりあえず完了ということで、先に進みます。

次に `FavoriteButton` を `Detail` に加えます。`isSet` プロパティを `isFavorite` プロパティへバインディングします。そのために `LandmarkDetail` でインデックス…`landmarkIndex` ですね。悪くない名前だと思います。そして、`firstIndex(where:)` で取得する、と。なかなか大変なことをさせてきますね。いいのですが、ランドマークのデータが `ModelData` の中にあるとは、このコードだけでは保証できていません。これは大事な気がします。そこは考慮しておくべき段階ですね。ロジックエラーでもよいのですが、まだ早いかな、外に任せたほうがいいかなという気がします。

とにかく、`LandmarkDetail` のところで環境の `ModelData` を持つ、というのは良いですね。そこでランドマークのインデックスを取得するプロパティを作っておく、という話でした。ただ、さっきはワクワクして書き始めましたが、ちょっと早いですよね、まだ。なので、`landmarkIndex`（この名前もちょっと気になりますが、間違ってはいないので良いでしょう）は、この段階ではオプショナルにしておいたほうがいいのではないでしょうか。`ModelData` の中の `landmarks` に対象のランドマークデータが必ず入っているとは限らないからです。逆に、必ず入っているのだとしたら、ここで `landmarkIndex` を最初からもらってしまえばいいわけですよね。環境があるわけで、どちらが良いかは後で書き換えます。 とりあえず今はいいとして、ランドマークのインデックスを取るにしても、モデルデータの中にランドマークの配列である `landmarks` があるので、それを取れるようにしておきます。`landmarks` を使い続けることで、その中の `firstIndex(where:)` を使ってインデックスを探していきます。具体的には、`firstIndex(where: { $0.id == landmark.id })` のようにして、ランドマークの `id` と `self.landmark.id` を照らし合わせれば大丈夫です。特に間違ってはいないのですが、少し紛らわしいので、クロージャの引数は省略して `$0.id == landmark.id` と書いたほうがすっきりします。

Swift 公式のドキュメントのどこかに、Swift では `self` を明示的に書くことはそうそうない、というようなことが書いてあります。なので、基本的には Swift では `self` を省略するほうが理想的みたいです。実際、コードを書いていても、`self` をやたらと書かなくてもいい言語なので、省略していくのがうまいやり方だと感じます。

このようにしておくことで、モデルデータの中に該当するランドマークが存在するならそのインデックスが手に入り、存在しなければ `nil` が返る、という状態を作り出すことができます。こちらのほうが強制アンラップよりも良いはずです。強制アンラップ自体が悪いわけではありませんが、先ほども言ったとおり、モデルデータ内のランドマークリストに、ここで渡されてきているランドマークが必ず含まれているとは限らない、という前提を尊重するなら、強制アンラップするにはまだ早い、という状況ですね。

ランドマークはちゃんと用意されているので、ここでモデルデータ中のランドマークを渡し、かつ Environment としてモデルデータを渡します。このコードだけを見れば、そのモデルデータを参照元として使っているので悪くはありません。ただ、私としてはこれだけだとあまりよろしくないかなという気もします。とはいえ、今のところはオプショナルを使っているので大丈夫そうです。では、次を読んでいきましょう。

次のステップとして、`body` プロパティの中でモデルデータを使い、バインディングラッパーを使う、という話になっています。これを進めていくと、まずは `HStack` を使います。ここにランドマーク名と Favorite（お気に入り）を入れていきます。どこまでやるかというところですが、ひとまずランドマーク名を `HStack` に埋め込みます。

“Embed” はどこだったか…Refactor でしょうか。いえ、Refactor は大げさですね。フォーマットでもないし……ここではなかったかな。Editor > Embed…あれ、ショートカットは何でしたっけ。忘れたときはヘルプで検索ですね。“Embed” が見当たりません。もしかして丸括弧を選択しているせいでしょうか。丸括弧ではない箇所を選んで……やはり Refactor ではないですね。Navigator でもない。どこだったっけ、という感じです。単に自分が見つけられていないだけですね。いかん、しょうがない、というところです。 とりあえず `HStack` を使ってやってみます。`HStack` に埋め込んで、その中に `Button`、`Spacer`、`Button`、`Spacer`、`Button` という感じで配置します。

そして、`FavoriteButton` の `isSet` に対して `Binding` します。`Environment` から取ってきたモデルデータ（`ModelData`）の中のランドマークの `isFavorite` を使っていく、という話です。ここはモデルデータの中の `landmarkIndex` を使わないといけません。ランドマークそのものだけではダメですね。結局、`landmarks[landmarkIndex]` に対して操作する形にする必要があります。

では、`Binding` したものを返すようにすればいいのでは、という発想で進めます。ランドマークそのものではなく、戻り値として `Binding<Landmark>` を返せばいいのかな、と。ただ、実際にはモデルデータの `landmarks` 配列の任意要素に対する `Binding` を返すことになるので、その組み立て方を考えます。

`Binding` で `landmarkIndex` が作れないかどうかを試してみます。ここは「`Binding` に対して渡していく」というスタイルを取っているコードですよね。つまり、`isFavorite` を `Binding` で渡す形です。モデルデータの `landmarks[landmarkIndex].isFavorite` にアクセスしたいのですが、`$`（ドル記号）がスコープにない、という問題が出ます。`$modelData` が見えないと、`Binding` の set に渡せない、ということになります。少しややこしくなってきました。

ひとまず実験として、`landmarks[0].isFavorite` に `$` を付けられるかを試してみます。ただ、ここでも「`$modelData` がない」という話になります。であれば、`Binding` に対してどう渡すかを、イニシャライザで返すなどの形で色々試してみます。

ということで、いったん計算型プロパティの `get`/`set` で組み立ててみます。`get` では対象のランドマークを返し、`set` では `ModelData.landmarks[index] = newValue` のように代入するイメージです。ただし、`ModelData.landmarks` を `private(set)` にしていると外側から書き込めません。`Binding` として外から更新できる必要があるため、ここは `var` にして書き込み可能にしておく、というのが一般的かもしれません。このあたりはアクセスコントロールの調整が必要です。

SwiftUI では特定のランドマークが選択されるので、それに応じてこの `FavoriteButton` を、そのランドマークの `isFavorite` にバインドする形にします。つまり、`FavoriteButton(isSet: $modelData.landmarks[landmarkIndex].isFavorite)` のようなイメージです。ここで、`landmarkIndex` がオプショナルになっていました。とりあえず今は強制アンラップで対応しておきます（あとで直します）。

これでビルドを通してプレビューします。今ランドマークの詳細を表示していて、星のアイコンがあります。星を押すと色が変わり、もう一度押すと元に戻ります。色が付いたり消えたりしてくれればOKです。ちゃんと動いている予感がします。もしダメならその時に動かなくなるので、そこから直していけばよいでしょう。

とりあえず `Binding` を組んで、`landmarkIndex` とモデルデータを使って更新できるようにしました。そんな感じで進めて、ステップ7まで行っておきました。 それで、ランドマークリストに戻ります。ランドマークリストのお気に入りのオン・オフを、ライブプレビューで確認していきます。ナビゲーションでリストからディテールビューへ移動し、ランドマークディテールに戻る動作も含めて見ます。

ランドマークリストがここで値をちゃんと持ってきているかが少し不安になったので確認します。プレビューは `Environment` でモデルデータを渡していて、モデルデータはその先でバインディングしていますね。大丈夫そうです。たとえば、このプレビューから、今のところいろいろある中で、一旦はお気に入り周りに絞って試しましょう。この中で、お気に入りをオフにしてみます。これで、バインディングのルール――値を変更できるようにする仕組み――が効いているかを見ます。

バインディングは、単に「受け取る（receive）」だけではなく、読み書きできる参照を渡すものです。もし受け取るだけでよければ `@Environment` で十分ですが、書き込みが必要なら `@Binding` が必要です。バインディングは値のストレージを参照し、異なるビュー間で同じデータを読み書きできるようにするためのリンクだと考えるとよいでしょう。複数のビューで値を共有し、変更を反映させます。あれこれ比較の細かい問題を気にしすぎかもしれませんが、今回はこれでよしとします。深追いはしません。

プロパティラッパーについても整理しておきます。データの値を状態として扱うのが `@State` です。`@State` のプロパティは基本的に `private` にし、デフォルト値も持てます。この点は重要です。

これでひと通りできました。次は次回、次のセクションへ進むことにします。

ただ、やり残したことがあるので触れておきます。先ほど話したとおり、今のところの `DetailView`（`LandmarkDetail`）の設計では、`Environment` によってデータを渡したときのプログラム上の挙動が複雑になってくる懸念があります。実際に、`landmarkIndex` はランドマークの配列から該当のランドマークが現れる場所を探しますが、見つからない可能性があります。強制アンラップするわけにはいかないので、オプショナルにしました。

`LandmarkDetail` の内部だけで完結している分にはそれでよいのですが、結局 `LandmarkList` を使ったときに、この問題を先送りにしてしまっています。`LandmarkList` や `LandmarkRow`、`LandmarkDetail` のどこかで、`landmarkIndex` が得られない可能性があるにもかかわらず、そこでどう扱うか――たとえば、該当するランドマークが見つからないときにお気に入りボタンを出さないだけでいいのか――を判断しないといけません。ここは方針を決める必要があります。 ただ、それも少し変ですよね。`LandmarkDetail` をどこまで汎用的にするのかという話です。そう考えていくと、`landmarks` の中に必ず該当するランドマークがある、という絶対的な前提を持っておくことが、今回のアプリにとっては大事になってくるはずです。

そのときにどうするかという手としては、チュートリアルにあった通り、ここで強制アンラップ（`!`）してしまう方法があります。これによって、「`landmarks` には必ずランドマークがあるのだからインデックスが取れる。先送りする必要はない」という前提で書けます。ただし、そうするとインデックスはオプショナルではなくなります。一方で、間違ったものを渡したときには落ちてしまいます。

ではどうしようかというと、1つの方法としては、`Environment` がいつ渡ってくるのかという点はありますが、`body` の中で「間違ったランドマークが渡ってきました」というメッセージを出すやり方が考えられます。ただ、それをやるためには `FavoriteButton` を出すかどうかの問題もありますし、それ以上の問題もあります。結局、`FavoriteButton` を出すかどうかを判断するということは、「含まれていないことも許容したビュー」にするということで、最初の問題、ここでのビックリマーク（強制アンラップ）をどう扱うかという話と変わらなくなってきます。

そうなると、含まれていなかったときには「ランドマークがありません」という扱いにして、ディテールを表示できないようにする、これも1つの手です。コードとしては、例えばこの `ScrollView` を出す前に、ランドマークのインデックスがちゃんと取れるなら `ScrollView` などを表示し、そうでないときには「指定されたランドマークが見つかりません」といった `Text` を出して、それだけで終える、といったスタイルが考えられます。

ただ、そこまでしなくても今回は妥協できるかもしれません。あくまでも今書いた方法だとランタイムの段階で判断するので、ユーザーがその状況になってしまったときには「何もありませんでした」という表示を見ることになります。それはそれでよいかもしれませんが、あまり好ましくないかなという気もします。

そうすると考えられるのは、ランドマークが渡され、モデルデータもあるという状況の中で、このランドマークがモデルデータの中にあるのなら、インデックスを受け取れば十分ではないでしょうか。 なので、書き換えてみましょう。ランドマークのインデックスを取る。ディテールは必ず何かしらのランドマークを表示する、というのを大前提にするのだとしたら、このようにするとランドマークインデックスを計算する必要がなくなって、逆にここがランドマークですね。ランドマークは、実際のものに近い感じもしてきましたが、まあ大丈夫でしょう。ランドマークはモデルデータから得られます。

このときはバインディングですね。今回はバインディングしたいんです。ランドマークに対してバインディングを作り、その中でランドマークの中のランドマークインデックスを扱う。これは絶対にある、という前提でいきたい……と思ったのですが、一旦やってみたところ、メッセージ（エラーメッセージ）が少し雑でわかりにくいですね。ここでちゃんとメッセージを出してあげれば、落ちたときにとても助かります。

これでランドマークが取れるようになったので、このコードとしては、ランドマークの座標（coordinates）か、バインディングか……座標はバインディングから値を取るので、座標がありますよね。あ、バインディングになっちゃうのか。だから、値を取るのは `wrappedValue`（ラップドバリュー）か。少し微妙な感じがしてきましたが、`wrappedValue` です。まあ、しょうがないのかなという感じがしてきましたね。

ランドマークをこうするとバインディングが取れるようになった、ただ、バインディングの状態だとこのような有様になるので、もう少し工夫がいります。どう工夫するかというと、やり方はあって、ランドマークインデックスを取って、ランドマークがある。バインディングが必要なのは値を取りたいだけなわけですよね。だから、そのときだけバインディングを作ればよく、ランドマーク自体を常にバインディングする必要は特にないはずです。やってみます。ランドマークは普通にモデルデータのランドマークを返せばよく、ランドマーク自体も特にバインディングにしなくてよい。ランドマークのインデックスを返せばよい。そこまでは良くて、実はこの「バインディングを作るところ」で、`Binding(get:set:)` として、`get` のときにはランドマークの `isFavorite` を返し、`set` のときにはランドマークの `isFavorite` に値を設定する、というバインディングをここで作ればいいのかなと思いました。

イニシャライザのパラメータ（クロージャ）でそれをやればよいですね。`isFavorite`、これは丸カッコ……これはアンラップできないですね。`isFavorite` がランドマーク構造体で、ランドマークはゲッターしか用意していない（あるいは `private(set)` などで保護されている）ので、ああ、そうか。ゲッターとセッター、両方が必要です。スマートにいけるかと思いましたが、結構そうでもないですね。

ここは必ず大丈夫と踏んで、とりあえずエラーハンドリングをなくすのは微妙です。エラー処理は必要ですね。とりあえず `get` はそうで、`set` も同様です。`newLandmark` を取って、`guard` は欲しいですよね。ということでこう書いて、ここはリターンではなく `set` ですね。`set` に対して `newLandmark`。これもまた、ランドマークが読み取り専用になっているので、`get` と `set` を用意して、`newLandmark` にして、モデルデータのランドマークに `newLandmark` を代入する……という流れで、一通りできたつもりでした。

`get` と `set`、`willSet`、`get` と `set` キーワード、アクセスディフィニションとしてのゲッターとセッター……はい、こうですね。と思ったら、意外とエラーがある。セッターがまだエラーで、`self` がイミュータブル。`self` がイミュータブルか。これじゃダメですね。インデックスで捉えてうまくいくかなと思ったけれど、バインディングにちょっと邪魔されています。そうすると、バインディングをどこまで作ったらいいのだろう。

`get`/`set` で代入していく。この辺は良いとして、`isFavorite` ……ちょっと読みますか。あと、丸カッコがどう、ですね。`isFavorite` ここが、ええと、これでいいのかな。こうして、バインディングですが、丸カッコがない。確かに丸カッコがもう一個欲しいですね。これ、改行するとバランスが悪いのはどういうことだろう。まあ、でも、こうですね。

こうするとアサインの問題が残って、アサインのためには `self` がミュータブルである必要があるから、`isFavorite` に代入できますよ、という話になっていて、やっぱりそういうことですね。セットするのが最終的には環境オブジェクトなわけですよね。環境オブジェクトであれば、そのときにセットするのって、別にミュータブルでやる必要はないですよね。 ここで `nonmutating set` を使います。これを書いている人はあまり見ませんが、今回のケースでは良いと思います。これで、ランドマークに書き込むときも `nonmutating` で済むようになります。こうするとエラーが取れますよね。

それと、モデルデータの `landmarks` で1番目を渡していたところは、インデックスを渡せば良くなるので、`1` で良くなるわけです。つまり、`landmarkIndex` を渡すようにします。こうすると全体がうまくいって、表示も動くはずです。いろいろ変えたので微妙かもしれませんが……あ、エラーですね。他の場所でエラーが出ています。`landmarks` のところです。

`LandmarkDetail` を表示するときにランドマークのインデックスを渡さないといけない、というルールになっています。なので、`filteredLandmarks` の中でランドマークを直接参照するのではなく、ここで `filteredLandmarks` の `indices` を取り、そのインデックスから `landmarkIndex` を求めて渡します。ラベル側も同様に `landmarkIndex` を渡します。

ただ、ここでまたエラーです。`indices` が ID を持たないとか、non-constant range、整数の Range ではない、といった趣旨のエラーになっていて、少しよく分かりません。`indices` と `indices` のレンジではない、というようなメッセージで、腑に落ちない感じです。

重要なのは、今のところランドマークとランドマークの対応が一致しない、という状況は発生していないという点です。想定外の状況は起こっていません。ただ、コードの書き換えが複雑になってしまっているのが気になります。ここは整理したいところです。ランタイムで落ちるわけではありませんが、挙動としては失敗です。ボタンを押してもダメです。戻ってもマークが付いているから良いのか……。あれ、インデックスを間違えたかもしれません。

例えば、St. Mary Lake を押すと St. Mary Lake が表示されます。ここでお気に入りを解除すると、リストからいなくなります。Turtle Rock も同様です。お気に入り状態で開いて、戻るといなくなるはずですが、押せていないかもしれません。St. Mary Lake を選んで開き、戻ると、まだ St. Mary Lake がいますね。この状態でフィルターをかけて……押せない。リスト上で押せないので、少しスクロールして押してみます。Chilkoot Trail を押したところ、違うものが出てきました。ここが問題だと分かりました。フィルターをかけたときに、`LandmarkDetail` が `landmarks`（モデルデータの全体）を使っていて、`filteredLandmarks` を使っていないのが原因ですね。

`filteredLandmarks` は `LandmarkList` にいます。ここを考慮しないといけないことが分かりました。意外と影響範囲の見極めが難しいです。`favoriteOnly` は確かに `landmarks` の中で指定するものなので、`LandmarkDetail` にはインデックスだけを渡している今の設計だと整合が取れません。やはりこの辺りを考えると、インデックスではなくランドマークそのものを渡すほうが良いです。

`LandmarkDetail` がやりたいことは、そのランドマークに対してお気に入り状態を変更することです。ランドマークを直接渡せば、`favoriteOnly` のフィルタリングに引きずられず、期待どおりに動作します。`LandmarkDetail` を `Environment` にぶら下げるのは少し大げさです。インデックスを取ろうという発想なら `Environment` から取っても良いのですが、全体を連携させたいわけではないので、そこまでしなくても大丈夫です。 ここでは、ランドマークをバインディングとして受け取るようにすれば済む話ではないでしょうか。つまり、詳細ビューにはランドマークそのものをランドマーク型で渡してあげます。そうすれば、わざわざインデックスを考慮したり、ランドマーク用のプロパティを別に用意したりする必要はありません。エンバイロンメントを渡す必要のない「ランドマークとして渡すもの」として扱えばよいので、コードはかなりシンプルになります。

一方で、モデルデータのバインディングがどうなるかは検討が必要です。モデルデータがあって、`@State` で大丈夫かどうか、`first` がどうなるか、モデルデータを損なわずに「ランドマークの0番目」をバインディングで渡す、という方針も一案ではあります。また、プレビューでは `@State` 相当の値を用意して渡してあげれば問題ありません。

ただし、実装を進めると、ランドマーク詳細をちゃんと呼べていない箇所があるかもしれません。インデックスで渡していたところをランドマークそのものに替え、そこでランドマークを渡すようにします。こうすると `indices` などは関係なくなるのですが、フィルタ済みランドマーク（`filteredLandmarks`）に対しては少し工夫が要ります。`filteredLandmarks` をそのままバインディングにするべきか、やはりインデックスで扱うべきか、という論点です。

結論としては、必要なときにその都度フィルターする設計であれば、インデックスで回したい場合でも、バインディングを掛ける先は「フィルターされていない元の配列」側で探す必要があります。つまり、フィルターしていない `modelData.landmarks` から、詳細に渡したランドマークの `id` が一致する要素のインデックスを取得し、そのインデックスを使ってバインディング先を特定します。たとえば次のようにします。

- ランドマークのインデックスを取る: `let landmarkIndex = modelData.landmarks.firstIndex(where: { $0.id == landmark.id })`
- バインディングで渡す: `$modelData.landmarks[landmarkIndex]`

このやり方なら、リスト表示はフィルタ済みの配列を使っていても、編集のバインディング先は常にオリジナルの `modelData.landmarks` に向けられます。

エンバイロンメントについては、`@EnvironmentObject` の `modelData` を使い、詳細には `modelData.landmarks[landmarkIndex]` へのバインディングを渡します。プレビューでは、`ModelData()` を環境に注入しておけば問題ありません。

実際にビルドしてみると、見た目ほどスマートではない部分もありますし、ビルドやタイプチェックに時間がかかることがあります。タイプチェックが合理的な時間で終わらない場合は、UI を小さく分けるのも有効です。たとえば、お気に入りのみのトグル（Favorites Only）の部分を独立したビューに切り出します。

たとえば次のように、`FilterBar` のような型を作って `View` に準拠させ、`Toggle` を内包します。

```
struct FilterBar: View {
    @Binding var showFavoritesOnly: Bool

    var body: some View {
        Toggle("Favorites only", isOn: $showFavoritesOnly)
    }
}
```

こうしておけば、親側の `showFavoritesOnly` とバインディングして使えます。スプリットビューやリストの構成の中で、この `FilterBar` を置き、`showFavoritesOnly` をここにバインドして使う、という流れです。

まとめると、詳細ビューはランドマークをバインディングで受け取り、リストがフィルターされている場合でも、バインディング先の特定は元配列から `id` を使って `firstIndex(where:)` で求めます。エンバイロンメントは `modelData` を渡し、プレビューではダミーの `ModelData` を環境に設定します。ビルドやタイプチェックが重い場合は、`FilterBar` のようにトグル部分を小さなビューに分割すると改善が見込めます。最後に、`showFavoritesOnly` はこの分割したビューにバインドして使う、という形にすればよいです。 なので、これは `showFavoritesOnly` をバインディングにして、`var` から `$` にして…とやりたいのですが、そういうのはできないと思うんですよね。これくらいの規模だと、`List`（あるいは `ForEach`）の中の `NavigationLink` のところで、だいぶ根本的にやり方を間違えているのではないかという気がします。

その中でランドマークのディテールを扱うには、インデックスを取って該当するディテールを取り出し、この中で `DetailView` などを使う、という流れになります。ストラクトはひとまずここに置きましたが、名前はちゃんと分かるようにしたいですね。`extension` でランドマークリストに手を入れて、ランドマークリストに対するフィルタバーになるので、意味的には重要です。コード上は特に問題ないとしても。

それで、この `NavigationLink` の辺りをいじるのかどうか。結局これを外でやるといろいろ面倒になってくるので、中で頑張るのが一番よさそうです。インデックスを取って渡す部分のやり方が間違っているのではないかと思うんですよ。コメントアウトして確かめるとどうなるか…多分壊れましたね。やはりここが問題で、バインディングが、たぶんランドマークへの `Binding` を求めているのに、呼び出すときの渡し方がおかしい、という状況です。今のままだとややこしいですね。

方針としては、モデルデータのランドマーク配列（`ModelData.landmarks`）に対して、インデックス経由でアクセスする形にして、そこからどうするかを決める感じになります。バインディングを変える、つまりイニシャライザを上げてやるんですかね。やってみます。`init` で `Binding` を取りますよね。`Binding(get:set:)` でゲッターとセッターのクロージャを渡すやり方です。ランドマークへの `Binding` をつくるために、さっき見たとおり `ModelData` はモデルデータで、`ModelData` には `landmarks` という配列があります。これでいけるかなと思ったんですけど、ビルドをかけるとフェイルして、「`ModelData` が来たらダメ」という感じになります。`ModelData` は `@EnvironmentObject` であって、さっきは `@State` にしていましたもんね。そこがダメですよね。

この辺を何とかするには、やっぱりここでバインディングを `init(get:set:)` で明示的につくって、`get` としてクロージャを渡し、`set` としてクロージャを渡して初期化を終える、という形を取った上で、`modelData.landmarks[index]` を読む・書くように書いていけばよさそうです。まずはここを整理して、`get` では現在の値を返し、`set` では新しい値を受け取って `modelData.landmarks[index] = newValue` のように更新します。

これでビルドは通るかなと思ったのですが、困りましたね。`get` と `set` の型が合っていないようです。タイプチェックで怒られているので、この `LandmarkDetail` 周りが原因なのは間違いないはずです。では、いったん外に出してみますか。ランドマークの `NavigationLink` で必要な情報を、とりあえずラベルの前まで丸っと抜き出します。名前はひとまず `LandmarkDetailView`…は語弊がありそうなので、`DetailView` にしておきます。`struct DetailView` にして、ボディの中にさっき書いた処理を移します。

これをやるためには、`ModelData` が `@EnvironmentObject` として必要だとはっきり見えてくるので、`@EnvironmentObject var modelData: ModelData` を追加します。これで `DetailView` が `landmarkIndex` を受け取る形にするのがよさそうです。今 IDE で比較しながらやっていますが、`DetailView` が `landmarkIndex` を受けて、内部で `modelData.landmarks[landmarkIndex]` にアクセスする形にします。

ただ、こうやって書き換えていく中で、最初に「これは良くないよね」と言っていた状態に、少し戻ってきてしまっていますね。ここはもう少し整理が必要だと思います。 これは困りましたね。たとえば配列の中にインデックスがあったとして、そのインデックスを探し、見つからなかった場合にどうするのかという問題が出てきます。Environment で Landmark を探して、その詳細を表示して、一発で Favorite を Binding していく……という方針を考えています。ただ、Favorite を Binding するために Environment を使うというのは、少し微妙な気がします。DetailView 側で Landmark を取得できさえすれば大丈夫なのですが、それだと先ほどの話と同じ問題にぶつかります。`LandmarkDetail` がすでに Landmark を取ろうとしていますから、ここで何かが競合しているのでしょう。これは型推論の問題ではないですよね。そう思ったのでいったん元に戻します。

とにかく Binding をここに渡したいのです。たとえば、getter も setter も何もしないようなものを一旦渡してみると、これは多分うまくいくはずです。コンパイルが通らないのは、中身のコードが間違っているから、というタイプのエラーに見えます。ビルドをかけてみると……やはり失敗しますね。Binding 周りで失敗しているようです。

`Landmark` の中で、`Landmark` の Binding が欲しいのです。Binding で `Landmark` をバインドしないと Favorite と連携できなくなってしまうので、そこが最終的に必要です。これを渡したいのですが、`LandmarkDetail` があるとビルドが通らず、`LandmarkDetail` を外すとすんなり通る、という状況です。つまり、`LandmarkDetail` がある状態だとコンパイラが型推論できない、ということですね。

そこで、無理やりではありますが、強制アンラップの Optional にして、一旦ダミーのデータだけを用意して通す、といった形にすると、`Landmark` 自体の Binding はできているはずなので、ランタイムまで行かなければビルド自体はすっきり成功します。やはり、ここは型推論が問題になっていて、つまりコードの書き方が間違っているということです。これくらいの変更で推論に失敗するということは、どこかに無理があるのだと思います。

ModelData の中の `landmarks`（`ModelData.landmarks`）も出てこないように見えます。ただ、ここまでビルドをかけると差分がはっきり出てきますね。まずはそこで、どこがリンクできない（あるいは解決できない）と言われているのかを確認します。

アプリケーションを組み立てる際、こうして段階的に作っていくと、時々まったく動かない状態になってしまうことがあります。レイアウトが崩れたり、スタックの挙動がおかしかったり、警告がたくさん出たりと、クラッシュに近い挙動になることもあります。そういうときは無理をせず、いったん原因を小さく切り分けたほうがよさそうです。

Landmarks でも同様ですが、どうしようかなという場面で、何かプロパティを追加して調整したい気もします。やはり Landmarks の Binding を取りたいのです。Binding を取りたいときに、Environment から Binding を取る方法はあるのか、そこを調べたほうがよさそうです。自分の知識不足ですね。

SwiftUI で「Environment Binding」といったキーワードで調べています。普通に `Binding` を使ってアクセスする方法、`Binding.constant` は今回関係なさそうです。Environment を書き換える話や、`presentation` 関連（iOS 15 以降なら `@Environment(\.dismiss)` のようなラップドバリュー）も見ましたが、これをそのまま Binding に渡したいわけではありません。15 以降の話はまた別件になります。ここは一度 ChatGPT にも助けてもらおうかと思います。`Binding.constant` は今回のケースにはやはり関係ないですね。 エンバイロメントを使って取得した値や状態を、別のバインディングに渡したいと考えています。特に、`Environment` で取得したオブジェクトの中にあるプロパティを、別の `Binding` に渡す方法について確認したいです。常識的なことだと思うのですが、うまくできず困っています。

ポイントは、対象がオブジェクトであることが多い点です。このあたりも気になっていますが、ひとまず今はそういう構造になっているので、それに合わせて考えます。たとえばステートの中で `userName` が `Environment` のオブジェクト由来だとして、これをどう扱えばよいのかということです。`Binding` の `userName` に対して、`@State` の `userName` を渡す、という形にしたいのですが、対象のオブジェクトが `Environment` のオブジェクトの中に配列として用意されている `objectList` の2番目の要素で、さらにその要素そのもの、もしくはそのプロパティを渡したい場合はどうするのがよいのでしょうか。ここが知りたいところです。

手がかりが見つからないときには、こうしたチャット型の生成AIはとても助かりますよね。生成AIが出るまでは、ネットで調べて情報をつぎはぎして想像していくのが当たり前でしたが、今はうまくつないでくれるのでありがたいです。

やり方としては、`Binding` の `init(get:set:)` を使うのが一般的だと理解しました。`Environment` オブジェクトがアイテムを持っている場合、そのアイテムがあるときには、それを `Binding(get:set:)` の形で渡す、というやり方です。では、それでやってみます。

ただ、ここでタイプチェックが通らなくなってしまった、という状況です。ここまで来ると、もうダメですよね。クイックに場当たり的なバインディングを作るのは怖いので、もう少し丁寧に進めます。

まず、`get` としてはモデルデータの `modelData.landmarks` の、`landmarkIndex` で指している要素を返すようにします。`set` では、`modelData.landmarks[landmarkIndex]` に対して新しい値を代入する形にします。複数行にしてしまいましたが、一行にまとめるほどのものでもないので、いったんこの形で実装しました。これで `Binding` の初期化は完了です。あとは、これを渡してあげます。

ビルドすると、いきなりビルドがフェイルしました。構文エラーが複数出ています。全然別のところかと思ったら、該当箇所はここでした。`set` が終わり、`Binding` が終わる位置の直後の部分ですね。不要なコードが残っていたので、それを削除します。もう一度ビルドします。これで通ればよいのですが、ダメだったらプロパティに切り出す形にします。とにかく、またタイプチェックがダメになってしまったので、仕方ないですね。

ここで必要なのは `landmarkIndex` です。`landmarkIndex` で `landmark` を取ろうとしている状況になっています。どのように対処するかというと、`filteredLandmarks` と併せて、たとえば `targetLandmarkIndex`（`Int`）を持たせて、そこから `Binding` の `landmark` を返すプロパティにします。そこに先ほどのコードを貼り付ければ、`Binding` を返すスタイルにできます。

この形にすれば、`targetLandmark` のようなバインディングをちゃんと取得でき、呼び出し側ではそれを使えます。その際、インデックスを取得している箇所では、`landmarkIndex` がクロージャなどのスコープで正しく参照されているところを取っている、という流れになります。 なので、こうするとランドマーク…ここ、`targetLandmark`。`targetLandmark` にすると、かなりの箇所でいろいろな不一致が出ますよね。これでビルドをかけると、これは「missing pattern」…ファンクションですね。で、これでビルドをかけると、かなりの部分で不一致がいろいろ出ているはずで、ビルドが通るかなと思うんですけど、相変わらず重いですね。

ここが `landmarkIndex`。間違えた、`index` ですね。あと、これだな。変じゃない？ `targetLandmark`。あと `index`。これが SwiftUI データに書いてあるようなところですね。これで、あと `index` でいいですね。こういうふうにしてあげてビルドをかけると、これでどこまで行けました…と思ったら、API の名前を開発項でランドマーク…この辺の数字が違うね。`targetLandmark`、あと `index` として `landmarkIndex`。こうですね。こうすると、そろそろもう家のソーナーぐらいに上げてきてる気がするんだけど、ビルドの不一致の量の上ではね。でも、まだダメですね。ビルドのエラーが出てきます。「type-checking in reasonable time でできませんでした」。本当かな、これ。でも本当かも。何もね…。

`landmarkDetail` で `targetLandmark` と `index` でやってるよね。そうすると、あとはこの `index` ぐらい。この `index` も若干気になっていて、ランドマーク配列の中で最初のインデックスを取っている…あれはインデックスじゃないじゃんね。`firstIndex` になってないね。このせいか。型のずれ方はもう何もないよね。ランドマーク型がずれてるよね。インデックスを取りたかったつもりなのに、インデックスを取ってない気がする。これも待ってるからちょっと。

モデルのランドマーク配列の中でインデックスを取るときに、ID を指定してるじゃないですか。これをちょっと調整したくて。次に、ランドマーク型ですが、ランドマーク型の配列を定義してますよね。どうだっけ…アホだね。ランドマークの配列を定義してますよね。この中で ID を使ってインデックスを取りたい、みたいなときに、例えば `extension` をランドマーク配列に生やす。別に配列じゃなくてもいいから、`extension Collection where Element == Landmark` として、ここで `firstIndex(byID id: Landmark.ID) -> Index?` みたいな感じで、ID を渡して返り値をインデックスにする。この中で `firstIndex(where: { $0.id == id })`。シーケンスじゃダメで、インデックスアクセスができるかできないかなので、`Collection` ですね。`Collection` の中で `firstIndex(where:)` で `{ $0.id == id }`。オプショナルなので、見つからなかったら `nil` という想定がある。インデックスだから返り値は `Index` にして、ここも `id` は `Index`…じゃなくて、ID は ID、返すのは `Index`。こうしてあげると、クロージャじゃなくてよくなるわけですよね。

なので、`landmarkIndex` というのは、モデルデータの `landmarks` の `firstIndex`…いや、`byID` にしよう。`landmarks.firstIndex(byID: landmark.id)`。名前がさっきの `firstIndex` と被るのは変ですね。`landmarks` のほうは `byID` で。普通、ID は被らないですよね。理屈の上では被る可能性もありますけど、普通の解説なんでね。これは ID だから、`index(byID:)` で普通にいいですよね。

ということで、`index(byID:)` に変えて、`landmarks.index(byID: landmark.id)` として、こういうふうにしてあげると、ここはクロージャじゃなくてよくなる。クロージャじゃないほうが書きやすいのと、あとは `guard` 文で使うようなときに便利だったりするので。これでインデックスを取って、そのインデックスを渡してディテールに表示する。これが見つからないことがある、という可能性は残しますね。ただし `EnvironmentObject` の `landmarks` は必ず `landmarks` から情報を取っていて、そのランドマークの情報からインデックスを取ろうとしている、というところを踏まえると問題ないですかね。

`byID` は微妙かな。`index(byID:)` でもいいんですけど。もう1個考えられるところがあって、`func firstIndex(of landmark: Landmark) -> Index?` としてランドマークを取るようにして、返り値をオプショナルのインデックスにする。それで中身は `index(byID: landmark.id)`。これは `firstIndex(of:)` という Swift 標準の名前付けに近い使い心地になります。これでいいですね。これで必ずある…いや、ここはオプショナルなので `guard` で落として、標準 API でしょうね。これでビルド通るでしょ、きっと。さすがに。通りましたね。

だから今まで間違っていたのは、純粋に `landmarkIndex` をインデックスで取るはずが、ランドマークそのものを渡しちゃってダメだった、ということですね。`targetLandmark`、`targetLandmark` of `index`…もうちょっといっぱい出したような気がしますね。`targetLandmark`、`targetLandmark`。まあ、`target` って名前がよくないのか。バインドされてるランドマークが欲しいわけなんですけど、もうちょっと View の中で当たりがバチバチしてるじゃないですか。なので、ランドマークからバインドされてるランドマークを作りたい気がしますね。そうしたらバインディングされたものが取れる、というのもあるかと。難しいな。

あと、そういえば、Swift でいわゆる `Bindable` っていうの、なかったでしたっけ。 ふと今思い出したんですけど、あるかなと。`@Bindable`。これは何だったかなというのも含めて、`@Binding` と `@Bindable`。これらのプロパティラッパーについて見ていきます。`@Binding` と `@Bindable` プロパティは、開発者向けドキュメントでは「プロパティラッパー型でバインディングを生成する。Observable オブジェクトのミュータブルなプロパティに対するバインディングを作ることをサポートする」といった説明になっていました。バインディングを生成して、Observable オブジェクトのミュータブルプロパティへバインドする、ということですね。良さそうです。つまり、ここに入ればいいんだ、と。

`@Binding` と `@Bindable` は違うと思うので、違いの話は良いとして、今回は `@Bindable` プロパティにフォーカスしたほうが分かりやすい気がします。単純なケースとして、Observable な型があって、それを `@Bindable var book` のようにして…で、`Book` はどこから取っているんだろう。`@Environment` かな。`@Bindable var book` で `book.title` にバインドする、これはいいんですけど、`BookEditView` に `Environment` から `book` を渡して…まだ全部出てないのかな。他の記事にしますか。同じ記事を見ている気がします。親ビューから渡される、親ビューが渡しているところを見たけど、同じ記事ですね。Apple のドキュメントを見ておきますか。

`@Bindable var book` として `Book` に、`book` を渡しているので、`@Bindable var ...`。すごく魅力的なコードに見えるんですけど、`@Environment` で `book` を渡して、`@Bindable var book` で `book.title` をバインドしていますね。ナビゲーションまでいってしまっていいのかな。

例えば、`.bindable`、`var landmark = Landmark` にもできるかな。今は `Landmark` を使おうとしていますよね。`Landmarks` かな。`Landmarks` で、例えばモデルデータの `landmarks` で合ってる？ここまで書いたとして、これがダメだったら、wrappedValue が Observable に準拠していなきゃダメ、ということか。`ModelData` だったら Observable ですね。じゃあ `ModelData` を `.bindable` にしてみればいいのかな。`modelData = ModelData()`。ここまでは OK ですね。ここまでは OK で、例えば、これで `Landmark` に `targetLandmarks` を今まで渡していましたけど、これで例えば `modelData.landmarks` の…ここで `landmarkIndex` かな。そうするとどうなる？ビルドをかけてみますか。どうなるかな。すごいアクセスボードやってるけど、まあダメか。あ、通ったね。これでいいんだ。

そうすると、`@Bindable` で `ModelData` を作って、インデックスは計算する必要があるけれども、インデックスを取ったら `Landmark` のターゲットのね、あとは要らない、ということは、わざわざ `@Binding` を頑張るほどでもないけど、取ったやつは要らなくなって、これで OK か。そうすると `Landmark` に行っている `modelData` をいろいろやって渡せていて、インデックスが取れていて、あとは `modelData.landmarks.firstIndex(of: landmark)` か。`firstIndex(of:)`。ここがなんか長いなと今感じてしまったんですけど、自分でやったやつですね、これね。`modelData.landmarks.firstIndex(of: landmark)`。まあでも、これはしょうがないかな。うん、はいはい。なるほど。そうすると、これでできたかな。

で、これで今 `LandmarkList` ですね。`LandmarkList` だけど、これを例えばアプリケーションのほう、`LandmarksApp`。これのビューを出して、いろいろやってみれば動くかどうか分かりますね。ちゃんと快適にアプリじゃないか。今はコンテンツというか…これね、スマートになったのかどうなのかちょっと分からないですね。まあまあ、やってみましょう。とりあえず。で、こうして動けばとりあえず良くて。どうだろう。ビルドはどうでしょう。いろいろ細かいことを言わなくても良かった気がする。

で、この2番目ですね。今まで間違ってたの。これ。ビルドをかけて2番目のものを選ぶと、ビルドがかかってない時の2番目を取ってしまうという問題が起こってたんですが、今回は 89 と、どれいるかな。ちゃんと出てきましたね。これでアクションを発火させてあげると…あれ、セットアップ？あれ、ビルドの問題か。これは誰の問題だ。これはリンクができていないという、そういった問題になっている気がする。ちゃんと押してるよね。自分でね。押してると思うんですよね。ちょっとアプリを移動してみますか。ちゃんとシミュレーターで。シミュレーターは今入ってるか。入ってるね。バインドが失敗してる気がしてならないですね。 ちょっと実行してみます。えーと、シミュレーターはどこに行こうかな……シミュレーターは、えーと、あれですね。今、動くのを待っていますが、バインドが失敗しているのはやっぱりですね。さすがに、これでダメだったらまた次回で直しますかね。いろいろ改造しながらやっていって、うまくいくつもりだったんですけど、まあ、うまくいかない。そんなもんですかね。

これでとりあえず動かして、アプリは動いてくれるかな……。あ、パスワードを聞かれています。えーと、あれ、動いた。いや、パスワードを聞かれていたのは全然別の話でした。なので、シミュレーターが今動くところですよね、きっとね。多分、本当だと思っていればちゃんと動くんじゃないかなと思っているんですけど。あー、動いた。動きましたね。

これで、お気に入りをポチッと押すと動いて、2番目を押すと落ちて……えーと、バインドされていないですね。あ、これは何回押したかな。戻ると、いなくなっています。例えば、これを1回ポチッと押すと、あれ、落ちていますね。で、戻ると、あ、いますね。もう1回行きますか。これでポチッと押すと、あれ、消えますね。これ、もう1回入れる……あ、大丈夫ですね。

これ、フィルターをかけると問題なのかな。フィルターをかけて、ここに来て、ポチッと……落ちていない。この問題は、つまりバインドはできているけど反映されていないのかな。なんかすごい謎の問題が出ていますね。これを1回選んで、例えばこれで1回押すと、まだいますよね。これをもう1回押すと、いなくなりますね。なので、バインディングができているってことは、更新ができていないってことですね。なるほど。そうすると、ちょっといろいろと適当にやってきたところが仇になっている感じがしますね。では、この辺についてはまた次回にしますかね。なんとなく当たりもついているような気もしないでもないんですが、いや、一応キリが悪いので、ちょっと見ておきますか。なんかステップをちゃんとやっていないところがあるわけですよ。

お気に入りをクリックするっていうことは、まず`DetailView`ですね。そこは注目して見ておきます。`DetailView`の中で、星を押せるビューは`FavoriteButton`ですよね。これがランドマークの`isFavorite`とバインドしていますね。なので、ここでは`LandmarkDetail`の`landmark`がバインディングで渡されていて、`isFavorite`をいじっているので、ここはOKですね。ボタンのほうはとても良い。バインディングしているので、この中身は良いです。

そうすると、さっき適当に作ったバインディングの問題ですかね。`Detail`に渡すとか、リストのとかですか。`LandmarkList`の中でバインドがある、この辺ですかね。`Landmark`で、`ModelData`からランドマーク数で指定したインデックスを渡している。これ、バインドされていますよね。バインドされているっていうことは、バインドの影響がちゃんとあって、それで、これはリストですよね。だから、リストの中で`LandmarkDetail`に対してはバインドされているものがあって、そのバインドされているものが変わる……やっと考えられるな、その点だった。

なんか気になっていたのが、`ModelData`が`ObservableObject`じゃないですか。これが`ObservableObject`っていったら、`@Published`とかになっていませんでしたっけ。普通、`ObservableObject`……このドキュメントを見ていてさっきも思ったんですけど、このドキュメントそのままの例でいろんなブログが書いてあったじゃないですか。それでいうと、呼び出し元が書いていないっていうね、すごく不思議な解き方をしているのが気になりました。なんか、自分で何かの技術を理解するブログを書くときには、自分でちゃんとコードを書いたほうがいいですよ、多分。コピペとかしていないで。

Appleのドキュメントって、時々あるんですけど、例を作るために無理やりなコードを書くことがあるんですよね。その無理やりなコードで学んだとしても、結構理解の妨げになるようなことがあるわけですよ。いろいろ細かいこと、状況を作るときに楽にやるために`lazy var`みたいなのを使うコードが、確かそういったプログラミング言語のドキュメントの中で出てくるんですけど、普通そんなところで`lazy var`は使わないだろう、みたいな。`lazy var`ってすごく難しいキーワードなんですよ。このキーワードを使っていろいろ例を組み回したところで、なかなか理解できないんじゃないかなという感じがあって。理解できるのはその人はいいんですけどね。そういうのがあったりするので、このオブジェクトとかコードが、そのまままるっと同じに見えるんですよね。比べてはいないですけど、はっきりとは。こういったのは、あんまりおすすめしないですかね。まあ、いいか。 とりあえず `ObservableObject` で良いのかどうか考えています。これはこれで問題なさそうですし、`@Environment` でできていますね。`@Bindable var book`……って、これ本当に `@Bindable` で良いのか？やっぱり `@Bindable` と `@Binding` を自分がよく理解できていない気がします。`@Bindable var book` にして、`book` は普通にバインディングして渡していますよね、という感じです。`@Bindable var` を渡すときも `@Bindable var` のまま `book` に渡して、それを `TextField` にバインディングしている。大丈夫そうに見えるので、迷い込んではいない感じです。ここは良さそうです。つまり `ObservableObject` で OK、`@Environment` でも OK、なのに、なぜリンクしないんでしょう。

ここで Detail に渡していて、星が動かないわけです。Detail の星が反応しません。となると、この `@Environment` がずれているのでは、という雰囲気になってきます。`@Environment` がずれるようなことってあるでしょうか。ビュー階層の途中で付け替えていなければ問題ないはずです。これはプレビューだから大丈夫でしょう。これもプレビューだから問題ない。アプリのルートについている。問題なさそうに見えます。

`List` のモデルデータが `@State` にあって、`ContentView` の中では本当に `@Environment` には言及していない。`List` の中で `@Environment` を使い始めています。この中で `@State` が1つあります。フィルターバーは先ほど構造の都合で分けましたが、分けると少し複雑になるので、これはもう一度まとめましょう。単体でもちゃんと動くので。ということで、フィルターバーはいったん後回しにして、フィルターバーのところに素直にコードを入れていきます。これでこれは良いとして、`List` はどうするか。`List` として `ForEach` で `NavigationLink` にして……この `@Bindable` 周りが間違っているのかな、というところです。今は適当に作ったので、そのせいかなという気もしないでもないのですが、`@Bindable` がないと下のバインドがダメになって、「個々の `Binding` にしないといけないよ」という話になります。ここはまず調べたほうが良いのかもしれません。

たとえば `@Bindable` をやめて、後で使いたい気もするので一度コピーだけ取っておいて、`DetailView` の中でこのバインドができないのなら、ここで `Binding(get:set:)` を使って、`get` とクロージャはこれ、という形にします。最後にそれを `landmark` に渡してあげる。これでビルドをかける……丸括弧が1個足りない。ここですね。ビルドをかけて、シミュレーターで実行します。来ました。これで動いていて、選んで……動いた。いい感じですね。オフにして戻るとオフです。もう一回オンにすると、いいですね。さすがに動きます。そういえばさっき、サーバーに入っているときだけ動かないみたいな謎の挙動がありましたが、起動はしていましたね。そこも気になりますが、今は動いています。これで良さそうです。

これをやるのに、さっきの `@Bindable` が使えるんじゃないのかな、というのが気になっているところですが、関係ないのかな。`@Environment` ですよね。もう一回やってみます。バインディングをもう一回やるにはこの2つか。こんな遠くに置かずに、ここに置いてあげて、下の行はいらない。ここからここまでですね。いらない。というふうにしてあげて、これでもコンパイルは通るのですが、そのときにうまく動かないのか、もう一回再現してみます。ここまで入れて OK、ここを切って、これですよね。今一回押したんですけど動かない。一回押したからこのまま戻るといなくなりますよね、という状況になった。つまり、`@Bindable` の使い方が間違っているだろう、という話になりました。どうなんでしょうね。`@Bindable` の使い方を GPT に聞いてみますか。自分の中で全然理解していないのに使っている時点で問題ですよね。ここから GPT に突っ込むと。

「`@Bindable` の使い方だけじゃなくて特徴も教えてください」という感じで聞いてみると、「iOS の特性の一つで、SwiftData のバインディングをシンプルにするために用意されている」みたいな答えが返ってきました。そんなに限定的には見えなかったのですが……モデル型に渡すと……そうですね、SwiftData の話ですかね。`@Bindable`。さっきと話が違うので、これは違う話をしていますね。ウェブで調べます。`@Bindable` はプロパティラッパーで、ミュータブルなプロパティの `Binding` を生成するのをサポートする。これだけ見ると良いと思うのですが、定義は `@dynamicMemberLookup` で、プロパティラッパーが `@Bindable` になっている。このプロパティラッパーは、ミュータブルなプロパティへの `Binding` を提供し、データモデルオブジェクト……という言葉が出てきました。なるほど、そういう位置づけですね。 「オブザーバブルプロトコル」と言っていましたが、ここで言いたかったのは `ObservableObject` プロトコルのことですね。全然別物ではなく、モデルデータは `ObservableObject` に準拠したもの、という理解で大丈夫です。自分は何か勘違いしていたのかもしれませんが、`ObservableObject` に準拠したモデルであれば問題ありません。

たとえば、次のようなコードは、入力として渡された `Book` を `@Bindable` プロパティでラップするものです。テキストフィールドが `Book` の `title` プロパティを編集できるようにするために、ドル記法（`$`）を使ってバインディングとして渡します。つまり、`TextField` の `text` には `$book.title` を渡す、という使い方です。ここまでは手応えがあって、`Book` があって、`title` があって、`@Bindable var book: Book` が外から渡されて、その `book` のプロパティをバインディングとして各所に渡していく、という流れです。

これが通常のバインディングと何が違うのかという点ですが、`@Bindable` プロパティラッパーは、`ObservableObject`（に準拠したクラス）などを包んで、その内部プロパティへのバインディングを簡単に提供できるものです。プロパティや変数に対して使えますし、`ObservableObject` にも使えます。UI 型の外側でもよく、グローバル変数でもローカル変数でも利用できます。たとえば、`Bindable` な値をビューのプロパティとして使うこともできます。

`List` で `books` を表示していて、`books` は普通に `@State var books: [Book]` のようになっているとします。このとき、各要素の `Book` は可変です。`Book` が `ObservableObject` に準拠したクラスで参照型なので、これを `Bindable` に包むことで書き込み可能なバインディングを作れます。そうすると、`$book.title` のようにバインドでき、リスト内のその要素そのものへの参照になっているため、編集すれば `books` 側もちゃんと更新されていく、というわけです。`Bindable<Book>` は `TextField` へのバインディング（`$book.title`）を提供し、変更を直接モデルデータに反映させられます。

同じアプローチで、`ObservableObject` を `Environment` に置いている場合にも使えます。たとえば、`@Environment` プロパティで関連する `ObservableObject` のインスタンスを取得し、それを `@Bindable` でラップして、`TextField` に `$book.title` を渡す、といったことができます。`@Environment private var ...` の形で書くのが正しいですね。チュートリアルではあまり強調されていませんでしたが、ここはそう理解してよさそうです。実際、`body` の中で `Bindable` を作り、`title` を渡すという同じ方法で動作します。

プロパティラッパーの観点では、`wrappedValue` はオブジェクトそのもの、`projectedValue` は `Bindable` 値（つまり、`$` でアクセスする側）です。この整理で良さそうです。`Identifiable` が関係あるのかと一瞬思いましたが、ここではモデルデータ（たとえば Landmarks の例）で特にそれ以上の仕掛けはしていないので、関与しないはずです。`isFavorite` のようなフラグも、`$landmark.isFavorite` のようにバインドすれば直接更新できます。モデルデータは `ObservableObject` で、`@Bindable` を使ってプロパティ単位のバインディングを取り出す、という理解で整合が取れます。 ランドマークリストが `Environment` を取ってきて、いちおう private にしようかなという話だから、これで出しっ放しにする必要はないですよね。こうした上で、モデルデータの `filteredLandmarks` 数、この辺が問題なのかなと思ってちょっと気になりましたが、これはランドマーク自体が `isFavorite` かどうかでフィルターをかけるだけなので、何も問題ないですよね。

その上で `NavigationSplitView` で `favoriteOnly` をトグルする。これはトグルするだけなので良さそうです。それで `ForEach` の `filteredLandmarks`、これはランドマークリストの中の話だから、問題がないと捉えていいのではないでしょうか。ランドマークを取って、そのランドマークにいろいろやりますが、`@Bindable` はここじゃなくて良いですね。とりあえず `@Bindable` はもっと外で良いです。一番外にしちゃいますか。これくらいでもいいと思います。

`@Bindable` が存在する中でランドマークを取ったとき、モデルデータのランドマーク数を見て、`firstIndex` でランドマークを取って、そのインデックスを `ModelData` の `landmarks` の中から拾ってあげれば OK な気がしますよね。

それでランドマークの中身を見ておきますか。ランドマークの中は、モデルデータの中の `landmarks` で、`Landmark` で、`isFavorite` の `Bool` 型ですよね。これは問題なしでしょう。他に `@Bindable init` ってセットしたことがあった気がするんですけど、この辺も見ておきたい。これは関係なかった。イメージセット、これも問題ない。大丈夫ですね。いつの間にか無くなってますね。`set...`、`Bindable`、`isSet`、`isSet isSet`、これはコメントアウトしていて使っていないですね。大丈夫です。説明を読むときに大成功じゃないですか。

シミュレーターをもう一回上げてみましょう。なんでだろうな。バインディングが切れてるとかじゃないとダメだけど、でも切れてるだけじゃないですよね。ちゃんと反映するんでね。これで、あとで自分の星をチッと押したんですけど、描画は変わらないですね。戻って…どうでしたね。トグルされたかっていうのが見られたほうがいいのかな。だから、トグルされたかどうか。ここはいいですよね。ランドマークディテールのこのバインディングのランドマークで。

それでトグルは、`MapView`、`CircleImage` があって、`FavoriteButton` で、`isSet` をボタンを押したときに切り替える。これでトグルされたか、ランドマークの `isFavorite`。この辺を、例えばどこがいいかな。`ScrollView` 全体でもいいですかね。`ScrollView` に例えば `.onChange(of: landmark.isFavorite)` で、変化があったときには `print` で「`isFavorite` が oldValue から newValue に変化した」という状況を出す。これを見ればいいのかなという感じですよね。

そして、これを試すには…プログラム、シミュレーターでもいいですけど、もはやこっちの Mac はシミュレーターにしますか。これを一応実行して、それでここに来て、いちおうフィルターをかけて、星のついたほうに行って、ここで押すんですけど、これ押す前にちょっと並べられるかな。画面ちっちゃいかな。これを横に置けると一番分かりやすくていいんですけど…消えた。あ、消えましたね。これでログメッセージは今のところから最大にして。それで、デフォルトの Scheme は何を探しているんだろう。まあいいか。もう…まあいいか。変更して、これでちょっと星のボタンを押しますね。どうなるかな。反応する…あれじゃないか。二回目、三回目、四回目、四回押した、五回押した。これで元に戻っている。いいですね。いいですけど…知らなかった、間違えたかな。`onChange isFavorite`、`onChange` がまた出てきた。`false` から `true` になった。けど、もう一回押すと、これで `true` から `false` になった。なりますね。大丈夫ですね。動いてますね。ここはいいということですね。

お気に入りに最初から入っているやつを選ぶときに、これは押してみますか。あれ、消えた。オンにすると動けますね。ってことはフィルターの…もしかして。セントメアリー湖を押す前に、こうして、一回これでセントメアリー湖行って、これで押すと `false` になった。消えた。オンになった。いいですね。これでセントメアリー湖をフィルター入れた状態で、セントメアリー湖へ行って、これを押すと反応しない、ということらしい。なるほどなのかな。これは、押して大丈夫で、デフォルト関係なくて、今押しまくってますが動かないね。動いたときがある。でも、ダメですね。 なるほど、とにかく分かったことは、Favorite の変更が、たとえばフィルターで「Favorite のみ」に限定したときに `onChange` の通知が回ってこない、という点です。つまり、バインディングがうまくいっていない可能性が出てきます。

ランドマーク（`Landmark`）のところは、`FavoriteButton` の `isFavorite` がバインディングされているはずですが、このバインディングが正しく動いていないようです。ここで、「`@Bindable` かな？」と思ったのですが、用途が違いますよね。ここはオブジェクトが `Observable`（あるいは `ObservableObject`）でないといけない、という話です。ランドマーク自体はバインディングを通じて渡ってきているはずなのに、`FavoriteButton` にそのオブジェクトをバインドした際、変更が届いてこないことが分かりました。分かったのですが、なぜそうなるのかが不明、という状況です。

フィルターとランドマーク配列については、「Favorites Only」の状態に応じてフィルターの方向を変えるだけで、最終的にはフィルター後のランドマークが表示されます。ですので、モデルの実体が直接影響しているとは考えにくい気がしています。いずれにせよ、ランドマークの配列が返ってくる状態です。

そのうえで、今回はインデックスを取得します。取得元はモデルデータ（`ModelData`）で、その中のランドマーク配列に対して `firstIndex(of:)`（実際には ID を使っているので `firstIndex(where:)` 相当）でインデックスを取っています。現在はアンラップしていますが、条件は常に同じです。やっていることは、`modelData` の中で ID を用いて普通に `firstIndex` を求めている、という状況なので、インデックス自体は問題なく取得できています。

インデックスが取れたら、あとは `modelData.landmarks[index]` のようにブラケットで指定してアクセスします。`modelData` は（`@Bindable` でなく）通常の保存型プロパティとして `landmarks` を持っていて、その要素をインデックス指定しているにもかかわらず、フィルターで絞った状態にすると変更が反映されません。つまり、バインド自体はされていて状態は変わっているのに、伝播されていない、ということになります。伝播されないにしても、`onChange` が反応していないのが気になります。

トグル操作後の挙動が問題なのかもしれません。`LandmarkDetail` の中で `FavoriteButton` に `isFavorite` をバインドしていますが、`FavoriteButton` 側では `isSet` にバインドしていて、その `isSet` をトグルしています。トグルしたところで `print` を出すようにして、`print("toggle: isSet=\(isSet)")` のように現在値を確認します。

また、`StarImage`（と認識している部分）の `isSet` がバインディングされている状態です。`isSet` の型は `Bool` のままですね。どこで定義していたかを見直して、`@State` が必要かどうかも確認します。たとえば `@State private var isSet: Bool` のようにしていると、アクセス修飾子の関係で保護レベルのエラーが出ることがあります。実際、`private` のせいでプロテクションレベルに引っかかったので、いったん `private` を外してビルドしてシミュレーターで動かしてみます。

状態が変わったときにアイコン（星）が期待どおりに変わるのかが気になっていましたが、そこを見落としていました。`toggle` 自体はできているので、たとえばボタンでアニメーションさせたい場合は、`withAnimation` で `toggle()` を包むとどうなるか、という点も含めて挙動を確認します。 どうなるんでしたっけ、ということはよく分かっていないのですが、例えば移動してプチッとアニメーションするような、色が変わる挙動は何も起きませんでした。これは自分の理解不足ですね。ここでは描画はされていない、ということで良い気がします。だとすると、ここで描画されない「バインディング」でいうことが起こるのかな、と。不思議です。自分でバインディングを書けば大丈夫なわけですよね。そこが分からない。

SwiftUIの仕様や、まだ知らない方法が関係しているのかもしれません。とりあえず、ビューにIDをつけて、それを更新させればよいらしい、という話を試します。ビューにIDをつけて更新、IDですね。はいはい。

まずは `@State private var id = UUID()` のようにステートを用意して、ビュー側に `.id(id)` を付けます。これで反映すればいけるでしょう、と思ったのですが、どうなるか。まずは普通に動くやつを試して、スターを押しても色が変わらなかった感じです。これでうまくいくと思ったのですが、うまくいかないですね。これは自分の問題ですね、きっと。IDはあるし……まあいいか。何かしたかなという不安があります。

それと、ステートにしましたね。表示したいイメージのアクティブ自体は、ディテールが変わればいいので、これは別に良い気がします。やめたことによって、ちゃんと色が変わるようになりましたよ、という理解で合っていますかね。まあいいか。これでお気に入りの状態にして、フィルターをかけた状態で押すと、変わらないですね。ここが引っかかります。IDは役に立たなかったことが分かったので消します。

解決策としては、このBindingをこんなところで使うのではなく、とにかく近い場所に置いておきます。これでもダメだったので、`LandmarkDetail` でコメントアウトして、Bindingを使うのをやめ、バインディングをちゃんと自分でイニシャライザ（`Binding(get:set:)`）で作って渡してあげると、これはうまくいきます。この辺はそういうものですかね。自分にはまだ分かりません。

これでフィルターをかけて選んで、プチッと押すと、ちゃんと変わりますよね、という感じです。腑に落ちないなあ。こういうものなのか。最適化がより働いている、ということなんですかね。フィルターでおそらくリストからいなくなるのが関係するのかな、とも思うのですが、的を射ていない可能性もあるので、動くなら良しとします。なぜBindingでできないのか。さっきドキュメントを読んだ感じだと問題なさそうなんですけどね。こういうのは気になってしょうがないので、コメントだけ残しておきます。複数行にして、ドキュメントコメントにします。FIXMEでもないし、TODOでもないので、メモとして。

「Bindingを使うと、Favorites Onlyスイッチをオンにした状態で見ているとき、Favoriteを押してもモデルデータは変化するものの、表示が更新されない。このため、バインディング型を直接初期化して渡している。こうすれば表示も適切に更新される。」

こんなメモを残して、このコードをこのまま使うことにしておけば、ひとまず安心ですね。更新しておきましょう。とりあえず、まずOKということにします。どうにも腑に落ちないのですが、目的は達成したので。

それから、`.environment` 周りを確認しました。ここしかなかったんですね。プライベートにしたかっただけなんですけど、できました。これでいいです。

今日はここまでにします。次回は「Drawing Paths and Shapes」のように、パスを使って描画をするあたりを進めていく感じになりそうです。お疲れ様でした。
