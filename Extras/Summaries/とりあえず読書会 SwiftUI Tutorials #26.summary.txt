Transcription & Summarize : とりあえず読書会 SwiftUI Tutorials #26

では、紹介を始めていきます。Swiftのチュートリアルを見ていて、前回からApple Watch対応のものを始めています。まずは私のほうでチュートリアルに沿って作ってみましたが、それを例になぞってリファクタリングし、iOS用のコードと同じような雰囲気に直していきたいと思います。直感に任せてやって、iOSと似ていくかどうかを試すやり方もありそうですし、iOSアプリ側のコードをちゃんと見て「実際どんなふうにやっていたっけ」と確認しながら進める方法もあります。自分でコードを書いたからといって、必ずしも次も同じ発想で書けるとは限らないので、一般的には既存のコードと照らし合わせて合わせていくことが多いのではないかと思いますが、あえて独自にやってみるのも面白いかもしれません。

では早速やっていきます。直すのは主に「ランドマーク」と呼んでいる部分、iOSの中で今のところ独自に存在しているものです。それ以外は、すでにiOS用に作ったものを流用しているので、ここを中心に見ていくことになります。まずはコピペによる細かな不備を直しつつ、`Environment`でモデルデータを取っておくのはそのままで良さそうです。ランドマークを`var`で受けているところは、`let`で良いですね。これは好みの問題ではあります。

次に「ランドマークインデックス」が少し気になります。現在は`firstIndex(where: { $0.id == landmark.id })`でID一致の要素を探していますが、`ModelData`にヘルパーを作っていなかったでしょうか。たとえば`indexByID`のようなメソッドを用意して、ランドマークを渡すとインデックスが返るようにしていたはずです。実装としては、IDで`firstIndex`を取得する形でした。これでインデックス取得はすっきりします。

一方で、`firstIndex(of:)`で取りたくなるところですが、見つからないことがあるので戻り値はオプショナルになります。元のコードは強制アンラップしていましたが、これはこの場合あまり賢くありません。`Environment`からランドマークを取ってインデックス検索をして、見つからなかったらどうするのかという問題があります。`LandmarkDetail`を表示する都合、対象のランドマークは基本的に存在しそうではありますが、`ModelData`を何に使っているのかというと、バインドしてインデックスの該当箇所を書き換えるために使っています。

であれば、ランドマーク自体をバインディングできたはずです。`@Binding var landmark: Landmark`のようにして、`Environment`を取らない構成にしても良いのではないかという気がします。そうすれば`landmarkIndex`のようなプロパティは要らなくなります。プレビューは出しておいたほうがよかったですね。もう遅れていますが、大丈夫でしょう。

この形にすると、`Binding`まわりを過剰に意識しなくてよくなり、`ModelData`とインデックスではなく、完全に`landmark`に対して`isFavorite`などを直接バインドできます。ランドマークの情報はひととおり持たせているので、参照箇所は置き換えられます。いまのところ、`ModelData`の何かしらをバインドしている箇所がひとつ残っていますが、そこはそういうものとして扱う想定です。

最後に、`@State`でモデルデータとして`ModelData`を持たせて、書き換え対象のランドマークは別に取得できるかどうか、というあたりを試してみました。 これをバインドできるのかな、この辺を。`@State` を使うためには、まずプレビューで確認したいですね。できた、渡した…いや、まだちゃんと渡していないので、これで OK ですね。後々、ランドマークのバインディングでちゃんと渡す必要がある状況が出てくると思いますが、まずはこれで良さそうです。

プレビューが出てくれるかどうか…ビルドエラーが出ているのかな。ビルドエラーは、ランドマークのバインディング周りですね。そうすると、`LandmarkList` がダメになってしまっている。`LandmarkDetail` は、iOS 側をイメージしていますが、iOS の `LandmarkDetail` ってどうなっていましたっけ。iOS の `LandmarkDetail` は、`let` でランドマークを持ち、`@EnvironmentObject` で `ModelData` を取っているという構成ですね。そして Favorite は、`isSet` に対して `bind`（`bind(to:)`）を作って渡していました。なるほど、という感じですが、これがなぜダメだったんでしたっけ。

後から書き換え対応が必要になって、`ModelData` の `bind(to:)` で `Binding` を返すということをやっていましたよね。インデックスで見つけて返す形です。ただ、`ModelData` を他にどこで使っているのかというと、`bind` だけですね。これをいろいろやるにあたって、うまくいかないねという話になって、`Binding` を作ることにしたのだと思うのですが、なぜそうしたのかを少し忘れていました。

バインディングを使わないと反映されない、というのが理由でした。反映されない理由は、`ModelData` ではない値をバインディングしていたから、だったはずです。そうです、`isFavorite` でフィルタした結果を使って、フィルタを通して手に入れたランドマークをバインディングしていたのですが、それはすでに `ModelData` から切り離されている構造体のコピーなので、ダメだったという話でしたね。

なので、`LandmarkDetail` ではなく、`LandmarkList` のあたりを見るべきでした。`LandmarkList` の中で `filteredLandmarks` を `landmarks` から返していますが、この `landmarks` は `isFavorite` かどうかでフィルタしています。ここで返っているランドマークは構造体なので、複製が作られてしまい、これのバインディングを渡しても何も反映されない、という問題がありました。

となると、一つの方法としては、「バインドして使う予定がある」箇所に対しては、最初からバインドされたもの（参照）を返す、という設計が考えられます。こういうコードはあまり見ない気もしますが、参照（`Binding`）を返すのは手段としてはありだと思います。そのアプローチでやってみます。必ず存在するものを探して強制的に取り出すようなコードは、あまり良くない気がします。なので、`landmarks` を取るときに、通常の `landmarks` だけでなく、「バインディングされた landmarks」も取れるようにしたいです。

そのためには、`Bundle` は関係なく、`ModelData` に対して `extension` を生やすのが良さそうです。`landmarks` を返すときに、すでにバインドされた形で返せたら良いのでは、という気がしてきました。`ModelData` の使い方はこの先また別途詰めるとして、ひとまずその方針でやってみます。

`ModelData` は `landmark` を持っていて、`load` して初期化で読み込んでいる状況です。`Hikes` をバインドすることもあり得ますが、必須ではないかもしれません。`Binding` としては、ランドマーク向けのものはすでにありますね。これを使っていけば良いのかな、という気がします。つまり、`binding(for:)`（ランドマークのバインディングを返すメソッド）をどう使うか、という話です。`Profile` もバインドしますね。そうすると、`Hikes` と `landmarks` のあたりが焦点になりますが、`Hikes` はそこまで重要ではなさそうです。やはりランドマークです。

結論としては、`landmarks` を内部に保持し、そのうえで必要な箇所にはランドマークのバインディング（例: `Binding<Landmark>` や `Binding<Bool>` の `isFavorite`）を返す、という形にするのが良さそうです。この辺り、実装はもう少し詰めます。 とりあえず `landmarks` はそのまま残しておいて、バインディングしたものを作ってみます。基本的にはバインディングしたものだけを扱う方が使いやすそうな気がします。

`extension ModelData` の中にタイプエイリアスを用意します。タイプエイリアスはまずいかなと思いつつ、`typealias BindingLandmark`、`typealias BindingLandmarks` のような感じで用意して、これは「バインディングのランドマーク」という意味合いにします。同様に、`BindingLandmarks` は配列ですね。`BindingLandmark` の配列という形にします。

その上で、`var bindingLandmarks: BindingLandmarks` のようなプロパティを用意して、`landmarks` に対して `.map { ... }` で `bind(to:)` かな、という感じで変換していきます。`Optional` にしているのは、バインドできない可能性を考慮しているからです。あとは `firstIndex` で `landmarks` のインデックスを返しているだけなので、周りはうまくやってくれるはず…と思ったのですが、そうでもないかもしれません。

ここは `indices` に対して `map` をかけていって、`index in ...` と一行で書ければよさそうです。自分自身、つまり `landmarks[0]` かな…と思ったら、ダメですね。`landmarks` が見つからない。あ、そうか。こちらが `Bindable` になっていないのですね。`ModelData` で、`Bindable` にしないといけません。

つまり、`map` の中で `bind(to:)` までやろうとすると少し負荷が高いです。そこで、`let modelData = self` のようにいったん保持しておいて、このときに `@Bindable` を付けてあげます。戻り値としては、`return` で `modelData.landmarks` の…どちらかを返す形にしたいのですが、ここで `modelData.landmarks` にアクセスしようとするとダメですね。`ModelData` がない、つまりキャプチャできないのか。そうなると、やはり少し変えないといけません。バインドを独自に作る形にする感じでしょうか。本当かな…。`Bindable` のときに `ModelData` をバインドさせるために、`ModelData` 自体をキープすることはできないのかな、と。ここが罠なんですよね。とりあえず。

この中で、`Landmark` から `ModelData.BindingLandmark`、つまり `bindingLandmark` に変換できませんよ、というエラーが出ています。こちらを修正すれば大丈夫です。`self` は取っていますが、`ModelData` はクラスですし、`map` してクロージャが終わったあとは参照の問題は大丈夫ですね。なので、これでバインドされたランドマークをまずは取得できます。

同じように、`featuredLandmarks` もバインディング版にしますし、この辺、`landmarksByCategory` も同様に対応したいところです。どうしようかな…。フィルタやプロフィールは関係ないですね。ひとまず、使い回せそうなこの2つをコピーして持っていきます。これらの名前を例えば `featuredBindingLandmarks`、`bindingLandmarks` のように変えて、参照先は `bindingLandmarks` にします。

`landmarksByCategory` は…なるほど。これはどうしましょうか。`landmarksByBindingLandmarks` のようにするのか。だんだんわちゃわちゃしてきましたね。`Binding` 側でも必要になりそうですし、`bindingLandmarks` というか、もう外側を全部 `Binding` としてしまいますか、という方向性もありそうです。 なので、`bindingランドマーク配列`という風にして、そうすると、ほかは`ランドマーク配列`…いや、`ランドマーク配列`でいいや。`bindingランドマーク`っていう風にして、`bindingランドマーク`は`ModelData`が持っているけど、これはランドマークを…って解釈する、循環参照みたいに解釈するとか、`typealias`…。`bindingランドマーク`、ちょっと名前つけにくいですね。`bindingランドマーク`…`bindingランドマーク`か。`bindingランドマーク = bindingランドマーク`でしょ。やっぱりここは厳密にやったほうがいい気がしますね。`import SwiftUI`ですが、そうね、名前はなんとつけますか。

`ランドマーク配列`の代わりに`bindingランドマーク配列`にしちゃって、`ランドマーク配列Byカテゴリー`も`bindingランドマーク配列Byカテゴリー`にして、全部`binding`でやってみましょう。どうなるだろうね。大丈夫だと思うんですけど、あんまり意味ない気がします。こういった`binding`を持ち出すの。まあ、「参照（書き込み可能な参照）を持ち出している」と思えば、そんなに不自然じゃないと思うんですけどね。

で、`sequenceランドマークのカテゴリー`、これはいいですね。コレクション、この辺はいいですね。あとは、この`bind2`が使わなくなりそうなので、コメントアウトしておくでしょ。で、あとは`bindingランドマーク配列`を返す。

で、このソース…じゃないや、`typealias`。この2つはグローバルで使えばいいですよね。で、`ModelData`の`ランドマーク配列`、これは何回呼ばれるようになったのかな。エラーが出てますね。取られてますね。いつ消えたんだろう。まあ、いいか。で、これで`bindingランドマーク配列`を返しますよね。

ここも`bindingランドマーク配列`にして、カテゴリーを取るのは、配列が壊れるのを避けたくて`ランドマーク配列`にしたくて、で、これでどうしようかな。`private typealias`で、`ランドマーク配列 = [Landmark]`ね。で、この`ランドマーク配列`も`private`で定義してあげて、`private`で定義しておけば大丈夫だと思うので、大丈夫ですね。うん。こうすることによって、外からは`binding`されたやつ、それだけしか使えないようにすることができると。うん。こうして、これでコンパイルはOKですよね。

で、`ランドマーク配列`は変更もできる必要があって、そうですよね。で、これで`ランドマーク配列Byカテゴリー`、あれ、さっき作ったやつだ。これはいいですね。`filteredランドマーク配列`、これもいらないですね。本当かな。こんなに消しちゃって大丈夫かな。一応、怖いからコメントアウトにしようかな。大丈夫だと思うんですけどね。まあ、これで、ここまでOKでしょ。

そうすると、他の画面でビルドエラーが出ていますよね。今ね、「`ランドマーク配列`がスコープにないよ」って言われてますが、`ランドマークリスト`は`bindingランドマーク配列`ですよね。で、それで、`ModelData`…これはなんだ。`featuredランドマーク配列`って`ModelData`がもうすでに持ってますよね。フィルターをかけても、これは無駄なことだったかな。`featuredBindingランドマーク配列`を返せばいいですよね。うん、そうですね。無駄だったかも。

で、これで`ランドマークロー`として、`ランドマークロー`は…この`ランドマークロー`はディテールを表示するのかな。えーと、`ランドマークロー`は一行一行表示して、`isFavorite`を表示しますよね。`StarImage`でね。で、`StarImage`は普通にスターなだけか。そうかな。うん、そんな気がしますかね。じゃあ、これはいいのかな。

えーと、あとは、`animationFilteredランドマーク配列`。これはエラーになるのは、`Equatable`に準拠していないからか。ランドマークのアニメーション…そうか。`animation(_:value:)`の`value`は`Equatable`ですね、アニメーションの`value`ね。`binding`、`binding`の配列、これは`Equatable`に準拠しないのか。配列で`binding`…。`Binding`自体はどうだろう。それにもよる。でも、`Binding`が`Equatable`だったら配列も`Equatable`になりそうですね。だから、これじゃダメなのか。なので、`.map(\\.wrappedValue)`ならいけますけど、ちょっと無駄が多い気がしますね。

えーと、で、`ランドマークリスト`でしょ。で、ランドマーク…。ランドマーク…。 とりあえずラップドバリューを渡してみます。そうすればフィルタが通るので、これで一度プレビューを止めて、またフィルタが選べるかを確認します。ランドマークリストですが、今は iOS をいじっているので、watchOS ではなく iOS に切り替えます。そうすると、もう少し余裕が出てくるかもしれません。

`ModelData` は、モデルデータ B…というか、`modelData = ModelData()` のようにデフォルトで読めるやつですね。これでいいかな、と思ったのですが、ダメでした。Non-Sendable、つまり「コンカレンシーセーフではない」と言われてしまいました。`ModelData` はクラスであって、コンカレンシーセーフではない、という指摘です。あ、そうか、`Binding` を使ったからか…と思ったのですが、今の場所では使っていません。ではどこで怒られているのか。これが `final class` だから、`Sendable` を付けると大丈夫ですが、今のこの安易な `Sendable` 付与は気を付けた方がいいですね。

とりあえず、`Sendable` のメンバーだけを `Sendable` のまま保持していて、`ModelData` はクラスであるけれども…という整理です。ランドマーク関連の `Binding` と `Sendable` の関係は、まあ任せるとしても、気になる挙動ではあります。あるいは、`ModelData` は `@MainActor` からのみアクセスするように絞る、というのもあります。どちらがいいでしょうか。`Binding` で書き換えたときに `Sendable` なデータが更新される、という観点では、これまで特に問題にはなっていませんでした。プレビューの外でやっているからこそ表面化しているのかもしれません。

で、これを外に持たせず、完全にプレビューごとにインスタンスを作るようにすればよさそうです。`private` はいらないかな、これでゼロから毎回作る感じにします。これと、これと、これ…という形で揃えます。そうですね、これで良さそうです。そうすればライフタイム管理もいりませんし、この方が長すぎずに済みます。

「Landmark のプレビュー」と言っていますが、これは `ModelData` の `landmarks`、つまり `Binding<Landmark>`（あるいは `Binding<[Landmark]>`）です。0番目の Row があるはずですよね。同様にして 2 つ目の Row、という形で 0 と 1 を並べます。これでいいはずです。

それから、`LandmarkRow` のコピーで間違えていた箇所がありました。不要なところは削除します。さて、これでどうなるか。エラーになっているところは、これも同じく `landmarks` 周りですね。`ModelData` のロードから入らないのかな…いや、`Binding<Landmarks>` で良いはずです。

ビルドは通って、次のエラーが「`landmarks` が incompatible」みたいなやつです。`ModelData` の `landmarks` の型と `Binding` の型が合わない、ということですね。`filter` で `Landmark` の `category == ...` という条件をかけたいのですが、こちらも `ModelData` 内の `Binding<landmarks>` に対して `filter` で `landmarks` を絞る必要があります。このあたりの `wrappedValue` がちょっと面倒ですね。`Binding` されているので、`bindingLandmarks.wrappedValue` に対して `filter` や `map` をかける、という形になります。

つまり、`modelData` の `bindingLandmarks` の `wrappedValue` を使って…ということですね。ここで要は、`wrappedValue`、`Binding<Landmark>`、`landmarks`、この辺は `landmarks.map(...)` かな、という整理です。ひとまずコンパイルを通すためにやっています。

ここは `landmarksByCategory` ではなく、`CategoryHome` は `Binding<landmarksByCategory>` を受け取るようにして、ここも `Binding<landmarksByCategory>` に寄せます。`FeaturedCard`（フィーチャードカード）も同様で、`featuredLandmarks` を `Binding` で渡します。`ModelData` の `featured`…というより、`featuredLandmarks` の `Binding` ですね。

あとは、`init(landmarks:)` に渡す際に、`featuredLandmarks` を `Binding` で取れています。今のところは、課題として渡しているので、`lazy` の `map` の `wrappedValue`…という感じになります。いろいろな `wrappedValue` を辿る場面が出てくると思います。

そんなふうにして `FeaturedCard` も用意して表示しているのですが、ここが何かできなくなってしまいました。バグになってしまっているのがちょっと厄介です。`FeaturedCard` と、`categories`、`landmarks`、`landmarksByCategory`…このあたり、`wrappedValue` 周りな気がします。`landmarksByCategory[category]` のようなところで「`wrappedValue` は無い」と言われているのかもしれません。`Binding<landmarks>` のつもりで書いて、`CategoryRow` の `landmarks`…あ、`landmarks` ですね、というところまで来ています。 なので、`map` で `wrappedValue` がここですね。これでバグとか言われなくなるでしょう。では次です。次は、これが `fetched`、`Binding`、`Landmarks`。これに対して `wrappedValue` ですね。ちょっと大掛かりな変更すぎてイマイチかなという気もします。

`bindingLandmark` ですね。これで `wrappedValue` です。今のところは `ModelData` が `Binding` を持っていないというのもあって、これは Swift の `ModelData` で `bindingLandmark` ですね。ここからも持たせるかな。`Landmark` を持たせるんじゃなくて、`Binding<Landmark>` を持たせて、これでこの辺は `wrappedValue` になっちゃいますね。

やっぱり…というほどでもないですけど、`wrappedValue` がちょっと格好悪いですね。どうしようかな、これ。`wrappedValue`。`Binding` でしょ、`Binding` 型で、まあしょうがないか。`Landmark` の `wrappedValue` の `name`。これで `bind` とかじゃなくても、普通に `Landmark` の実体を渡せますよね。そういった状況になってくれたと。とりあえずコードをスマートにするためなんですよ。

その代わりに、`Landmark` が `bindingLandmark` とか `wrappedValue`…。これはちょっと大げさかな。すると、このイニシャライザー、この辺は `bindingLandmark` にしちゃって、そして、上位のプロパティでは `Binding` ではない `Landmark` を返す、つまり `bindingLandmark` の `wrappedValue` を返す、というふうにしてあげればいいですよね。そうすると `Landmark` に対して `wrappedValue` みたいに、全部スマートに書けますよね。とりあえずね。こうして、これがいいかな。

そして、上で `Binding` が必要なところ。ここだけは `bindingLandmark` みたいに書いてあげれば、メリハリも良いですね。で、`ModelData` の `bindingLandmarks[0].wrappedValue`、そしてここが選ばれるんですね。これはイニシャライザー、`Landmark`、`bindingLandmarks[0]` ですよね。で、`wrappedValue`。このエラーは何だ。`wrappedValue` ですよね。で、`Landmark` が取れていますよね。あ、そっか、`bindingLandmark` に変えたんだ。だから、`bindingLandmark` にしてあげて、`wrappedValue` じゃないよという、そういった話か。はいはい、なるほど。で、こうしてあげると、まだいいですね。

Feature と `bindingLandmarks` のイニシャライザーをする前に、`.lazy` の `.map` で `wrappedValue` を取り出して `FeatureCard` に渡す、みたいな感じですね。それで `pages`。これがまだエラーになるのは、あ、`lazy` が残っている。あ、そっか、これで `lazy` が残っちゃうのか。あ、そっか、`lazy` のあとの `map` だから、これを実体化してあげないといけないのか。

そのときに、この `Pages` のイニシャライザー、これですね。たとえば、`init(pages: some Sequence<Page>)` というふうに取るイニシャライザーを作って、`self.pages = Array(pages)` として配列に `Page` を入れてあげる、というふうにすれば、これでさっきのビルドは通りますよね。こっちの方がいいんじゃないかなという気がするんで、これにしますか。 razyを扱う際にいくつかの懸念があるようですが、基本的には問題を解決するためにrazyを利用するのが目的のようですね。マップや特殊なマップについては、特定の機能がないことに戸惑っていますが、解決には至らないようです。

ランドマークスに関しては、「bindingランドマークス」と呼ばれる特定の操作を行うようです。`all_satisfy`メソッドはシーケンスとして使うことを考えていますが、柔軟に対応できるように考えを進めているようです。

プロトコルでまとめるべきかというアイデアも出ていますが、実装する手間が増えることも懸念されています。bindingランドマークを基本として、その他のランドマークの操作を調整しようとしています。

具体的な操作としては、`with_same_category`を使ってランドマークを比較し、必要に応じてbindを解除したり、比較したりしようとしています。この際、イテレーターを使用して次に進む方法を考えたり、イテレーターをベースにしてシーケンスを操作しています。

`drop_first`や`remove_first`といったメソッドがないことにも悩んでいますが、イテレーターを用いた次のステップに進む方法を模索しています。`any_sequence`を使うか、イテレーターで操作するかの選択にも考慮が必要です。いずれにしても、すでに一度操作を行った部分は考慮に入れて、ふさわしい方法で続けるべきとしています。全体として、最適解を模索しつつ、その場で解決を図っている印象です。 イテレーターやシーケンスを利用することで、不必要なコレクションを求める必要がなくなります。`first`を使いたい場合、これは非常に便利です。`is_same_category`も変更することになりますが、この場合もコレクションを使って処理を行います。シーケンスで`first`が使えないという問題もありますが、これは前述と同様の処理方針が役立ちます。

具体的には、コードの効率化をそれほど追求しないのであれば、シーケンスをレイジーにして処理するという方法があります。`self`を使ったレイジーシーケンスも可能です。例えば、`self`のレイジー属性で`dot map`を使い、特定の値をラップするという手法があります。そして、`is_same_category`を適用することで、リストの先頭から同じカテゴリーのものを取り出すことができます。

このアプローチにより、安全に`is_same_category`を用いたバインディングが可能となります。カテゴリーに基づいてスクリプトを整理し、レイジーな評価を使って効率化を図ります。見た目に多少違和感があるかもしれませんが、機能的には問題なく動作するはずです。最終的に`is_same_category`をバインディングに対して使用し、それに基づいてランドマークを設定していくことで、処理を整理することができます。

このようにして、バインディングランドマークとして処理を進め、その上でプロパティを定義すると、今までの理論に基づいた合理的な処理が可能となります。ランドマークに対するバインディングも重要ですが、それを過度に強調する必要性については再考の余地があります。また、`wrap_to_value`を毎回使うのは効率的でないため、イニシャライズ時に明確なバインディングを設定しておく方が後々便利でしょう。

この方法では、カテゴリーごとにランドマークをバインディングし、処理に一貫性と効率を持たせることができます。これにより、プロジェクト全体でのデータ管理や処理がよりシームレスに行えるでしょう。 バインディングランドマークスについて話しています。バインディングランドマークスを操作する際、どのようにレンダリングやバインディングを行うかを考えています。これは配列全体をバインディングする方法や、その後の変換方法に関連します。バインディングランドマークスがどのように配列になっているか、あるいはどのようにアレイのバインディングが行われているかを考慮し、お互いに交互に変換する方法について議論しています。

この中で重要なのは、イニシャライザーでランドマークスを扱う際、うまくバインドさせることです。このバインドを行うために、コンピューテッドプロパティを使って固定の型ではなく、多様な方法で操作が可能になります。バインディングの中でデータを適切に取得し、再度セットすることが求められます。そして、GETとSETの方法を活用し、正しいバインディングができるかを確認し、互換性を保つことが狙いです。

この実装では、同じ数のランドマークが必要で、それらを一致させるために、新しいランドマークスを考慮してバインディングが必要です。結局、プログラムが失敗しないためには、バインディングによってセットする際、全く同じオブジェクトへのバインディングが必要となります。ジップ関数を使って新しいランドマークスと既存のランドマークを同期させ、整合性を保つようにしています。 バインディングランドマークに新しいランドマークを追加することで、セットは実現できます。ただ、これには注意が必要です。まず、GETはゲッター、SETはセッターというように考えます。問題点は、Non-SendableからSendableに変換していることです。NewランドマークがSendableであると仮定しています。しかし、Non-Sendable FunktionからIsolated Sendableに変換している部分が問題となっています。ランドマークはSendableなので、AddSendableを使うことになりますが、これがうまく行くかは不安があります。

バインディングができたなら、ランドマークを振り返ることが可能です。これを実現するために、アサーションを使います。ランドマークのIDを基にソートして、それらが一致するかどうか確認します。この方法を用いれば、順番も完全に一致させることができます。これで、バインディングが効果を持つようになります。

もしもバインディングが正しく機能しているなら、ランドマーク数を取得することが可能になります。準備段階として、これを進めていました。このプロセスで、ランドマークのバインディング数はプライベートタイプを利用していますが、Bindingを使用すれば、ランドマーク数を外に出すことが可能になります。

次に、Bindingランドマーク数をカテゴリーごとにグループ化することができます。これにより、バインディングされたランドマーク数を管理することができます。モデルデータをバインドする手法も活用して、ランドマークのフィーチャリングを実現できますが、これにはフィルターとマッピングが必要となります。

まとめると、新しいランドマークを活用して、既存のバインディングランドマークを振り返りつつ機能を向上させる手法を考えていました。この手法により、ランドマークの操作が柔軟になることが期待されます。全体としては、設計を見直しつつ、より効率的なバインディングを目指して進んでいます。 コードの話をしている場面のようですね。Bindingランドマーク数の取り扱いについて議論しています。まず、「Featuredランドマーク数」という名前にして適切に設定し、これはBindingによってランドマーク数を返す雰囲気で進めます。Bindingランドマーク数をカテゴリーごとにまとめようとしているようですが、それがあまり意味ないかもしれないという悩みを抱えています。Bindingの名称やFeaturedランドマーク数といった用語がややこしく、整理する必要があるようです。

具体的には、ランドマークの名称を整理し、`AtBinderBlueBar`や`AtBindingBar`といった記述に落ち着かせようとしています。このことで、使用時にはランドマークの名前をそのまま使え、Bindingしたときには `$` を付ければ問題が解決するという話に進みます。

さらに、ModelDataを利用してBindingランドマーク数やFeaturedランドマーク数をどのように扱うか議論が続きます。モデルデータのプロパティや、フィルタリングの手法についても触れています。コメントアウトして影響を確認したり、`Featured`や`Filtered`のランドマークを整理する過程で、コードロジックの再確認をしています。

この名付けの整理やプロパティの活用により、「Bindingランドマーク数」がどれくらい変化するか検討しながら、全体の構造を把握しようとしている様子がうかがえます。 「ランドマーク」フィルターについて、どうして `Bindable` が使えないのかを考えました。最初に、`Filteredランドマーク` が `Bindable` になると使えなくなるため、そのままの状態であることが必要です。そして、`Filteredランドマーク数` を `Binding` にして回せるようにし、`Map` を使う必要があるところですね。

次に、`Binding` なランドマーク数の話に移ります。`ランドマーク数` を `ラップトバリュー` にする場合があります。モデルデータは `Featuredランドマーク数` を保持していなかったので、`BindingFeaturedランドマーク数` で初期化されるのがいいでしょう。`Replace` で `Binding` を消す作業も行い、`Featuredランドマーク数` か `Bindingランドマーク数` にするところが重要です。ただ、これで色々と問題があるので、調整が必要です。

`Bindingランドマーク数` を使って `イニシャライザー` を定義し、`サムシーケンス` ではなくなりますが、この形で進めます。要は `Bindingランドマーク数` という名前から、よりわかりやすい「ランドマーク」になることで、名前がスッキリします。

最後にラベルの定義ミスを修正し、`SELF` での書き出し部分をきちんと書き直すことで、意図した `Binding` の動作を得られるようにしました。誤った `Binding` との違いを正し、これで期待通りの動作をすると思います。 フォールループの中でアンダースコアに対して代入をしようとしています。ポイントはランドマーク数にDollarが必要かどうかです。Bindingがあると助かりますね。そして、ラプトバリューについて考えますが、これはBindingではありませんので修正が必要です。適切にBindingしてオプショナルにすると良いでしょう。また、別の部分での再変換が必要になるかもしれませんが、試してみましょう。

スクリプトをビルドして実行した際に、データが正しく取得できていれば、正常に動作するはずです。ランドマーク一覧を確認し、Bindingしたランドマークも処理しますね。モデルデータの部分で若干の混乱がありますが、必要であればコメントアウトしておいても問題ないでしょう。

特にクリック時の動作が重要ですが、最初の設定を見直して、Bindingが適切に行われているか確認します。お気に入りの設定やトレイルの処理にも注意が必要です。Bindingランドマークの利用箇所では、フィルタリング操作が正しく行われているか確認し、Bindingの流れを整理します。

アイテムスクリプションは、モデル管理から取得するものであり、コンテンツビューにおける操作も見直します。フィルタリングの条件設定を忘れないようにしましょう。特に、UsefavoriteOnlyパスとしてフィルタリングする部分は重要です。

末尾でのモデルデータの確認やランドマークのBindingに対しフィルタリングをかけた後、シミュレーターで動作確認をしましょう。どこに問題があるのかを探し、再調整する必要があります。条件分岐なども含め、全面的にチェックして対策を行います。 Switchの「フェイバリッドオンリー」は単に削除しただけのようです。自動化されたフィルターでフェイバリッドオンリーがオンだった場合の処理を行いました。条件が真の場合は特定の処理を、それ以外の場合はモデルデータのバインディングをそのまま返しています。これでコードは適切に動作しますが、何かうまくいかないところがありました。

リストを確認したところ、ちゃんと機能していることがわかりました。しかし、コードのバインディングがうまく機能していなかった部分がありました。ランドマークリストのランドマーク行やディテールにバインディングを適用しないと、UIが更新されない問題が発生しました。具体的には、スターをクリックしても期待した動きが見られなかったところです。でも、コード全体にバインディングを適用することで、ちゃんと機能するようになりました。

Apple Watch向けのターゲットも設定しました。watchOSのランドマークディテールが正常に機能するには、モデルデータのバインディングをきちんと定義する必要があります。ビルドが成功し、今のところ大きな問題はなさそうですが、バインディングの使用に頼りすぎていると感じています。これは、これまで見てきたUIコードとは異なるアプローチであり、必ずしも良いコードとは言えないかもしれません。どこで再評価のタイミングが来るかを考えるのも価値がありそうですが、すぐには答えが見つからないため、今回のところはここで一区切りとします。 バインディングを使い続ける利点は、元のデータが同一であることが保証され、例えば外部から渡されてきたランドマークとエンバイロメント内のランドマークを照合して見つけて処理することがランタイムに依存するのを避けられることです。通常、渡されたランドマークはエンバイロメントに存在していると考えられますが、その保証が無くなる可能性もあります。それよりも、ランドマークのバインディングを扱うことで、ランドマークが確実に存在していると保証できます。この点から今回、エンバイロメントを使わなかったというのが理由です。

以前はエンバイロメントが登場する以前の方法で普通に処理を行っていたでしょうが、あまり触っていなかったのでその頃のセオリーはよく分かりません。ですが、不要なコードを整理しつつ、細かいバインディングは削除しました。それで良さそうですね。エラーもありませんね。

フェーバリットボタンのバインディング処理も順調です。ランドマークリスト関連では、まだiOSのモデルデータを使用していますが、このモデルデータも順調に利用できています。リファクタリングが順調に進行しており、最近の様々な試みが随分と成果を上げています。最終的には完成したコードがどのようなものになるか楽しみにしています。

現状のコードはかなり論理的に整っており、多少煩わしい部分はあるものの、全体的にきれいにまとまっているように思います。インデックスを検索することは、今では不要となり、依存しなくなったのは良い兆しです。これでビルドも無事成功し、警告も解除できそうです。

警告はトレイトセットに関連しているようですが、ビルドの問題を解消した際、アセットカタログのコンパイルで出ていました。トレイトセット自体の場所が不明ですが、これに関連する部分をクリーンして警告を再確認します。アセットカタログのトレイトセットに関連する部分を探してみると、UIトレイトコレクションに関連しているのかもしれません。これは、アプリケーションのユーザーにとって個別のエレメントを表現するコレクションです。アセットカタログのトレイトコレクションが問題の原因として考えられ、デバイスに関する部分も関与している可能性があります。 ユニバーサルデザインやプラットフォームに関する議論が続いているようですね。端末間でのリソース管理や警告をどのように処理するかを考えています。特にAppleのiPhoneやApple Watchに関連した話題で、「リソースをターゲットから外す」という対策や、警告を消す方法について模索しているようです。単品でのビルドや警告の減少効果を試みるも、警告はそのまま残ってしまうようです。そうした中で、クリーンビルドを試みたものの、やはり警告が出続けるため、別の資産が原因だと判断しています。

そこで、「復活カバラが落ちた」というアセットを見直し、それ復元する措置を考えています。「ウォッチでいい」という結論に至り、引き続きアプリのリソース配置についても再検討を行うようです。最終的に、今回のビルドでの警告は解消されませんでしたが、シミュレーターのバージョンやビルドのバージョンに関わる警告であることを確認しました。警告内容から、OSの影響というよりもシミュレーターのバージョンが関係していると考えているようです。

次回については、引き続きチュートリアルの続きを行うということです。リファクタリングが一区切りついたので、次はSection 4に進むようですが、どうもSection 3もまだ完了していない部分があるようです。そのため、次回の読書会ではこの続きから、アプリのリスト構築に関するセクションを進める計画のようですね。これで本日の作業は終了し、「お疲れさまでした」と締めくくっています。
