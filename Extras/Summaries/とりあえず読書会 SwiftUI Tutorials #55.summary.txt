Transcription & Summarize : とりあえず読書会 SwiftUI Tutorials #55

バウンドが `AdditiveArithmetic` を求めているのが問題でした。これを外す場合は、同時にこちら側の `Bound` に課している条件も外さないといけない状況です。

このとき、一つ問題が起こります。`ClosedRange` が `EnclosableRange` に準拠していないといけないのですが、これはまだ対応していません。`extension ClosedRange …` で `EnclosableRange` にしようとしても、準拠できていない状態です。`OffsettingRangeBound`、`EnclosableRange`、`PartialRangeBound` から `CountableRange` とか……。`CountableRange` は `typealias` ですよね。ということは、`Bound` の `Stride` がなぜ `SignedInteger` を求めているのか、というヒントは `CountableRange` 側にありそうです。ただ、`Double` は `CountableRange` ではないはずなので、そこはなぜなのかという疑問は残ります。とはいえ、問題を切り分けていけば解決に近づくので、方向性としては良さそうです。

ここまでは大丈夫です。ただ、このままだと実装上、`Element` の `ClosedRange` の `Bound` が `AdditiveArithmetic` でないといろいろ問題が起こってくるはずです。コメントを外すとどこかしらでエラーになります。`SignedInteger` のエラーを消してみるとどうでしょう。

今見ているのは `Double` に対する距離で、`distance(to:)` は取れますし、`advanced(by:)` も使えます。連続性を表現できれば良いのかな、と。`Stride` は `Double` ですよと言っているのに、少し不思議な感じがします。Playground はここにはないので、`Strideable` を確認します。`Strideable` は、`Stride` が `Comparable` かつ `SignedNumeric` で、`distance(to:)` で距離が計算でき、`advanced(by:)` で進められます。つまり、自分の `Stride` に対するイメージが間違っていました。`Strideable` は、渡してあげた距離分だけ `Stride` でステップを踏んでいく、という形です。であれば `Double` でもいけますね。自分が勘違いしていたのは何だったのかというと、`Integer` なんかは 1 つずつ進めますよね。あれが `CountableRange` の話です。勘違いしていた点はひとまず理解できました。あとは「ストライド」と言っているものがどんなものか、実際にはいろいろ使ったことはないのですが、面白いですね。

ということで、`Double` は `Strideable` です。そのうえで、今回どこかで `Stride == Double` を求めているはずですが、どこでしょう。参考用のコードは横に置いておいて、機械側はこっちを見ていきます。`enclosingRange` を呼んでいるところでエラーになっているということは、この `EnclosedDoubleRange` が求めているものが間違っている可能性があります。どこで `Stride == Double` を求めているのでしょう。理想的には「最小のステップができる単位」を作れたら良いのですが。

たとえば、ここで `EnclosedDoubleRange` を求めないことにすると、まあ当たり前ですがそうなりますね。`Element` に何も条件がなければ、`Element` が `EnclosedDoubleRange` のときに、`EnclosedDoubleRange` が `AdditiveArithmetic` を求めない場合はどうなるか。`Bound` が `Self.Element.Bound` …みたいなところで、「ラベルが邪魔している」と言われています。どっちだったかというと、`min`/`max` の型が違う、という話でした。タプルのラベルが邪魔をしていたようです。`lower` がありましたね。だから逆でした。ラベルを付ければよくて、`lower` がこれ、`upper` がこれ、というふうに付けました。 大丈夫ですよね。それで、こっちがローアー、こっちもローアー、あとこっちとこっちがアッパーです。その上で、また `min` / `max` がうまくいっていない感じですね。`min` と `max` は何だろう……。`min` は `Comparable`、コレクションの中…あ、`min` は2つの値を `Comparable` として取るやつと、コレクション（`Sequence`）が持っているやつがありますよね。なるほど、`Sequence` が `min()` / `max()` を持っているから、そっちに引っ張られてダメなんだ。グローバル関数を使うなら `Swift.min` / `Swift.max` と書かないといけないんですね。うーん、毎回 `Swift` と書くのはちょっと煩わしいですが、省略する方法は特にないので我慢ですかね。そうした方が確かに明示的です。

では、ローアーとアッパーについて。`bounds` をタプルに合わせると、この規模感のコードだと逆に冗長になってしまいます。外にこれを丸ごと渡すならタプルにして分解されないことを要件にする、というのもあり得ますが、今回はその必要はありません。`lower` がレンジのローアー、`upper` がレンジのアッパー、と変数名で十分に分かりやすいので、これでいきます。

こうしてあげると…コードが、うーん、読めないか？ いや、左側を消そう。こうですね。これで完成しましたかね。ビルド…お、シャキッとしてる。あ、そうか、`Optional` のレンジだからまたありますね。`lower` / `upper` と `overallRange`。これが取れていない場合にエラーになるようにして、条件がいつ `isEmpty` になるかを見ます。こうすると全部が通るようになって、ビルドも通りました。ここはまず良さそうです。

で、`EnclosableRange` はこれが必要ですよ、と言っていて、`ClosedRange` もこれが必要ですよと言っています。インターフェースは揃っているのか。エレメント（正しくはバウンドですね）が `AdditiveArithmetic` であることを求めている。さらに `smallestEnclosingRange` がどうだったか、という話ですね。それだけですかね。

あと考えられるのは、これがなくなると中の計算ができないから、これがある状態にしておく必要があること。`EnclosableRange` だから、中のレンジのバウンドが距離を取れないといけないのかな、というあたりは悩ましいですが、少なくとも現状の計算、つまり肝心の `smallestEnclosingRange` を計算するには `AdditiveArithmetic` が必要です。`min` と `max` が使えない状況では、この振る舞いを期待するのはおかしい。であれば、`EnclosableRange` は最初から「バウンドが `AdditiveArithmetic` であること」を最低条件として求めるのが筋ですね。今回はそれを求めておいた方が良いと思います。`smallestEnclosingRange` ができない `EnclosableRange` は、あまり意味がないですからね。

ということで、これで完成です。要は、`EnclosableRange` のバウンドが `AdditiveArithmetic` かどうか、というのを最低条件として確定させました。結局のところこの辺はそれで確定ですね。

試しに、仮のものを全部消してコンパイルしてみると、問題はここだけ、というのが分かりました。これでビルドを通すと、ちゃんと通ります。大丈夫ですね。つまり、なかったのはこれ…いや、これがなければできない、ということですよね。そうです。`EnclosableRange` も入れておきます。ほかの `Range` 系も入れられるなら入れたい気はしますが、`CountableRange` は `typealias` でした。 エンクローザブルレンジについては、このあたりでいったんまとまっています。`PartialRange` とかも関係ありますが、あれはそもそも `upperBound`／`lowerBound` が両方そろっていないので、エンクロージングできません。つまり対象外ということです。その点はよく表記できていますね。これで「完成した」という感じでしょうか。

ほかにできることがないかも確認しました。これでベクトルで買ってきた後、エンクローザブルレンジの `lowerBound` と `upperBound` のように扱えるのでまず良いですし、特定の型でこのエンクローザブルレンジに対応させる、いわゆる独自型を使ったときにも、自分でそれぞれの実装を書いておけば、ちゃんと動くようになります。良い感じですね。

このあたりで、レンジ表現の書き方がややこしいところもないとは言えませんが、`RangeExpression` が `Bound` を取っていましたし、そこで得た `Bound` を `AdditiveArithmetic` に乗せて扱えば良いわけです。拡張の面でも、`Sequence` の `Element` がエンクローザブルレンジのものに対して機能を載せていく、という拡張としてここで良いですね。データを作るのは自分自身のデータから作って、それを使って回していきます。開始と終端がそもそもなかった場合には、無効な範囲として `0` から `0` を作って返す、という形にしています。

ただ、ここはどうしましょうか。`0` から `0` と書きましたけれど、本音としては「無効な範囲」を返したいわけです。未定義（undefined）ではないし、不正（illegal）でもない。やはり「無効（invalid）」ですね。`available`／`unavailable` という感じでもないです。なので、`invalid` という名前で、`Self` を返すプロパティ（たとえば `static var invalid: Self`）を用意しておいて、その上で一般的にこういった範囲で無効なものを扱えるようにするのが良さそうです。

では始めていきます。とりあえずの紹介で、リファクタリング――チュートリアルのリファクタリングを進めておりますが、その最後の最後、最後の一山というところを見ています。関数、ジェネリック関数に、そういえばチュートリアルを進めているときにできなかったな、というのがあって、もう一度挑戦してみようと前回やり始めたところ、思いのほか謎のところで引っかかってしまい、うまくいきませんでした。今日はその続きです。前回途中、真ん中くらいからいろいろあってコードが見えにくかったところもあるので、改めて画面でちゃんとコードが見える形で話を進められたらという感じで、挑戦を続けていこうと思います。

このコードですね。画面にある `SmallestEnclosingRange` の修正をして、いい感じにまとまったと思っていたのですが、どこがダメだったのか。今の `ObservationRanges` は `Double` に対してキー・パスを取っていましたよね。このキー・パスが指しているのは `Range<Double>` なので、`SmallestEnclosingRange` が期待しているのは、いくつかの配列――配列の中にいくつかの範囲があったときに、そのすべての範囲の中の最も小さいところから、最も大きいところまでをカバーする最小の包絡範囲、ということになります。どんな形でもいいから、とにかく条件に見合えば `SmallestEnclosingRange` が使えたらいいよね、という感じで作り始め、いい感じにコードができた段階で、改めて最後のチェックをしようとしたら、肝心の `Double` が出てきていなかった、という状況になりました。

これを直さないことには、チュートリアルをちゃんと動かすことができません。今のコードは、`Sequence` の `Element` が `EnclosableRange` に準拠することで汎用化する、という狙いでした。準備は少し大げさですが、本当に汎用化したいならこれくらいでいい、という話をしていたわけです。ただ、現状はうまく動いていません。そもそも、ここはジェネリックにせず、`Sequence` に対してではなく、`Element` がこのプロトコルで表現されるのではなく、以前のように `Range<Double>` という具体型で指定していた、というのが元の形でした。そこをもう一度見直しつつ、修正を進めていこうと思います。 やることとしては、どこまで戻せるのか、何に戻せるのかを考えます。戻すとしたらこれですかね。`==`、`==`、`Range<Double>`。最初はこうなっていたわけですよね。

このコードは当初、問題なく全部動く状況でした。どこが変わっているのかというと、ここですね。今は「具体的に `Range<Double>` に対して使う」と明言しておけば大丈夫、という状況だったものを、「これでいいじゃん」という形に汎用化しようと直したらダメになってしまった、という流れです。

直近で見て分かるように、この辺に確認用のコードを入れておきます。例えば、コメントで `// MARK: ダミーとして` として、`func dummy()` を用意します。この中でレンジをいくつか作ります。

- `let r1: Range<Int> = 0..<5`
  - `Int` のレンジです。今回はメソッドやプロパティが呼べれば良いので、要素数は厳密にしなくてもよく、例として `0..<5` にします。
- `let r2: Range<Double>` これは本命ですね。今回の PR では `Range<Double>` を相手にしていました。
- `let r3: ClosedRange<Int>` にしてみるとか、`Range<Float>` にしてみるとか。
- `let r4: CountableRange<Int>` も試せます。

これらが全部、`==` の定義や `smallestEnclosingRange` を使って汎用化できれば「うまくいった」という話になるはずです。`r1.smallestEnclosingRange(...)` のように呼べるかを見ます。`Range<Float>` にして複製してみても、どちらもおそらくうまくいかない、という状況です。

問題になっているのは、もともと `Range<Double>` に固定していたときは、`Double` 以外ではダメでした。今の形はそれよりは良いのですが、「`Int` にしたら効いていない」わけです。ただ、`Double` を相手にしていたおかげで、たまたま付けておいた（食わせておいた）`smallestEnclosingRange` のジェネリックが汎用化できるのでは、ということに気づけました。しかし実際にはそれが失敗していた、ということも分かりました。

ということで、`smallestEnclosingRange` の汎用化、つまり「エンクロージング・レンジのジェネリック化」「`Range<Double>` からの汎用化」をきちんとやる必要があります。

`r1`（`Range<Int>`）ではなく `Range<Double>` の方を見ます。参照しているプロパティの要件を見ると、`Double.Stride` を要求している、と書いてあります。`Stride` は `SignedNumeric` に準拠している必要がある、というやつですね。「`Double` が `Stride` ではないのでは？」という疑問が出ますが、`Double` は `Strideable` に準拠していて、その `associatedtype Stride` は `Double` です。つまり「`Double` を `Stride` にすれば普通に動くのでは？」という発想になります。

`Stride` は何でしたっけ。`Strideable` には、ある値から与えられた値までを一定の歩幅で進む、という概念があり、`distance(to:)` と `advanced(by:)` がセットで定義されます。`Stride` が整数の場合は、x と y の距離 n が定義できて、`x.distance(to: y) == n` かつ `x.advanced(by: n) == y` のように往復できる、という話でした。整数なら 1, 2, 3, 4, 5, 6… と「歩幅」を素直にイメージできますが、`Double` のときのストライドは何なのか、というのが今回の引っかかりどころです。 とりあえず、英語の「approximation」はよく見るのですが覚えていないので、日本語で確認したいと思います。日本語では「近似」です。

ビルドが通ったり通らなかったりしているのですが、今は通りました。なぜ通ったのかが分かりません。以前はここにも上にあった気がします。`Element` の `Bound` が `AdditiveArithmetic`……よく出てきますね。どこがおかしかったのでしょうか。これはいらないですよね。`Element` が `AdditiveArithmetic` だというのは、`Range`（正確には `RangeExpression`）や関連する制約のどこかで既に言っているはずです。なので、`Element` に対して改めて重ねて書く必要はないはずです。

ちょっと待ってください。どこを直したのか、コードをどこまで戻せるか確認します。こうして、この辺のいろいろを消して……こうなって……あ、この辺はこれでいいのか。2カ所選ばれているところみたいですね。こうすると、ここだ、これが出た。そうすると、`RangeExpression` の `Bound` が `AdditiveArithmetic`。そして、この `Range`（あるいは `ClosedRange`）の `Element` が `AdditiveArithmetic` のときに……いや、`Range` が `AdditiveArithmetic` のときに拡張、というのはおかしいですね。拡張対象は `Range`（や `ClosedRange`）で、制約はその `Bound` あるいは `Element` が `AdditiveArithmetic` のとき、のように書くべきです。`Sequence` は、ここでは `Element` のみが関係するので大丈夫ですね。

問題があるのはここです。コピペで同じことをもう一回書いてしまっているのですが、`ClosedRange`、`ClosedRange`……押したときにエラーが消えない。どこを押したのでしょう。`Element` に `AdditiveArithmetic` を課した結果、型推論がそちらに引っ張られて、もう戻れない状況になりました。

ここまで直していきます。やったこととしては、`Bound: AdditiveArithmetic`、`Range` の `Bound: AdditiveArithmetic`。今回関係あるのは、`RangeExpression`（あるいは `Range`/`ClosedRange`）の `Bound: AdditiveArithmetic` を求めている箇所です。押したときに、`Range` の `Element: AdditiveArithmetic` に限る、という条件が必要ですよね。その制約が必要です。`ClosedRange` が `RangeExpression` で、かつ `Element: AdditiveArithmetic`……これでもまだ不要なままです。`Sequence` の `Element`、`Bound` はこのコードでは依存していません。依存していない以上、制約として書く必要はありません。ここに「`Bound: AdditiveArithmetic`」と書いてあっても、このコードがそれに依存していないなら関係ない、ということです。依存していない、つまり制約は不要ということですね。何が違ったのか。

もう一回、コンパイラを相手に、まずはコメントアウトして、無理やりコンパイルが通る形にします。`Element` の条件をいったん消してみます。これでもダメですね。では、ここの条件を一回消してみます。これでエラーが1個消えました。もう1個も消える。なるほど。そうしたときに、`0` が使えないのと、足し算（`+`）、引き算（`-`）や `min/max` を使っていたところができなくなります。`AdditiveArithmetic` による `zero` と加減算に依存していたからです。ここは良いのですが、`ClosedRange` で `Element` が `AdditiveArithmetic`、例えば `Bound: AdditiveArithmetic` であれば、距離の `0` は `zero` で表せますよね。そこが大丈夫かどうかを確かめないといけません。

Playground で確認しました。Playground を用意していなかったので、作ります。Range は意外と知らないことが多いですね。自分の話ですが。Xcode で Blank の Playground を作って試します。Range で距離（`distance`）やカウント（`count`）を利用できるかどうか。例えば、

- `let r1 = 0..<0`
- `let r2 = 1..<2`
- `let r3 = -3..<8`

のようにして、先ほどと同じようなケースを作ります。`r1.isEmpty`、`r2.isEmpty`、`r3.isEmpty` は取れます。では距離は何で取れるのか。`distance` は直接はないので、`count` かな？ ただ、`count` は `Range<Int>` が `Collection` に準拠している場合に限ります（`ClosedRange` は `Collection` ではありません）。まず一番大事なのは、0 で割るのが問題、というこの事情です。ここをきちんと確認して、0 の距離（`zero`）の扱いで落ちないようにする必要があります。

一度、`Never` かな……いや `Never` ではないですね。とにかく、まずは無理やりコンパイルを通せる形にしてから、`Element` の制約を最小限にして、`zero` と加減算が本当に必要な箇所にだけ `AdditiveArithmetic` を課す、という方針で直していきます。 まずは前提条件（コンディション）を整えるのが第一です。75行目のためだけに、`smallestEnclosingRange` の中でエラーチェックをしたり、都合のよい値を返すような実装にするのはおかしい、という点が大事です。その上で、どうするかを考えます。

ここは `isEmpty` かどうかも関わってきますし、`Range(uncheckedBounds:)` を使っている以上、どこまでチェックすべきかという論点もあります。ジェネリックな実装の中では、無効（invalid）な範囲を作れてしまう可能性はままあります。ただし、`Comparable` を要求している以上、`lowerBound` と `upperBound` の組から極端におかしな境界が出てくることは基本的にはないはずです。

一方で、レンジ型では `0...0` や `1...1` のような範囲は作れてしまいます。内部では `min` と `max` で統一的に処理しているため、`1...1` が成立するにはそれに対応する値が揃っていなければならず、その時点で無効になるケースもある、という見方もできます。そう考えると、「無効な範囲をあえて扱う」可能性も尊重すべきです。実際の使用箇所では `0...0` のような範囲が入ってくることも許容して正常とみなす、という設計のほうがよいかもしれません。`smallestEnclosingRange` 側で余計な加工をしてしまうと、「無効な範囲を扱わない」前提のアプリケーションがこのプロパティを使えなくなってしまいます。変なチェックは入れない、という結論で良さそうです。

そうなると、呼び出し側、つまり `GraphView` の中で適切にチェックすればよい、ということになります。`observations` から `KeyPath` を取ってくる前提で、`observations` は必ず空ではない（`isEmpty == false`）という約束が用意されています。空でないなら、今回のように有限の範囲（`lowerBound` と `upperBound` からなる `ClosedRange` を前提に `enclosingRange` を求めている）になるので、少なくとも1要素以上がある保証が出た時点で、この場面では `nil` が返ってくることはありません。したがって、`enclosingRange` はここでは大丈夫です。

あとは簡単で、今回の `observationRange` は通常の `Range` を構成しています。このパスの裏では `Range` が使われているので、ここで「無効なレンジ」である可能性は残ります。その場合は `isEmpty` が `true` になるという大前提がありますから、そこは `guard` 条件で弾いてあげればよいでしょう。

与えられたレンジは、外部リソースを読むなどの都合で外から渡されると考えると、何が入ってくるかは分かりません。ただし、イニシャライザの時点で「必ず1個以上ある」ことは決まっているので、その条件を `guard` で満たさないものは早期に抜ける、という方針で問題ありません。`isEmpty` かどうかも外から与えられる値次第ですが、この条件付けで十分だと思います。`overallRange` が確定するまで計算できない部分は、その時点まで遅延させればよいでしょう。

ゼロ除算については、どこで起きていたかというと `overallRange` 周りでしたね。ただ、`overallRange` が空ではない（`isEmpty == false`）という前提が立つなら、幅がゼロになるケースはその経路には入りません。`lowerBound` や `upperBound` 自体が 0 である可能性はありますが、それだけで問題は起きません。

最後に、`AdditiveArithmetic` を使っているのはここでしたっけ？`max` を使う想定でしたよね。 必要なのは Comparable ですね。`AdditiveArithmetic` はゼロを使うときに必要だったのを覚えていますが、無効な範囲を表現するためには不要です。というのも、`ClosedRange` には「無効な範囲」という概念がそもそもありません。`0...0` は正当な範囲であって無効ではありません。したがって、Smallest Enclosing Range（最小包含範囲）を作る処理では、範囲が取れない可能性を表現したい場合は、無理に「ゼロからゼロ」を使うのではなく、`nil` を返すのが適切です。

実装方針としては、範囲のイテレータから最初の要素が取得できなければ、範囲が存在しないので `nil` を返します。最初の要素があれば、その要素の下限と上限を初期値として `min` と `max`（ここではタプルで保持）を持ち、残りの要素がある限り走査して、`min` と `max` の位置関係を更新していく、という形にします。これで Smallest Enclosing Range を構成できます。

この設計にすると、境界 `Bound` に要求するプロトコルは `Comparable` だけで十分です。`AdditiveArithmetic` は不要になります。`RangeExpression` の定義上も `Bound: Comparable` が要求されていますし、下限と上限（開始点と終了点）があって、それを使ってイニシャライズできればよいので、要件はきれいに揃います。

コードの形としては、例えば最初に取得した範囲から
- `let bounds = (min: first.lowerBound, max: first.upperBound)`
のようにタプルを作り、以降は `bounds.min` と `bounds.max` を更新していきます。こうしておくと、名前の衝突を避けながら、`min`/`max` の更新が分かりやすく書けます。最終的に `bounds.min` と `bounds.max` から新しい範囲を作ればよいです。

距離を求めたいときは `distance(from:to:)` を使います。`Int` のように `Strideable` に適合している型であれば、`lower.distance(to: upper)` の形でも求められます。例えば `Range<Int>` を扱うとき、`r1.lowerBound` から `r1.upperBound` までの距離を取り、`r1` や `r2` それぞれについて同様に計算して `print` で確認する、といったデバッグ出力もできます。出力のラベルは A、T、X、Y、Z のように付けておくと分かりやすいです。

なお、途中で「配列」と言いかけていますが、ここで扱うのは `Range<Int>` そのもの（配列ではない）として考えるのが正しいです。Range 自体をどう扱うかはこのままで問題なさそうです。 こうしてあげたときに、誰が 0 を示すか、という話ですね。これは distance の話で、やってみれば OK です。`A` が empty のときは結局 0。よく考えると、`0` から `0` は `0` ですし、empty のときが結局 0 というのは当たり前でした。という感じで、とにかく分かりました。そうすると大丈夫ですね。empty は前提条件から外れているので、これで問題ありません。

こう見ていくと、オーバーオールのレンジも、出てきたとおり「`upperBound` から `lowerBound` を引いたもの」と解釈できます。つまり、`Range` の幅は `upperBound - lowerBound` です。ここはもう少し厳密に解釈できます。求めたいのはアディティブな算術（`AdditiveArithmetic`）としての差分ですが、レンジ自体（`Range`）ではなく、そのバウンド（`Bound`）のほうが「距離」を計算するために必要な性質を持ちます。

`RangeExpression` は `distance` を持っていません。用意されているのは `contains(_:)` と `relative(to:)` でした。ということは、距離を得るためにはバウンドが `Strideable` である必要があります。つまり、`Bound: Strideable` です。

`Range` に対して拡張を生やす想定であれば、別途ユーティリティは不要です。自分自身に `distance` を持たせられます。例えば次のように書けます。

- `extension Range where Bound: Strideable { var distance: Bound.Stride { lowerBound.distance(to: upperBound) } }`

ここで使っているのは `Strideable` のメソッド `distance(to:)` です。`lowerBound.distance(to: upperBound)` の形が正しい順序です。`Bound.Stride` は符号付き数値ですから、必要なら `magnitude` で絶対値を取れます（「マグニチュード」ですね）。

`distance` が `Int` かどうかという点ですが、汎用的には `Int` ではありません。`Bound` の `Stride` に依存します。例えば `Int` の場合は `Stride == Int` ですが、`Double` なら `Stride == Double` になります。したがって、`Range` 単体では `Comparable` だけでは距離は計算できず、`Bound: Strideable` という制約が必ず入ってきます。

`RangeSet` も少し見ました。`formUnion(_:)`、`union(_:)`、`formIntersection(_:)`、`subtract(_:)` といった集合演算の API が揃っていて、場合によっては配列でマップして作るより `RangeSet` を使う選択肢もあります。ただ、無理に使う必要がある場面ではなさそうです。内部的には配列を使っていそうですが、`contains` や `isEmpty` などが用意されています。`Bound` は `Comparable` が要求されます。

改めて `Range` を見ると、`public struct Range` として `lowerBound`、`upperBound`、イニシャライザ、`contains(_:)`、`isEmpty` などがあり、他にも `clamped(to:)` があります。`clamped(to: limits)` は、与えたリミットにレンジを収めるためのメソッドです。書式は `clamped(to:)` で、引数はリミットのレンジです。

一方、途中でシンタックスがおかしくてセミコロンを書けと言われる状態もありましたが、そこは単純に記述が間違っていただけです。`Range` の拡張は `extension Range where Bound: Strideable { ... }` のように書き、`distance` は `lowerBound.distance(to: upperBound)` として定義すれば解決します。 あとは `overlaps` と `contains`、それからマッチング用の `RangeExpression` ですね。レンジはいろいろと配列に使うようにしてあります。文字列表現、比較可能、ハッシュ化可能、変更可能といった性質も押さえています。`PartialRange` についてはひととおり扱ったので、ここまでで区切りでしょうか。

バウンド（`Bound`）は `Comparable` までの制約で止まる、という整理でよさそうです。追加で必要としているのは何かというと、`AdditiveArithmetic` です。`Strideable` が求めているのは `Comparable` で、かつ `Stride` は `SignedNumeric` ですね。`SignedNumeric` である `Stride` は、加減算ができる、という意味で `AdditiveArithmetic` の性質を含みます。ここまでを踏まえると、`Strideable` を直接使ってもよいのですが、`AdditiveArithmetic` が出ていれば `Strideable` にも対応しやすくなります。

距離（ディスタンス）を考えるとき、`Stride` は `SignedNumeric` です。普段はそこまで一般化しませんが、レンジの中でバウンドとそのストライドが同じパターンで表現される（たとえば `Int` のような）場合には、バウンドが `Strideable` でなくても、`AdditiveArithmetic` が大事になります。`AdditiveArithmetic` に従っていれば、距離は「アッパーバウンドからローワーバウンドを引く」と考えられます。つまり `upperBound - lowerBound` が一番すっきりします。

もちろん、ローワーバウンドとアッパーバウンドが無いと距離は取れません。したがって、レンジに対して距離を求めるには、少なくとも `lowerBound` と `upperBound` を持つ型が必要です。`Range` や `ClosedRange` はどちらも `lowerBound` と `upperBound` を持つので大丈夫です。一方で、`PartialRange` はどちらか一方の端しか持たないので、ここでは対象外になります。この点が少し気になっていました。

方針としては、バウンドが `AdditiveArithmetic` なら距離（ここでは便宜的に「マグニチュード」と呼んでいるもの）を提供したいわけです。やり方は二つ考えられます。ひとつは「`Range`/`ClosedRange` に素直に生やす」。もうひとつは「`lowerBound` と `upperBound` を持つ範囲型のためのプロトコルを定義して、そこにプロトコル拡張で生やす」です。

プロトコル拡張で書くなら、たとえば「`lowerBound` と `upperBound` を持つこと」を要件にした上で、`where Bound: AdditiveArithmetic` の条件で `var magnitude: Bound { upperBound - lowerBound }` のように書くイメージです。いずれにせよ、`RangeExpression` そのものに付けるのは難しいです。`RangeExpression` は `relative(to:)` はありますが、`lowerBound`/`upperBound` を直接は持たないので、このままだとダメですね。

今回の目的に限れば、`Range` であろうと `ClosedRange` であろうと、要するに「両端を持つレンジ互換のもの」であれば、バウンドが `AdditiveArithmetic` のときに `upperBound - lowerBound` でマグニチュードを計算できます。実際、いま扱っているのは `Range` 型なので、その `magnitude` はこれで十分です。`ClosedRange` でも同じ要領でいけます。

もう一つ気になる点がありましたが、確認してみると問題ありませんでした。 えーと、`EnclosableRange` を使ったときは大丈夫ですね。これで大丈夫でした。`EnclosableRange` も大丈夫で、`RangeExpression` のときは、そもそも `lowerBound` がないので、`EnclosableRange` の `Magnitude` などは存在しません。あ、完璧ですね。はい、これで言われたとおりになりました。OK じゃないでしょうか。

もう一度最後に見ておきますけど、このバウンドで、プライマリー型パラメータですね。ここは一応変えておきますが、プライマリー型パラメータです。ここが `AdditiveArithmetic` だから、今のところは何の役にも立っていないんですけど、今後何かの都合で良くなる可能性があるので、`AdditiveArithmetic` で大丈夫でしょう。`AdditiveArithmetic` はとりあえず絶対条件です。

それで、`Range` と `ClosedRange` はすでにインターフェースが揃っていますが、`EnclosableRange` とマーク付けされていないので、そこはマークを付けてあげます。これによって、`EnclosableRange` を想定した全ての場所で、`Range` と `ClosedRange` が使えるようになります。OK ですね。

その上で、`Sequence` で `Element` が `EnclosableRange` だったときには、`Sequence` 側で特に対応がなければ、相手側のイニシャライザに委譲して返します。それ以外だったら、ループを回して、最小と最大を更新していって、最後までループが回ったら（イテレータで回しています）、`lowerBound` と `upperBound` で `Element`、要は `EnclosableRange` 自身を組み立てて返してあげる、と。そういうことによって、このコードが完全にジェネリックプログラミングで表現できました。今回はレンジの話ですけれども、どんな型であっても `Comparable` であれば、そこに適合させれば、プログラム上のレンジが完璧に動作します。今ない型でも動くので、いい感じになりましたよね。汎用化もそうですが、それ以上のこともできますよね、ジェネリックプログラミングは。未来に登場し得る型に対しても効かせていけるので、これはライブラリを作る人には特に重要な話ですね。アプリケーションだと、このプロジェクト内がすべてですからね。

もう一回だけ確認して、これで通れば完璧ですね。動きは大丈夫でしょう。ちょっと動かしてみますけど、こんな感じで、まだ画面も何もないですよね。多分、ここでソートを入れればソートは動くし、フィルターを掛ければフィルターも入るし、これもお気に入りにしようと思えばお気に入りになるし、「お気に入りのみ」にすればこうなるし。で、ちょっとリアルではやっていなかったですけど、今回は私の思想によって、現在のフィルタリングのままソートを外しても勝手に消えることはなくなった、ということにして、これでフィルターを掛ければもういなくなる、という感じで、タイミングとしては悪くないでしょうね。これは個人的にお気に入りの改修ですけど、こんな感じでできましたね。

やっぱり macOS 以外、例えば watchOS をやると、iOS と watchOS を両方ビルドするので、これが通れば、iOS と macOS も今回のリファクタリングの影響でエラーになる、みたいなことがないというのが確認できますし、まあ大丈夫でしょうけど、一応ね、確認して。それでビルドが通ったら OK ですかね。うん、なんかもったいぶられています。見ておくと、何もないですかね。今見たファイルが `HikeGraph`。とにかくビルドは成功しましたね。こっちですね、`Range`、この `extension` の拡張を見ました、って感じですね。

これで全部のファイルを上から見ていったことになるので、最終的なリファクタリングはこれで完成ですね。ちょうどリアルなプログラムで、この辺はもうリソースだけなので、フォルダの分け方を今回はこうしました。iOS 用のフォルダには iOS 専用のファイルを分けてもよかったんですけど、そうすると結局内容のところが多いので、並べてしまえば「`HikeGraph` は全部なんだな」とか「`HikeView` は iOS と macOS は一緒で watchOS は別なんだな」とか、隣を見れば分かるので。あの辺の自動化を Xcode がやってくれたら最高だなとは思うんですけど、今はやってくれないのでね。こんな感じで、OK ですかね。うん、全部できましたね、これでね。

じゃあ、やっとこれで SwiftUI チュートリアルを読み終わったので、今度は何もまだ決めていないんで、ちょっと考えてみますけど、まず SwiftUI…
