Transcription & Summarize : とりあえず読書会 SwiftUI Tutorials #17

それでは、とりあえず読書会。SwiftUI Tutorialですね。こちらを読んでいきましょう。

ちょっと日が空いてしまったのですが、途中で中断が入ってしまいました。今回は、全体で気になったところをとりあえず試してみたいと思います。気になったところは、コンピューターが止まっていた状況で、それから特に何ということもしていないので、改善されているのかどうかがとても気になります。まずはやっていくしかない、という感じで見ていきます。

どこが気になったかというところから説明すると、プレビューを出したほうがよさそうです。どこをプレビューするかというと、`CategoryHome` ではなく、階層の一番上にある `ContentView` がよいですね。ここをプレビューで見て、まず動きを確認していこうと思います。動きというか、気になっているのは、プロフィールを表示する画面をボタンでトグルするところです。これから先を読み進めると何か対応が入るのかもしれませんが、それならそれで、暫定対応として様子を見ます。

その前に、気になるというほどではないのですが、プレビュー中は MacBook がすごく熱を持つんですよね。どこかが悪さをしているのか。一旦クリーンはかけました。再起動まではしていないのですが、おかしくなって困ったら再起動する、という感じでやっています。

こんな感じで少し困っていますが、Any iOS Device ではなくシミュレーターにしておきますかね。とりあえず、Any iOS Simulator ではなく、シミュレーターをちゃんと指定しておきます。iPhone 17 くらいでいいかな。これで、プレビュー中です。 これをピン留めしていますね。ピン留めはこれでいいです。今作ったのはこれで、プロフィールボタンを押すとこう出てきます。このボタンはトグルになっていて、もう一回押すと閉じるはずなのですが、これは押せないじゃないですか。ここが気になっているところです。そうなると、トグルじゃなくていいのでは、という点が気になります。

ただ、iPad ならボタンが見えるのではと思って、iPad で試そうとしています。前回はこれでコンピューターがハングアップする状況でしたが、今回はどうでしょうか。ハングアップの症状は、カーソルが動かなくなり、キーボード入力を受け付けなくなる。ただし、それ以外の機能は動いているように見える、という感じでした。見た目は動いているのに入力だけ止まる状態で、かなり困ります。コンピューターがすごく熱くて、調子が良くないのかもしれません。まあ、しょうがないですね。iPad シミュレーターさえ動いてくれれば今回は助かるのですが。

iPad シミュレーターのビルドが終わりました。これで表示されたら表示されたで、今まで何だったのだろうという気もしますが…。Twitter でも話題に出ていましたし、とにかくこれでプレビューされるといいのですが。

トグルの前にいろいろ確認しておくと、これでプレビューを切り替えても大丈夫ですよね。あれ、どこだ…。なんかダメですね。プレビューできませんでした。予期しないエラーだそうです。予期しないエラーって何でしょうね。あ、でも他のところを押すと取れますね。というか、他のところを押してからなら取れたのでは？ ちょっとボタンのトグルがどうなっているのか、もう少し見ます。

これを押して、もう一度押すとキャンセルされるのですが、ボタンが押されたかどうかを見ておきましょう。トグルのところから、ここでボタンが押されたかどうかを確認します。最初は `print` で見てもいいのですが、ブレークポイントにしてみましょう。ブレークポイントで、コンディションは特になく、アクションを Log Message にして、ここを通過したことが分かるようにログを出すようにします。さて、どうでしょう。今はキャンバスになっています。これを押しても…出ませんね。ブレークポイントのログは出ないのか。そうですか。では `print` にしましょう。こんな感じで、ボタンを押したときに出すようにします。出ましたね。もう一回ここを押したとき…出ないですね。もう一回押して、押して…これだと分かりにくいですね。どうしましょう。トータルのカウントを出しますか。`static` はいらないので、ひとまず `var count = 0` にして、押されたところで `count += 1`、ログに `count` を入れてあげれば、押した回数が分かります。1 が出て、もう一度で 2 が出て…押すたびに増えていますね。そういう挙動になっています。

次に、`sheet` の話です。`sheet` の定義をもう一度見ます。フルスクリーンにするなら `fullScreenCover`、モーダルな `sheet`。縦方向がコンパクトな環境（iPhone のポートレートなど）では、`sheet` は自動的に `fullScreenCover` に適応される、という説明があります。`View.presentationCompactAdaptation` というモディファイアで、縦・横の環境に応じた挙動を指定できます。パラメータとしては、表示状態を表すバインディング（`isPresented` 系）と、表示する `content` クロージャを受け取ります。`onDismiss` はシートが閉じられたときに呼ばれます。`content` は実際に表示される中身ですね。

UI 関連の記事を見ても、モーダルという言葉が頻出します。Apple のドキュメントでも、`sheet` は「バインディングが `true` のときにモーダルビューを表示する」と説明されています。やはりモーダルビューという位置づけです。

そうなると、このボタンはトグルといっても、基本的にはモーダル表示を出すトリガーであって、再度押して閉じるという使い方は前提になっていません。そもそも表示中はボタン自体が背後に隠れて押せないので、トグルにはなりませんよね。

あれ、プレビューが頑張っていますね。プレビューを出そうとして頑張っている感じです。何かコードを変えましたっけ。まあいいか。というわけで、とりあえず「トグルだとおかしい」と言い切るのは言い過ぎかもしれませんが、現状はボタンを押せないので、トグルとしては機能しない、という状況です。 ボタンを押したときにトグルにすれば、という場面はよくありますよね。`showingProfile` ですね。トグルって便利そうでよく使われるのですが、現在の状態に依存するので、日本語入力の切り替えボタンと同じで、今が何かを把握していないと、トグルした後に何になるのかが分からないのです。これは制御が結構難しいものだと思います。

今回も、ボタンが押されたときに `false` になっていて、トグルして `true` になった、そしてシートが隠されたときには `false` に戻る、という挙動ですよね。だったらトグルである必要はありません。ボタンが押されたときには `true` をセットすればいいのです。そうすると「ボタンが押されたらシートを出す」という意味に変わるので、意図が全然違います。これでちゃんと動けばよくて、実際に表示されましたね。閉じれば消えますし、もう一度押すとまた表示されます。これでいいのです、まずは。

なので、トグルを使うときは、本当にトグルでやる必要があるのかどうかを考えたほうが、何かと楽です。コードを見ていると、トグルでなくてよいところを、あえてトグルを使っている例を結構見かけます。トグルを書くときには、本当に必要なのかを見直したほうがいいですね。

次に、もう1点気になっているところがあります。`Featured` に対してはプロフィールボタンが付いていますよね。ではリストのときはどうなるのかを見てみると……ああ、これならまあ、という感じですが、「`Featured` の中ではプロフィールが見られるのに、リストではプロフィールを見られない」のは変ではないでしょうか。プロフィールって、もっと大きい概念（アプリ全体の設定やユーザー情報）だと思うので、リストでもプロフィール表示ができるようにしたほうがいいのではないか、と気になっています。

iPhone の場合、上部はナビゲーションバーでした。だから両方ともナビゲーションボタンとして置いておけばいいだろうと思っていたのですが、これだと少し話が変わってくるかもしれません。`Toolbar`、つまりツールバーですね。ツールバーにして、ツールバーのボタンとして出す、という形にしましょう。`Toolbar` はどこに出てくるのでしょうか。ちょっと試してみます。

今付いている `Toolbar` は、リストに対して付いています。`Featured` の中のリストに付いているのかな。`NavigationSplitView` の中にあるリスト、という理解でよさそうです。つまり、このリスト全体に対してボタンが付いている。`NavigationSplitView` ですね。

`ContentView` を見ると、`CategoryHome` と `LandmarkList` があります。`LandmarkList` の `body` を見ると、ここに `NavigationSplitView` があって（ここがエラーで赤くなっているのは置いておきます）、その後に `Toggle` があって、`List` がある。とりあえず試しに、このあたりに `toolbar` を入れてみましょう。リスト側のほうに入れます。あ、ここに出ますね。今はまだ中身を何も作っていないので、最終的には両方にあったほうがいいでしょう、きっと。そんなイメージです。

どこにどう実装していくかを考えます。`NavigationSplitView` の外側を見ると、その前のコンテナは `TabView` ですね。`TabView` の中に少し置いてみます。`Toolbar` はここに置けるでしょうか。ボタンを置いて、`Label` はこれで、とやってみます。プレビューでは、画面の端が見えていないですが、一応動かせました。うーん、でも出ないですね。 とりあえず、このボタンをいじって、プロフィール画面をどう表示するかを考えていこうという話になります。まず、このプロフィールボタンはどの画面でも同じボタンなので、共通化してしまって良さそうです。Toolbar…というより、Toolbar 内に置くプロフィール用のボタンを共通化します。

やり方としては、プロフィール用に新しくコンポーネントを作るのが良いと思います。試しにやってみます。Toolbar のボタン（プロフィール）部分をまるっとコピーして、View のコンポーネントとして切り出します。この中で、Toolbar 用ですが、名前は「ProfileToolbar」にしましょう。新しい Swift File を作って、`ProfileToolbar` のようにします。中身は SwiftUI です。

実装はモディファイアで持たせるのが良さそうです。`ViewModifier` を自作して、`body`（`ViewBuilder`）で実装します。つまり、`struct ProfileToolbar: ViewModifier` を作り、`body(content: Content) -> some View` の中で、`content` に対して `toolbar` を載せていく形にします。プロフィールを開く状態はバインディングで扱いたいので、`@Binding` のフラグを用意します。型は `Bool` ですね。たとえば、`@Binding var isShowingProfile: Bool` のようにします。

これを使いやすいように、`View` への extension も用意します。`extension View` に `profileToolbar` という関数を生やして、`Binding<Bool>` を受け取り、`modifier(ProfileToolbar(...))` を返すようにします。こうしておけば、呼び出し側は `view.profileToolbar(showingProfile: $isShowingProfile)` のように書けます。インデントなどは細かい話ですが、整えておきます。

画面名は「ユーザープロフィール」と言わず、単に「プロフィール」で問題なさそうです。ということで、まとめると、`View` に対して関数 `profileToolbar` を追加し、引数は `showingProfile`（`Binding<Bool>`）を受け取る形にします。モディファイアの戻り値は `some View` です。実際の適用は、`modifier(ProfileToolbar(isShowingProfile: showingProfile))` のように書きます。忘れていましたが、モディファイアを当てるときは `modifier(...)` を使います。`some View` で返すのも問題ありません。

できたので、まずはチュートリアルで作っていた `CategoryForm` のところに書いていた `toolbar` をそっと消し、代わりに `profileToolbar(showingProfile: $isShowingProfile)` を適用します。バインドする変数名は `showingProfile` にします。これで共通のプロフィール用 Toolbar モディファイアが使い回せるようになります。 Xcode のウインドウが隠れていたので広げました。不要なものをどかして、ボタンを押したときに正しく動作し、赤く表示されることを確認しました。OK です。

次に、リスト側（`LandmarkList`）でも、チュートリアルにはありませんが、同じコードでツールバーを出すようにします。`LandmarkList` にも同じツールバーを表示させたいので、先ほど用意したプロファイル用のツールバーモディファイアを使い、ここでバインディング（`@Binding`）を受け取るようにします。

このとき、「プロフィール画面を表示する」ためのシートも各画面に書く必要があるのかが気になります。場合によっては、プロフィールシート用のモディファイアをもう一つ作って、それで表示させるのも十分ありだと思います。ただ、`showingProfile` を2つ持って同時に2枚出ることは多分ありません。ならば、元になるところに持たせてしまえばどうだろう、と思いました。いわば `ContentView` です。やってみましょう。

`ContentView` に `@State private var showingProfile = false` を用意します。そのうえで、`CategoryHome` 側ではローカルの状態は消して、バインディングに差し替えます。つまり、`@Binding var showingProfile: Bool` を受け取り、プロファイル用ツールバーにはその `showingProfile` を渡します。

次にシートの場所です。`TabView` があって、その直下に `.sheet(isPresented: $showingProfile, ...)` を付け、`isPresented` に `showingProfile` を渡します。`CategoryHome` に対しても `showingProfile` をバインディングで渡します。省略できる書き方もあるのでしょうが、慣れていないのでまずは素直に書いて動作を確かめます。

`LandmarkList` も同様の形にして、`Binding<Bool>` の `showingProfile` を受け取り、必要な箇所にそのバインディングを渡します。

では押してみます……ビルドに失敗。どこかがおかしいのはプレビューのほうですね。SwiftUI のプレビューで `@Binding` を要求しているのに、値を用意していませんでした。

対応として、プレビュー側で `@State var showingProfile = false` を用意します。もう一箇所、別のプレビューでも同様に `showingProfile` を用意して渡します。`PreviewProvider` の中でバインディングとして渡せば大丈夫です。

これで OK のはずです。ボタンがちゃんと動くかどうか、プレビューが頑張っているので少し待って……押すとシートが出てきます。押すと消えます。もう一回押すとまた出てきます。リスト側でも同様に動作しています。

画面の上のほうも見たいのですが、スクロールで押し出されてしまいますね。とはいえ、コードは文字的にはすっきりしました。何か挙動に違いがあるのかは、もう少し触って確かめます。 とりあえず、これによって、このシートは大元のビューのところで表示・非表示を一箇所で切り替える形を取ります。そして、`showingProfile` はタブの他の2つに `Binding` で渡します。この中の、いわゆるナビゲーションの `NavigationSplitView` のアイテムとしてツールバーを表示します。ここが2箇所で同じものを作る使い分けになるので、これでいいんじゃないですかね。もしダメだという指摘があれば教えてほしいですが、勘としては良さそうなので、これで安心して次に進んでみようと思います。

で、プロファイル…どこか分からないや。チュートリアルに戻ります。Chapter 3 の Working with UI Controls ですよね。ここが終わったところだったんですかね。とりあえず最後を見てみますか。一番最後、どうだった気がするんだけれど、いきなり言っちゃいましたが、キャンセルボタンは終わってないですよね。終わってないか。じゃあどこまでだ。「Define a profile editor」、全然作ってないじゃないですかね。なので、あと `EditButton`、`EditMode` が回ったでしょ。これは「Display user profile」、ここですね。ここが終わったところだと思われます。おそらくこれでプロファイルサマリーを作って、`HikeBadge` を作りましたね。プロファイルサマリーを表示させるのはここですね。ここまでです。なので次はセクション2からですね、今日は。

エディットモードを加えていく流れになっていて、ユーザーはビューとエディットモード（プロファイルの詳細）をトグルで切り替えられることを望んでいる。エディットモードは、既存の `ProfileHost` ビューに `EditButton` を追加することで実現していくらしい。さらに、それぞれの値を編集していくコントロールも作っていく、と。そういったことをやるようです。

そのためにステップ1。まずは `ProfileHost` を選んで、持てるデータ…`@Environment` プロパティで持てるデータをここに追加する。このビューはまだ `@EnvironmentObject`（あるいは `@Environment`）を持っていないですよね。`ProfileSummary` や（たぶん）`HikeBadge` もまだ持っていないですよね。プレビューが失敗する？ 失敗するのか？ なんか訳に自信がなくなってきたので、訳し直しますね。プレビューが失敗する？ 翻訳ツールがうまく動いていない。`@Environment` プロパティラッパーを持つプロパティを使っていないこのビュー…うーん、全然訳に自信がない。`ProfileSummary` を使っている。`@Environment` プロパティラッパーを持っていないこのビューは `ProfileSummary`（や関連するビュー）…ここであっているか？ 構文の話なのか？ こういう英語は高校生の頃から苦手で、今みたいに逆に訳して外す、みたいなことを少しやってしまうので、変わってないですね。

モディファイアがない、修飾子がないとプレビューは失敗しますか？ そういう意味か。ここも全然違った。これ、勝手に付けたんじゃなかったっけ？ そんな気がしますね。とりあえず、プレビューができるようにしましょうというお話でしたね。

ステップ2。`@Environment` プロパティを付けて、`ProfileSummary` に `editMode` というのを付けるらしい。SwiftUI は、`@Environment` プロパティラッパーを使ってアクセスできる値を提供しています。`Environment` から `EditMode` を取得するために、`@Environment(\.editMode)` を使用する、ということでした。ここでそれを使って `editMode` の値…「ビルドインのエディットモード」かな、つまり環境に組み込まれている編集モードを利用できる、という基本的な話ですね。自信はあまりないですが、要するに `@Environment(\.editMode)` で組み込みのエディットモードを使う、という理解でいきます。 とりあえず用意してみます。`ProfileHost` に `EditMode` を持たせます。`ProfileHost` に対して `Environment` の `EditMode` を入れて、編集できるものを管理するために `EditMode` を使う、というところまで作りました。その上で、`Environment` のモード値をオン・オフ切り替えするための編集ボタン（エディットボタン）を作ります。レイアウトとしては、`Spacer` を入れてからエディットボタンを上の右側に置きたい、ということですね。

`EditMode` の値は同じく `Environment` から参照します。前のステップで作った `EditMode` と同じ要領で、その値にアクセスします。これでエディットボタン周りはもうできるはずですが、編集モードの環境をどう制御するかは、実際に作ってみれば分かりそうです。

`body` のところに `HStack` を入れて、`Spacer` を入れて、その後にエディットボタンを配置します。ちゃんとありますね。`Spacer` がイニシャライザに出た、という感じです。これでエディットボタンが見えないのは、プレビューのデバイスを iPhone にしていないからでしょうか。iPhone のプレビューにして確認します。あ、`Profile` を表示していないからでした。エディットボタンを押す場所は `HStack` ですよね。`ProfileHost` の上に載る想定なので、スペースの入れ方で隠れてしまうと見えません。どこからちゃんと表示させるかを調整しないと、隠れてしまいますね。まあまずは良しとして、`ProfileHost` のプレビューだけを見る分にはこれで大丈夫そうです。…あ、ダメでした。`Environment` に入れていなかったからです。入れ忘れていました。`Environment` にモデルを入れます。これで良いですかね。`ContentView` はとりあえず 1 個で、少し見にくいですが、まずはこれで進めていきましょう。

ステップ4として、モデルデータクラスをアップデートします。`ModelData` に `UserProfile`（ここでは `Profile`）のインスタンスを含めます。そして `Profile` を `ProfileView` のディスミス後まで保持する、ということですね。`ModelData` 自体に `Profile` を持たせ、そこにデフォルトを入れる設計です。ここは気になっていたところで、今はバンドルからの読み込みをイニシャライザでやっていますが、`Profile` は将来的にネットワークから読み込む可能性もありそうです。となると、ここで `Profile` だけデフォルトをあらかじめ設定しておく必要性はそこまで感じないのですが、とりあえず今回はここに置いてみます。イニシャライザでデフォルトを用意するのは良いとして、少し大げさな気もしますね。

`Profile` を用意できたら、`Environment` からユーザープロファイルデータを読み込んで、`ProfileHost` などのコントロールにセットします。グローバルなアプリの状態（state）の更新をすぐには反映させないために、まず編集前の値をコピーして扱います。つまり、ユーザーが名前などを入力しても、確定するまでは本体の `ModelData` を更新しないように、編集用のコピーを使う、という話です。

具体的には、`Environment` を `ProfileHost` に追加した上で、`ProfileSummary` を表示させますが、その際に `ModelData.profile` のコピーを渡します。`VStack` が付いていますね。`VStack` の中に置くべきところを、`ProfileHost` の `VStack` の外に置いていたので、そこを修正します。ここではデフォルトの `Profile` を渡しているだけ、という状態ですが、`ModelData` の中には引き続きデフォルトの `Profile` が入っているので、少し気持ち悪い構造に見えます。ひとまず先に進めて、後で見直すことにします。

`Environment` の設定としては、`Environment` に `ModelData`（`modelData`）を入れ、表示側の `profile` には `modelData.profile` を渡します。つまり、値型のコピーを渡す、ということですね。これでエディットがちゃんと見えるようになりました。押しても今は何も起きませんが、まずは良いです。

次に、条件付きビューを作ります。`EditProfile` は `EditMode` のときに表示されるビューです。編集モードに入った際の挙動は Live Preview でも確認できます。`EditMode` 時のビューは、ひとまず `TextField`（編集用のテキストフィールド）だけを置く形で始めます。 とりあえず、`EditMode` がオプショナルなんだ、ということですね。これの `wrappedValue` が `.inactive` だった場合は、仕様に沿って `EditMode` の `wrappedValue` を使ってみましょう。このときは好みの問題だと思いますが、自分はこちらのほうがよい気がします。

それで、`EditMode`。`EditMode` が何なのかという点ですが、型を見ていないとイニシャライザが出ているから…綴りが違うから、ということですかね。`EditMode` のプロパティの型がどこで定義を取るのか、ここが反応の出どころかもしれません。バインディングの `EditMode` 型ですね。

`EditMode` 型は、`.inactive`、`.transient`、`.active` があり、あと `isEditing` がありますね。`.inactive` は「編集可能なビューコンテンツではないとき」の状態で、テンポラリな編集モードのときには `.transient`。読み方はよく分かりませんが、こういうモードがあるのですね。

ともかく、さっきの構造をそのまま考えるなら、`.inactive` でない場合は編集モード、ということになります。読み方を踏まえると、やっと分かってきました。`EditMode` が `nil` だったときには…本当ですか？ `EditMode` が `nil` ってどういう状況なのか、まずそこが気になります。勘ですが、どうなんでしょう。

バインディングで `EditMode` がオプショナル、つまり `Binding<EditMode?>` になっているわけですよね。なぜオプショナルなのかというと、「バインドされていない場合」が考えられるのだと思います。編集コンテンツを編集できるかどうかの話ですね。`EditMode` の `nil` の話が出てほしいのですが、`nil` の話が出ていない気がして気になります。これは調べないと怖いですね。

ということで少し調べます。SwiftUI の `Environment` の `EditMode` あたりを見ます。この辺は UIKit より SwiftUI 側の情報が強いかな？ あるいは開発者ドキュメント？ これです。スクロールしづらいんですけど…。

「`EditMode` の Environment がセットされていないとき」と書いてあります。組み込みのものですよね。それがセットされていないときはどうなるのか。これは GPT に聞いてしまったほうが早いかもしれません。試してみます。

「SwiftUI の Environment `EditMode` についての質問です。この `EditMode` は `Binding<EditMode?>` ですが、この値が `nil` になるケースを教えてください」という感じで聞いてみます。

返ってきた答えとしては、オプショナルになっている理由は「`EditMode` が提供されていない可能性があるから」。そうですよね。SwiftUI は `List` などの一部のコンテナが `EditMode` を環境値として提供していて、それを参照できるが、それ以外で使うと存在しないために `nil` になる、と。すごく当たり前のことでした。

つまり、`EditMode` が与えられる状況で使っているのなら、`nil` は想定しなくてよい、という話になってきました。具体的に `nil` になるケースは、`EditMode` を明示的に設定していないとき。例えば、`VStack` の中で `EditMode` の Environment を書いた場合でも、`List` などが自動的に提供する環境値がなければ `nil` になる。iOS が標準のモード用に `EditMode` を自動でインジェクトするのは `List` などの場合で、逆にそれが存在しないなら `nil` になる、という説明です。

さらに、プレビューでバインドの値を渡している場合、例えば `environment(\.editMode, .constant(.active))` のように定数を与えると、バインディングを参照しようとしても更新可能ではないため、`nil` になることがある、という話もありました。コンスタントを使っているので、オプショナルの中身が書き換えられないケースですね。うーん、こんな感じでしょうか。

要するに、環境が `EditMode` を用意していないときには、`Binding<EditMode?>` のバインディングが `nil` になる、という話。ここだけは納得できる気がするので、それでよさそうです。まあ、本当にちゃんと確かめないといけないのですが。 とりあえず、改めてこの状況を見直してみます。つまり「絶対にエディットモードが返ってくるから、`nil` のときは返ってこない」と言いたいのかな、ということを想像するのですが、そうであればここはビックリマーク（強制アンラップ）のほうが正しい、という感じもします。

状況がだいたい分かってきたので、これを `switch` 文で書き換えます。`switch` 文のほうが明瞭だと思います。`EditMode` が `Binding` なので、`wrappedValue` で `EditMode` を取り出し、`case .inactive` のときにはサマリーを表示する、という形にします。これまではそれ以外のときの扱いが曖昧だったので、まずは書いてみます。`active` と `transient` と `nil` の状況のときには、テキスト……まあ何でもいいのですが、たとえば「プロファイルエディター」や「プロファイルサマリー」を出す、という想定です。

あれ、まだ止められていない。暗黙の `default` がないのかな？あ、`Optional` でしたね。さらに、`EditMode` 側が `Optional` だから、これは `Optional` に対する `switch` で、`wrappedValue` に対して `some` と `none` を書く必要があります。たぶん、`some` が抜けている、というコンパイラーの指摘ですね。`nil` と `some` が抜けているのでは、と思ったのですが、`wrappedValue` ですよね。いったん書き換えてみましょう。あ、`some` はこっちか。まだ網羅していないと言われます。

えーっと、網羅していない。`case .inactive`、`.active`、`.transient`、そして `some`。つまりこの3つのケース（`.inactive`、`.active`、`.transient`）と、`nil`（`.none`）の4通りが必要、ということですよね。おかしいな……やはり網羅していないのか。では `default` を書くべきかな……といっても `break` は書けません。`View` を返さないといけないので、とりあえず `EmptyView` を返してみます。これで、`.inactive` を入力すると「網羅していない」のエラーは出なくなるはずですが、`.some(.inactive)` がないよ、という話になります。つまり、将来 `EditMode` のケースが増えたときも拾えるように、`default` で受けるべき、ということですね。

この形にしたとき、`.inactive` のときには「プロファイルサマリー」が表示されます。`EditMode` が `.active` のときにはエディターが表示され、`.transient`（読み方は「トランジエント」でしょうか。一過性の、という意味ですね）も一時的な編集モードなので、これもエディットモードとして扱ってよさそうです。どういうモードかはまだよく分かっていないのですが。

`nil` のときは、サマリーを表示するのが妥当だと思います。`EditMode` がバインドされていないときに編集モードに入っていいのかという問題を考えると、`nil` をサマリーに寄せるほうが安全です。なので、`nil` もサマリー側に入れる、という考え方はあります。ただ、これは個人的な好みですが、`nil` は想定されないはずなので、ここは `fatalError` のほうが潔くて好きです。たとえば「`EditMode` が合いませんよね」といったメッセージで `fatalError` を投げて落とします。そうしておけば、「ここに来るはずがない」ことがコードから明らかになり、ここに来たときには想定していないことが起こっている、とすぐに分かります。単にここを `EmptyView` にしてしまうと、それが本当に正しい `EmptyView` なのかどうかが分からなくなってしまいます。 これは、状況によりますが、`@unknown default` を使うのは避けたほうがいいかなという気がします。将来、選択肢（ケース）が増えたときに、`fatalError` にしていると、OS のアップデートなどで `EditMode` の条件が増えたときにアプリがまったく動かなくなる、というのはさすがにまずいですよね。そこが気になるところです。

そういうときにどうするか。プロファイルエディターを出すのか、その代わりにプロファイルサマリーを出しておくべきか、あるいは何も出さないべきかは悩みどころです。ひとまずプロファイルサマリーを出すようにしてみます。とはいえ `@unknown default` なので、想定外の状況であることは間違いありません。なので、それなりの対処はしておくべきです。きちんとログシステムを使っているなら、ここでログを出しておくべきです。「ありえないことが起こっている」わけですから。そうでない場合はアサーションですね。`assertionFailure` か `assert` を使うイメージです。

たとえば、`assertionFailure("予期しない EditMode が検出されました: \(mode)")` のように、どんな `EditMode` だったかもメッセージに含めたほうが良いかもしれません。`EditMode` をアンラップする場合、このときはオプショナルになりますが、上で `nil` はもう弾いてあるので、ここに入ってくるはずがなく、素直にアンラップで良いはずです。

ここで問題になるのが、`switch` 文の `@unknown default` 節で `View` を返さなければいけない点です。`Result Builder`（`ViewBuilder`）の文脈なので、`switch` の各分岐で最終的に `View` を返さないといけません。`fatalError` や `assertionFailure` をそのまま書くと、「返せない」扱いになってしまって、こういう書き方はできない、という状況になります。ではどうするか。

- デバッグビルドではアサートを出し、リリースではフォールバックのビューを返す、というやり方が現実的です。具体的には `#if DEBUG ... #else ... #endif` です。
  - `#if DEBUG` 側で `assertionFailure("予期しない EditMode ...")` を呼ぶ。
  - `#else` 側でプロファイルサマリー（フォールバックの `View`）を返す。

これなら、デバッグ時は確実に気づけますし、リリース時はアプリが落ちずに最低限の画面を出せます。

もう一つの手は、`ViewBuilder` に対して `Void` を `EmptyView` にマッピングする拡張を入れる方法です。`assert` は `Void` を返すので、`ViewBuilder` の中で `assert(...)` を式として書けるようにしてしまう、という発想です。イメージとしては、`extension ViewBuilder { static func buildExpression(_ expression: Void) -> EmptyView { EmptyView() } }` のようにして、`Void` を `EmptyView` に変換します。こうしておけば、`assert(...)` を書いた行そのものが `EmptyView` として扱われるので、`if` ブロックにしなくてもビルダーの中で成立します。ただ、こういう書き方を実際にやっている人はあまり見たことがないので、妥当性は要検討です。`Void` を `EmptyView` に置き換えつつ、フォールバックとしてプロファイルサマリーを出す、という構成にはできます。

整理すると、
- `@unknown default` は将来に備えるための最後の砦なので、何らかのフォールバックの `View` を返すのが安全です。
- デバッグ時には `#if DEBUG` で `assertionFailure`（あるいは `assert`）を出し、リリースではフォールバックの `View`（例: プロファイルサマリー）を返すのが現実的です。
- もう少し工夫するなら、`ViewBuilder` に `buildExpression(_ expression: Void) -> EmptyView` を足して、`assert(...)` を書いてもビルダーが破綻しないようにする手もあります。

この方針なら、未知の `EditMode` が来てもアプリが完全に動かなくなることは避けつつ、開発中には確実に異常に気づけます。 とりあえず上手くいくのではないかと思います。たぶん、ここに `EmptyView` を入れてみればいいわけですよね。というか、`Void` を返してみました。`Void` はこれですね、空のタプル `()` です。とりあえず、ここで描画は変わらないはずです。

これが `extension` を実装していなかったとすると、`Void` をそのまま置くわけにはいかない、という状況になります。なので大丈夫でしょう。これでいいのかな……。どうしましょう。でも、`assertionFailure` のほうがここに置くのは良さそうですよね。そう考えると、`if` でフォールバックを書くとか、そういうのをやるのも煩わしいんですよね。そこで、今回はこれにしました。とりあえず。

ちょっと大げさで、誰かにレビューしてもらうと何を言っているのかわからなくなるかもしれませんが、ひとまずこうしておいて、どこに置くのが良いかはこの辺でいいかな、という感じです。`ViewBuilder` というビルダーに対して、さっきの `extension` を SwiftUI に効かせておいて、内部コードの中では `Void` が渡されたときに `EmptyView` に置き換えてくれるようにしました。こちらのほうが良いのではないでしょうか。まあ、分かりづらいかもしれませんが。

これなら、たとえばここで inactive のときに `print` を入れて何か出す、とすると、ここで出ますよね。ほら。そうすると `print` が発火されて、いいのかな。ちょっと強引すぎる気もしますけど、`print` も `Void` を返すので、`Void` を返したということは、さっきの `extension` のおかげで `EmptyView` にできるわけです。つまり、`print` を挟み込んでいける、という副次的な効果も得られます。まあ、いいでしょう。言語機能をこういう使い方をするのは、ときとして筋が悪いこともありますけれど、今回はとにかく `assertionFailure` を入れたいがために、これを入れてみた、という感じです。

リリースモードが検出されたら、暫定的にプロフィール画面を表示する、という感じにしておいて、うっかりデフォルトに落ちたときにはコンソールのログを見れば、あれが出てきたよね、という状況を作ることができました。

では次です。ここまでできましたので、次はセクション3に進みます。時間的にもこれくらいで。ここだけ気になったところがありました。`Edit` ボタン、`Profile` のデフォルトのあたりです。`ModelData` の中で `Profile` に対してデフォルトがありましたよね。ここでデフォルトを入れて、デフォルトはこういう名前、いわゆる何々アローみたいな名前をデフォルトで設定しておく、というのはあり得なくはないので悪くはないのですが、それを `ModelData` に入れておくかどうかが、個人的にとても気になっています。

`ModelData` は、たとえばここ、入っていない可能性を考慮しておきたい。つまり、`Profile` は入っていない可能性があります、ということにした上で、そうするとデフォルトは入りませんよね。それを踏まえてこれを渡してあげる。`Profile` が空の可能性があるのなら、ここでデフォルトの `Profile` を使う。いや、デフォルトじゃない、`draftProfile` でした。`draftProfile` を `@State` として持っておいて……あ、そうでした、編集するときにはドラフトにコピーするんじゃなかったでしたっけ。

この後の `ProfileSummary` に表示するものはこれでよくて、編集するときにはドラフトにコピーされているかどうかが分かる状態になります。登録されていなかったのだとしたら、デフォルトを表示しましょう、というコードになるので、こちらのほうが良いのではないでしょうか。そうしないと、デフォルトなのか、編集してそうなったのか、コードからは何も分からなくなってしまいます。これで良いといえば良いのですが、そんなふうに考えたので、落としてみます。 ここが重複してしまうのは次回以降に直すとして、とりあえず今はこれで良さそうです。.default になりましたね。こんなふうにしておきます。今は少し答えが見えにくい状況なので、三項演算子を使う…という話もありましたが、「デフォルト」ってそんなに大きな概念ではないのでは、という気もします。だからこそオプショナルにしたわけです。

先ほどのところですが、プロファイルそのものに持たせるのではなく、あくまで `ProfileHost` の中で「デフォルトはこれです」という形で持たせるほうが良いと思います。正確には「デフォルト」というより「デフォルトプロファイル」ですね。

`static let` にするか普通の `let` にするかは迷うところですが、どちらでも構いません。効率は `static` のほうが良さそうなので、ひとまず `static` にしておきます。そうすると「`ProfileHost` のデフォルトプロファイル」という立て付けになります。ただ、これはプロファイルをどこで使うかにもよります。`ProfileHost` で言う「デフォルト」と、もし他の画面でデフォルトを用意しない前提で使う場合の扱いは少し違ってきます。

モデルデータとして「デフォルトプロファイル」というものがあり、それがこれです、という形にしておけば、モデルデータを扱うすべての箇所でデフォルトプロファイルを取得できます。ここは計算型プロパティにしておきます。`static` でも良いのですが、使いたいときにすぐ取れない可能性もありますし、メタタイプから辿れば出てきますが、必要時に設定される計算型プロパティのほうが扱いやすい場面もあります。

このデフォルトプロファイルを `draftProfile` に入れるのか、という話ですが、そうだとすると、まだモデルデータにアクセスできない箇所もあるので、これは後の話になります。もし `draftProfile` にデフォルトがすでに入っているなら、それを使ってしまえばよく、さっきのように深いところから辿る必要はありません。

`draftProfile` の初期化を考えると、やはり `static` のほうが良い気がしてきました。つまり、`static let` でデフォルトプロファイルを用意し、それを計算して返す、という方針です。`Environment` に入っているのは `ModelData` なので、`ModelData` の `defaultProfile` を使うかたちです。これで、ひとまずデフォルトプロファイルで `draftProfile` を初期化できました。

さらに、アプリケーションのモデルデータとしてのデフォルトプロファイルを使って、まだ設定されていなければそれを採用する、という形にします。モデルデータとデフォルトプロファイルの所在が同じなので、もし無かった場合でも同じ実装でデフォルトを返せます。

デフォルトを取得する箇所も、`ModelData.defaultProfile` を使うようにします。それで良いですよね。`Profile` に `default` メンバーが無い（`no member 'default'`）というコンパイルエラーになるところは、`ModelData.defaultProfile` に差し替えれば解消します。こんなふうに渡してあげれば OK です。

このように、プロファイルの「デフォルト」の持たせ方・使い方を整理して、今使っているものが実データなのか、それともデフォルトから取ってきたものなのかが分かるようにしておきます。モデルデータのプロファイルはオプショナルにして、「まだプロファイルが登録されていない」という状態を表現できるようにしてあります。これによって、プロファイルが無かったときにどうするか、たとえば「プロファイル入力をお願いします」と促す、といった動作も実装しやすくなります。

そんな感じで、今日はとりあえず満足したので、次回は編集モードを作っていく作業を進めていきましょう。では、終わりにします。お疲れさまでした。
