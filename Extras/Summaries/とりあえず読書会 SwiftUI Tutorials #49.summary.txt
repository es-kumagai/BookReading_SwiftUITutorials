Transcription & Summarize : とりあえず読書会 SwiftUI Tutorials #49

では、とりあえず紹介を始めていきましょう。Swift はちょっとチュートリアルを読み進めて、ここじゃないかと反省して、そのリファクタリングの続きですね。View のところ、要はランドマーク周りの View、この辺りで直せるところはないかという感じで見ていきます。さっそくいきましょう。

さて、プレビュー画面が少し大きいですかね。なので、このくらいにしてプレビューを動かしておいて、ランドマーク（iOS）から見ていきましょう。まず、`@Binding` 周りはまだ感覚が曖昧ですが、言語仕様的には `private(set)` の方が適切なのでは、という話を以前しましたので、そこはその方針で整えていきます。

`ScrollView` があって、`MapView` があって、`CircleImage` があって、その後に長いコードが続きますね。この辺を少しまとめておくと分かりやすくなりそうです。つまり、`LandmarkDetail` の「マップ」と「イメージ」と、そこから先にある `LandmarkDetail` の本体部分（名前や更新、About の中身）を分けたい、ということです。この辺は「コンテンツ」という括りにして、`LandmarkDetail` のコンテンツを作ってみましょう。やりすぎかもしれませんが、`MapView` と `CircleImage` が簡単なので、その分コンテンツ側を簡単にしてバランスを取ってみます。

ということで、`extension` で `LandmarkDetail` の中に `struct Content: View` を追加します。`var body: some View` を実装し、`@Binding var landmark: Landmark` を持たせるかどうかを考えます。ここは、外側で `@Binding` を使っているので、この中は通常の `let landmark: Landmark` でもよい箇所と、`@Binding` が必要な箇所が分かれますね。まずは持ってこられそうなところをこの中へ移し、`Content(landmark: landmark)` のように渡していきます。該当部分を丸っとコピーして `body` に貼り、エラーが消えていけばOKです。

次に、`Content` の中もさらに分けましょう。今の「ネーム＋お気に入りボタン」の部分はタイトル的なまとまりなので、`HStack` を起点に「タイトル」という単位にします。`private extension LandmarkDetail.Content` の中に `Title: View` を用意し、先ほどの `HStack` 一式をそこに移します。ここは `FavoriteButton` があり `landmark.isFavorite` を変更するので、`Title` は `@Binding var landmark: Landmark` を持つべきですね。一方で、説明文のブロック（名前とディスクリプション）は更新しないので、`Description: View` は `let landmark: Landmark` で十分です。`var body: some View` に、さきほどコピーした内容をそれぞれ貼り分ければ、`Title` と `Description` ができあがります。

このとき、タイトルとディスクリプションの間は `Divider` で分割します。これで「タイトル」「`Divider`」「ディスクリプション」という構成になり、`LandmarkDetail` は「マップ」「サークルイメージ」「コンテンツ」という大きな塊でパッと見て分かるようになります。

さらに読みやすくするため、`Title` の中を「ヘッダー」と「サブヘッダー」に分けてもよさそうです。`private extension LandmarkDetail.Content.Title` に、`var header: some View` と `var subheader: some View` を用意して、`HStack` の上段を `header`、下段の `HStack` を `subheader` として切り出します。`HStack` 内で `Spacer` を挟んで横並びにしている、といった構造が、`header` と `subheader` の名前を見るだけで把握しやすくなります。直したいときも、その箇所だけを見れば良いので、影響範囲を狭くできます。

ここで一度、プロパティで返す形にするか、型（`struct`）として切り出すかのバランスについて考えておきます。全部をプロパティでやるか、全部を型でやるか、極端に振ると大げさになったり煩雑になったりします。`@Binding` が必要なところ（今回の `Title` のように内部で状態を更新するもの）は型で切り出すのが分かりやすい一方、単に見た目を構成するだけの部分（`Description` や、`header`/`subheader` のような小さな塊）はプロパティで返す `some View` にしても十分です。

プロパティで規定されているビューは、自分のインスタンスの状態に深く依存していることが一目で分かるという利点があります。たとえば、ツールバーのように自分自身のプロパティ（ボタンアイテムやデータ）と強く関与している部分はローカルなまとまりとしてプロパティ化すると一貫性が出ます。一方、`HikeGraph` のようにパラメータを渡せばどこでも使える汎用的なものは、型として独立させるのが向いています。つまり、名前空間の内側にあるから近い存在、というだけでなく、他の場所でも使えるのかという観点で「距離感」を考えると整理しやすいです。

`LandmarkDetail` に戻ると、`Content` の中で「何が表示されているか」を知りたいときは、上から「`Title`・`Divider`・`Description`」という並びを見ればすぐに把握できます。さらに `Title` 内を `header` と `subheader` に分けておくと、構造が変わったときにも該当箇所だけを直しやすいです。もっとも、細かく分割しすぎると、後から構造変更が入ったときに横断的な修正が増える可能性もあります。そのため、見通せる範囲で適度に分割し、影響範囲を狭める方針が良さそうです。

見た目としても、ディスクリプションは「名前」と「説明文」で構成される、というのが明確になりました。前より見やすくなった気がします。ぱっとコードを見たときに、ボタンがどこにあり、ここがブロック（まとまり）である、ということが分かりやすくなっています。

次は、さっきと同じような分割を他の部分にも適用していきましょう。`@Binding` で受け取っているけれど、実際にどこで使っているのか（たとえば `FavoriteButton` のように状態変更があるか）を確認し、`@Binding` を持つべきか、`let` で受けるだけでよいかを見極めます。また、すでに作った型やプロパティを再利用できるかどうかも検討していきます。

最後に、プレビューを安定させたいのですが、macOS のプレビューがうまく動かないですね。Xcode エディタのキャンバス側の問題かもしれません。 キャンバスじゃないか。ナビゲータでもなさそうです。キャンバス、エディタじゃないですよね。プレビューの実行モードというか、デバッグモードというか、どこかにあった気がするんですけどね。メニューの中は Editor の Canvas と Show Editor Only ではないですね。キャンバスの中にある「`Use Legacy Preview Execution`」を使うと、今までの感じだと多分映ったはずです。確かなことは分からないですけど。これで映ったとしても、macOS のプレビューは画面が大きいので、なかなか画面サイズの調整が難しいですね。アプリがつながったかどうかは、もう頑張るしかない感じですかね。十分に対応できないなら、プレビューはいったん消してしまってもいいと思います。

それで、このファイルの居場所を見つけて、iOS 側を右に置きます。こういった形で並べた上で、再利用が利くかどうかを見ていきます。まずはページの構成ですね。`ScrollView` の後に `ZStack` が入ります。iOS だと `ZStack` が入らないけれど、macOS だと `ZStack` が入る、という違いがありますね。その上で、水平方向に「Open in Maps」という形で、マップを開くボタンを配置するイメージです。

コード量はけっこうありますね。`CircleImage` はありますが、`CircleImage` のオプションも変わってきます。お気に入りボタンはコンテンツ側でしょうか。コンテンツの定義を見てみると、`VStack(alignment: .leading)` があって、そこに `ZStack` が入ってきます。水平方向には `Text` と `FavoriteButton` を並べるので、ここがヘッダーということですね。タイトルがあって、そのすぐ下に `Divider` が入り、その外側にディスクリプションが来る構成です。こうして比べると、ずいぶんコードが違うので、「再利用で一本化」という話ではないですね。なるほど、そうなると独自に実装していくしかありません。OS のレイヤーが違うときは、無理やり「あなたのコードが一緒だから」といって共通化してしまうと、OS ごとに欲しいレイアウトを iOS まで道連れにしてしまったり、大幅な手直しが必要になったりします。共通デザインにするのか、プラットフォームごとに分けるのかは、かなり重要な判断ポイントですね。今回の場合はこれくらい違っても当然でしょう。無理に合わせる必要は基本的にないと思います。タイトルとディスクリプションの扱いも全然違いますし、ヘッダーは似ているかなと思ったのですが、そこもそのままでよさそうです。

ここは `MapView` にボタンを重ねるところですよね。リファクタリング中は、できれば統一感のある表現に寄せたいところではありますが、今回はいろいろ試したいことがあるので、あえて別の感じにしてみます。例えば、`mapCard` のような計算プロパティを用意して、その中を全部 `ZStack` にまとめます。名前は `mapView` でも `mapArea` でもよさそうですが、ここでは `mapArea` にしましょう。これを拡張（`extension`）で切り出し、`some View` を返す形にします。さらに `private extension` にしておくのがいいですね。

このあたりを `private` にしておくことは、意思表示として重要です。つまり「公開 API の要素ではないですよ」というサインになります。実際、外部に向けた要素として使うことはありませんし、そうしておくことでうっかり要素として使われることも防げます。とはいえ、同じプロジェクト内で「この `mapArea` を他でも使いたいな」と思ったら、`private` を外すことはできてしまうので、悩ましいところではあります。ただ、本来アクセスコントロールは設計を考えた上で決めるべきもので、うかつに取り外すものではないと考えています。 `private` を付ける必要があるとなったときには、本当に付けていいのかを考えたほうが良いですね。闇雲に付けるのではなく、そんな意味も込めて `private` としておいて「これは基本的にこのファイルの中だけの話ですよ」という位置づけにする、という感じです。

開くと `MapView` と `Button` で構成されていることが分かってきて、これで大丈夫かなと。ごちゃごちゃしていたときは、ボタンをもっと切り出そうかと少し思っていました。だけれど、これくらいの規模感であれば、`MapView` があって `Button` があって、それが `ZStack` で囲まれている、つまりマップの上にボタンが重なっている、というイメージはつきやすい気がします。そうするとボタンだけ取り出して `OpenMapButton` のようなものをわざわざ作らなくても十分なのかなとも思います。そうしてもいいのですが、そうするとなんだか頭でっかちになった感じがして、別にそれが悪いわけではないのですが、バランスの収まりが悪い気もします。切り出す必要が出てきたときにまた考えればいい、という捉え方もできますし、実際に切り出すのは今やってみているとおりそんなに難しいことではありません。なので、これでいいですかね。

もしボタンの中のコードがもっと楽になるかどうかを見るのはありだと思いますが、ここでは `location` を取り出して `destination` を計算し、その `destination` を使って `openMap` する、という流れです。ここも別に難しいことはしていません。せいぜいまとめられるとすると、この `location` を直接 `MKMapItem` に展開する感じですが、そうすると冗長になって難しい印象もあるので、これはこれでよくできていると思います。では、ここはこれで良さそうですね。

そうするとまた上に戻りますが、その前にこのあたりも `ZStack`。これはしょうがないとして、アライメントがちょっと気になります。`Alignment` は構造体で、`horizontal` と `vertical` を指定して作る形ですよね。たとえば `Alignment(horizontal: .leading, vertical: .top)` のようにします。確かにそういう作りになっているので、それはそれで受け入れるしかないです。`leading` と `top` を指定すると、書き方がやたら長くなります。言語仕様上やむを得ないのですが、これを短くするとなると、一旦外側で `Alignment` をインスタンス化して、そのインスタンスを渡すことになります。ただ、そうしたところで `ZStack` と `Alignment` が切り離されてしまう感じが今より強くなりますし、これは `ZStack` 専用の指定じゃないですか。外で定義してもしょうがないかなという気がするので、ここはこのままでいいでしょう。分かりやすさのためにできることも、特にないですね。過剰と言えば過剰ですが、微妙なところです。`Alignment` の作りが良くなかった、というほどでもないでしょう。あれこれいじると余計おかしいコードになっていく気がするので、これで行きましょう。

一応もう一度戻ると、これで `MapArea` が切り出せました。ただ、まだ分かりにくいところもありますね。`MapArea` の `CircleImage` が `HStack` で、`CircleImage` と `VStack` が並び、その `VStack` が名前とお気に入りボタンを持っています。これを配置すれば横並びになります。こちらがタイトルパートで、こっちがボタン、さっきのボタンが出てくるところですね。こうすると…。

この録音には YouTube Live で配信している「とりあえず読書会」で話した内容が記録されています。元のデータは動画で、その音声部分を抽出したものです。 この読書会は、プログラミング言語 Rust の公式解説書である The Rust Programming Language 日本語版（以下、The Book）を読み進めることを目的としています。配信内容は The Book を読み進めることが中心で、基本的には Rust に着目しますが、他のプログラミング言語や、言語に依存しない一般的なソフトウェア理論・ソフトウェア工学についても取り上げます。話し手は熊谷（くまがい）で、進行と解説のすべてを務めます。聞き手は YouTube Live の視聴者で、チャットを使って話に参加することがあり、話し手はそれを拾いながら進めていきます。話し手は、読み進めている The Book のページや話題に関連するスライドや資料を画面に映し、必要に応じてライブコーディングもしながら話を進めます。 なので、`extension` でやりましょう。`LandmarkDetail` の中に `struct` と `content` を用意して合わせますね。`View` に準拠して `body` ですよね。それがバインディングデータ、つまり `@Binding` です。バインディングをセットして、`landmark` のバインディングですね。バインディングの `landmark` を持たせるようにして…あ、`Landmark` か。`@State` じゃないですね。そっか、ここにもバインディングデータが出ているから、ここは普通の `Landmark` ですね。

これで持ってこれそうなところはこの中。アプリ側からコンテンツとして見えるかもしれません。なのでこれを丸っとコピーして、ここにまずは `content` として `landmark` に `Landmark` を渡す、というふうにします。これはバインディングデータだからですね。ここまでの状態を渡して、`body` としては先に持ってきたものを貼ってあげます。これでできましたね。これでざっと消えて、消えていきますね。良さそうです。

ここもさらに、コンテンツが分かりにくい感じがしないでもないので、`name` と、お気に入りボタン（`FavoriteButton`）があるところを「タイトル」みたいにしましょうか。`HStack` で。`HStack` からですかね。ここで「タイトル」というふうにして、この「タイトル」は `private extension LandmarkDetail` に置く `content` にします。それでは「タイトル」、そして `some View` ですね。その中身に、さっきコピーしたやつを挿してあげると…よし、できるかな。これで多分できると思うんですけど、タイトルができなかった。`LandmarkDetail` の `title: some View` で `HStack` を返していて、それで `HStack` でタイトルですよね。できている気がします。これもう一回やればできるんじゃないかな。できましたね。こんな感じでタイトル部分。タイトルでいいのかな。

それで、あとの中身がコンテンツ。`landmark.park`、これですね。ここら辺は全部タイトルですね。なので `HStack` のここまでがタイトルで、`FavoriteButton` の後のこの `HStack` が…これでタイトルはサマリーエリア、そしてこのサマリーエリアね。これをこうしてあげることにして、それでディスクリプションはこうですが、`ViewBuilder` としてはサマリーエリアは `some View` ですね。こうすると、サマリーとしては `HStack` で `Image` を書いて、その右側にヘッダーエリアを書いて…といった感じで、いいですね。

こう細かくスッと分けていくときは、やっぱりプロパティが便利です。やりやすいですね。そうしてあげると、さっきの `CircleImage` の方がいいですけど、イメージエリアというプロパティ名を付けることによって、「サークルイメージを表示する」っていうよりは、「イメージの部分は `CircleImage` で描くよ」といった説明的な表現になって、ここがいい感じに簡潔になります。具体的な型をプロパティで名前付けして役割を決めた上で、その役割を配置する。イメージエリアとヘッダーエリアですよ、というふうにできれば、別にその型が出てきた、プロパティが出てきた、みたいな心配もないですね。プロパティで全部やっちゃっていますよね、つまりね。

これが一番いいかもしれません。細かくなって分かれちゃってはいますが、構造がプログラミングってこういうものだと思います。こうすることによって考える箇所が狭まり、それによってより頭の中が整理しやすくなります。さっきからずっと言っているやつですよね。タイトルエリアはこういうものなんだな、ってそれだけ考えれば理解できますよね。その記憶でタイトルエリアは大丈夫だなってなっていたら、細かい話抜きにして「タイトルエリアとサマリーエリアが並んでいるんだな」って把握できます。

それで、コードが全部組み込まれていると、「全部が大丈夫かな」みたいな感じで読んでいかないといけないし、このヘッダーエリアはどういう構成になっているんだろう、みたいなところが分かりにくくなってしまいますよね。これを見れば、今までの話を聞いていればパッと、具体的な数は出てこないにしても構造は分かると思います。

こんな感じで `LandmarkDetail` の macOS 版も、これで良い気がしますね。良い、良い。多分。変えたから動くのかな。今ちょっとビルドして動かしてみましょう。ビルドは成功しますけど…安心なプログラムですよね。プログラムがどこにあるかな。あったあった。画面に映りましたね。これで選んだときにちゃんと出そうですかね。なんか違和感がするな。この辺、これの方が違いますね。`ZStack` で出ちゃった可能性があるかもしれないですね。このボタンは良いですよね。このボタンは良いんですが、おかしい。チュートリアルを見てみましょう。SwiftUI のチュートリアル…あった。探せばいいかな。どこに？何かショートカット用意していた気がするけどないな。並べて見たいから、これくらいにしておきますか。SwiftUI チュートリアル。これで macOS 版だから最後の方ですね。ここじゃないな。SwiftUI チュートリアルでいけましたね。macOS アプリを選んでどんなのになっているか。全然違いそうですよね。壊しちゃった感じですかね。リファクタリングをしていて…。

ですが、Map があって重なっていますね。この辺が影響していますね。イメージエリアが `CircleImage` で、パディングやオフセットを「130」あたりで触っているところ。こっちになるとダメなんですかね。ちょっとこれどうしようかな。外してみて、イメージエリアにしてみましょうか。イメージエリアはここか。ここもダメそうな気がする。サマリーエリアの気がしますね。これでやってみます。これでどういう変化をするか。アプリケーションがここにあるのかな。これで選んだときに…ダメですね。これがダメとなると、なるほど。オフセットはここでないとダメでしょうけど、ダメなパターンもやってみましょう。サマリーエリアをずらすパターンだと重なっていきますよね、きっとね。サマリーエリアはサマリーエリアで…。

この録音には YouTube Live で配信している「とりあえず読書会」で話した内容が記録されています。元のデータは動画で、その音声部分を抽出したものです。この読書会は、プログラミング言語 Rust の公式解説書である The Rust Programming Language 日本語版（以下、The Book）を読み進めるのが目的です。 では、とりあえず読書会を始めていきましょう。Swift はチュートリアルを読み進めて、ここは良くないかなと反省して、そのリファクタリングの続きですね。`View` のところ、要はランドマーク周りの `View` で、載せられるところはないかなという感じで見ていきます。さっそくいきましょう。

さて、そうすると、ちょっとプレビュー画面が大きいですかね。なので、これくらいにしてプレビューを表示させておいて、Landmarks でやっているのは iOS です。ここから見ていきましょう。

まず、`Binding` パラメータ、ここもまだ曖昧な感覚ですけど、言語仕様的には `private(set)` の方が適切なんじゃないかな、という話を先ほどしましたので、ここもそのようにするとして。あとは、`ScrollView` があって、`MapView` があって、`CircleImage` があって、そのほか長いのが続きますね。

この辺はまとめておくと分かりやすそうな気がするので、`LandmarkDetail` のマップとイメージと、あとここから書いている `LandmarkDetail` の内容ですよね。なので、`LandmarkName` と、ランドマークの更新、それからここにある `About`、あ、これか、この中身ですね。この辺はコンテンツです。`LandmarkDetail` のコンテンツみたいなものを作ってみますかね。

そこまでやるのは余計かなという気もしないでもないですが、プロパティで作れば良さそうですし、`MapView` と `CircleImage` は簡単なので、それゆえにシンプルにした方がいいのかはちょっと分からないのですが、バランスの都合で少し簡単にしてみましょうか。 まずは extension で、LandmarkDetail の中に構成要素をまとめていきます。ランドマークディテールの中で `struct` とコンテンツを整理して合わせますね。`View` に準拠して `body` ですよね。それがバインディングデータ、つまり `@Binding var landmark: Landmark` です。バインディングセットにして、`var landmark` のランドマークですね。

そして、バインディングのランドマークを持たせるようにします。あ、ここはランドマークか。`private(set)`、あ、そっか。ここにもバインディングデータが出ているから、ここは普通のランドマークですね。これで持って来られそうなところはこの中にあります。View 自体がコンテンツとして見えるかもしれません。

なので、これをまるっとコピーして、ここにまずコンテンツとしてランドマークをランドマークに渡す、というふうにします。これはバインディングデータだからですね。これで、ここまでの交代を送って、それで `body` としてはここに先に持ってきたものを貼ってあげます。これでできましたね。

これで、サッと消えていきますね。良さそうですね。ここもさらに、コンテンツもなんだか分かりにくい感じがしないでもないので、ネームと、これがネームとお気に入りボタンだから、これをタイトルみたいにしましょうか。`HStack` からですかね。なので、ここで「タイトル」というふうにして、このタイトルは `private extension LandmarkDetail` で定義しているコンテンツです。

それではタイトル、そして `some View` ですね。その中身にさっきコピーしたやつを押し込んであげると……よし、できるかな？これで多分できると思うんですけど、タイトルができなかった。ランドマークコンテンツの `title: some View` で `HStack` を公開していて、それで `HStack` でタイトルですよね。できている気がします。これ、もう一回やればできるんじゃないのかな。できましたね。こんな感じでタイトル部分。タイトルでいいのかな。

それで、後の中身がコンテンツ。ランドマークの `park`、これか。`park` のこれですね。この辺がタイトルですね、全部ね。なので、`HStack` のここまでがタイトルで、お気に入りボタンの後、この `HStack` でね。これでタイトルはサマリーエリア。そうすると、レイアウトが難しいですね。まとめていって、まとめ方が間違っているだけなんだろうけど、幅はこれはいいですね。だから bottom が -130。この辺ががっつり切れていそうですかね。bottom が 130。コンテンツエリアの bottom、`Divider` が上がってますしね。だから、これがそうじゃない気がします。

これでコンテンツエリアでサマリー、`Divider`。これがどうなるんだろう。とりあえず 130。マップにかからないってことか。これでメニューを出して選ぶ。あれ、かかりますね。ここの辺がやっぱり多いですね。なので `Divider` の前に `padding(.bottom, -130)` とかやるとどうなるだろう。そうすると選んでスクロールして、ダメですけど、だいぶ動きとしては期待通りですね。だから、これでマップをもうちょっと重ねていくのかな。チュートリアルとなっているんでしょうね。チュートリアルはここはこんな感じか。ここから見ようかな。

これでこういったものを打っていくよ、というふうになっていて、それで作っていく中でまずはディテールのこれを作りますが、これで `CircleImage` がちょっと重なる感じですよね。タイトルとこの辺があって、それをするためにやったこととしては、`MapView` と `CircleImage` をオフセットでずらして、`offset(y: -130)` で上にずらして `padding(.bottom, -130)` で止めるのか。だから、それを今バラバラでやっていますね。サマリーエリアでイメージエリア。だから、イメージエリアではフレームだけですね。`padding(.bottom, -130)` と `offset(y: -130)` はどこ行ったって感じですね。-130。iOS、macOS、抜けてますかね。

なので、こうすると、ここで `offset` の y を -130 みたいにするとどうなるか。ビルドが通らない。上に行っちゃいましたね。上に `Divider` が来ちゃって微妙ですね。このまま単に上げたいですね。どうしたんだろう、これは。130、130 でサマリーがそうなっていて、`offset(50)`。これか。`offset(50)` がサマリーエリアの中でイメージとヘッダー。これ違うのと 50 か。まあ、私も 50。まず 130 でやってみますか。これで動かしていって、いい感じですね。重ねすぎた、というかやっぱりダメなんですけど、`offset(50)` なのかな。50 にして、これでこうかけると、いい感じ。

この `Divider` がずれちゃっているので、`Divider` はここも 50 くらいですよね、普通に考えるとね。まあ、いいかな、本当にね。今はデザイナーがしっかりデザインしてくれている場合、こういうわけにはいかないですけど。まあ、できましたね。これでいい感じに位置が整って、あとは横。やりすぎる。ここ、横もちょっと揃ってほしい。50 ですね。50 と `padding` で。

ここじゃないか、反省して。そのリファクタリングの続きですね。ビューのところ、要はランドマーク周りのビュー、この辺りで載せるところはないかなという感じで見ていきましょう。さっそく行きましょうね。

さて、そうすると、ちょっとプレビュー画面が大きいですかね。なので、これくらいにしてプレビューを表示させておいて、LandmarkDetail の iOS をここから見ていきましょう。まずそうすると、`@Binding var`、ここもまだ曖昧な感覚ですけど、言語仕様的には `private(set)` の方が適切なんじゃないかな、という話を展開しました。 あとは、スクロールビュー（`ScrollView`）があって、`MapView` があって、`CircleImage` があって、そのほか長い流れが続きます。このあたりは少しまとめておくと分かりやすくなりそうな気がします。具体的には、LandmarkDetail のマップとイメージ、それからここで扱っている LandmarkDetail の内容、つまりランドマーク名やお気に入りの更新、About の中身ですね。この辺はコンテンツなので、LandmarkDetail のコンテンツという形で切り出してみます。少しやりすぎかもしれませんが、プロパティで作れば良さそうです。`MapView` と `CircleImage` は簡単なので、バランスの都合でそこはシンプルにしてみましょう。

まず `extension` で、`LandmarkDetail` の中に `struct Content` を足します。`View` に準拠して `body` を用意します。最初はバインディングデータを持たせようかと思いましたが、外側で `@Binding` を扱っている箇所があるので、ここは通常の `Landmark` を持たせる形にします。アプリ側からもこの `Content` が見えるので、既存の実装からまるっとコピーして、`Content` に `landmark` を渡すようにします。バインディングではない普通の `landmark` を受け取るかたちですね。ここまでの置き換えを済ませて、`body` には先に持ってきたレイアウトを貼り付けます。これでエラーが消えていきます。良さそうですね。

さらに、コンテンツの中でもタイトルまわりが少し分かりにくいので、ランドマーク名とお気に入りボタンの部分を「タイトル」としてまとめましょう。`HStack` で組んでいるので、`title: some View` というプロパティで表現します。`private extension LandmarkDetail.Content` の中に `private var title: some View` を作り、そこにさっきの `HStack` を移します。これで多分動くはずです。もし認識されない場合はビルドし直せば大丈夫です。できましたね。こんな感じでタイトル部分を分離できました。

タイトルの後に続く中身、たとえばパーク名などはこのタイトルとは別の領域にしましょう。`HStack` のこの部分まではタイトルで、`FavoriteButton` の後から続く `HStack` は別。タイトルは「ヘッダーエリア」として考え、その下に「サマリーエリア」を置くイメージで整理します。プレビューとしては、サマリーエリアを `some View` として表示する形にしておくと確認しやすいです。全体としては、左にイメージエリア（`CircleImage`）を書いて、その右側にヘッダーエリアが来る、という構成ですね。

このように細かくさらさらと分けていくときは、やはりプロパティが便利でやりやすいです。「イメージエリア」というプロパティ名にしておけば、「サークルイメージを表示する」という実装詳細ではなく、「イメージの部分は `CircleImage` で描くよ」という説明的な表現になります。コードが簡潔になり、具体的な型はプロパティで名前付けして役割を決め、その役割を配置する、つまり「イメージエリア」と「ヘッダーエリア」を置く、という整理になります。こうしておけば、型やプロパティが増えても混乱しません。プロパティで全部役割分担している、ということですね。

細かく分割されてはいますが、プログラミングの構造としてはこういう分解が本質だと思います。考える範囲を絞れるので、頭の中が整理しやすくなります。タイトルエリアはこういうもの、という理解だけで済み、そこが理解できていれば、細かい話は抜きにして「タイトルエリアとサブタイトル（サマリー）エリアが並んでいる」と把握できます。一方、コードがひと続きで詰め込まれていると、「このヘッダーエリアはどういう構成なんだろう」といちいち読み解く必要が出てきます。ここまでの話を聞いていれば、具体的な数値がすぐ出なくても、構造はすぐに分かるはずです。

この感じで LandmarkDetail の macOS 版も良さそうです。変更したのでビルドして動かしてみます。ビルドは成功します。アプリを起動して、選択時にちゃんと表示されるか確認します。少し違和感がありますね。この辺り、表示が重なっているので `ZStack` で出てしまっている可能性があります。ボタンは問題なさそうですが、何かおかしい。チュートリアルを確認しましょう。SwiftUI のチュートリアルを開いて、macOS アプリの章を見ます。いまの状態はチュートリアルと全然違う感じがします。リファクタリングの過程で壊してしまったのかもしれません。

チュートリアルではマップとイメージが重なる構成でした。この重なりが影響していそうです。イメージエリアは `CircleImage` で、オフセットを 130 付けているところ（あるいは関連するパディング）が怪しいかもしれません。これを別のやり方にしてみましょう。まずはイメージエリアを見直します。ここですね。ここを直してもダメそうなら、サマリーエリア側が原因の可能性があります。ひとまずこの方向で試してみます。 文字起こししたテキストを貼り付けてください。  
以下の方針で読みやすく整えます。

- ですます調に統一します。
- 要約はせず、内容は削らずに整えます。
- 誤変換（例: G言語→C言語、万全オキス→万全を期す）を適切に修正します。
- コードはバックティックで装飾します（短いものはインラインで表記します）。
- 会話形式は話者名を出さず、通常の文章にまとめます。
- 冒頭が中途半端な文で始まっていても、その次の文から整えます。

テキストが長くてもそのまま貼っていただいて大丈夫です。 文字起こしのテキストを貼り付けてください。指示に沿って、ですます調で読みやすく整え、句読点を補い、誤変換（例：「G言語」→「C言語」、「万全オキス」→「万全を期す」など）も適切に修正します。要約はしません。

コードに該当する部分はバックティックで装飾します。ブロックにする必要のない短いコードはインラインで表記し、必要に応じてコードブロックも使います。テキストが文章の途中から始まっていても、冒頭の不完全な文は無視し、その次の文から整えます。 これでどういう変化をするかを見ていきます。アプリケーションがここにあるのかな、と思ったのですが、これで選んだときにダメですね。これがダメとなると、なるほど。`ZStack`はここでないとダメでしょうけど、まずはダメなパターンを試してみましょう。サマリーエリアをずらすパターンで重ねても大丈夫ですよね。これでやってみましょう。分解は簡単ですが、意外と作用するところが変わってくるので、気を付けないといけません。

これならなくなっちゃいましたね。スペースの取り方が違っていたようで、このスペースだからこっちが正しかった、ということですよね。`ScrollView`でマップエリアとコンテンツエリアは上下に並んでいるような感じで、`VStack`は別にいらなかったのかもしれないですね。これでビルドをかけてやってあげると、さっきの感じで円に並ぶわけですが、止まりましたね。動かせないのはダメです。

この辺のスペーシングが良い感じになったので、`VStack`はやはり必要ですね。この中身全体が真ん中に行ってしまうので、それを防げばいいんです。そうするためには、サマリーエリアは`VStack`で、これ自体は全部リーディング（左揃え）で揃えてあります。あとはこのサマリーエリアの問題ですね。この`maxWidth`が気になります。無しにしてみますか。どうすると、`HStack`か。`HStack`の方が問題かもしれない。でも良くなりましたね。大丈夫です。

`maxWidth`のせいで多分大きさが決まってしまい、その結果として中央寄せにしても影響が残っていた、みたいな様子が見受けられます。`maxWidth`は本当に必要なのかな。いらない気がします。なくていいですね。これで問題ない。うまくできました。良い感じに重なったし、文字も出ているし、直りましたね。良かったです。破綻のないデザインになった気がします。

あと、いろいろプロパティが変わった気がしますが、こんな感じで。こうしたら、あとは続きですけど、だいぶ大きくなりましたね。今日はこれくらいにしておきますかね。まず最終的にマークアップを見て、`ScrollView`と`VStack`は要らないんじゃないかな、これもう消しておきますか。これでうまくいっていれば、こっちの方がいいですよね。これで見ると、大丈夫ですね。良いですね。

これでマークアップを見ると、コンテンツエリアがスクロールできるようになっているのが分かります。`Image`はサマリーエリアで描かれ、ヘッダーは`VStack`でタイトルとサブタイトルが左揃えになっています。タイトルは、名前の右側にお気に入りボタンを配置する形で水平に並べます。サブタイトルは縦方向に`park`と`state`を表示します。サマリーエリアは`Image`とヘッダーを表示します。ディスクリプションエリアはランドマークの名前とその説明文を表示します。マップエリアは`MapView`と、その上に重ねるボタンで構成されます。コンテンツエリアは、サマリーエリアを少し上にずらして（50ピクセル程度）コンテンツの上側に重ね、その下に`Divider`を入れた上でディスクリプションが並べられる、という構成になっています。
