Transcription & Summarize : とりあえず読書会 SwiftUI Tutorials #9

では、今日も「とりあえず読書会」を進めていきます。前回からパスを使った描画を扱っています。ベジェ曲線は名前をよく聞きますが、実際に数値で扱おうとすると難しいですね。スイスイ使える人もいるのでしょうけれど、数式や数値でやろうとすると途端に難しく感じます。ベジェ曲線で描いて数値に変換する、といったことをするのかもしれませんが、そのあたりはまだよくわかっていません。

また、Swift の対応や、いわゆるリファクタリングも頻繁にやっている都合で、だんだんとチュートリアルと実際のコードが合わないところが増えてきました。そこは個人的には面白いポイントでもあります。

では先に進めます。今日は、前回背景を描いたので、場所ごとのランドマークに対応するアイコンを上に載せていきます。セクション3はバッジシンボルを描く回です。ランドマークのバッジは、カスタムのインシグニア（徽章）で、Landmark App のアイコンに現れる山をベースにしたものを作っていく、という流れですね。

マウンテンシンボルは2つのシェイプで構成されています。1つは山頂のスノーキャップ（冠雪）を表現するシェイプ、もう1つは植生（ベジテーション）を表現するシェイプです。まずはアプリケーションのアイコンをバッジに設定できるよう、空の App Icon をプロジェクトの Asset Catalog に作り、リソースからダウンロードした単一の PNG ファイルをその App Icon の所定のスロットに入れます。これができたら、次にバッジシンボルの作成に入ります。

まずアイコンのセットアップです。Asset Catalog に `App Icon` はすでにありますが中身が空なので、プロジェクトの `Resources` 内にあるアイコン画像（PNG）を対応するスロットへドラッグ＆ドロップします。これでリソース側は準備完了です。

次にバッジシンボルを作っていきます。新しいカスタムビュー `BadgeSymbol` を作成し、その中で `Path` の API を使ってシンボルを描画します。サイズや位置は `Double` を使って調整していくイメージです。練習として、スペーシングに関する倍率（multiplier）を設けて、`topWidth` や `topHeight` を調整し、描画にどんな影響が出るかを試してみると良いでしょう。

実装では、`BadgeSymbol` の `body` に `GeometryReader` を置き、その中で `Path` を組み立てていきます。プレビューの描画を待つ間にコードを少し見直しますが、`GeometryReader` の内側でインデントが深くなりがちな点が気になります。そこで、今回も少しリファクタリングして、ネストを浅くします。

具体的には、`extension BadgeSymbol { struct SymbolPath: View { ... } }` のように、`BadgeSymbol` の拡張の中に `SymbolPath` というサブビューを切り出します。`SymbolPath` の `body` で `Path` を描く形にすると、`GeometryReader` のクロージャがすっきりします。あるいは、`Path` を生成する関数に描画処理を集約し、`SymbolPath` 側には生成済みの `Path` を渡して描いてもらうやり方でも構いません。

`GeometryReader` からは描画領域の `bounds`（`CGRect`）を受け取り、`makePath(in bounds: CGRect) -> Path` のような関数を用意してパスを組み立てます。必要に応じて `bounds.size`（`CGSize`）を使って相対的に座標や寸法を計算します。これで段取りは良さそうです。上の実装では `makePath` を使っていたので、そのまま `GeometryReader` から受け取った `bounds` を渡す形に整えていきます。 そういえば、`makePath`でジオメトリを扱えなかったのでしたっけ。`BadgeSymbol`がプロパティを持っていたのかどうか、そこがポイントですね。`BadgeSymbol`では`GeometryReader`でやっていますが、ジオメトリは外から渡してもよいわけです。何て書いてありましたかね。`BadgeSymbol`で`GeometryReader`…ただ、`GeometryReader`は中でやってしまったほうがよい気もするので、ここはクロージャにしましょう。`Path`を渡して、`makePath`に対してその`Path`とジオメトリ、つまりサイズを渡してあげる、という形ですね。

これでいいでしょうか。`Path`に対して with 〜、`makePath`をトレーリングクロージャで呼んでいる感じですね。トレーリングクロージャは、えーと、`inout`だから…つまり渡すのは`Path`で良いはずです。それで`makePath`に`Path`を渡す、と。このときにハンドラーが必要でしたっけ？まあ必要ですね。`var`でいけるのかなと定義を見ておきますが、イニシャライザーはコールバックで`inout Path`ですよね。`inout Path`が渡ってきて、そうか、そういうハンドラーで渡すのでしたっけ。

メトリクスが定まっていて、それを`addLine(to:)`で`CGPoint`を使ってどんどん表現していく、と。このあたりはリファクタリングの余地はまだなさそうです。はい、これでOKで、`BadgeSymbol`ができました。`BadgeSymbol`ができたら次のステップとして、シンボルのボトム部分を描いていきます。そして`move(to:)`を使って、キャップや隙間も作っていく、と。そういうふうにして`addLine(to:)`をやっていくということですね。

なので、これをコピーして貼り付けていきますが、このあたり、どんどん長くなってきましたね。まあ今回はこれくらいでいいでしょう。やるとしたら、パス用のメトリクスみたいな型を作って、幅や高さを管理させるか、そういうくらいですかね。

あと、`BadgeSymbol`が`body`の中で`GeometryReader`をいきなり使っていますね。これを考慮すると、`BadgeSymbol`が最初からサイズを受け取ってしまえば、いろいろ融通が利きそうです。これをやってみましょう。つまり、`BadgeSymbol`があって、これは`State`になるんですかね。やっぱり、`State`が必要な場面がまだよく分かっていない気もします。内容が固まってくるので、`makePath(with bounds:)`ですよね、というふうに捉えられます。

というか、`with`なんていらないですよね。もうプロパティに`bounds`があるので、`bounds`を引数で受ける必要はありません。するとこのパスを作るのも、`makePath`でいきなり渡してあげれば良いはずです。あれ、これでスッキリしすぎかなと思いましたが、`BadgeSymbol`がまだ定義されていないからですね。これで`Path`だけ渡せばよい、ということになって、そうすると余計なことをあまり気にしなくてもよくなってきそうです。

`makePath`とかありますけど、この中で、`height`とか`spacing`とか、こういった値を定義するときには、イニシャライザーを作ったほうがよいですね。`bounds`を渡すイニシャライザーを定義して、`init(bounds:)`を作っておきます。その後、こういったパラメータは、`width`や`height`から計算していく、という流れで、この辺を全部… とりあえず、まとめて一つのトピックとして考えます。`width` と `height` は `Double` で、`保存型`（格納型）にするか `計算型` にするかですが、イニシャライザで細かいことをするより、`計算型プロパティ` にしておいたほうが良いかもしれません。ここでは `var width: Double`、`var height: Double` のようにして、`bounds` から計算した幅と高さを返す形にします。パフォーマンスはこの程度なら問題ないと思います。もし何か問題が出たら、そのときにチューニングすれば十分な状況でしょう。同様に `var middle: Double` も計算するようにします。

次に、`topWidth` や `topHeight` のように個別に値を持たせるのではなく、両方がそろっているときは `サイズ` にまとめたい気がします。そこで `var topSize: CGSize` として、`CGSize` を返すプロパティにし、`width` と `height` をそれぞれ計算式で求めるようにします。このあたりはサンプル（チュートリアル）のコードの意図も汲みつつ、意味的にまとめたほうが扱いやすいと思います。`width` と `height` に残っていた式は置き換えればよいので、パスを作るときにも個別の値は不要になります。これで OK です。

続いて、`topWidth` や `topHeight` といったトップ系の参照箇所を `topSize` に直していきます。該当箇所を修正して、不要になったものは削除します。`topSize` に合わせてサイズ系の参照もそろえていきます。`height` のトップ側についても、`topSize.height` で良いはずです。

プレビュー側では、ここに `BadgeSymbol` を作ります。`GeometryReader` を使って `GeometryReader { geometry in ... }` の形にし、`BadgeSymbol` に渡す `bounds` 相当は `geometry` から取得するようにします。多少重くなるかもしれませんが、今の環境なら問題ないでしょう。プレビューでレイアウトが崩れずに表示されることも確認できたので OK です。

では、もう少し調整を続けます。これでトップ側の `Path` の部分も調整していきます。 こんな感じで部分的なポーションを用意して、`Path`に対して処理する形にします。パスは `inout` で受け取ります。なぜ `inout` なのかというと、クロージャで設定してその場でパスを書き換えるからでしょう。なので、ここで `topPortion(path:)` と書いてありますよね。次に `bottom`、つまり `bottomPortion` です。`bottomPortion` のように名前を付けていくと、何をやっているのかが少し分かりやすくなってきます。特にこういう機械的な処理では、パスを分けて扱う感じですね。

それから、`makeTopPortion(path:)` のようにしてパスを渡して、それをトップにムーブして、`makeBottomPortion(path:)` という流れにします。そこまで劇的に快適になるわけではないのですが、こうして見たときに「上のほうが狂っているな」みたいな状況になったときは、`makeTopPortion(path:)` をいじればよいと分かるので、まあまあ分かりやすいと思います。`move(to:)` はしょうがないですよね。`move` というのはこういうところでは避けられません。

これで取り入れて、要はこの `body` が……ちょっとやりすぎましたね。リファクタリングもしたところで、次に行きましょう。えーと、`drawBottomPortion`、これでいいんだ。次、ステップ5ですね。シンボルを Apple のカラーで塗りましょうということで、`fill` でシンボルカラーを指定します。このシンボルカラーはバッジシンボル側にしかないので、シンボルカラーをカラープロパティとして実装しないといけない感じですかね。今回の場合は、`BadgeSymbol` のカラー、そして `bounds` と一緒に使う想定です。

色はレッドじゃなくてもいいですね。構造体なので、よく出てくる話ですが、「値はもうバシッと決まる」ので `let` にするか、状態が変わる可能性があるなら `var` にするか、という判断になります。構造が後から作られていく可能性があるなら、`let` のほうがいいのかな、という気もしますが、その辺りは分かりません。パフォーマンスやフォーマットの都合があるなら、それを考えて決めればいいのではないでしょうか。

パス全体に対して塗る、ということは、ここですね。`body` に対して `fill` で `Color` を指定します。`fill(symbolColor)` のような形です。これで完成でしょう。紫で色が付きますよね。隙間の部分はどうするのでしょう。このままだと全部紫ですが、これからどうにかなっていくのでしょうね。

それで、パープルカラーだけど、既定のカラー感ですね。なるほど、これを使って塗ると。塗るときにシンボルカラーをどう考えるかです。シンボルカラーを既定の値で固定する、という考え方もあります。既定の値で固定するのであれば、引数で取ってはいけないわけですね。逆に、バックグラウンドとして扱うのであれば、グラデーションカラーはパラメーターで渡しています。今は既定のパラメーターを `private let` で内包していますね。そうすると、バッジは裏方で色を決めている、ということになります。その方針でいってみますか。

なので、どうするか。バッジのシンボルとしてのカラーを、ここにプロパティを設定するスタイルで持たせます。これをプライベートにする、というやり方です。今回みたいに `BadgeSymbol` という独自の型が存在する事情かもしれませんが、既定値を指定することによって、「バッジシンボルといえば普通この色だよね」という発想ができるようになりました。

ただ、ここで少し気になります。カラーをバッジに埋め込むというより、もう少しちゃんと扱ったほうが良さそうな気がしてきます。カラーだけに、ですね。そうすると、`Color` を拡張してあげる、みたいなことになってくるのでしょうか。どこに置こうかな。この辺に置きますかね。 とりあえず Swift のファイルを追加して、名前は「Color」か「Style」か迷いましたが、ひとまず「Style」にしておきます。FillStyle 固定にするか、対象のパラメータを S にして S を `ShapeStyle` にするジェネリック関数にするかは、ちょっと際どいですね。まあ、ジェネリック関数でいく方針で一応覚えておきます。

まずはカラーまわりを調整していきましょう。ファイル名は後でまた考えます。要は、一度ここで定義を集約しておきたい、ということです。`SwiftUI` をインポートして、`extension` でまず `Color` を拡張してみます。`Color` に対して、例えば `badgeSymbol` のようなプロパティを用意して、`Color.badgeSymbol` のように指定できるようにします。こうしておくと、色の指定が統一されて便利ですし、意図も明確になります。例えば「ホワイトがいいな」という指定と同じことを、`Color.badgeSymbol` で表現できるようになった、というのが今の状態です。

同じことを `Path`（や `.fill` の引数）でもやりたくて、ドットで補完したときに `.badgeSymbol` が出てきてほしいのですが、今は出てきません。`background` 系で出てくるのは、`BackgroundStyle` を介しているからでしょうか。`BackgroundStyle` は `ShapeStyle` を拡張している形なのか、あるいは「`ShapeStyle` だけど `BackgroundStyle` のときにはこれを使う」といった拡張の仕方があるのか、といった構造になっていそうです。

だとすると、これはきっと `ShapeStyle` に対して拡張をして、`where` 句で条件を付ける、例えば `where Self == Color` のような形にすればよさそうです。`Color` にも同様の拡張を用意して `var` として定義しておけば、実装はできます。この状態だと、`fill` に対しては `.badgeSymbol` がちゃんと出てきますね。こういうふうに使えるようになるのがわかります。

一方で、このとき `Color` 側では使えなくなるはずだと思っていたのですが、`Color` に対しても `.badgeSymbol` が出てきます。`Self` が `Color` のときは使える、ということですね。ちょっと不思議ではありますが、そういう挙動になっているようです。

ここまで準備すると、「外側から与えられる変更にも対応できるようにしておきたいよね」という気持ちになります。`Color` を渡していたところを、`ShapeStyle` にしておくと、より柔軟になります。これで十分な気がします。

命名についても確認しておきます。`Color` と呼ぶのはおかしいですし、「シンボルのスタイル」とだけ言うと何のスタイルなのかが分からなくなってきます。どちらかというと `fill` のスタイル、つまり `ShapeStyle` ですよね。そういった名前にしておいたほうがよいと思いますが、こちらで何という名前にしていたか、少し分からなくなってきました。 とりあえず、先にこれです。フィルスタイルは、こうすると分かりやすくなりますよね。外から指定できるようにしましたが、名前はどうしておきましょうか。

この `width` は何だという話になってくるのですが、`width` は表示領域の幅、つまり `bounds` から計算したバッジの幅です。ただ、この中では正方形を扱っているので、幅というより「長さ」ですね。正方形を表現するときはスクエアなので、`square_size_length` のような名前がよさそうです。つまり、あのシンボルの正方形のサイズの長さ、ということです。これは外から使わないので `private` にします。

次に `height` まわりです。最初は `height - spacing`、次も `height - spacing` を引いたもの…といった形で試しました。線の `height` の部分を抜くとどうなるのか、と試行錯誤しました。ここは一度インスペクターを見てみると分かるのですが、とにかくボトム部分ですね。`bottom_portion_height` という感じでしょうか。そんな気がする、というニュアンスが伝わる名前を付けたいところです。これも `private` でいいですね。基本的に全部 `private` でよいと思います。

では、この `spacing` は何を表しているのかを見てみます。`height` と組み合わせて、ボトム側で `spacing` を使っていますし、手順として上側、`top portion` でも `spacing` を使っています。Y 座標方向のスペースですね。これを 0 にするとどうなるのか……まったく変わらないわけではなく、少し山のような差が出ます。つまり、ボトムとトップにおける `spacing` の調整ということです。用語としては `spacing` で通じると思います。部分の `spacing`。`bottom` に対して `portion` は少しうるさく感じるかもしれませんが、`portion` でよい気もします。`spacing` 自体は大丈夫でしょう。

次に `middle` とは何か、という問題があります。中央の位置なのか。`middle_top_size` のようにするのか。中央、`center`。角度差にするとどうか、そのあたりの話ですね。`middle length` と言うのか、何になるのか。`middle` でよいのか、`center`、`position`、`middle position`…。`middle length size`、あるいは `square_size_half_length` でもよいのかな、とも思いました。おそらくこちらのほうが意味は分かりやすいでしょう。少し長くなりがちですが、`length` だけだと分かりにくい部分が出てくる気がします。`square` にこだわらず、`badge_size` や `badge_length` でもいいのかもしれません。ただ、`badge_symbol` の `length` と言うと「長そう」という印象にもなり得ます。`size` のほうがよいかもしれません。長くなりがちではあるものの、よく分からなければ両方書くほうがまだマシかな、一般的ではないにせよ……まあ、いいか、という感じです。

とりあえずこのくらいでよしとして、これでバッジシンボルが出来上がりました。ついでにやっておきたいのが、バッジバックグラウンドのグラデーションです。これも外側から与えたい気がします。今の流れだとパラメーターがあって、それを外側から与える形になりますね。少しややこしいパラメーターになってしまっていますが、どうするのがよいか。パラメーターという形にして、複雑なところがあるので規定のパラメーターを用意して与える、という方針です。要は、`RotatedBadgeSymbol` を描く、ということですね。 とにかく、`RotatedBadgeSymbol` を回転させていくんだという話です。面白いですね。なので、これをひとまず `RotatedBadgeSymbol` として進めていきます。さっきリファクタリングしたときのように、新しく出てくるチュートリアルの型をなぞりながら作らないといけなくなってくるのが面白いですね。

まずは `BadgeSymbol` を作って、その中で `bounds` と `fillStyle` を渡す必要があります。これは `BadgeSymbol` が求めるものと同じなので、`RotatedBadgeSymbol` もそれを受け取るようにします。つまり、`bounds` と `fillStyle` を引数で受け取れるようにしておきます。

次に、View の構造体のプロパティを `let` にするか `var` にするかですが、チュートリアルだからといってコードが常に正しいとは限りません。`bounds` などを書き換えたときに描画が変わる仕組み（たとえば `@State` やバインディング）をまだ用意していないなら、まずは不変の `let` にしておくほうがよさそうだと感じました。ということで、ここは `let` に統一しましょう。

そうなると気になるのが `BadgeBackground` です。こちらのパラメータも、View のプロパティは `let` にしておきます。同様に、`BadgeBackground` が何を持っているか見直すと、ここでジオメトリを使っていますが、`BadgeSymbol` と統一感がありません。なので `bounds`（`CGSize`）を持たせるのがよさそうです。ここでは `GeometryReader` を使わず、先にジオメトリを直して、ここを `bounds` にしておけば成り立ちます。`GeometryReader { geometry in ... }` のところで `bounds` を `geometry.size` にしておけば、他でも使い回しやすくなります。

受け取り方については、`@Environment` で受け取るか、`@Binding` が必要になってくるのか、どちらがよいかは状況次第ですが、今回は引数（`bounds` や `fillStyle`）として明示的に渡す方針でよさそうです。

現在の箇所だと、`RotatedBadgeSymbol` は `bounds` と `fillStyle` と `Angle` を受け取ります。`RotatedBadgeSymbol` という名前からして回転が主題ではありますが、引数の並び順は、優先度が高いものや関連度の深いものから並べていくと使い勝手がよく、API デザイン的にもよくなります。この文脈では、まず `bounds`、次に `fillStyle`、最後に `angle` という順番がよさそうです。`BadgeBackground` や `BadgeSymbol` も同様に、`bounds` と `fillStyle` を受け取る形にそろえておきます。

こうしている間に、あれ、選ばなかったですね。まだアタッチされていないからかな。回っていますね。良さそうな予感がします。コード的にも無駄がなさそうです。次に進みましょう。

実験として `Angle` をいじってみてもよいのですが、今回は先に進みます。セクション 4 では、具体的に回転させて、いよいよ `BadgeBackground` の中にこのシンボルを配置していきましょうという話になります。

こういった幾何模様で、どうやって全部のシンボルを用意していくのだろうという不安が、Landmarks 分だけよぎりましたが、このアプリアイコンの前提になっている山の絵を回転させてシンボルを作る、という発想はなかなかすごいなと思いました。こうやって作っていけば再利用もしやすいですね。細かい言い回しはともかく、発想が良いです。

この辺の話はまた次回にしましょう。いい具合の時間ですし、今日はこれで終わりにします。お疲れ様でした。 文字起こしのテキストがまだ届いていないようです。整形したいテキストを貼り付けてください。長い場合は複数回に分けて送っていただいて大丈夫です（つながりは私のほうで維持します）。

整える際は次の方針で対応します。
- 文体は「です・ます調」
- 要約はせず、内容は削らない
- 誤変換や誤字を適切に修正（例：「G言語」→「C言語」、「万全オキス」→「万全を期す」など）
- コードはバックティックで装飾。短いコードはインラインで、必要に応じてコードブロックも使用
- 会話形式の表現は、発話者名を出さずに地の文へ整形
- テキストにない内容（挨拶など）は追加しない
- 文頭が中途半端でも、続く文から自然になるように整える

準備ができましたら、そのままテキストをお送りください。
