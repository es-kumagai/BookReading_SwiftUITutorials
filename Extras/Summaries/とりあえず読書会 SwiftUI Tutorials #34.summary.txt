Transcription & Summarize : とりあえず読書会 SwiftUI Tutorials #34

では、紹介を始めていきましょう。Swift というわけで、とりあえず今まで iOS で作ったものに加えて、watchOS アプリが終わり、ついでに macOS アプリもだいぶ進んでいるという状況です。その中で、コードに少し微妙なところがあるので、今日はそのリファクタリングを主に進めたいと思います。とりわけカテゴリーの検索あたりがなんとなく気になるので、そこを直していきたいです。

前回の中で、考え方次第では悪くないよね、という話をしたのが、ランドマークリストのカテゴリーフィルターに関する部分です。フィルターの種類としては `All`、`Lakes`、`Rivers`、`Mountains` の4つが用意されていますが、`Lakes`・`Rivers`・`Mountains` と比べて `All` が少し異質に見えるのが気になります。つまり、排他的に「これまたはこれ、またはこれ、またはこれ」と並べるのが自然なはずなのに、`All` だけ性質が違う、という違和感です。もちろん「フィルター」として考えれば `All` はありなのですが、「カテゴリー」として捉えると違和感がある、というのがまず1つです。

ただし、考え方次第では「ランドマークリストにおけるフィルターカテゴリー」という価値観の中で、この4つを対等に並べるという捉え方も可能です。それでも良いのですが、コードを見たときに、フィルター条件を組み立てる箇所、たとえば `filteredLandmarks` の中で、条件として「カテゴリーフィルターが `All` のときにはこれ、それ以外のときにはこれ」というように分岐がアンバランスになっているのが気になります。もし同じ価値観で統一するなら、全部を均等に分岐するか、あるいは特別扱いの分岐自体が不要になるはずです。

もう1つ気になるのは、フィルターの `rawValue` とランドマークのカテゴリーの `rawValue` を比較している点です。`All` に対しては `rawValue` がランドマークのカテゴリーの `rawValue` と一致しません。また、ランドマークのカテゴリーとフィルターが表すカテゴリーは、`All` さえなければ同じものです。であれば、同じ概念は同じ型や同じ表現で扱ったほうが、何かと良いことがありそうだと感じています。ここも直していきたいところです。

もう1点、今回のフィルターに関連して気になるのは、「お気に入り」か否かによってリストが変化する挙動です。お気に入りのみ、というフィルターにしたとき、詳細画面でお気に入りの切り替えを行うと、リストから除外されてしまいます。そうすると左側のリストから項目が消え、背後のバインディングが切れてしまって、詳細側のオン・オフが画面上で正しく再表示されない、という問題がありました。状態自体は変わっているので動作としては間違っていないのですが、表示が矛盾する形になります。前回は、ひとまずちゃんと動くようにコードを修正しましたが、まだ少し汚い感じがするので、ここも綺麗に直したいです。

具体的には、リストから項目を選び、詳細を開いて、お気に入りの星を付けたり外したりできます。ところが、お気に入りのみのフィルターが有効な状態で、そこで星を外すと、その時点で左側のリストからは消えます（「お気に入りのみ」なので当然ではあるのですが）。このとき、選択していた項目がリストから消えるため、後ろのバインディングが切れて詳細画面の表示が更新されなくなります。これを避けるために、「お気に入りのフィルターが有効でも、今まさに詳細を表示している選択項目は、その場では消さない」という対処を入れました。ただし、別の項目を選んだ瞬間には消える、という挙動になります。これでも良いといえば良いのですが、どちらかというと、自分の方針としては「フィルターを変更するまでは、いったんフィルタリングされた表示をそのまま維持する」ほうが好みです。つまり、フィルターの条件が変化するまでの間は、現在の表示を維持する、という挙動にしたいと考えています。まずはその方針で実装してみます。 そうすると、やろうとしていること、これでできることとしては何がありますかね。要は、フィルターした結果を少し取っておいて、フィルターの設定が変わったときにその内容を反映させる、つまり取り直す、という感じですかね。そういったところをやっていけばいいのかなと思います。

やっていくにあたって、今何をやっているのかを画面で見られた方がいいのかなと不意に思ったので、ちょっとテロップを付けられるか試してみます。テロップは…これですね。題目のテロップ。打ってみて、とりあえず何にしましょうかね。「フィルター設定を…」あ、なんか文字化けしています。フォントの選択で…あ、これだと化けますね。ヘルベチカになっているので、これを日本語フォントにしないといけないですね。日本語フォントはヒラギノですね、Macなので。ヒラギノ…どこだ。ヒラギノのフォントがたくさんあります。いやでも、フォントも豊かになりましたよね。昔は本当に全然なかったものですけど。ヒラギノ、しかも綺麗だしね、Macだと。ヒラギノ角ゴ、これでいいかな。サイズはまあいいか。太さは W3 ぐらいかな。お、出てきました。ちょっと巨大すぎますね。サイズは普通に…そう。あ、まだ出ていないかな。あ、まだ出ていないか。ということで、今調整中なので、もう少しで出てくると思います。少々お待ちください。

それで、フィルターの文字のサイズもそうだし、フィルターのテロップのプロパティとして…フォントがちょっと小さいのか。じゃあ 64。64 ぐらいだと…あ、それでもこんなにか。ちょっと映しながらやってみますか。せっかくなのでね。出るかな。あ、これで多分、上の真ん中辺に映っていると思うんですけど、これからやろうとしていることですね。これを実際に寄せつつ、どっちにしようかな。右上がいい気がするんですよね。ということで、ここにして…できているかな。これはまだ有効にしないと移動しないですね。あれで、どこかに移動したと思うんですけど、まだちょっと小さいです。うーん、フィルター…フィルターの設定。フォントが 64 とか近いのかな。74、96 ぐらいにしてみます。これで見えないなりに、ちょっとやってみますか。右寄せは難しそうだから、とりあえず左上にしておいて、フィルター設定を操作した時にだけ反映させる、みたいな感じでやっていこうかなと思います。題目…まだかな。まずはこんな感じでやっておいて、またゆっくり調整しますが。はい、じゃあこれで一本ずついきましょう。

では、そういうことでやっていこうと思いますが、更新のトリガーが一つですよね。題目が分かりにくいかな。やろうとしていることをもっと細かく書きますかね。つまり、やろうとしているのは、フィルター設定を操作した時にだけ、フィルター状況を反映してリストを更新することです。これで良さそうですね。「やっていること」…題目というか、やっていることですかね。まあいいか、題目で。はい、じゃあこれで OK ですね。さっそくやっていきましょう。

まずは、ちょっと見にくいかもしれませんが、更新します。これで下の方に置こうかな。下なら…あ、下、いいですね。スペース空いていましたね。ここにしましょう。よし、じゃあいけますよ。

そうすると、フィルターが変わったことを反映できる…というか、認識できる必要がありますよね。カテゴリーフィルターを監視するということになるのかな。カテゴリーフィルターだけじゃないか。カテゴリーフィルターと、あとは `Show Favorites Only` ですか。というと、`Show Favorites Only` だけ監視すれば十分な気がするんですけどね。それだけでいいのか。`Show Favorites Only` を純粋に監視して、カテゴリーフィルターの変更も反映しないといけないから。この辺りを「フィルタリング」としてまとめてしまったらいいんじゃないかなと思うんですよ、構造体で。 まずは、`LandmarkList` の中にフィルター用の型を作ります。`extension` で `struct Filter` を定義し、これを使ってフィルター状態を表現するようにします。

`Filter` には、例えば `var showFavoritesOnly` と、もう1つカテゴリ用の `categoryFilter` を構造体のプロパティとして持たせます。`Filter` 自体を `Hashable` にしておけば、値の変化を検出できるようになります。これでフィルターの変更を判定できるようになります。

次に、`categoryFilter` をどう扱うかですが、これは現状では watchOS ではサポートしていません。対応としては、`categoryFilter` をオプショナルにするか、あるいは watchOS でもフィルターを使えるようにするかのどちらかです。まずは macOS と iOS だけを対象に進めます。その前提で型を用意しておき、初期値も設定します。初期値としては、`showFavoritesOnly` は `false`、`categoryFilter` はプラットフォームに合わせて未設定（必要ならオプショナルで `nil`）の状態にしておく想定です。

フィルターが用意できたら、それを使って各所の条件分岐を整えていきます。まず、従来 `showFavoritesOnly` などの個別の値を直接使っていた部分は、`filter.showFavoritesOnly` のように `Filter` 経由で参照するように書き換えます。同様にカテゴリの条件も `filter.categoryFilter` を使います。たとえば、

- `filter.categoryFilter`
- `filter.showFavoritesOnly`

という形でフィルター処理をかけます。

このとき、macOS ターゲット側で `LandmarkList` の `categoryFilter` が見つからないというエラーが出たので、該当箇所を `filter.categoryFilter` に、また `showFavoritesOnly` も `filter.showFavoritesOnly` に置き換えます。これで参照の不整合を解消します。

`@Binding` の扱いについては、`showFavoritesOnly` は `Binding<Bool>` として問題なく使えます。リストやメニューのモディファイアに渡している箇所もそのままで大丈夫です。

ここまで直したらビルドします。ビルドは成功しました。動作も従来どおりのはずですが、ついでにもう1点、フィルターの変更を検知できるかを確認します。`List` 内のフィルター設定部分に `onChange` を仕込みます。

`onChange(of: filter) { oldFilter, newFilter in
    print(newFilter)
}`

このように `onChange(of: filter)` で `oldFilter` と `newFilter` を受け取り、`print(newFilter)` しておけば、フィルターが変わったことを検出できます。まずはこれで OK というところまで進めます。 これをビルドしてみます。ここは `Equatable` で良かったですね。`Hashable` でなくても良いので、無理に `Hashable` にはしないという選択肢もあります。どっちが良いかは少し悩ましいところですが、`Hashable` でも良い気はします。比較の際にハッシュ値を使う手もありますが、まあいいか、とりあえず実行します。

まず動作に問題がないことを確認しつつ、ログも一緒に見たいので、見えるところに並べて実行します。ログはこちらで、今は何も出ていない状態です。リストを触るだけでは特に何もありません。お気に入り状態のチェックに関するログが出る程度で、この星アイコンをクリックしたときに状態変化が起こるくらいですね。

フィルターを変更すると、たとえば「Filter changed」のようなログが出ます。ここで「Mountains」に切り替えると、これも変化が反映されています。「Favorites only」も大丈夫ですね。画面上は少し動きが分かりにくいかもしれませんが、ちゃんと新しいフィルターが適用されています。`onChange` で検出してフィルタリングを整えられれば問題なし、ということで、この方針で実装を整えていきます。`Xcode` はもう再開ですかね。

やることとしては、まずフィルターによる絞り込みはできているので、命名を整えます。カテゴリーに関する名前は、リファクタリングでリネームして、`Category` ではなく複数を表すなら `Categories`、あるいは用途によっては `CategoryFilter` のほうが適切です。カテゴリーによるフィルターは機能していて、名前の表現も良い感じになりました。

次に、`filteredLandmarks` です。これは、もともと `filteredLandmarks` の中でやっていた処理を切り出して、`filteredLandmarks` の内部に組み込む形にまとめました。フィルターを作るときにフィルタリングの対象となるのはやはり `LandmarkList` なので、`LandmarkList` に持たせるのが良い、という判断です。表示中のランドマークの配列名は、ひとまず `filteredLandmarks` にしておきます。これを保存型プロパティにして、`private(set)` にします。

そして新たに、更新用の関数を `updateLandmarkList` にしました。この更新処理の中でフィルター条件を適用し、最後は値を返すのではなく、`filteredLandmarks` に代入して反映する、という流れにします。これで更新が可能になりました。

次の確認事項としては、フィルターはすでに決まっていて、ランドマークのリストは `Binding` の `landmarks` になっているはずです。初期値がまだ決まっていないかもしれません。今ビルドすると、28行目でエラーになりますね。「self がイミュータブル」と言われているので、これは状態を更新する処理である以上、`mutating func` にする必要があります。`mutating func` に直します。

あとは、パラメータとして `filteredLandmarks` と `LandmarkList` を扱います。`LandmarkList` の定義の中で、`filteredLandmarks` の値が未設定なので、ここをきちんと設定します。本来は `Binding` にしないといけないので、`Binding` にして…あ、これでいけるかな。以前にそういう拡張を作っていたはずですが、今の形ではその拡張は使えないですね。現状の構造だとそこは適用できないので、もう少し整理して対応していきます。 とりあえず、`filteredLandmarks` が決まっている状態で始まっています。それで、フィルターと、あとは「Favorites only」、要はフィルターですね。フィルター条件が決まっている状況なので、イニシャライザーで頑張らなくても大丈夫です。`filteredLandmarks` を予期しないで持たせた上で、イニシャライザーを定義して、その中で消化すれば十分です。

なので、`filteredLandmarks` に対して、`update` は `self` を更新するので、このままだとダメですね。そこで、`updateLandmarkList` という関数を作った上で、別に `private func makeLandmarkList` を用意します。戻り値としてランドマークのリストを返すようにして、まずはその関数を作り、関数内で `return` する形にします。そうしておけば、`updateLandmarkList` ではこれを使って、`filteredLandmarks` に対して `makeLandmarkList()` を代入すれば良い、という流れです。

最初は代入できずにエラーになっていました。型が `Binding<Landmark>` になってしまっていたので、`Landmarks`（ランドマークのリスト）に直しました。これでできました。良いですね。

この関数は `private` にするので、定義の場所も整理します。とりあえずカットして、`private extension LandmarkList` の中に置くことにします。ここは片手にしているだけなので、もっと下に移動しましょう。`private extension LandmarkList` の中で `private func makeLandmarkList()` を定義します。これで副作用なしの関数として使えるので、イニシャライザーの中でも `makeLandmarkList()` によってフィルターを有効に使っていけます。

次にフィルターも調整します。フィルターは初期値を固定で与えるのではなく、`filter = filter` という形でイニシャライザーで代入して初期化します。ここでは仮置きにしておきます。フィルターの定義の順番も少し変えておきましょう。順番を変えるとインターフェース化の問題が出てくる可能性はありますが、状況次第かなと思います。とりあえずここから上のほうに移しておきます。

この状況で作り進めていくと、`selectedLandmark` が要らなくなる可能性があります。とはいえ、`selectedLandmarkID` を持っておくかどうかは意味のある判断ポイントです。`selectedLandmark` を残しておくと、選択中のものが分かるという利点があるので、ここは残しておきます。だいたいのところは ID を保持しているので、うまくいっていますね。`selectedLandmarkID` はオプショナルで表現されているので、選択がなければ `nil` を指す、という感じです。良いですね。

フィルターがあって、`showingMenu` という状態変数があって、`showingProfile` という、状態変数というかバインディングもあります。これで良さそうです。できた感じがします。

もう1つ、フィルターはこのままだと更新されないので、`onChange` のところで対応します。`filter` が変わったときに、`updateLandmarkList()` を呼ぶようにします。ランドマークを更新できるようにするには、このメソッドは `mutating` にしないとダメですね。`updateLandmarkList` は `mutating` な `private` メソッドにして、その上で、`makeLandmarkList` はプロパティを変更しない関数（副作用なし）として実装します。これで大丈夫です。今日もできたかな、というところですね。まだペラですね。明日かな。

ここで、イニシャライザーで何を渡そうとしているのかも整理します。イニシャライザーを作ったので、`showingProfile` を設定しておかないといけません。`showingProfile` はバインディングなので、`_showingProfile = showingProfile` のように、アンダースコア付きのほうに代入します。

最後に、`makeLandmarkList` は自分のプロパティを使ってしまうので、このままではダメ、という点も注意が必要です。プロパティに依存せずに使いたいなら引数で必要な情報を受け取るようにして、純粋な関数にするか、逆にインスタンスメソッドとしてプロパティに依存させるのか、どちらかに設計をはっきりさせると良いです。 やることは、`static`関数にしなければならないですかね。つまり、`private static func makeLandmarkList(with filter:)`としてデータ型を受け取るようにすれば、必要な情報が揃いますよね。前は`selection`をフィルターに残そうとしたのですが、今回はそれがいらなくなります。なので、フラグを変更することは今回はしないということにして、フィルターは`@State`で管理し、`selection`は不要ですね。こんな感じです。

モデルデータでランドマークを扱うにあたって、`landmarks`は`ModelData`から取得し、それをフィルターしたものを設定しないといけません。ランドマークは`ModelData`から取るわけですが、`ModelData`は`Environment`にあります。ここでは直接扱えないのですね。なるほど。そうすると、`static`関数にする必要がなくなってきました。イニシャライザーに渡すのではなく、モデルデータを引数に受け取れるなら`static`である必要はなく、普通の関数にします。リストは`@State`で保持し、`with filter`もいらなくなります。そしてこの後、`makeLandmarkList`をイニシャライザー内で呼べないという話になってくるので、つまりここでやることとしては、まずイニシャライザーと同様の形でフィルターの既定値を用意し、`@State`のランドマークリストにその値を入れる、という流れで良さそうです。

こうしてあげるとイニシャライザーは不要になります。あとは、フィルター、というかランドマークのリストが更新されるように、リストが表示されるタイミングで`updateLandmarkList`を呼び、フィルターが変わったときにも`onChange`で呼ぶようにします。これで、フィルターを適用した後にアプリが動いて、リストがちゃんと出ています。リストが表示されていて、「お気に入りのみ」に切り替えると、その通りに絞り込まれます。

ところが、項目を選んだときに、押してもリストからは消えずに、あれ、押せなくなるのか……。失敗しましたね。押せなくなるということは、検索（`find`）がおかしいということですかね。スナップショットの問題かもしれません。リストを更新したときにスナップショットが変わってしまう。`apply`し直せば大丈夫そうな気がするんですけどね。でも、これはダメと言っていますよね。明らかに失敗です。これではダメなのか。

やったこととしては、フィルターが変わったときに`onChange`が発動するようにしてあります。フィルターが変わっていなくてもいいので、まず一回試してみましょう。もう一度アプリを起動します。この後、何も変わっていない状況で、フィルターをこの状態で押すと……もうこの中で動かないですね。ダメか。ということは、`updateLandmarkList`をやった時点でアウト、ということですね。アウトというのは、つまり、詳細画面で表示しているリストとのリンクが途絶えてしまうということですかね。リンクが途絶える。しかし、押せているようにも見えます。ログを見ておきますか。ログで正しく動いているのか確認します。これで一回クリック。もう一回くらい押しておきました。 この時に、押せている風になっていないですね。押せている風になっていないということは、変更の反映が全然できていないということです。では、今やった変更は何でしたっけ。ランドマークのフィルターの条件について、フィルターが変わったときに再フィルタリングするのではなく、キャッシュしておく、という方針に変えたのでしたね。

つまり、キャッシュしておいたとして、フィルターをいじって用語（条件）が変わったときに、バインディングがもうなくなってしまうんですかね。フィルターでしょ、セレクション。どこをいじったかというと、まずメソッドのところで、このバインディングの返し方は普通に Environment からモデルデータを拝借してフィルタリングをやっている、という状況です。あとは、以前はセレクションをキープしていましたが、最初はね、それをキープしなくなったというところが変化点としてあります。これを復活させるとどうなるんでしょう。復活させるにはどこまで戻せばいいのか……いや、復活はいいか。

`makeLandmarkList` では、そうですね。フィルター自体は残っているんですよね。そうすると、モデルデータへのリンクが消えている、ということになるんですかね。これはまずいですね。自分がまだ、このバインディング周りの仕様を理解し切れていないということですよね。こういう問題にしょっちゅうぶつかるような気がします。

まずはどうしましょうか。フィルタリングは…なんだろう、難しいな。`filteredLandmarks` が `@State` になっていますよね。だから、これが変化するとバインディングが崩れるのか。ああ、バインディングが崩れる可能性はありますね。そうすると、この `filteredLandmarks` は書き込み可能でなければならない、ということなんですかね。

書き込み可能にする一つの方法としては、クラスで包んで参照型にする、というのが一般的にありますが、それはなんとなく下手な感じがします。では計算型プロパティにするのはどうか。計算型プロパティにしてもダメですね、多分。それだとね。おそらく「`filteredLandmarks` が `@State` だからまずい」という発想で合っているのだと思います。

だとすると、例えばやれることとしては、クラス `DataSource` みたいなものを作って、内部に `var filteredLandmarks`、そして `Binding<[Landmark]> landmarks` のように持たせて、初期値はこれ、というふうにしていくんですかね。バインディングに対して `wrappedValue` に代入できるのかな。もしかして、`Binding` の `wrappedValue` だけやってみますか。

つまり、`@State` じゃなくて、`filteredLandmarks` をプライベートな `var` にしたときに、この中で、ここは初期化しておきますけど、バインディングのパラメータですね。これの `filteredLandmarks` の `wrappedValue` に代入……いや、これは代入できないか。やっぱり肝は `Binding` ですね。

それで、`makeLandmarkList` で、バインディングを作らなかったとして、ランドマークをバインディングを作らずに返すとすると、これはダメですね。バインディングを作らないとリンクがちゃんとできなくなってしまうので、これはダメです。ランドマークのバインディングを差し替えないといけないから、これだとダメで、ここはアンダースコア `_` は？ これもダメですか？ そうですよね。

やはり `DataSource` として持たせて、初期値がこうあって、それで `dataSource = DataSource(...)` のようにして、`dataSource.landmarks` に代入することができますよね。これで `dataSource` がこの辺で使える。これと、あ、ここは違いますね。`dataSource`。

そして、あのエラーは何だ？ ドローイングプロファイルのイニシャライザー。ここのイニシャライザーが、モデルデータも OK で、フィルターも OK で、ドローイングメニューも OK で、ドローイングプロファイルが `Binding` で、やっぱり `dataSource` も OK。なのに「イニシャライザーがない」ってどういうことだ？ 「`private` protection level」か。「Landmark イニシャライザー」ってどういうことだ？

ああ、ここだ。`private` で保護しちゃった。これのことか。`DataSource` か。`DataSource` を `private` で保護したことによって、こうなってしまうのは面倒ですね。 まずは`private`をやめてみます。少し待ってください。イニシャライザーを作らないといけないのが面倒なので、この状態で一度実行して、うまくいくかどうかを見ます。あれ、うまくいきませんね。データソースはバインディングでいいのか……これでいいはずですが、全然ダメです。リストが更新されていません。

更新されていないということは、フィルター状態が変化して再評価は走り、適切なランドマークリストは再度作られているはず、という感じです。やっぱりキャッシュが問題ですね。バインディングを生かすためには、フィルターが変わったことを検出して、その後に再評価すればよいのかな。バインドはそのままで再評価、という方針です。ただ、バインドはそのままでいけるのかは難しいところです。

フィルターのアップデート自体はできたとしても、その変化を検出しないといけません。検出は必要ですが、検出するとバインディングが切れてしまう、という懸念もあります。ということは、リストが同一なら更新しない、という扱いにするのがよいのかもしれません。

再評価して、さらにバインディングを更新する、という手もありそうです。アップデート時に何かをする予定なのであれば、データソースがランドマークリストを持っていて、変更が整ったときにバインドを差し替える、という形です。モデルデータからフィルターをかける必要がありますが、そこはすでにやれています。モデルデータからのフィルタリング自体はできています。

では、何が問題なのでしょう。要はフィルターとランドマーク、そしてバインディングの関係です。新しいリストから作られたバインディングが、画面と連動していないのかもしれません。画面側が古いバインディングを握り続けている可能性があります。

スナップショットはなかなか難しかったです。別のスナップショットの取り方としては、IDをリストで保存しておいて、それを使って順次書き換えていく、という方法もありかなと思います。ただ、もう少し素直に、Environmentのランドマークから普通に処理したい気がします。 それを少し模索したいのですが、今まで計算型プロパティでやっていた場合はこの通り動きます。しかし、そうではないやり方にすると、`filteredLandmarks` に代入したときに情報が古くなってしまいます。データ駆動でやっていないので、「更新された」という通知が起こらないのです。これは先ほどの話と同じですね。

リストUIを更新させるための力技としては、やりたくはないのですが、トリガー用の `Bool` を用意しておいて、そのトリガーを動かしてしまう、という方法があります。つまり、`updateLandmarkList` の中でそのトリガーをトグルして再描画させる、という発想です。ただ、これは書き忘れそうですし、UIで使っていないと発火しないので、結局クリックしないと更新されなくなる、という状況にもなり得ます。これもダメですね。根本的に間違っているやり方だと思います。

計算型と格納型の話に戻ると、格納型に計算結果を代入してしまい、しかも `Binding` を使っているのが問題だと思います。つまり、ランドマークリストをバインディングで扱っているからこそ、格納してしまうと整合が取れなくなる、ということです。

そこで方針を変えます。ランドマークリストの「データソース」をやめて、まずは計算型プロパティを復活させて、動くものを作ってみましょう。もう一つ重要なのはフィルター用のIDです。`selectedLandmarkID` と同じように、`@State` で管理してよさそうです。たとえば、`@State private var displayingLandmarkIDs: [Int] = []` のように、リストに表示するランドマークのID配列を持っておきます。とりあえず何も表示しない初期状態を想定しておけば、そこにフィルターの結果を入れていく形です。

そして、この `displayingLandmarkIDs` を使ってフィルターを掛けます。やることはシンプルで、IDが `displayingLandmarkIDs` に含まれているランドマークだけを出すようにします。具体的には、モデルデータ（`ModelData`）からランドマークを全部取り出して、絞り込み条件を適用します。`ModelData` の中の `Binding<Landmark>` の配列に対して `filter` をかけ、クロージャの中で「`displayingLandmarkIDs.contains(landmark.id)`」という条件にします。これでフィルタ済みの `Binding<Landmark>` のリストが取れます。

取得できたら、そのまま戻り値として `Binding<Landmark>` の配列を返せば、型推論で適切に扱ってくれます。これで `filteredLandmarks` が計算で求まるようになります。

更新系の関数名も整理します。`updateLandmarkList` ではなく、たとえば `updateDisplayingLandmarkIDs` のように、実際に更新している対象（IDの配列）を名前に含めたほうが分かりやすいです。処理の中身はこれまで `makeLandmarkList` でいろいろやっていたものを持ってきてしまってよいと思います。関数名としては、`make` も `get` もしっくり来ないので、いっそ分けていた関数をやめて、`updateDisplayingLandmarkIDs` の中にまとめてしまうのが素直かもしれません。わざわざ関数を分けるほどの価値があるかどうかは、今のところ微妙だと感じています。 とりあえず、これでさっきの `updateLandmarkIDs`、この中で今のコードを適用してあげて、`return` ではなくて `displayingLandmarkIDs` に対して代入してあげます。`displaying` ですね。`displayingLandmarkIDs` に値を入れてあげるわけですけど、その前にやりたいことがある気がします。フィルターですね。

フィルターに対して、モデルデータ。モデルデータからは `Binding<Landmark>` と言っていますけど、今はそれだけではないですよね。モデルデータには生の `landmarks` がありますよね。だから、モデルデータからはもう `Binding` とかは気にせず、`landmarks` に対してフィルターをかけて、条件を満たすものを取ることができます。フィルターも、`landmarkFilter` のような値を引き継いで、そのまま直接渡せますね。これでフィルターされたやつ、つまり条件を満たしたランドマークの配列が得られます。これで十分ですね。

あとは、これを代入で入れてあげれば完成ですかね。条件を満たしたものを取るだけだとダメなので、`.map` で `id` を取り出します。これで良さそうです。フィルターして、ランドマーク数とランドマークの `id` が変わるわけですよね。ここで `id` を取ってあげると、`id` のリストが取れます。これで良さそうですね。`id` が変更され、その変更がトリガーになって、モデルデータから `Binding` を適切に取得して利用できる、という流れになります。良さそうな気がします。

データソースがなくなっただけですね。だから、フィルターでランドマークを取れば良くて、あとはここを直します。`updateLandmarkList` じゃなくて何でしたっけ。`updateDisplayingLandmarkIDs` ですね。これを呼んであげます。UI のこの `onAppear` から見たときには、`updateDisplayingLandmarkIDs` という名前は少し違和感があります。`updateLandmarkList` のほうが分かりやすいですね。こちらは `updateLandmarkList` という名前にして、関数の中でやることとしては、フィルターを満たすものでランドマーク `id` を更新する。そうすると表示用のリストが変わってくれるので、関数としては名前通りになります。

これで実行できたのかな。押してみます。大丈夫ですね。次にフィルターを変えたときにどうなるかを見ます。フィルターを変えて、例えばまずは Mountains みたいな感じにして、これも大丈夫ですね。Icy Bay というところもフリップでいけていますね。では、いよいよ Favorite Only。そうすると 2 個ですよね。今はこの星を外すと、星が外れた状態でお気に入りではないのですが、リストには残るというふうに変えたので、こうして残っています。

今回、始めた最初と違うところは、別のリストを選択しても、`displayingLandmarkIDs` でキャッシュしているおかげで残ったままで良い、という点ですね。こちらでもお気に入りを外せます。残ったものだから選択できます。ON にする、できましたね。

この上でリストを例えば Lakes にすれば、このときにリストがちゃんと変わります。お気に入りのみの Lakes。これで OFF にするのもちゃんと効いていたから、今は何か 1 回ミスしたのかな。あとはもう一度 Mountains に行って、Icy Bay を選んで OFF。大丈夫ですね。これで Favorite Only を外せば、当たり前に Favorite じゃないのが出てきます。失敗した？ 最初に 1 個出てなかったですよね。これで ON/OFF はいいんですけど、もう一回再現するには、Favorite Only にして、そこから Favorite Only を外せばいいんですかね。出てきますよね。これは遅延の可能性があるから、遅延なのかな。こういった謎挙動は少し嫌ですね。

ほかにももう少しいろいろいじってみます。ALL にして、選んだときに別にリストはおかしくならないですよね。これで、先ほどの Lakes をお気に入りにしておいて、ほかにもお気に入りにしておきます。Hidden Lakes などなど入れて、これでお気に入りのみに変えると、お気に入りのみになります。ここで先ほどの Lakes を OFF にしたり、Icy Bay を OFF にしたりして、それで Favorite Only を外す、でいいのかな。外すとこんな感じになって、このときにクリックしたときに大丈夫そうですかね。もう一回 Rivers にして、Rivers で Favorite Only を入れて、ここでお気に入りを外して、Favorite Only から ALL に直すと 3 つ。こうやると ALL は大丈夫なんじゃないかな、ということで、OK ということにしておきますかね、という感じです。

こんな感じで、キャッシュが理想から少し外れちゃったのですが、`Binding` は少し使いにくいですね。ビューの再構築が発生してしまうと、古い `Binding` が効かなくなってしまいます。これも考慮して、新しいビューに切り替わったときに改めて `Binding` を取り直さないとダメです。つまり、`Binding` 以外でなんとか状況を把握して、その状況を使って、`Binding` を計算型プロパティで組み立てていく、というのが、少し大げさに言えばセオリーになってきそうだ、という印象を持ちました。 これで良いでしょう、きっと。あとは `selectedLandmarkID` です。これは今は使っていませんが、残しておいていいと思います。今後、選択したランドマークに対して何かを行うようにしたい場合、`selectedLandmarkID` が取れることは重要だと思うので、念のため残しておきましょう。

これでフィルターは作れました。`showingMenu` もこれでいいですね。`showingMenu` とこの辺のステートはまとめたい気もしなくはないですが、まあ今回はこのままでいきます。あと、トリガーはもういらないですね。こんな余計なものがなくてもビルドはちゃんとできます。できています。

それで、これをまとめた、という感じでしょうか。OKです。ただ、ここがちょっと気持ち悪いんですよね。`titleString` でごてごてやっているのと、`title` という名前そのものも気になるので、ここは後日いじりたいところです。これはまた次回に回します。

フィルターとランドマークは良い感じにかかっています。スマートに適用できている感じがしますね。`contains` も大丈夫そうです。`updateLandmarkList` もだいぶ落ち着いてきた気がしますが、`and` とか `or` とかを使って条件を作っているところは、せっかくフィルター型を作ったので、そこに任せるか、あるいは `FilterCondition` という型を作って任せるようにしたい気がします。この辺も次回やりましょう。内部でオブジェクトの関数を呼んだり、コンディションに `append` したりしていて、理解するのが大変ですよね。自分が作ったコードならまだしも、人のコードでいきなりこれが来たら「何だこれは」となりがちな難しい部分なので、役目を凝縮したちゃんとした型を作って、きれいにしましょう。

ここも次回の話ですが、今はフィルターの `rawValue` とランドマークのカテゴリーの `rawValue` を比較しています。本来は「カテゴリー」という観点でうまく組み合わせて、ランドマークのカテゴリーとフィルターに設定されているカテゴリーを同じものとして判断できるはずです。今それができていないシンプルな理由は、フィルター側のカテゴリー名が混ざっているからです。`category` と `categories` が混在していて、しかも今回は `.all` が混ざっているために比較できない、という状況があります。ここはちゃんと `Category` 型で比較したいので、今後リファクタで直していきましょう。

この辺をどこかで特化してしまえば、あとは `ModelData` からランドマークの条件に応じたフィルターをかけて、IDで取得するだけです。ランドマークをフィルターして、このくらいの処理なら、状況によってはこれをドットでつないで `lazy` として、1個ずつやっていく方法もあります。あ、でも「ランドマークに `lazy` がない」と言っていましたね。`ModelData` には直接はないので、ここで `.lazy` を付けてあげると、`filter` と `map` の操作を後回しにして、要素ごとに1回ずつ処理でき、そのうちフィルターで落ちたものには `map` をしない、ということができます。例えば、この後に `.first` を書くような場面では、フィルタリングされたものだけに処理が走るのでパフォーマンスが良くなる、というのはよくあります。ただ、今回はそんなに変わらなそうなので、このままでいいでしょう。

`body` 側も特に問題ありません。ランドマークIDの検出と、ランドマークリストが表示された段階で、一度ランドマークリストのIDのリストを更新して、適切なリストを出せるようにしています。表示前に計算するので大丈夫です。そして、フィルターが変更されるたびに、そのIDリストの内容を計算し直します。計算し直すことによって、再描画が走るとき、フィルターを変えたときに、今入っている `displayingLandmarkID` と一致していなかったときだけ差し替える、といったパフォーマンス向上もあり得ます。フィルターを変えたら再描画でいいでしょう、という感じがするので、今回はこれで良いと思います。

ほかに気にするところはそのくらいです。利用範囲（スコープ）もきれいに整えたはずなので、だいたい良さそうです。次回は、この辺のカテゴリーについて、`.all` をちゃんと特化して、カテゴリーでフィルターできるようにすることと、フィルター、というかフィルターの調整用の機能をどこかに置いて、よりきれいなコードにしていきましょう。
