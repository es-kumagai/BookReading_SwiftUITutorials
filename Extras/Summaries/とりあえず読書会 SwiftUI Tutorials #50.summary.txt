Transcription & Summarize : とりあえず読書会 SwiftUI Tutorials #50

では、とりあえずご紹介を始めていきましょう。今日も引き続き、完成した SwiftUI チュートリアルのコードを見直して、直すところは直していきます。いわゆるリファクタリングですね。だいぶ落ち着いてきた感じもあって、振り返りつつ要所を解説する、そんな形になっていますが、一応リファクタリング作業という位置づけです。

こういった作業は、慣れていないと意外と難しいところがあると思います。他の人がどんな感じでリファクタリングしているのかを見る機会として、気楽に眺めてもらえれば良いのかなと思います。リファクタリングって結構難しいんですよね。自分の考えは意外とまとまっているようでまとまっていなくて、この時はこれが良いと思っても、別の日には別の方が良いと思って戻したり、ということがあると思います。慣れていないうちは、自分の理想像が見えていないので、行きつ戻りつしながら、自分にしっくりくるもの、そして理屈の面でも理にかなったものを目指していくことになるのかなという気がします。

そういう意味では、やはり API デザインガイドラインはよくできていますね。とてもコンパクトにまとまっているのに、考え方の基準になる大事なポイントがしっかり書かれています。じっくり読むとリファクタリングもしやすくなると思うので、おすすめです。

さて、そんな感じで進めていきましょう。さっそくコードに行きますが、ここは終わっていますね。`LandmarkDetail` の macOS までは終わりました。なので、続いて `LandmarkDetail` の watchOS をやっていきます。プロジェクトのスキームも watchOS にして、プレビューも見ながら進めるのが良いでしょう。リファクタリングをしているとデザインが崩れていたりすることがある、という話は前回も結構しましたが、プレビューが使えるなら有効活用したほうが良いですね。SwiftUI（というか Xcode）のプレビュー機能は本当に便利です。

ここで、まだ少し迷っているのが、`@Binding` の値をどのアクセスコントロールにすべきか、という点です。今のところの感覚では、`private(set)` にしておくと `@State` とのバランスが良く、言語仕様的にもぴったりな感じがします。しばらくは自分でも `private(set)` を付けて運用してみて、支障が出るかどうかを見ていこうと思います。……ビルドは通りましたね。ではプレビューも大丈夫なはずです。

ただ、プレビューの設定が思いのほか狭いですね。こちらは、今 `Landmark for watchOS 2` ビルドをやっているものと違いそうです。`Prebuilding module dependencies: Swift Compiler Plugin` といった表示が出ていて、Xcode 側の問題に見えます。どう直るのかは分からないのですが、ひとまず試してみます。こうしてプレビューを起動して……。こういうのは意外とありますよね。Xcode を再起動すると直る、みたいなことはありがちです。お、動きました。

では見ていきます。`private(set)` は良さそうですね。`body` の `ScrollView` に `CircleImage` と `Text` が並んでいて、この辺はシンプルです。他のビューをいろいろいじったので、これも他の OS のビューに揃えていったほうが分かりやすい気がします。そのうえで、パディングの印象が少し違いますね。名前だけでも違ってくるかもしれません。ここはヘッダーパート、ヘッダーエリアのような感じで、この前使った構成に合わせていきましょう。 こんな感じでしょうか。地図までスクロールするのが大変なんですよね。これはもう、実機の事情がそうなっているので、仕方ない気がします。

前回は「ヘッダー」と「コンテンツ」という名前の付け方をしていましたが、Apple Watch 的にはその分け方はしっくり来ないですね。ヘッダービューというより、むしろメインビューに見えます。イメージとタイトル（イメージ、タイトル）を含めたものがコンテンツで、`LandmarkDetail` のコンテンツになっている、という整理にしたいです。

そこで、`Divider` の手前まで……というより `Divider` も含めて、その下のテキスト群までをひとまとめにして「コンテンツ」と名付けます。`LandmarkDetail` に対して拡張（`extension LandmarkDetail`）をかけ、`var contents: some View` を返す形にします。ここは `Result Builder`（`@ViewBuilder`）を使わないとこういう書き方ができないので、`@ViewBuilder` を付けておきます。こうすると見た目も崩れていなさそうです。

同じノリで、全体のレイアウト名もそろえます。ここは「コンテントビュー」ではなく、macOS に合わせて「コンテントエリア」という名前にしましょう。表示するのはひとつのマップビューだけですが、統一感のために、マップ側は「マップエリア」と名付けます。つまり、「コンテントエリア」と「マップエリア」が `Divider` で区切られている、という表現になります。`private extension` で `@ViewBuilder` を使い、`var contentArea: some View`、`var mapArea: some View` のように分けて、`mapArea` では `MapView()` を返すだけにしておくイメージです。`MapView` 側の `.scaledToFit()` などの細かい指定はここでは一旦抜きにして、`body` では「`contentArea` と `mapArea` を `Divider` で区切ったもの」という構成が分かりやすくなります。`Divider` の扱いはこれで良いでしょう。

ここまで通したところで、上側には `Image`（`CircleImage`）、`name`、`isFavorite`、それと `park` と `state` が並びます。この辺りはひと組として扱いたいです。macOS では、これらを「サマリー」と呼び、その中に「イメージエリア」と「ヘッダーエリア」があり、さらに「タイトルエリア」と「サブタイトルエリア」に分けていました。あまりにも名前が違うと統一感がなくなり、同じコードでも一貫性が落ちてしまうので、ここでも macOS に倣って命名を合わせます。

つまり、まず全体としてはここが「サマリーエリア」です。その上で「タイトルエリア」には `landmark.name` と `isFavorite` をまとめます。定義は `@ViewBuilder var titleArea: some View` として、その中に今コピーした内容を貼り付ける形です。次に、サマリーの「サブタイトル」は `landmark.park` と `landmark.state` なので、こちらは `@ViewBuilder var subtitleArea: some View` として定義します。これでサブタイトル側も用意できました。 なので、サマリーエリアはイメージ、タイトルエリア、サブタイトルエリアで構成します。さっきと同じ発想で、細かい話になりますが、ここは「イメージを貼る場所」なので安直ですけど「イメージエリア」といった名前を付けてあげて、その上で `@ViewBuilder` で `var imageArea` のようにしておくと、これでOKですね。

こんな風にしておくと良いのは、サマリーはイメージとタイトルを置いて、そこに分割線（`Divider`）を入れてサブタイトル、というふうに分かりやすくできる点です。もともと `body` を見ると、各エリアに対して `VStack` は別にいらないかな、スタックなしでも崩れないかな、という気がしたので、ここはプレビューで確認しました。大丈夫ですね。ということで、サマリーエリアはイメージとタイトル、`Divider` を挟んでサブタイトル。その後に `Divider` が入って、マップエリアが続く、という単刀直入なUIになりました。

そして、さっき言った通りサマリーエリアは、イメージとタイトル、分割線、サブタイトル、という構成です。これで、例えば「タイトルエリアはどんな表示なのかな」と確認したいとき、ここをちゃんと「タイトルエリア」と認識していれば、「なんかここがおかしいぞ」となった際にも、タイトルエリアだけ定義を見れば原因を特定して直していけます。そんな感じで、マップビュー（マップエリア）はこれ、イメージエリアはこれ、タイトルエリアはこれ、というふうに分けておくのが良いです。タイトルエリアはランドマークの `name` と、`isFavorite` を扱う部分ですね。サブタイトルは `park` と `state` で終わり。直すところは他になさそうです。これで良いので、次に進みましょう。ランドマークリストです。

ランドマークリストビューになっていて、モデルデータは `@Environment` で持っています。`private var` や `@State` がいろいろあって、`selectedLandmarkID` がオプショナル。データとして存在しない可能性も考慮してオプショナルですよね。`displayingLandmarkIDs` は現在表示しているランドマークのIDで、これはIDを配列で保持します。最初は空で、後で表示するものを設定していきます。

`filter` はランドマークリストのフィルターです。Xcode のプロジェクトナビゲーターにもフィルターがありますが、名前の区別さえ忘れなければ大丈夫ですね。`showingMenu` は `false`、つまりメニューを表示していない状態です。それから、`Binding` でさっきから言っている `private(set)`、これは妥当なのではないかという仮説です。 `filtered_landmarks` は、バインディングされたランドマークの配列を返すようにしています。これはデバッグメッセージだったので、そろそろ不要ということで削除しました。`landmarks` はモデルデータから `binding_landmarks` を取得し、`display_id` がランドマークの `id` を含む場合、つまり表示対象のものだけを返します。バインディングを作り直さないと変更が伝わらないので、このような実装になっており、やや分かりにくいところはありますが、関数名を `filtered_landmarks` のようにしておくことで、「フィルタ済みのランドマーク群をバインディングとして返す」という意図が読み取りやすくなります。こうした命名は可読性の面で意外と有効です。

次に、`landmark_by_id` で ID を元にランドマークを取り出します。ここはバインド済みのものを取得する想定で問題ありません。`selected_landmark` は、`selected_landmark_id` を持っている場合にそれを基に取得します。ここは `match` ベースでも書けますが、今回はガードと `return` を使った素直な書き方にしています。

`map` を使って書くなら、`selected_landmark_id` は `Option` なので、最初は `selected_landmark_id.map(|id| landmark_by_id(id))` のように書けそうに見えます。しかし、`landmark_by_id` 自体が `Option` を返すため、この場合は `map` ではなく `and_then`（いわゆるフラットマップ）を使うのが正解です。つまり、`selected_landmark_id.and_then(|id| landmark_by_id(id))` という書き方になります。どちらのスタイルでも実現はできますが、慣れていないと読みにくいことがありますし、変数名だけでは `Option` であることが表れにくいという問題もあります。結果として、`selected_landmark_id` が `Option` なのかどうかが、ぱっと見では分かりづらい点があります。 いきなり `map` を使ったときに、これを配列と誤認することはあまりないと思います。ただ、対象がオプショナルで、さらに「オプショナルにも `map` がある」ということを学習していないと、少し似た思い込みをしてしまうかもしれません。短く書けるのは良いのですが、ここでまで学習コストを高める必要はないかなという気分もあります。ここでは `guard` で書いておけば、`selectedLandmarkID` がオプショナルであることが分かりますし、`if let` でオープンにすれば余計なことを考えなくて済みます。1行で収めずに、4行くらいに分けておいたほうが、なんとなく読みやすいかなという気がします。

`updateLandmarkList` では、`displayingLandmarkIDs` とフィルターを使って ID で更新します。`filter` で配列を作って、もう一度 `map` で ID の配列を作るくらいなら、`landmarks.lazy` を使うのが良さそうです。`lazy` にしておけば `filter` と `map` が遅延評価になるので、有用な値だけに対して `map` が走り、最後に `Array(...)` で配列化すればよい、という整理になります。`filter` と `map` が独立して二度走ることを避けられるので、`lazy` は良い効果があるかもしれません。

準備を終えた上で、`body`。`Bindable` でモデルデータをバインドできるようにして、`Environment` でもらった値もバインドできるようにした上で、`NavigationSplitView` の `selection` を `selectedLandmarkID` と関連付けます。フィルター後のランドマークを順に回して Row を表示します。シミュレーターの表示もここはシンプルにまとまっていて良さそうです。

フィルターが変わったときにはランドマークリストを更新します。これは最適化ですね。お気に入り状態がオンのものだけを出している状態で、オフにしたとき、従来のリスト実装だとその場で消えてしまい、元に戻すには探し直さないといけないことがあります。そういったことが起こらないように、`displayingLandmarkIDs` で管理するようにどこかで仕様変更しました。フィルターが変化するまではリストは保持しておき、フィルター設定が変わったときに改めて組み直す、という方針です。アニメーションも、`filter` と `landmarks` への変更に対して適切に適用できるようにしています。

watchOS では長押しをすると個別のタップができなくなるので、これは面倒だからやめよう、という話もしました。シミュレーターで見ると、押したときに項目が出て、戻るときはこのボタンで戻る、という挙動です。長押ししても今は何も起きませんが、これを有効化するとプロフィール画面が出てくる、という作りに途中でリファクタリングしました。コメントアウトしてある watchOS 向けのコードですね。

ビルドの設定で「Landmarks for watchOS」とすべきところを間違えて、少しハマりました。コンパイラがタイプミスを防いでくれるだろうという期待もありますが、スキームの選択を間違えるとどうしようもないですね。直してビルドすると、`showFavoritesOnly` がスコープにないというエラー。確かに `ListMenu` で使っているのに、もうトップレベルには存在しません。これは `Filter` の中に移動したので、`@State` を `@Binding` として渡す形に直し、`filter.showFavoritesOnly` を使うのが正しいです。修正後は、長押しでメニューが出てくることを確認できました。その代わり、長押しを有効にするとリストのタップで行選択ができなくなる、という問題が発生します。リストメニューを出すためには長押しを使いたいのですが、それだと通常のタップ選択と競合してしまう、という問題です。

リストメニューは独自のモディファイア（`ListMenuModifier`）で実装しています。定義を見ると、ボタンを表示して、押されたらプロフィールを出すなど、特に難しいことはしていません。理想としては、長押しと通常のタップを使い分けつつ、選択もできることです。そこで `ListMenuModifier` の中で `onLongPressGesture` と `onTapGesture` をそれぞれ使い、挙動を `print` で確かめてみます。プレビューを固定しておき、どこでも確認できるようにしてから試すと、タップでアイコンが出て、長押しでメニューが出ることは確認できました。

選択時には `selectedLandmarkID`（`Int?`）を更新したいので、これをモディファイア側へ `@Binding` として渡します。`ListMenuModifier` のプロパティとして `@Binding var selectedLandmarkID: Int?` を持たせ、必要ならアクセス制御も調整します。…と進めたのですが、`body` の中でモディファイア経由で現在選んでいるものを更新する、という設計は少し違う感じもします。`onTapGesture` 側で「通常の選択をしたい」だけなので、本来は `List(selection:)` にバインディングを渡して、状態変数を更新するのが素直です。ドキュメント（Safari で確認）にあるとおり、`List` の初期化で `selection` に `Binding` を渡し、コードから選択を変更したい場合はその状態変数を更新します。変化をフックしたいときは `onChange(of: selectedLandmarkID) { ... }` を使うのが良い、という理解です。

このあたりを踏まえて、`selectedLandmarkID` で…というところまで来ました。 とりあえず渡しておきますか。`selectedLandmarkID` として、`selectedLandmarkID`。ここがなんか違うらしいですね。List のモディファイアで `selectedLandmarkID`、バインディング、バインディング……これも違うらしいです。読み取り専用プロパティで、プロパティに代入できません。サインしていない感じがしますね。うーん、なんかおかしくなります。

とりあえず `onTapGesture` は無しにして、`.onChange` で、`of: selectedLandmarkID` か。アクションとしては、今回は `print` するだけにしますね。こうして `print`。で、ダブルクォートで文字列補間して、同様に文字列補間して……ここですね。`print` がなんか変なところにありましたね。`oldValue` と `newValue`。ここでね、`oldValue` と `newValue`。これで……あれ、良くない。丸カッコが抜けてますね。こうして、またダブルクォート。`.onChange` で、インスタンスメソッド。これが、`Binding` は `Equatable` に準拠している、`Binding<Int>` が `Equatable`。あ、そっか、`.onChange` だからか。なるほどね。だから、`.onChange` で Wrapped ではないのかな。それで、`oldValue`、`newValue` がプリミティブな文字列リテラル。汎用的なところを持ちますね。

で、OK で、`oldValue` と `newValue` は Optional の可能性があるから、どうするか、っていう感じかな。`Optional` 値の `debugDescription`。そうですね。なので、これを Optional でもいいんですよ、っていうための一つの方法としては、ここに、まず `Any` ですね。こうしてあげると大丈夫。で、ここの丸カッコはいらない。うん。で、あとは文字出力とかなんて、分かんないですね。ここの隣、ここに、ここにしますかね。

これでプレビューを見て、タップでね、どういう反応をしますか。シングルタップ、それが大通りにね、効いてくれば OK という感じですが、プレビューが進まないな。コンパイラエラーか。ここか。えーと、`selected` モディファイア、`selectedLandmark`。`selectedLandmark` が `Binding` の `ID` ですよね。で、それで、あー、ここ全然違った。`Binding` が付いてるね。なので、ここは完全に `Binding<Int>` ではなくて `Int` で良いと。で、そうすると `wrappedValue` などのはずがなく、これでよしとして……大丈夫かな。あれ、まだダメだ。ビルドエラーかな。ビルドエラーを先に直しますか。押したときに、どこがダメなのか。ここか。`Binding<Int>`、`Binding<Int>`……。これ、何をやったんだろうね。`Binding<Int>` を渡してるけど、そんなものは渡さないですね。`Binding<Int>` じゃなくて、`selectedLandmarkID` ですよね。なので、今のやつは、ここ。ラベルを入れて、`selectedLandmarkID`。`ID` を渡す必要はなかったんですよね、コードを見るとね。

できたら、一回押すと、値は変わらないですね。なので、いくつかの意味を直すには、押したときにタップが発動するようにして、その中でどこが押されたのかを判断できれば、そのまま渡せると。渡せると、このクリック（タップ）が効いてくると。なるほど。これは調べないとわからないですね。FIXME、せっかくだから取りたいですもんね。これ、実際のプロダクトとかだったとすると、工数とか期間の余裕とか相手の予算とかね、FIXME というよりは TODO で残しておいたりするんでしょうけど。ここなら、`onTapGesture` ができたのを思うとやりたいけど、オンタップしたセルを知るには、セルに対して `onTapGesture` を書かないとダメかな。やってみますか、そういった感じで。

これをやるとすると、ちょっと Swift と言われ、そんなにこの場でやっている程度なんで、全然違うことをやりそうな雰囲気を感じるんですけど、まず一番最初のゴールはね、できれば良いってのがあって、それが本当に正しいやり方なのかどうかっていうのは、そのあと考えていけばまずは良い、学習の段階としてはね、と思うんで。まあまずはね、無理やりでもやって、それでね、誰かが「こんな無駄なコードを書いてる」みたいに思ったら、そこで学べば良い。ありがたい。こんな感じでやっていきましょう。という感じなので、逆に言うとね、「そのやり方ヤバいでしょ」みたいなことを教えてもらえると、自分の成長の機会になってとても良い。まあまあいいや。 とりあえず、`onChange` は期待できませんでした。あちらはフィルターの役割なので、これはこれで問題ないと考えます。Apple のサンプル「Landmarks」の `LandmarkList` に倣うと、まずバインディングは要らなさそうですね。あとで気づくかもしれませんが、まずはリストのコンテキストメニューから。長押しは実装されていましたよね。`onChange` で `newValue` と `oldValue` を受け取って `selected` を見る、という形を試しましたが、ここは書き換えたので無しです。`onTapGesture` を使っても `onChange` が発動しないので、これも無しにします。

その代わり、`contextMenu` モディファイアで、長押しでメニューが出るようにしました。これは長押しというよりコンテキストメニューの話なので、ここで完結です。

それとは別に、セルのタップも実現します。普段は何もしなくてもできますが、今回はどうするか。`List` 側では `selectedLandmarkID` は `nil` のことがありますが、`LandmarkRow` のランドマークが、押したときに表示されてほしいのです。そこで `onTapGesture` を付けて、`selectedLandmarkID` を書き換えるだけではダメそうだという気がしていました。どうするのが良いのか、これは GPT に聞いてもいいかもしれません。

`ForEach` で `LandmarkRow` を並べていて、全体は `NavigationSplitView` です。`NavigationSplitView` 内でランドマークの一覧を表示し、その各行（Row）が表示されています。この行に `onTapGesture` を付け、いきなり回避策に走るのではなく、まずは `print` でランドマークの `id` を出して動きを確認しました。押したときに期待どおりに動いたので、`onTapGesture` の中で `selectedLandmarkID` に、その行のランドマークの `id` をセットするようにしました。すると、例えば "Silver Salmon Creek" がちゃんと表示される感じになりました。

スクロールの挙動も調整したいのですが、マップの表示があまり良くないですね。通常の Apple Watch だとどう動かすのか、少し気になります。戻してみると "Turtle Rock"、良いですね。それから "Chilkoot Trail" も出ます。これでできました。ここを長押しするとメニューが出て、ちゃんと長押しに反応しています。出た出た。できましたね。

この上でリファクタリングを続けます。この辺の `List` は仕方ないとしても、コードが少し重なってきています。分割する手は十分にあります。`LandmarkRow`、`List` の中での行エリア、`RowView` といった単位で切り出せそうです。`onChange` なども絡むので、ひとまとめにするとすべてが溶けてしまいます。`ForEach` はそれぞれランドマークに対応していて、行（Row）で扱うのが良さそうです。ここはこれで良いでしょう。`ForEach` は回す役なので必要です。

`selectedLandmarkID` の関係もあり、`List` と `ForEach` の配置は必要です。`List` に対して items 的な領域名にするのも少し変なので、ここは分割してみたいです。`List` の中のさらにリスト的な塊、名前の雰囲気は変わってしまいますが、仮に `ListBlock` のようなビューに切り出します。`List(selection:)` でセレクションを受けつつ、そこから `ForEach` を回すので、`ListBlock` 自体は外に出しておきます。

また、`listMinimumWidth` というエクステンションは `private extension` で良さそうです。どれも `LandmarkList` とセットで使います。今見ている `LandmarkList` はすべて共通の構造なので、この形で問題ありません。したがって、`ListBlock` も共通化できます。 リストの共通部分は、`@ViewBuilder` でまとめています。こればかり定義しているので、もう少し上の層に寄せます。`private extension LandmarkList` を作り、ここにリスト用のビルダーを置く形にします。`List` を使ってビルダーのベースはOKです。リストは出ますし、ここは過剰にやり過ぎないようにしたいところですね。

ポイントとして、`onTapGesture` は watchOS のときだけ有効にします。つまり `#if os(watchOS)` の条件付きコンパイルで、watchOS の場合にだけタップジェスチャーを考慮するようにします。これで Apple Watch 向けの挙動は完成です。

次に、`LandmarkRow`（リストの1行）を切り出しておきます。`ForEach` の中身をカットして、`listRow` を `landmark` を引数に取るインターフェースにし、`@ViewBuilder` で実装します。`func listRow(_ landmark: Landmark)` のようにしてもよいのですが、編集が必要なケースもあるので、ここはバインディングを渡す形にします。つまり、`Binding<Landmark>` を受け取るようにし、呼び出し側ではバインディングを渡します。戻り値は `some View` にします。これでコンパイルの「Unexpected …」のようなエラーも解消し、無事に行単位のビューが出るようになりました。

`id` に関しては、バインディング先の `id` がそのまま取れます。バインディングからでも `id` を参照できるのはよくできていますね。

この変更によって、`body` 側はスリムになります。最初はリストの部分を `ListBlock` のように切り出していましたが、「リストと一緒に読まないと意図が分かりづらい」と感じたので、これはやめて、`List` の中に素直に戻しました。多少長くはなりますが、`List` と `ForEach` でセクション相当を組み立てているのが読み取りやすくなります。その上で、行の見た目や挙動だけを後ろ（`listRow`）に回す構成にすると、ちょうどよいバランスだと思います。

`ForEach` の書き方については2通り考えました。`content:` パラメーターに `listRow` をそのまま渡す形にするか、クロージャで `landmark` を受け取り、`listRow` にダイレクトに渡す形にするかです。慣れていれば `content:` に直接 `listRow` を指定する形でも読めますが、少し分かりづらいと感じる人もいると思います。今回は、過度に凝ったクロージャの形にせず、`ForEach` でランドマークを回して、そのまま `listRow` に渡すというシンプルな形にしました。

最後に、`onChange` でフィルターが変わったときには `updateLandmarkList` を呼ぶようにしています。また、`defaultFilter` は使われていないことが分かったので削除しました。 リストと言っても、ここではこういう消し方ですね。これでも大丈夫か…`onChange`があるって感じですかね。試してみます。`onChange`で、クロージャですね。ちょっと変えますね。これでいいや。

フィルターが変わったらリストを更新するようにして、アニメーションはこのようにランドマークの`wrappedValue`をデフォルトとして与えています。これは良いですね。`onChange`を渡したので、ここにあった`FIXME`は達成したため削除可能です。

バインディングは要りませんでした。なので、このバインディングを消していきますが、一番内側から消すのが楽ですね。これを消して戻って、`landmarkID`のパラメータがなくなったので消して、そこで渡すべき`landmarkID`のバインディングも消します。ここもクリックして`landmarkID`を消す、と。

こうやって何気なく「もう要らなくなったコードがあるな」と思ってザクザク消していますが、慣れていないと「これは要らなくなった」という事実が頭から飛ぶことが普通によくあるはずです。これはどう対処するといいのでしょうか。残っていると「このコードは何なんだろう？」となって、誰かが読まざるを得なくなります。負担がかかるので、できれば消したいわけですよね。でも、覚えておくのは難しいというのはあると思います。

自分も記憶は得意なほうではないはずですが、ここでも「いらない」という前提で、一連の流れの中でやっているのだと思います。いらなくなったからこっちのコードをこう変えて、次にこう変えて、その流れの最後でいらなくなったものを消す、という感じですね。もちろん忘れるときはあります。なかなか難しいことをやっているっぽいので、消す予定のものがあれば、最近の自分も含めてですけど、あまり紙にわざわざメモを取らないですよね。でも、今やっている変更に対して「後でいらなくなる」ということを少しメモしておくのが良さそうです。

この「いらなくなる予定の変更」をこれからいろいろかけていくときに、「いらなくなったら消す」で済ませると、最後に当たらないと見逃す可能性がありますし、他の人が触れる可能性があるときは、なぜいらなくなるのかが分からなくなります。そういったところをちゃんと書いた上で、メモしておくほうが今のところは良いのかもしれません。自分だけの頭の中に書いても仕方ないので、とにかく「いらなくなる予定のもの」をちゃんとメモしておく。

こういったメモの仕方として、Xcodeの場合は行で…ブレークポイントではないですね。右クリックでブックマークできますよね。ブックマークはどこでも良いので、右クリックから追加します。これでブックマークして、このブックマークにメモを書けます。例えば「今のリファクタリングが終わったら不要になる」みたいに書いておくとメモになります。このメモは右側のブックマークナビゲータで見ることができます。クセがつけば、メモをいろいろ付けながらコードを書いていって、コードが一段落したらメモを見る、という流れにできます。メモがなくなることを目標にする、そんな感じが良いかもしれません。

では、そんな感じでやっていきます。メモはどう消すんだ…選んでここで消すのか。チェックできてもしょうがない、あ、チェックするとチェックマークが入って、メニューにも反映されるんですね。なるほど。チェックを入れて管理して、最後に消せばいいのか。もう完全に「この辺は要らないよ」という状態になったら、バシッと消せばいい。こんな風に使っていけば良さそうですね。 とりあえず、リストメニューは今のメモが間違って終わっていたので、バインディングを消します。`LandmarkList` は ID のバインディングを消して、リストメニューは残します。これで終わり、で良いですよね。OK、できました。いいですね。これでリストが見やすくなりました。

`onChange` と `animation` と、OS ごとにリストメニューや `frame` の扱いが異なっても大丈夫です。だったら、この辺の細かいところはいじらず、こちら側で OS ごとに分けて書けば良いですね。iOS だったらこれ、macOS だったらこれ、で終わり。プラットフォームの都合でどうしても見にくくなってしまいますが、これはしょうがないですかね。もしこの辺が混雑して困るようであれば、モディファイアを工夫する手もあります。ただ、工夫しすぎても、名前だけでいい感じにまとめて分けるのは難しそうな雰囲気があります。ですので、こうやって素直に書いておいたほうが良いかもしれません。

この辺を何というモディファイア名にするかは相当難しいと思います。ツールバーが2つあって、`navigationTitle` があって、それが iOS と macOS 専用のもの、と言われても「さて、それは何なの？」という感じになります。これを「iOS と macOS 専用のモディファイア」みたいな名前にしてしまうと、「だから何？」という感じになってしまい、その後のコードの書き方がかえって難しくなってくる気がします。なので、これで良いでしょう。

ディテール側は `selectedLandmarkID` に対して `flatMap` で処理していて、この辺は少しややこしいですね。`landmark(byID:)`、つまり `landmark(by:)` は `Optional` を返します。こういう「何が書いてあるのか分かりにくい」ときは、変数に切り出すとすごく分かりやすくなります。たとえば、`selectedLandmark` があって、`selectedLandmarkID` に値がある場合は、`flatMap` で `landmark(by:)` の結果を返し、そうでなければ `nil`。つまり、今のコードでぴったりです。

`selectedLandmark` で `landmark` の `element(byID:)` を使う部分も、同様にコピーして使い回せる可能性があります。`selectedLandmark` で `landmark.element(byID:)`、ここまでをコピーして、先ほどの `selectedLandmark` を見ましょう。`selectedLandmark` は `Binding<Landmark>` で、`landmark(by:)` がモデルデータになっていますよね。そのうえで、先ほどのとおり `selectedLandmarkID` がなければ `flatMap` の結果は `nil` です。`selectedLandmarkID` がある場合には、モデルデータの `landmarks.element(byID:)` を使う、ということになります。

こちらは `landmark(byID:)` ですが、`landmarks` は `modelData.landmarks`、つまり `Landmark` の配列です。`bindingLandmark`（`Binding<Landmark>`）でそれが ID とつながっていて、こっちは `Landmark`。`modelData.landmarks` 自体は `[Landmark]` ですが、全体を `Binding` した `Binding<[Landmark]>` になっている想定です。`element(byID:)` はフィルタで取ったようなものですが、`landmark(byID:)` のように、`Binding<[Landmark]>` に対するサブスクリプト（`subscript`）で ID から要素を引ける拡張を当てている形ですね。

この「サブスクリプト」というのも、最初は分かりにくいところです。定義を辿ろうとすると、ID の定義のほうに飛んでしまって、辿りにくいことがあります。`Binding<[Landmark]>` の中にサブスクリプトが見当たらないように見えても、`Sequence` か、`Element: Identifiable` なシーケンスに対する拡張で `element(id:)`（またはそれに相当する）を提供しているはずです。`Landmark` に対してサブスクリプトや `element(byID:)` を定義している、という理解で良いと思います。

最後に、`.focusedValue` で `selectedLandmark` を渡しています。`selectedLandmark` は自分、つまり `LandmarkList` のプロパティです。`.focusedValue` は何をするモディファイアだったか、という話ですが、ここでは選択中のランドマークをフォーカスの環境値として関連付けている、という使い方になっています。 focusedValue は `KeyPath`、`WritableKeyPath` に対して値を渡すか、`selectedLandmark` に `landmarkID` のランドマークを入れていくのか……と考えていましたが、`selectedLandmark` にランドマークの ID を入れていくので合っていますね。`focusedValue` か……あ、これで良いのか。ということで、これも iOS で `focusedValue` を使います。`focusedValue` はリストに対して使って、それに対してお気に入りを操作する、という形にします。

いまは macOS で動作テストをしていますが、macOS にした上で、ここのコードを `selectedLandmark` に対して `selectedLandmark` という形にしてあげます。これでビルドをかけて、ビルドが通ったので実行します。これで選択したランドマークのお気に入りを操作できれば、このコードで機械的に合っているということになります。

たとえばセントメリー湖を選んで、お気に入りを押すと入りますね、ちゃんと。消すのも問題ありません。レイク・マクドナルドも動きますね。大丈夫です。そんな感じで良かったです。うっかりしていましたが、うまくできました。

あとは `.onAppear` と `.onChange` ですね。この辺は統一感を持たせたいところです。OS に依存せずどこに置いても良いので、上のほうにまとめようかと思いましたが、いまのところはここだけです。何か考えていたことがあった気もしますが……まあいいか。という感じで、これで OK ですね。やはり上のほうに持っていきますか。あとはここくらいかな。まあ、これで良いでしょう。

OS ごとの条件分岐は外側ですね。あの辺、本当にかさばってしまって、`#if` は結構見にくいんですよね。何とかしたいところですが、あまり良くない感じです。モディファイアを作っておいて、ここで OS 依存に分ける（`#if os(macOS)` / `#if os(iOS)` のように）というのもありますが、ややこしくなります。ここは素直に書いたほうが良いですね。ちょっと面倒な程度なので、独自ルールを作るより、多少面倒でも素直に書いたほうが多くの人にとってわかりやすいです。

それと、`.onChange` は完全にデバッグ用ですね。デバッグメッセージごと消して、これで良いです。できました。これでランドマークリストがスッキリして良いですね。

もう一つだけ見ておきましょう。ランドマーク行（`LandmarkRow`）です。何度も言っているやつですが、`private(set)` で十分という言語仕様への信頼はいまだ覆っていないので、このままで良いです。

`HStack`、`LandmarkRow`、この辺のプレビューはありますね。OS 全部向けのプレビューですが、macOS のプレビューは出しにくいので iOS にしました。これでプレビューを出しておきます。バインディングは良いとして、`HStack` で `Image` があって、これは `LandmarkRow` なので `Image` があり、`VStack` に `Text` の `name` と `park`。いつもと少し違う感じですね。`isFavorite` は `Spacer` を置いてからの `isFavorite`。イメージとコンテンツ、という感じになりそうです。

たとえば、`HStack` で画像エリアとしてこの `Image` を切り出して、`private extension LandmarkRow` に `var imageArea: some View` を作ります。`@ViewBuilder` を付けて、さっきコピーしたものを貼り付けます。これでまず画像エリアは OK。

次がコンテンツエリアですね。コンテンツエリアとして、`Spacer` まで含めてがっつり持っていくかどうか。崩れないか少し心配なので、プレビューを見てからにします。コンテンツエリアを使いながら、いったんコンテンツエリアの中身はコメントアウトして、プレビューを出します。`Spacer` がいい具合に動かない気がしているんですよね。どうでしょう、動くのかな。この予感が当たっていたら、少し UI の感覚が養われてきた、みたいな達成感がありそうです。

とりあえずプレビューを出して……下のほうかな。スクロールができない。タイトル系とスペースを空けて、ここが崩れる可能性があるかもしれません。コンテンツエリアにこれを持っていっただけですからね。そこでコンテンツエリアをこの部分に定義して、`@ViewBuilder` を付けます。`contentArea: some View` としてこうですね。これでプレビューが崩れるかどうか、確認します。
